
Build_Output/KeyTag.elf:     file format elf32-littlearm


Disassembly of section .text:

00023000 <__isr_vector>:
   23000:	20010000 	.word	0x20010000
   23004:	00027795 	.word	0x00027795
   23008:	000277d5 	.word	0x000277d5
   2300c:	000277d7 	.word	0x000277d7
   23010:	000277d9 	.word	0x000277d9
   23014:	000277db 	.word	0x000277db
   23018:	000277dd 	.word	0x000277dd
	...
   2302c:	000277df 	.word	0x000277df
   23030:	000277e1 	.word	0x000277e1
   23034:	00000000 	.word	0x00000000
   23038:	000277e3 	.word	0x000277e3
   2303c:	000240a1 	.word	0x000240a1
   23040:	000238f7 	.word	0x000238f7
   23044:	000277e7 	.word	0x000277e7
   23048:	000277e7 	.word	0x000277e7
   2304c:	000277e7 	.word	0x000277e7
   23050:	000277e7 	.word	0x000277e7
   23054:	000244b9 	.word	0x000244b9
   23058:	000277e7 	.word	0x000277e7
   2305c:	000277e7 	.word	0x000277e7
   23060:	000277e7 	.word	0x000277e7
   23064:	000277e7 	.word	0x000277e7
   23068:	000277e7 	.word	0x000277e7
   2306c:	000277e7 	.word	0x000277e7
   23070:	000277e7 	.word	0x000277e7
   23074:	000277e7 	.word	0x000277e7
   23078:	000277e7 	.word	0x000277e7
   2307c:	000277e7 	.word	0x000277e7
   23080:	000277e7 	.word	0x000277e7
   23084:	000277e7 	.word	0x000277e7
   23088:	000277e7 	.word	0x000277e7
   2308c:	000277e7 	.word	0x000277e7
   23090:	000277e7 	.word	0x000277e7
   23094:	000277e7 	.word	0x000277e7
   23098:	00026175 	.word	0x00026175
   2309c:	000277e7 	.word	0x000277e7
   230a0:	000277e7 	.word	0x000277e7
   230a4:	000277e7 	.word	0x000277e7
   230a8:	000277e7 	.word	0x000277e7
   230ac:	000277e7 	.word	0x000277e7
   230b0:	000277e7 	.word	0x000277e7
   230b4:	000277e7 	.word	0x000277e7
	...
   230c0:	000277e7 	.word	0x000277e7
   230c4:	000277e7 	.word	0x000277e7
   230c8:	000277e7 	.word	0x000277e7
   230cc:	000277e7 	.word	0x000277e7
   230d0:	000277e7 	.word	0x000277e7
   230d4:	000277e7 	.word	0x000277e7
   230d8:	000277e7 	.word	0x000277e7
	...

00023400 <__do_global_dtors_aux>:
   23400:	e59f3030 	ldr	r3, [pc, #48]	; 23438 <__do_global_dtors_aux+0x38>
   23404:	e5d32000 	ldrb	r2, [r3]
   23408:	e3520000 	cmp	r2, #0
   2340c:	112fff1e 	bxne	lr
   23410:	e92d4010 	push	{r4, lr}
   23414:	e1a04003 	mov	r4, r3
   23418:	e59f301c 	ldr	r3, [pc, #28]	; 2343c <__do_global_dtors_aux+0x3c>
   2341c:	e3530000 	cmp	r3, #0
   23420:	159f0018 	ldrne	r0, [pc, #24]	; 23440 <__do_global_dtors_aux+0x40>
   23424:	11a00000 	movne	r0, r0
   23428:	e3a03001 	mov	r3, #1
   2342c:	e5c43000 	strb	r3, [r4]
   23430:	e8bd4010 	pop	{r4, lr}
   23434:	e12fff1e 	bx	lr
   23438:	20005080 	.word	0x20005080
   2343c:	00000000 	.word	0x00000000
   23440:	00027b6c 	.word	0x00027b6c

00023444 <frame_dummy>:
   23444:	e59f301c 	ldr	r3, [pc, #28]	; 23468 <frame_dummy+0x24>
   23448:	e3530000 	cmp	r3, #0
   2344c:	012fff1e 	bxeq	lr
   23450:	e92d4010 	push	{r4, lr}
   23454:	e59f1010 	ldr	r1, [pc, #16]	; 2346c <frame_dummy+0x28>
   23458:	e59f0010 	ldr	r0, [pc, #16]	; 23470 <frame_dummy+0x2c>
   2345c:	e1a00000 	nop			; (mov r0, r0)
   23460:	e8bd4010 	pop	{r4, lr}
   23464:	e12fff1e 	bx	lr
   23468:	00000000 	.word	0x00000000
   2346c:	20005084 	.word	0x20005084
   23470:	00027b6c 	.word	0x00027b6c

00023474 <_mainCRTStartup>:
   23474:	e59f30e4 	ldr	r3, [pc, #228]	; 23560 <_mainCRTStartup+0xec>
   23478:	e3530000 	cmp	r3, #0
   2347c:	059f30d8 	ldreq	r3, [pc, #216]	; 2355c <_mainCRTStartup+0xe8>
   23480:	e1a0d003 	mov	sp, r3
   23484:	e10f2000 	mrs	r2, CPSR
   23488:	e312000f 	tst	r2, #15
   2348c:	0a000015 	beq	234e8 <_mainCRTStartup+0x74>
   23490:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
   23494:	e1a0d003 	mov	sp, r3
   23498:	e24daa01 	sub	sl, sp, #4096	; 0x1000
   2349c:	e1a0300a 	mov	r3, sl
   234a0:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
   234a4:	e1a0d003 	mov	sp, r3
   234a8:	e2433a01 	sub	r3, r3, #4096	; 0x1000
   234ac:	e321f0db 	msr	CPSR_c, #219	; 0xdb
   234b0:	e1a0d003 	mov	sp, r3
   234b4:	e2433a01 	sub	r3, r3, #4096	; 0x1000
   234b8:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
   234bc:	e1a0d003 	mov	sp, r3
   234c0:	e2433a02 	sub	r3, r3, #8192	; 0x2000
   234c4:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
   234c8:	e1a0d003 	mov	sp, r3
   234cc:	e2433902 	sub	r3, r3, #32768	; 0x8000
   234d0:	e3c330ff 	bic	r3, r3, #255	; 0xff
   234d4:	e3c33cff 	bic	r3, r3, #65280	; 0xff00
   234d8:	e5033004 	str	r3, [r3, #-4]
   234dc:	e9532000 	ldmdb	r3, {sp}^
   234e0:	e38220c0 	orr	r2, r2, #192	; 0xc0
   234e4:	e121f002 	msr	CPSR_c, r2
   234e8:	e243a801 	sub	sl, r3, #65536	; 0x10000
   234ec:	e3b01000 	movs	r1, #0
   234f0:	e1a0b001 	mov	fp, r1
   234f4:	e1a07001 	mov	r7, r1
   234f8:	e59f006c 	ldr	r0, [pc, #108]	; 2356c <_mainCRTStartup+0xf8>
   234fc:	e59f206c 	ldr	r2, [pc, #108]	; 23570 <_mainCRTStartup+0xfc>
   23500:	e0522000 	subs	r2, r2, r0
   23504:	fa000044 	blx	2361c <memset>
   23508:	e59f3054 	ldr	r3, [pc, #84]	; 23564 <_mainCRTStartup+0xf0>
   2350c:	e3530000 	cmp	r3, #0
   23510:	0a000001 	beq	2351c <_mainCRTStartup+0xa8>
   23514:	e1a0e00f 	mov	lr, pc
   23518:	e1a0f003 	mov	pc, r3
   2351c:	e59f3044 	ldr	r3, [pc, #68]	; 23568 <_mainCRTStartup+0xf4>
   23520:	e3530000 	cmp	r3, #0
   23524:	0a000001 	beq	23530 <_mainCRTStartup+0xbc>
   23528:	e1a0e00f 	mov	lr, pc
   2352c:	e1a0f003 	mov	pc, r3
   23530:	e3b00000 	movs	r0, #0
   23534:	e3b01000 	movs	r1, #0
   23538:	e1b04000 	movs	r4, r0
   2353c:	e1b05001 	movs	r5, r1
   23540:	e59f002c 	ldr	r0, [pc, #44]	; 23574 <_mainCRTStartup+0x100>
   23544:	fa00000b 	blx	23578 <atexit>
   23548:	fa000021 	blx	235d4 <__libc_init_array>
   2354c:	e1b00004 	movs	r0, r4
   23550:	e1b01005 	movs	r1, r5
   23554:	fa0000f4 	blx	2392c <main>
   23558:	fa000009 	blx	23584 <exit>
   2355c:	00080000 	.word	0x00080000
   23560:	20010000 	.word	0x20010000
	...
   2356c:	20005080 	.word	0x20005080
   23570:	200053b4 	.word	0x200053b4
   23574:	000235ad 	.word	0x000235ad

00023578 <atexit>:
   23578:	2300      	movs	r3, #0
   2357a:	4601      	mov	r1, r0
   2357c:	461a      	mov	r2, r3
   2357e:	4618      	mov	r0, r3
   23580:	f000 b854 	b.w	2362c <__register_exitproc>

00023584 <exit>:
   23584:	b508      	push	{r3, lr}
   23586:	4b07      	ldr	r3, [pc, #28]	; (235a4 <exit+0x20>)
   23588:	4604      	mov	r4, r0
   2358a:	b113      	cbz	r3, 23592 <exit+0xe>
   2358c:	2100      	movs	r1, #0
   2358e:	f000 f8b1 	bl	236f4 <__call_exitprocs>
   23592:	4b05      	ldr	r3, [pc, #20]	; (235a8 <exit+0x24>)
   23594:	6818      	ldr	r0, [r3, #0]
   23596:	6a83      	ldr	r3, [r0, #40]	; 0x28
   23598:	b103      	cbz	r3, 2359c <exit+0x18>
   2359a:	4798      	blx	r3
   2359c:	4620      	mov	r0, r4
   2359e:	f000 f917 	bl	237d0 <_exit>
   235a2:	bf00      	nop
   235a4:	000236f5 	.word	0x000236f5
   235a8:	000279f8 	.word	0x000279f8

000235ac <__libc_fini_array>:
   235ac:	b538      	push	{r3, r4, r5, lr}
   235ae:	4d07      	ldr	r5, [pc, #28]	; (235cc <__libc_fini_array+0x20>)
   235b0:	4c07      	ldr	r4, [pc, #28]	; (235d0 <__libc_fini_array+0x24>)
   235b2:	1b64      	subs	r4, r4, r5
   235b4:	10a4      	asrs	r4, r4, #2
   235b6:	b91c      	cbnz	r4, 235c0 <__libc_fini_array+0x14>
   235b8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   235bc:	f004 ba10 	b.w	279e0 <_fini>
   235c0:	3c01      	subs	r4, #1
   235c2:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   235c6:	4798      	blx	r3
   235c8:	e7f5      	b.n	235b6 <__libc_fini_array+0xa>
   235ca:	bf00      	nop
   235cc:	2000507c 	.word	0x2000507c
   235d0:	20005080 	.word	0x20005080

000235d4 <__libc_init_array>:
   235d4:	b570      	push	{r4, r5, r6, lr}
   235d6:	4e0d      	ldr	r6, [pc, #52]	; (2360c <__libc_init_array+0x38>)
   235d8:	4c0d      	ldr	r4, [pc, #52]	; (23610 <__libc_init_array+0x3c>)
   235da:	1ba4      	subs	r4, r4, r6
   235dc:	10a4      	asrs	r4, r4, #2
   235de:	2500      	movs	r5, #0
   235e0:	42a5      	cmp	r5, r4
   235e2:	d109      	bne.n	235f8 <__libc_init_array+0x24>
   235e4:	4e0b      	ldr	r6, [pc, #44]	; (23614 <__libc_init_array+0x40>)
   235e6:	4c0c      	ldr	r4, [pc, #48]	; (23618 <__libc_init_array+0x44>)
   235e8:	f004 f9ee 	bl	279c8 <_init>
   235ec:	1ba4      	subs	r4, r4, r6
   235ee:	10a4      	asrs	r4, r4, #2
   235f0:	2500      	movs	r5, #0
   235f2:	42a5      	cmp	r5, r4
   235f4:	d105      	bne.n	23602 <__libc_init_array+0x2e>
   235f6:	bd70      	pop	{r4, r5, r6, pc}
   235f8:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
   235fc:	4798      	blx	r3
   235fe:	3501      	adds	r5, #1
   23600:	e7ee      	b.n	235e0 <__libc_init_array+0xc>
   23602:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
   23606:	4798      	blx	r3
   23608:	3501      	adds	r5, #1
   2360a:	e7f2      	b.n	235f2 <__libc_init_array+0x1e>
   2360c:	20005078 	.word	0x20005078
   23610:	20005078 	.word	0x20005078
   23614:	20005078 	.word	0x20005078
   23618:	2000507c 	.word	0x2000507c

0002361c <memset>:
   2361c:	4402      	add	r2, r0
   2361e:	4603      	mov	r3, r0
   23620:	4293      	cmp	r3, r2
   23622:	d100      	bne.n	23626 <memset+0xa>
   23624:	4770      	bx	lr
   23626:	f803 1b01 	strb.w	r1, [r3], #1
   2362a:	e7f9      	b.n	23620 <memset+0x4>

0002362c <__register_exitproc>:
   2362c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   23630:	4d2c      	ldr	r5, [pc, #176]	; (236e4 <__register_exitproc+0xb8>)
   23632:	682c      	ldr	r4, [r5, #0]
   23634:	4607      	mov	r7, r0
   23636:	460e      	mov	r6, r1
   23638:	4691      	mov	r9, r2
   2363a:	4698      	mov	r8, r3
   2363c:	b934      	cbnz	r4, 2364c <__register_exitproc+0x20>
   2363e:	4b2a      	ldr	r3, [pc, #168]	; (236e8 <__register_exitproc+0xbc>)
   23640:	4c2a      	ldr	r4, [pc, #168]	; (236ec <__register_exitproc+0xc0>)
   23642:	602c      	str	r4, [r5, #0]
   23644:	b113      	cbz	r3, 2364c <__register_exitproc+0x20>
   23646:	681b      	ldr	r3, [r3, #0]
   23648:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
   2364c:	6863      	ldr	r3, [r4, #4]
   2364e:	2b1f      	cmp	r3, #31
   23650:	dd3e      	ble.n	236d0 <__register_exitproc+0xa4>
   23652:	4b27      	ldr	r3, [pc, #156]	; (236f0 <__register_exitproc+0xc4>)
   23654:	b91b      	cbnz	r3, 2365e <__register_exitproc+0x32>
   23656:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2365a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   2365e:	208c      	movs	r0, #140	; 0x8c
   23660:	f004 f8c2 	bl	277e8 <malloc>
   23664:	4604      	mov	r4, r0
   23666:	2800      	cmp	r0, #0
   23668:	d0f5      	beq.n	23656 <__register_exitproc+0x2a>
   2366a:	2300      	movs	r3, #0
   2366c:	682a      	ldr	r2, [r5, #0]
   2366e:	6002      	str	r2, [r0, #0]
   23670:	6043      	str	r3, [r0, #4]
   23672:	6028      	str	r0, [r5, #0]
   23674:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
   23678:	b30f      	cbz	r7, 236be <__register_exitproc+0x92>
   2367a:	f44f 7084 	mov.w	r0, #264	; 0x108
   2367e:	f004 f8b3 	bl	277e8 <malloc>
   23682:	2800      	cmp	r0, #0
   23684:	d0e7      	beq.n	23656 <__register_exitproc+0x2a>
   23686:	2300      	movs	r3, #0
   23688:	f8c0 3100 	str.w	r3, [r0, #256]	; 0x100
   2368c:	f8c0 3104 	str.w	r3, [r0, #260]	; 0x104
   23690:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
   23694:	6862      	ldr	r2, [r4, #4]
   23696:	f840 9022 	str.w	r9, [r0, r2, lsl #2]
   2369a:	2301      	movs	r3, #1
   2369c:	4093      	lsls	r3, r2
   2369e:	eb00 0182 	add.w	r1, r0, r2, lsl #2
   236a2:	f8d0 2100 	ldr.w	r2, [r0, #256]	; 0x100
   236a6:	431a      	orrs	r2, r3
   236a8:	2f02      	cmp	r7, #2
   236aa:	f8c0 2100 	str.w	r2, [r0, #256]	; 0x100
   236ae:	f8c1 8080 	str.w	r8, [r1, #128]	; 0x80
   236b2:	bf02      	ittt	eq
   236b4:	f8d0 2104 	ldreq.w	r2, [r0, #260]	; 0x104
   236b8:	4313      	orreq	r3, r2
   236ba:	f8c0 3104 	streq.w	r3, [r0, #260]	; 0x104
   236be:	6863      	ldr	r3, [r4, #4]
   236c0:	1c5a      	adds	r2, r3, #1
   236c2:	3302      	adds	r3, #2
   236c4:	6062      	str	r2, [r4, #4]
   236c6:	2000      	movs	r0, #0
   236c8:	f844 6023 	str.w	r6, [r4, r3, lsl #2]
   236cc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   236d0:	2f00      	cmp	r7, #0
   236d2:	d0f4      	beq.n	236be <__register_exitproc+0x92>
   236d4:	f8d4 0088 	ldr.w	r0, [r4, #136]	; 0x88
   236d8:	2800      	cmp	r0, #0
   236da:	d1db      	bne.n	23694 <__register_exitproc+0x68>
   236dc:	4b04      	ldr	r3, [pc, #16]	; (236f0 <__register_exitproc+0xc4>)
   236de:	2b00      	cmp	r3, #0
   236e0:	d0b9      	beq.n	23656 <__register_exitproc+0x2a>
   236e2:	e7ca      	b.n	2367a <__register_exitproc+0x4e>
   236e4:	20005128 	.word	0x20005128
   236e8:	00000000 	.word	0x00000000
   236ec:	2000509c 	.word	0x2000509c
   236f0:	000277e9 	.word	0x000277e9

000236f4 <__call_exitprocs>:
   236f4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   236f8:	f8df a0d0 	ldr.w	sl, [pc, #208]	; 237cc <__call_exitprocs+0xd8>
   236fc:	9001      	str	r0, [sp, #4]
   236fe:	4689      	mov	r9, r1
   23700:	f8da 4000 	ldr.w	r4, [sl]
   23704:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 237cc <__call_exitprocs+0xd8>
   23708:	b914      	cbnz	r4, 23710 <__call_exitprocs+0x1c>
   2370a:	b003      	add	sp, #12
   2370c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   23710:	6865      	ldr	r5, [r4, #4]
   23712:	f8d4 6088 	ldr.w	r6, [r4, #136]	; 0x88
   23716:	1e6f      	subs	r7, r5, #1
   23718:	00ad      	lsls	r5, r5, #2
   2371a:	eb06 0b05 	add.w	fp, r6, r5
   2371e:	3504      	adds	r5, #4
   23720:	4425      	add	r5, r4
   23722:	2f00      	cmp	r7, #0
   23724:	da14      	bge.n	23750 <__call_exitprocs+0x5c>
   23726:	4b28      	ldr	r3, [pc, #160]	; (237c8 <__call_exitprocs+0xd4>)
   23728:	2b00      	cmp	r3, #0
   2372a:	d0ee      	beq.n	2370a <__call_exitprocs+0x16>
   2372c:	6862      	ldr	r2, [r4, #4]
   2372e:	6823      	ldr	r3, [r4, #0]
   23730:	2a00      	cmp	r2, #0
   23732:	d145      	bne.n	237c0 <__call_exitprocs+0xcc>
   23734:	2b00      	cmp	r3, #0
   23736:	d043      	beq.n	237c0 <__call_exitprocs+0xcc>
   23738:	f8c8 3000 	str.w	r3, [r8]
   2373c:	b116      	cbz	r6, 23744 <__call_exitprocs+0x50>
   2373e:	4630      	mov	r0, r6
   23740:	f004 f85a 	bl	277f8 <free>
   23744:	4620      	mov	r0, r4
   23746:	f004 f857 	bl	277f8 <free>
   2374a:	f8d8 4000 	ldr.w	r4, [r8]
   2374e:	e7db      	b.n	23708 <__call_exitprocs+0x14>
   23750:	f1b9 0f00 	cmp.w	r9, #0
   23754:	d009      	beq.n	2376a <__call_exitprocs+0x76>
   23756:	b926      	cbnz	r6, 23762 <__call_exitprocs+0x6e>
   23758:	3f01      	subs	r7, #1
   2375a:	f1ab 0b04 	sub.w	fp, fp, #4
   2375e:	3d04      	subs	r5, #4
   23760:	e7df      	b.n	23722 <__call_exitprocs+0x2e>
   23762:	f8db 207c 	ldr.w	r2, [fp, #124]	; 0x7c
   23766:	4591      	cmp	r9, r2
   23768:	d1f6      	bne.n	23758 <__call_exitprocs+0x64>
   2376a:	6861      	ldr	r1, [r4, #4]
   2376c:	682a      	ldr	r2, [r5, #0]
   2376e:	3901      	subs	r1, #1
   23770:	428f      	cmp	r7, r1
   23772:	bf16      	itet	ne
   23774:	2300      	movne	r3, #0
   23776:	6067      	streq	r7, [r4, #4]
   23778:	602b      	strne	r3, [r5, #0]
   2377a:	2a00      	cmp	r2, #0
   2377c:	d0ec      	beq.n	23758 <__call_exitprocs+0x64>
   2377e:	6863      	ldr	r3, [r4, #4]
   23780:	9300      	str	r3, [sp, #0]
   23782:	b136      	cbz	r6, 23792 <__call_exitprocs+0x9e>
   23784:	2301      	movs	r3, #1
   23786:	f8d6 0100 	ldr.w	r0, [r6, #256]	; 0x100
   2378a:	fa03 f107 	lsl.w	r1, r3, r7
   2378e:	4201      	tst	r1, r0
   23790:	d109      	bne.n	237a6 <__call_exitprocs+0xb2>
   23792:	4790      	blx	r2
   23794:	6862      	ldr	r2, [r4, #4]
   23796:	9b00      	ldr	r3, [sp, #0]
   23798:	4293      	cmp	r3, r2
   2379a:	d1b1      	bne.n	23700 <__call_exitprocs+0xc>
   2379c:	f8d8 2000 	ldr.w	r2, [r8]
   237a0:	4294      	cmp	r4, r2
   237a2:	d0d9      	beq.n	23758 <__call_exitprocs+0x64>
   237a4:	e7ac      	b.n	23700 <__call_exitprocs+0xc>
   237a6:	f8d6 0104 	ldr.w	r0, [r6, #260]	; 0x104
   237aa:	4201      	tst	r1, r0
   237ac:	d104      	bne.n	237b8 <__call_exitprocs+0xc4>
   237ae:	f85b 1c04 	ldr.w	r1, [fp, #-4]
   237b2:	9801      	ldr	r0, [sp, #4]
   237b4:	4790      	blx	r2
   237b6:	e7ed      	b.n	23794 <__call_exitprocs+0xa0>
   237b8:	f85b 0c04 	ldr.w	r0, [fp, #-4]
   237bc:	4790      	blx	r2
   237be:	e7e9      	b.n	23794 <__call_exitprocs+0xa0>
   237c0:	46a0      	mov	r8, r4
   237c2:	461c      	mov	r4, r3
   237c4:	e7a0      	b.n	23708 <__call_exitprocs+0x14>
   237c6:	bf00      	nop
   237c8:	000277f9 	.word	0x000277f9
   237cc:	20005128 	.word	0x20005128

000237d0 <_exit>:
   237d0:	e7fe      	b.n	237d0 <_exit>
   237d2:	bf00      	nop

000237d4 <nrf_gpio_pin_port_decode>:
 *
 * @return Pointer to port register set.
 *
 */
__STATIC_INLINE NRF_GPIO_Type * nrf_gpio_pin_port_decode(uint32_t * p_pin)
{
   237d4:	b480      	push	{r7}
   237d6:	b083      	sub	sp, #12
   237d8:	af00      	add	r7, sp, #0
   237da:	6078      	str	r0, [r7, #4]
    ASSERT(*p_pin < NUMBER_OF_PINS);
#if (GPIO_COUNT == 1)
    // The oldest definition case
    return NRF_GPIO;
   237dc:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
    {
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
        return NRF_P1;
    }
#endif
}
   237e0:	4618      	mov	r0, r3
   237e2:	370c      	adds	r7, #12
   237e4:	46bd      	mov	sp, r7
   237e6:	bc80      	pop	{r7}
   237e8:	4770      	bx	lr

000237ea <nrf_gpio_cfg>:
    nrf_gpio_pin_dir_t   dir,
    nrf_gpio_pin_input_t input,
    nrf_gpio_pin_pull_t  pull,
    nrf_gpio_pin_drive_t drive,
    nrf_gpio_pin_sense_t sense)
{
   237ea:	b580      	push	{r7, lr}
   237ec:	b084      	sub	sp, #16
   237ee:	af00      	add	r7, sp, #0
   237f0:	6078      	str	r0, [r7, #4]
   237f2:	4608      	mov	r0, r1
   237f4:	4611      	mov	r1, r2
   237f6:	461a      	mov	r2, r3
   237f8:	4603      	mov	r3, r0
   237fa:	70fb      	strb	r3, [r7, #3]
   237fc:	460b      	mov	r3, r1
   237fe:	70bb      	strb	r3, [r7, #2]
   23800:	4613      	mov	r3, r2
   23802:	707b      	strb	r3, [r7, #1]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   23804:	1d3b      	adds	r3, r7, #4
   23806:	4618      	mov	r0, r3
   23808:	f7ff ffe4 	bl	237d4 <nrf_gpio_pin_port_decode>
   2380c:	60f8      	str	r0, [r7, #12]

    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   2380e:	78fa      	ldrb	r2, [r7, #3]
                               | ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos)
   23810:	78bb      	ldrb	r3, [r7, #2]
   23812:	005b      	lsls	r3, r3, #1
   23814:	431a      	orrs	r2, r3
                               | ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)
   23816:	787b      	ldrb	r3, [r7, #1]
   23818:	009b      	lsls	r3, r3, #2
   2381a:	431a      	orrs	r2, r3
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
   2381c:	7e3b      	ldrb	r3, [r7, #24]
   2381e:	021b      	lsls	r3, r3, #8
   23820:	ea42 0103 	orr.w	r1, r2, r3
                               | ((uint32_t)sense << GPIO_PIN_CNF_SENSE_Pos);
   23824:	7f3b      	ldrb	r3, [r7, #28]
   23826:	041b      	lsls	r3, r3, #16
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   23828:	687a      	ldr	r2, [r7, #4]
                               | ((uint32_t)sense << GPIO_PIN_CNF_SENSE_Pos);
   2382a:	4319      	orrs	r1, r3
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   2382c:	68fb      	ldr	r3, [r7, #12]
   2382e:	f502 72e0 	add.w	r2, r2, #448	; 0x1c0
   23832:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
   23836:	bf00      	nop
   23838:	3710      	adds	r7, #16
   2383a:	46bd      	mov	sp, r7
   2383c:	bd80      	pop	{r7, pc}

0002383e <nrf_gpio_cfg_output>:


__STATIC_INLINE void nrf_gpio_cfg_output(uint32_t pin_number)
{
   2383e:	b580      	push	{r7, lr}
   23840:	b084      	sub	sp, #16
   23842:	af02      	add	r7, sp, #8
   23844:	6078      	str	r0, [r7, #4]
    nrf_gpio_cfg(
   23846:	2300      	movs	r3, #0
   23848:	9301      	str	r3, [sp, #4]
   2384a:	2300      	movs	r3, #0
   2384c:	9300      	str	r3, [sp, #0]
   2384e:	2300      	movs	r3, #0
   23850:	2201      	movs	r2, #1
   23852:	2101      	movs	r1, #1
   23854:	6878      	ldr	r0, [r7, #4]
   23856:	f7ff ffc8 	bl	237ea <nrf_gpio_cfg>
        NRF_GPIO_PIN_DIR_OUTPUT,
        NRF_GPIO_PIN_INPUT_DISCONNECT,
        NRF_GPIO_PIN_NOPULL,
        NRF_GPIO_PIN_S0S1,
        NRF_GPIO_PIN_NOSENSE);
}
   2385a:	bf00      	nop
   2385c:	3708      	adds	r7, #8
   2385e:	46bd      	mov	sp, r7
   23860:	bd80      	pop	{r7, pc}

00023862 <nrf_gpio_pin_set>:
    }
}


__STATIC_INLINE void nrf_gpio_pin_set(uint32_t pin_number)
{
   23862:	b580      	push	{r7, lr}
   23864:	b084      	sub	sp, #16
   23866:	af00      	add	r7, sp, #0
   23868:	6078      	str	r0, [r7, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   2386a:	1d3b      	adds	r3, r7, #4
   2386c:	4618      	mov	r0, r3
   2386e:	f7ff ffb1 	bl	237d4 <nrf_gpio_pin_port_decode>
   23872:	60f8      	str	r0, [r7, #12]

    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   23874:	687b      	ldr	r3, [r7, #4]
   23876:	2201      	movs	r2, #1
   23878:	fa02 f303 	lsl.w	r3, r2, r3
   2387c:	4619      	mov	r1, r3
   2387e:	68f8      	ldr	r0, [r7, #12]
   23880:	f000 f819 	bl	238b6 <nrf_gpio_port_out_set>
}
   23884:	bf00      	nop
   23886:	3710      	adds	r7, #16
   23888:	46bd      	mov	sp, r7
   2388a:	bd80      	pop	{r7, pc}

0002388c <nrf_gpio_pin_clear>:


__STATIC_INLINE void nrf_gpio_pin_clear(uint32_t pin_number)
{
   2388c:	b580      	push	{r7, lr}
   2388e:	b084      	sub	sp, #16
   23890:	af00      	add	r7, sp, #0
   23892:	6078      	str	r0, [r7, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   23894:	1d3b      	adds	r3, r7, #4
   23896:	4618      	mov	r0, r3
   23898:	f7ff ff9c 	bl	237d4 <nrf_gpio_pin_port_decode>
   2389c:	60f8      	str	r0, [r7, #12]

    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   2389e:	687b      	ldr	r3, [r7, #4]
   238a0:	2201      	movs	r2, #1
   238a2:	fa02 f303 	lsl.w	r3, r2, r3
   238a6:	4619      	mov	r1, r3
   238a8:	68f8      	ldr	r0, [r7, #12]
   238aa:	f000 f812 	bl	238d2 <nrf_gpio_port_out_clear>
}
   238ae:	bf00      	nop
   238b0:	3710      	adds	r7, #16
   238b2:	46bd      	mov	sp, r7
   238b4:	bd80      	pop	{r7, pc}

000238b6 <nrf_gpio_port_out_set>:
    p_reg->OUT = value;
}


__STATIC_INLINE void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask)
{
   238b6:	b480      	push	{r7}
   238b8:	b083      	sub	sp, #12
   238ba:	af00      	add	r7, sp, #0
   238bc:	6078      	str	r0, [r7, #4]
   238be:	6039      	str	r1, [r7, #0]
    p_reg->OUTSET = set_mask;
   238c0:	687b      	ldr	r3, [r7, #4]
   238c2:	683a      	ldr	r2, [r7, #0]
   238c4:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
}
   238c8:	bf00      	nop
   238ca:	370c      	adds	r7, #12
   238cc:	46bd      	mov	sp, r7
   238ce:	bc80      	pop	{r7}
   238d0:	4770      	bx	lr

000238d2 <nrf_gpio_port_out_clear>:


__STATIC_INLINE void nrf_gpio_port_out_clear(NRF_GPIO_Type * p_reg, uint32_t clr_mask)
{
   238d2:	b480      	push	{r7}
   238d4:	b083      	sub	sp, #12
   238d6:	af00      	add	r7, sp, #0
   238d8:	6078      	str	r0, [r7, #4]
   238da:	6039      	str	r1, [r7, #0]
    p_reg->OUTCLR = clr_mask;
   238dc:	687b      	ldr	r3, [r7, #4]
   238de:	683a      	ldr	r2, [r7, #0]
   238e0:	f8c3 250c 	str.w	r2, [r3, #1292]	; 0x50c
}
   238e4:	bf00      	nop
   238e6:	370c      	adds	r7, #12
   238e8:	46bd      	mov	sp, r7
   238ea:	bc80      	pop	{r7}
   238ec:	4770      	bx	lr

000238ee <sd_app_evt_wait>:
 *
 * @post An application interrupt has happened or a interrupt pending flag is set.
 *
 * @retval ::NRF_SUCCESS
 */
SVCALL(SD_APP_EVT_WAIT, uint32_t, sd_app_evt_wait(void));
   238ee:	df3e      	svc	62	; 0x3e
   238f0:	4770      	bx	lr
   238f2:	bf00      	nop
   238f4:	4618      	mov	r0, r3

000238f6 <POWER_CLOCK_IRQHandler>:
 */

nrf_nvic_state_t nrf_nvic_state = {0};

void POWER_CLOCK_IRQHandler()
{
   238f6:	b580      	push	{r7, lr}
   238f8:	af00      	add	r7, sp, #0
	NRF_CLOCK->EVENTS_HFCLKSTARTED = 0;
   238fa:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   238fe:	2200      	movs	r2, #0
   23900:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
	nrf_gpio_cfg_output(20);
   23904:	2014      	movs	r0, #20
   23906:	f7ff ff9a 	bl	2383e <nrf_gpio_cfg_output>
	nrf_gpio_pin_clear(20);
   2390a:	2014      	movs	r0, #20
   2390c:	f7ff ffbe 	bl	2388c <nrf_gpio_pin_clear>
}
   23910:	bf00      	nop
   23912:	bd80      	pop	{r7, pc}

00023914 <soc_evt_handler>:
 *
 * @param[in]   evt_id      SOC stack event id.
 * @param[in]   p_context   Unused.
 */
static void soc_evt_handler(uint32_t evt_id, void * p_context)
{
   23914:	b580      	push	{r7, lr}
   23916:	b082      	sub	sp, #8
   23918:	af00      	add	r7, sp, #0
   2391a:	6078      	str	r0, [r7, #4]
   2391c:	6039      	str	r1, [r7, #0]
    SD_flash_operation_callback(evt_id);
   2391e:	6878      	ldr	r0, [r7, #4]
   23920:	f000 fbfc 	bl	2411c <SD_flash_operation_callback>
}
   23924:	bf00      	nop
   23926:	3708      	adds	r7, #8
   23928:	46bd      	mov	sp, r7
   2392a:	bd80      	pop	{r7, pc}

0002392c <main>:
	NVIC_SetPriorityGrouping(0);
}

__attribute__((optimize("O0")))
int main(void)
{
   2392c:	b580      	push	{r7, lr}
   2392e:	af00      	add	r7, sp, #0
#if SOFTDEVICE_ENABLED
    BleStackInit();
   23930:	f000 feac 	bl	2468c <BleStackInit>

	GapParamsInit();
   23934:	f000 fe48 	bl	245c8 <GapParamsInit>
	GattInit();
   23938:	f000 fe8e 	bl	24658 <GattInit>
//	ConnParamsInit();
	ServicesInit();
   2393c:	f000 fee0 	bl	24700 <ServicesInit>
	AdvertisingInit();
   23940:	f000 ffc4 	bl	248cc <AdvertisingInit>
	SystickInit();
   23944:	f000 fbc2 	bl	240cc <SystickInit>

//	AdvertisingStart();

	nrf_gpio_cfg_output(BLUE_LED);
   23948:	2010      	movs	r0, #16
   2394a:	f7ff ff78 	bl	2383e <nrf_gpio_cfg_output>
	nrf_gpio_cfg_output(GREEN_LED);
   2394e:	200f      	movs	r0, #15
   23950:	f7ff ff75 	bl	2383e <nrf_gpio_cfg_output>
    nrf_gpio_cfg_output(RED_LED);
   23954:	200e      	movs	r0, #14
   23956:	f7ff ff72 	bl	2383e <nrf_gpio_cfg_output>

    nrf_gpio_pin_set(BLUE_LED);
   2395a:	2010      	movs	r0, #16
   2395c:	f7ff ff81 	bl	23862 <nrf_gpio_pin_set>
    nrf_gpio_pin_set(GREEN_LED);
   23960:	200f      	movs	r0, #15
   23962:	f7ff ff7e 	bl	23862 <nrf_gpio_pin_set>
    nrf_gpio_pin_set(RED_LED);
   23966:	200e      	movs	r0, #14
   23968:	f7ff ff7b 	bl	23862 <nrf_gpio_pin_set>

    nrf_gpio_pin_clear(BLUE_LED);
   2396c:	2010      	movs	r0, #16
   2396e:	f7ff ff8d 	bl	2388c <nrf_gpio_pin_clear>
//    nrf_gpio_pin_set(BLUE_LED);

    NfcInit();
   23972:	f000 fdc1 	bl	244f8 <NfcInit>

    }*/

    while(1)
    {
        sd_app_evt_wait();
   23976:	f7ff ffba 	bl	238ee <sd_app_evt_wait>
   2397a:	e7fc      	b.n	23976 <main+0x4a>

0002397c <SystemCoreClockUpdate>:
#elif defined ( __GNUC__ )
    uint32_t SystemCoreClock __attribute__((used)) = __SYSTEM_CLOCK_64M;
#endif

void SystemCoreClockUpdate(void)
{
   2397c:	b480      	push	{r7}
   2397e:	af00      	add	r7, sp, #0
    SystemCoreClock = __SYSTEM_CLOCK_64M;
   23980:	4b03      	ldr	r3, [pc, #12]	; (23990 <SystemCoreClockUpdate+0x14>)
   23982:	4a04      	ldr	r2, [pc, #16]	; (23994 <SystemCoreClockUpdate+0x18>)
   23984:	601a      	str	r2, [r3, #0]
}
   23986:	bf00      	nop
   23988:	46bd      	mov	sp, r7
   2398a:	bc80      	pop	{r7}
   2398c:	4770      	bx	lr
   2398e:	bf00      	nop
   23990:	20005064 	.word	0x20005064
   23994:	03d09000 	.word	0x03d09000

00023998 <SystemInit>:

void SystemInit(void)
{
   23998:	b580      	push	{r7, lr}
   2399a:	af00      	add	r7, sp, #0
    /* Workaround for Errata 16 "System: RAM may be corrupt on wakeup from CPU IDLE" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/ */
    if (errata_16()){
   2399c:	f000 f8f0 	bl	23b80 <errata_16>
   239a0:	4603      	mov	r3, r0
   239a2:	2b00      	cmp	r3, #0
   239a4:	d002      	beq.n	239ac <SystemInit+0x14>
        *(volatile uint32_t *)0x4007C074 = 3131961357ul;
   239a6:	4b69      	ldr	r3, [pc, #420]	; (23b4c <SystemInit+0x1b4>)
   239a8:	4a69      	ldr	r2, [pc, #420]	; (23b50 <SystemInit+0x1b8>)
   239aa:	601a      	str	r2, [r3, #0]
    }

    /* Workaround for Errata 31 "CLOCK: Calibration values are not correctly loaded from FICR at reset" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/ */
    if (errata_31()){
   239ac:	f000 f908 	bl	23bc0 <errata_31>
   239b0:	4603      	mov	r3, r0
   239b2:	2b00      	cmp	r3, #0
   239b4:	d006      	beq.n	239c4 <SystemInit+0x2c>
        *(volatile uint32_t *)0x4000053C = ((*(volatile uint32_t *)0x10000244) & 0x0000E000) >> 13;
   239b6:	4b67      	ldr	r3, [pc, #412]	; (23b54 <SystemInit+0x1bc>)
   239b8:	681b      	ldr	r3, [r3, #0]
   239ba:	0b5b      	lsrs	r3, r3, #13
   239bc:	4a66      	ldr	r2, [pc, #408]	; (23b58 <SystemInit+0x1c0>)
   239be:	f003 0307 	and.w	r3, r3, #7
   239c2:	6013      	str	r3, [r2, #0]
    }

    /* Workaround for Errata 32 "DIF: Debug session automatically enables TracePort pins" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/ */
    if (errata_32()){
   239c4:	f000 f92c 	bl	23c20 <errata_32>
   239c8:	4603      	mov	r3, r0
   239ca:	2b00      	cmp	r3, #0
   239cc:	d005      	beq.n	239da <SystemInit+0x42>
        CoreDebug->DEMCR &= ~CoreDebug_DEMCR_TRCENA_Msk;
   239ce:	4b63      	ldr	r3, [pc, #396]	; (23b5c <SystemInit+0x1c4>)
   239d0:	68db      	ldr	r3, [r3, #12]
   239d2:	4a62      	ldr	r2, [pc, #392]	; (23b5c <SystemInit+0x1c4>)
   239d4:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
   239d8:	60d3      	str	r3, [r2, #12]
    }

    /* Workaround for Errata 36 "CLOCK: Some registers are not reset when expected" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/  */
    if (errata_36()){
   239da:	f000 f941 	bl	23c60 <errata_36>
   239de:	4603      	mov	r3, r0
   239e0:	2b00      	cmp	r3, #0
   239e2:	d00e      	beq.n	23a02 <SystemInit+0x6a>
        NRF_CLOCK->EVENTS_DONE = 0;
   239e4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   239e8:	2200      	movs	r2, #0
   239ea:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
        NRF_CLOCK->EVENTS_CTTO = 0;
   239ee:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   239f2:	2200      	movs	r2, #0
   239f4:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
        NRF_CLOCK->CTIV = 0;
   239f8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   239fc:	2200      	movs	r2, #0
   239fe:	f8c3 2538 	str.w	r2, [r3, #1336]	; 0x538
    }

    /* Workaround for Errata 37 "RADIO: Encryption engine is slow by default" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/  */
    if (errata_37()){
   23a02:	f000 f95d 	bl	23cc0 <errata_37>
   23a06:	4603      	mov	r3, r0
   23a08:	2b00      	cmp	r3, #0
   23a0a:	d002      	beq.n	23a12 <SystemInit+0x7a>
        *(volatile uint32_t *)0x400005A0 = 0x3;
   23a0c:	4b54      	ldr	r3, [pc, #336]	; (23b60 <SystemInit+0x1c8>)
   23a0e:	2203      	movs	r2, #3
   23a10:	601a      	str	r2, [r3, #0]
    }

    /* Workaround for Errata 57 "NFCT: NFC Modulation amplitude" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/  */
    if (errata_57()){
   23a12:	f000 f975 	bl	23d00 <errata_57>
   23a16:	4603      	mov	r3, r0
   23a18:	2b00      	cmp	r3, #0
   23a1a:	d00b      	beq.n	23a34 <SystemInit+0x9c>
        *(volatile uint32_t *)0x40005610 = 0x00000005;
   23a1c:	4b51      	ldr	r3, [pc, #324]	; (23b64 <SystemInit+0x1cc>)
   23a1e:	2205      	movs	r2, #5
   23a20:	601a      	str	r2, [r3, #0]
        *(volatile uint32_t *)0x40005688 = 0x00000001;
   23a22:	4b51      	ldr	r3, [pc, #324]	; (23b68 <SystemInit+0x1d0>)
   23a24:	2201      	movs	r2, #1
   23a26:	601a      	str	r2, [r3, #0]
        *(volatile uint32_t *)0x40005618 = 0x00000000;
   23a28:	4b50      	ldr	r3, [pc, #320]	; (23b6c <SystemInit+0x1d4>)
   23a2a:	2200      	movs	r2, #0
   23a2c:	601a      	str	r2, [r3, #0]
        *(volatile uint32_t *)0x40005614 = 0x0000003F;
   23a2e:	4b50      	ldr	r3, [pc, #320]	; (23b70 <SystemInit+0x1d8>)
   23a30:	223f      	movs	r2, #63	; 0x3f
   23a32:	601a      	str	r2, [r3, #0]
    }

    /* Workaround for Errata 66 "TEMP: Linearity specification not met with default settings" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/  */
    if (errata_66()){
   23a34:	f000 f984 	bl	23d40 <errata_66>
   23a38:	4603      	mov	r3, r0
   23a3a:	2b00      	cmp	r3, #0
   23a3c:	d076      	beq.n	23b2c <SystemInit+0x194>
        NRF_TEMP->A0 = NRF_FICR->TEMP.A0;
   23a3e:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23a42:	4a4c      	ldr	r2, [pc, #304]	; (23b74 <SystemInit+0x1dc>)
   23a44:	f8d3 3404 	ldr.w	r3, [r3, #1028]	; 0x404
   23a48:	f8c2 3520 	str.w	r3, [r2, #1312]	; 0x520
        NRF_TEMP->A1 = NRF_FICR->TEMP.A1;
   23a4c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23a50:	4a48      	ldr	r2, [pc, #288]	; (23b74 <SystemInit+0x1dc>)
   23a52:	f8d3 3408 	ldr.w	r3, [r3, #1032]	; 0x408
   23a56:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
        NRF_TEMP->A2 = NRF_FICR->TEMP.A2;
   23a5a:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23a5e:	4a45      	ldr	r2, [pc, #276]	; (23b74 <SystemInit+0x1dc>)
   23a60:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
   23a64:	f8c2 3528 	str.w	r3, [r2, #1320]	; 0x528
        NRF_TEMP->A3 = NRF_FICR->TEMP.A3;
   23a68:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23a6c:	4a41      	ldr	r2, [pc, #260]	; (23b74 <SystemInit+0x1dc>)
   23a6e:	f8d3 3410 	ldr.w	r3, [r3, #1040]	; 0x410
   23a72:	f8c2 352c 	str.w	r3, [r2, #1324]	; 0x52c
        NRF_TEMP->A4 = NRF_FICR->TEMP.A4;
   23a76:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23a7a:	4a3e      	ldr	r2, [pc, #248]	; (23b74 <SystemInit+0x1dc>)
   23a7c:	f8d3 3414 	ldr.w	r3, [r3, #1044]	; 0x414
   23a80:	f8c2 3530 	str.w	r3, [r2, #1328]	; 0x530
        NRF_TEMP->A5 = NRF_FICR->TEMP.A5;
   23a84:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23a88:	4a3a      	ldr	r2, [pc, #232]	; (23b74 <SystemInit+0x1dc>)
   23a8a:	f8d3 3418 	ldr.w	r3, [r3, #1048]	; 0x418
   23a8e:	f8c2 3534 	str.w	r3, [r2, #1332]	; 0x534
        NRF_TEMP->B0 = NRF_FICR->TEMP.B0;
   23a92:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23a96:	4a37      	ldr	r2, [pc, #220]	; (23b74 <SystemInit+0x1dc>)
   23a98:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
   23a9c:	f8c2 3540 	str.w	r3, [r2, #1344]	; 0x540
        NRF_TEMP->B1 = NRF_FICR->TEMP.B1;
   23aa0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23aa4:	4a33      	ldr	r2, [pc, #204]	; (23b74 <SystemInit+0x1dc>)
   23aa6:	f8d3 3420 	ldr.w	r3, [r3, #1056]	; 0x420
   23aaa:	f8c2 3544 	str.w	r3, [r2, #1348]	; 0x544
        NRF_TEMP->B2 = NRF_FICR->TEMP.B2;
   23aae:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23ab2:	4a30      	ldr	r2, [pc, #192]	; (23b74 <SystemInit+0x1dc>)
   23ab4:	f8d3 3424 	ldr.w	r3, [r3, #1060]	; 0x424
   23ab8:	f8c2 3548 	str.w	r3, [r2, #1352]	; 0x548
        NRF_TEMP->B3 = NRF_FICR->TEMP.B3;
   23abc:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23ac0:	4a2c      	ldr	r2, [pc, #176]	; (23b74 <SystemInit+0x1dc>)
   23ac2:	f8d3 3428 	ldr.w	r3, [r3, #1064]	; 0x428
   23ac6:	f8c2 354c 	str.w	r3, [r2, #1356]	; 0x54c
        NRF_TEMP->B4 = NRF_FICR->TEMP.B4;
   23aca:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23ace:	4a29      	ldr	r2, [pc, #164]	; (23b74 <SystemInit+0x1dc>)
   23ad0:	f8d3 342c 	ldr.w	r3, [r3, #1068]	; 0x42c
   23ad4:	f8c2 3550 	str.w	r3, [r2, #1360]	; 0x550
        NRF_TEMP->B5 = NRF_FICR->TEMP.B5;
   23ad8:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23adc:	4a25      	ldr	r2, [pc, #148]	; (23b74 <SystemInit+0x1dc>)
   23ade:	f8d3 3430 	ldr.w	r3, [r3, #1072]	; 0x430
   23ae2:	f8c2 3554 	str.w	r3, [r2, #1364]	; 0x554
        NRF_TEMP->T0 = NRF_FICR->TEMP.T0;
   23ae6:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23aea:	4a22      	ldr	r2, [pc, #136]	; (23b74 <SystemInit+0x1dc>)
   23aec:	f8d3 3434 	ldr.w	r3, [r3, #1076]	; 0x434
   23af0:	f8c2 3560 	str.w	r3, [r2, #1376]	; 0x560
        NRF_TEMP->T1 = NRF_FICR->TEMP.T1;
   23af4:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23af8:	4a1e      	ldr	r2, [pc, #120]	; (23b74 <SystemInit+0x1dc>)
   23afa:	f8d3 3438 	ldr.w	r3, [r3, #1080]	; 0x438
   23afe:	f8c2 3564 	str.w	r3, [r2, #1380]	; 0x564
        NRF_TEMP->T2 = NRF_FICR->TEMP.T2;
   23b02:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23b06:	4a1b      	ldr	r2, [pc, #108]	; (23b74 <SystemInit+0x1dc>)
   23b08:	f8d3 343c 	ldr.w	r3, [r3, #1084]	; 0x43c
   23b0c:	f8c2 3568 	str.w	r3, [r2, #1384]	; 0x568
        NRF_TEMP->T3 = NRF_FICR->TEMP.T3;
   23b10:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23b14:	4a17      	ldr	r2, [pc, #92]	; (23b74 <SystemInit+0x1dc>)
   23b16:	f8d3 3440 	ldr.w	r3, [r3, #1088]	; 0x440
   23b1a:	f8c2 356c 	str.w	r3, [r2, #1388]	; 0x56c
        NRF_TEMP->T4 = NRF_FICR->TEMP.T4;
   23b1e:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23b22:	4a14      	ldr	r2, [pc, #80]	; (23b74 <SystemInit+0x1dc>)
   23b24:	f8d3 3444 	ldr.w	r3, [r3, #1092]	; 0x444
   23b28:	f8c2 3570 	str.w	r3, [r2, #1392]	; 0x570
    }

    /* Workaround for Errata 108 "RAM: RAM content cannot be trusted upon waking up from System ON Idle or System OFF mode" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/  */
    if (errata_108()){
   23b2c:	f000 f928 	bl	23d80 <errata_108>
   23b30:	4603      	mov	r3, r0
   23b32:	2b00      	cmp	r3, #0
   23b34:	d005      	beq.n	23b42 <SystemInit+0x1aa>
        *(volatile uint32_t *)0x40000EE4 = *(volatile uint32_t *)0x10000258 & 0x0000004F;
   23b36:	4b10      	ldr	r3, [pc, #64]	; (23b78 <SystemInit+0x1e0>)
   23b38:	681b      	ldr	r3, [r3, #0]
   23b3a:	4a10      	ldr	r2, [pc, #64]	; (23b7c <SystemInit+0x1e4>)
   23b3c:	f003 034f 	and.w	r3, r3, #79	; 0x4f
   23b40:	6013      	str	r3, [r2, #0]
        NRF_P0->PIN_CNF[16] = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
        NRF_P0->PIN_CNF[18] = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
        NRF_P0->PIN_CNF[20] = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
    #endif

    SystemCoreClockUpdate();
   23b42:	f7ff ff1b 	bl	2397c <SystemCoreClockUpdate>
}
   23b46:	bf00      	nop
   23b48:	bd80      	pop	{r7, pc}
   23b4a:	bf00      	nop
   23b4c:	4007c074 	.word	0x4007c074
   23b50:	baadf00d 	.word	0xbaadf00d
   23b54:	10000244 	.word	0x10000244
   23b58:	4000053c 	.word	0x4000053c
   23b5c:	e000edf0 	.word	0xe000edf0
   23b60:	400005a0 	.word	0x400005a0
   23b64:	40005610 	.word	0x40005610
   23b68:	40005688 	.word	0x40005688
   23b6c:	40005618 	.word	0x40005618
   23b70:	40005614 	.word	0x40005614
   23b74:	4000c000 	.word	0x4000c000
   23b78:	10000258 	.word	0x10000258
   23b7c:	40000ee4 	.word	0x40000ee4

00023b80 <errata_16>:


static bool errata_16(void)
{
   23b80:	b480      	push	{r7}
   23b82:	af00      	add	r7, sp, #0
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
   23b84:	4b0b      	ldr	r3, [pc, #44]	; (23bb4 <errata_16+0x34>)
   23b86:	681b      	ldr	r3, [r3, #0]
   23b88:	b2db      	uxtb	r3, r3
   23b8a:	2b06      	cmp	r3, #6
   23b8c:	d10d      	bne.n	23baa <errata_16+0x2a>
   23b8e:	4b0a      	ldr	r3, [pc, #40]	; (23bb8 <errata_16+0x38>)
   23b90:	681b      	ldr	r3, [r3, #0]
   23b92:	f003 030f 	and.w	r3, r3, #15
   23b96:	2b00      	cmp	r3, #0
   23b98:	d107      	bne.n	23baa <errata_16+0x2a>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
   23b9a:	4b08      	ldr	r3, [pc, #32]	; (23bbc <errata_16+0x3c>)
   23b9c:	681b      	ldr	r3, [r3, #0]
   23b9e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   23ba2:	2b30      	cmp	r3, #48	; 0x30
   23ba4:	d101      	bne.n	23baa <errata_16+0x2a>
            return true;
   23ba6:	2301      	movs	r3, #1
   23ba8:	e000      	b.n	23bac <errata_16+0x2c>
        }
    }

    return false;
   23baa:	2300      	movs	r3, #0
}
   23bac:	4618      	mov	r0, r3
   23bae:	46bd      	mov	sp, r7
   23bb0:	bc80      	pop	{r7}
   23bb2:	4770      	bx	lr
   23bb4:	f0000fe0 	.word	0xf0000fe0
   23bb8:	f0000fe4 	.word	0xf0000fe4
   23bbc:	f0000fe8 	.word	0xf0000fe8

00023bc0 <errata_31>:

static bool errata_31(void)
{
   23bc0:	b480      	push	{r7}
   23bc2:	af00      	add	r7, sp, #0
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
   23bc4:	4b13      	ldr	r3, [pc, #76]	; (23c14 <errata_31+0x54>)
   23bc6:	681b      	ldr	r3, [r3, #0]
   23bc8:	b2db      	uxtb	r3, r3
   23bca:	2b06      	cmp	r3, #6
   23bcc:	d11d      	bne.n	23c0a <errata_31+0x4a>
   23bce:	4b12      	ldr	r3, [pc, #72]	; (23c18 <errata_31+0x58>)
   23bd0:	681b      	ldr	r3, [r3, #0]
   23bd2:	f003 030f 	and.w	r3, r3, #15
   23bd6:	2b00      	cmp	r3, #0
   23bd8:	d117      	bne.n	23c0a <errata_31+0x4a>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
   23bda:	4b10      	ldr	r3, [pc, #64]	; (23c1c <errata_31+0x5c>)
   23bdc:	681b      	ldr	r3, [r3, #0]
   23bde:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   23be2:	2b30      	cmp	r3, #48	; 0x30
   23be4:	d101      	bne.n	23bea <errata_31+0x2a>
            return true;
   23be6:	2301      	movs	r3, #1
   23be8:	e010      	b.n	23c0c <errata_31+0x4c>
        }
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x40){
   23bea:	4b0c      	ldr	r3, [pc, #48]	; (23c1c <errata_31+0x5c>)
   23bec:	681b      	ldr	r3, [r3, #0]
   23bee:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   23bf2:	2b40      	cmp	r3, #64	; 0x40
   23bf4:	d101      	bne.n	23bfa <errata_31+0x3a>
            return true;
   23bf6:	2301      	movs	r3, #1
   23bf8:	e008      	b.n	23c0c <errata_31+0x4c>
        }
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x50){
   23bfa:	4b08      	ldr	r3, [pc, #32]	; (23c1c <errata_31+0x5c>)
   23bfc:	681b      	ldr	r3, [r3, #0]
   23bfe:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   23c02:	2b50      	cmp	r3, #80	; 0x50
   23c04:	d101      	bne.n	23c0a <errata_31+0x4a>
            return true;
   23c06:	2301      	movs	r3, #1
   23c08:	e000      	b.n	23c0c <errata_31+0x4c>
        }
    }

    return false;
   23c0a:	2300      	movs	r3, #0
}
   23c0c:	4618      	mov	r0, r3
   23c0e:	46bd      	mov	sp, r7
   23c10:	bc80      	pop	{r7}
   23c12:	4770      	bx	lr
   23c14:	f0000fe0 	.word	0xf0000fe0
   23c18:	f0000fe4 	.word	0xf0000fe4
   23c1c:	f0000fe8 	.word	0xf0000fe8

00023c20 <errata_32>:

static bool errata_32(void)
{
   23c20:	b480      	push	{r7}
   23c22:	af00      	add	r7, sp, #0
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
   23c24:	4b0b      	ldr	r3, [pc, #44]	; (23c54 <errata_32+0x34>)
   23c26:	681b      	ldr	r3, [r3, #0]
   23c28:	b2db      	uxtb	r3, r3
   23c2a:	2b06      	cmp	r3, #6
   23c2c:	d10d      	bne.n	23c4a <errata_32+0x2a>
   23c2e:	4b0a      	ldr	r3, [pc, #40]	; (23c58 <errata_32+0x38>)
   23c30:	681b      	ldr	r3, [r3, #0]
   23c32:	f003 030f 	and.w	r3, r3, #15
   23c36:	2b00      	cmp	r3, #0
   23c38:	d107      	bne.n	23c4a <errata_32+0x2a>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
   23c3a:	4b08      	ldr	r3, [pc, #32]	; (23c5c <errata_32+0x3c>)
   23c3c:	681b      	ldr	r3, [r3, #0]
   23c3e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   23c42:	2b30      	cmp	r3, #48	; 0x30
   23c44:	d101      	bne.n	23c4a <errata_32+0x2a>
            return true;
   23c46:	2301      	movs	r3, #1
   23c48:	e000      	b.n	23c4c <errata_32+0x2c>
        }
    }

    return false;
   23c4a:	2300      	movs	r3, #0
}
   23c4c:	4618      	mov	r0, r3
   23c4e:	46bd      	mov	sp, r7
   23c50:	bc80      	pop	{r7}
   23c52:	4770      	bx	lr
   23c54:	f0000fe0 	.word	0xf0000fe0
   23c58:	f0000fe4 	.word	0xf0000fe4
   23c5c:	f0000fe8 	.word	0xf0000fe8

00023c60 <errata_36>:

static bool errata_36(void)
{
   23c60:	b480      	push	{r7}
   23c62:	af00      	add	r7, sp, #0
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
   23c64:	4b13      	ldr	r3, [pc, #76]	; (23cb4 <errata_36+0x54>)
   23c66:	681b      	ldr	r3, [r3, #0]
   23c68:	b2db      	uxtb	r3, r3
   23c6a:	2b06      	cmp	r3, #6
   23c6c:	d11d      	bne.n	23caa <errata_36+0x4a>
   23c6e:	4b12      	ldr	r3, [pc, #72]	; (23cb8 <errata_36+0x58>)
   23c70:	681b      	ldr	r3, [r3, #0]
   23c72:	f003 030f 	and.w	r3, r3, #15
   23c76:	2b00      	cmp	r3, #0
   23c78:	d117      	bne.n	23caa <errata_36+0x4a>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
   23c7a:	4b10      	ldr	r3, [pc, #64]	; (23cbc <errata_36+0x5c>)
   23c7c:	681b      	ldr	r3, [r3, #0]
   23c7e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   23c82:	2b30      	cmp	r3, #48	; 0x30
   23c84:	d101      	bne.n	23c8a <errata_36+0x2a>
            return true;
   23c86:	2301      	movs	r3, #1
   23c88:	e010      	b.n	23cac <errata_36+0x4c>
        }
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x40){
   23c8a:	4b0c      	ldr	r3, [pc, #48]	; (23cbc <errata_36+0x5c>)
   23c8c:	681b      	ldr	r3, [r3, #0]
   23c8e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   23c92:	2b40      	cmp	r3, #64	; 0x40
   23c94:	d101      	bne.n	23c9a <errata_36+0x3a>
            return true;
   23c96:	2301      	movs	r3, #1
   23c98:	e008      	b.n	23cac <errata_36+0x4c>
        }
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x50){
   23c9a:	4b08      	ldr	r3, [pc, #32]	; (23cbc <errata_36+0x5c>)
   23c9c:	681b      	ldr	r3, [r3, #0]
   23c9e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   23ca2:	2b50      	cmp	r3, #80	; 0x50
   23ca4:	d101      	bne.n	23caa <errata_36+0x4a>
            return true;
   23ca6:	2301      	movs	r3, #1
   23ca8:	e000      	b.n	23cac <errata_36+0x4c>
        }
    }

    return false;
   23caa:	2300      	movs	r3, #0
}
   23cac:	4618      	mov	r0, r3
   23cae:	46bd      	mov	sp, r7
   23cb0:	bc80      	pop	{r7}
   23cb2:	4770      	bx	lr
   23cb4:	f0000fe0 	.word	0xf0000fe0
   23cb8:	f0000fe4 	.word	0xf0000fe4
   23cbc:	f0000fe8 	.word	0xf0000fe8

00023cc0 <errata_37>:

static bool errata_37(void)
{
   23cc0:	b480      	push	{r7}
   23cc2:	af00      	add	r7, sp, #0
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
   23cc4:	4b0b      	ldr	r3, [pc, #44]	; (23cf4 <errata_37+0x34>)
   23cc6:	681b      	ldr	r3, [r3, #0]
   23cc8:	b2db      	uxtb	r3, r3
   23cca:	2b06      	cmp	r3, #6
   23ccc:	d10d      	bne.n	23cea <errata_37+0x2a>
   23cce:	4b0a      	ldr	r3, [pc, #40]	; (23cf8 <errata_37+0x38>)
   23cd0:	681b      	ldr	r3, [r3, #0]
   23cd2:	f003 030f 	and.w	r3, r3, #15
   23cd6:	2b00      	cmp	r3, #0
   23cd8:	d107      	bne.n	23cea <errata_37+0x2a>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
   23cda:	4b08      	ldr	r3, [pc, #32]	; (23cfc <errata_37+0x3c>)
   23cdc:	681b      	ldr	r3, [r3, #0]
   23cde:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   23ce2:	2b30      	cmp	r3, #48	; 0x30
   23ce4:	d101      	bne.n	23cea <errata_37+0x2a>
            return true;
   23ce6:	2301      	movs	r3, #1
   23ce8:	e000      	b.n	23cec <errata_37+0x2c>
        }
    }

    return false;
   23cea:	2300      	movs	r3, #0
}
   23cec:	4618      	mov	r0, r3
   23cee:	46bd      	mov	sp, r7
   23cf0:	bc80      	pop	{r7}
   23cf2:	4770      	bx	lr
   23cf4:	f0000fe0 	.word	0xf0000fe0
   23cf8:	f0000fe4 	.word	0xf0000fe4
   23cfc:	f0000fe8 	.word	0xf0000fe8

00023d00 <errata_57>:

static bool errata_57(void)
{
   23d00:	b480      	push	{r7}
   23d02:	af00      	add	r7, sp, #0
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
   23d04:	4b0b      	ldr	r3, [pc, #44]	; (23d34 <errata_57+0x34>)
   23d06:	681b      	ldr	r3, [r3, #0]
   23d08:	b2db      	uxtb	r3, r3
   23d0a:	2b06      	cmp	r3, #6
   23d0c:	d10d      	bne.n	23d2a <errata_57+0x2a>
   23d0e:	4b0a      	ldr	r3, [pc, #40]	; (23d38 <errata_57+0x38>)
   23d10:	681b      	ldr	r3, [r3, #0]
   23d12:	f003 030f 	and.w	r3, r3, #15
   23d16:	2b00      	cmp	r3, #0
   23d18:	d107      	bne.n	23d2a <errata_57+0x2a>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
   23d1a:	4b08      	ldr	r3, [pc, #32]	; (23d3c <errata_57+0x3c>)
   23d1c:	681b      	ldr	r3, [r3, #0]
   23d1e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   23d22:	2b30      	cmp	r3, #48	; 0x30
   23d24:	d101      	bne.n	23d2a <errata_57+0x2a>
            return true;
   23d26:	2301      	movs	r3, #1
   23d28:	e000      	b.n	23d2c <errata_57+0x2c>
        }
    }

    return false;
   23d2a:	2300      	movs	r3, #0
}
   23d2c:	4618      	mov	r0, r3
   23d2e:	46bd      	mov	sp, r7
   23d30:	bc80      	pop	{r7}
   23d32:	4770      	bx	lr
   23d34:	f0000fe0 	.word	0xf0000fe0
   23d38:	f0000fe4 	.word	0xf0000fe4
   23d3c:	f0000fe8 	.word	0xf0000fe8

00023d40 <errata_66>:

static bool errata_66(void)
{
   23d40:	b480      	push	{r7}
   23d42:	af00      	add	r7, sp, #0
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
   23d44:	4b0b      	ldr	r3, [pc, #44]	; (23d74 <errata_66+0x34>)
   23d46:	681b      	ldr	r3, [r3, #0]
   23d48:	b2db      	uxtb	r3, r3
   23d4a:	2b06      	cmp	r3, #6
   23d4c:	d10d      	bne.n	23d6a <errata_66+0x2a>
   23d4e:	4b0a      	ldr	r3, [pc, #40]	; (23d78 <errata_66+0x38>)
   23d50:	681b      	ldr	r3, [r3, #0]
   23d52:	f003 030f 	and.w	r3, r3, #15
   23d56:	2b00      	cmp	r3, #0
   23d58:	d107      	bne.n	23d6a <errata_66+0x2a>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x50){
   23d5a:	4b08      	ldr	r3, [pc, #32]	; (23d7c <errata_66+0x3c>)
   23d5c:	681b      	ldr	r3, [r3, #0]
   23d5e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   23d62:	2b50      	cmp	r3, #80	; 0x50
   23d64:	d101      	bne.n	23d6a <errata_66+0x2a>
            return true;
   23d66:	2301      	movs	r3, #1
   23d68:	e000      	b.n	23d6c <errata_66+0x2c>
        }
    }

    return false;
   23d6a:	2300      	movs	r3, #0
}
   23d6c:	4618      	mov	r0, r3
   23d6e:	46bd      	mov	sp, r7
   23d70:	bc80      	pop	{r7}
   23d72:	4770      	bx	lr
   23d74:	f0000fe0 	.word	0xf0000fe0
   23d78:	f0000fe4 	.word	0xf0000fe4
   23d7c:	f0000fe8 	.word	0xf0000fe8

00023d80 <errata_108>:


static bool errata_108(void)
{
   23d80:	b480      	push	{r7}
   23d82:	af00      	add	r7, sp, #0
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
   23d84:	4b13      	ldr	r3, [pc, #76]	; (23dd4 <errata_108+0x54>)
   23d86:	681b      	ldr	r3, [r3, #0]
   23d88:	b2db      	uxtb	r3, r3
   23d8a:	2b06      	cmp	r3, #6
   23d8c:	d11d      	bne.n	23dca <errata_108+0x4a>
   23d8e:	4b12      	ldr	r3, [pc, #72]	; (23dd8 <errata_108+0x58>)
   23d90:	681b      	ldr	r3, [r3, #0]
   23d92:	f003 030f 	and.w	r3, r3, #15
   23d96:	2b00      	cmp	r3, #0
   23d98:	d117      	bne.n	23dca <errata_108+0x4a>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
   23d9a:	4b10      	ldr	r3, [pc, #64]	; (23ddc <errata_108+0x5c>)
   23d9c:	681b      	ldr	r3, [r3, #0]
   23d9e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   23da2:	2b30      	cmp	r3, #48	; 0x30
   23da4:	d101      	bne.n	23daa <errata_108+0x2a>
            return true;
   23da6:	2301      	movs	r3, #1
   23da8:	e010      	b.n	23dcc <errata_108+0x4c>
        }
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x40){
   23daa:	4b0c      	ldr	r3, [pc, #48]	; (23ddc <errata_108+0x5c>)
   23dac:	681b      	ldr	r3, [r3, #0]
   23dae:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   23db2:	2b40      	cmp	r3, #64	; 0x40
   23db4:	d101      	bne.n	23dba <errata_108+0x3a>
            return true;
   23db6:	2301      	movs	r3, #1
   23db8:	e008      	b.n	23dcc <errata_108+0x4c>
        }
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x50){
   23dba:	4b08      	ldr	r3, [pc, #32]	; (23ddc <errata_108+0x5c>)
   23dbc:	681b      	ldr	r3, [r3, #0]
   23dbe:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   23dc2:	2b50      	cmp	r3, #80	; 0x50
   23dc4:	d101      	bne.n	23dca <errata_108+0x4a>
            return true;
   23dc6:	2301      	movs	r3, #1
   23dc8:	e000      	b.n	23dcc <errata_108+0x4c>
        }
    }

    return false;
   23dca:	2300      	movs	r3, #0
}
   23dcc:	4618      	mov	r0, r3
   23dce:	46bd      	mov	sp, r7
   23dd0:	bc80      	pop	{r7}
   23dd2:	4770      	bx	lr
   23dd4:	f0000fe0 	.word	0xf0000fe0
   23dd8:	f0000fe4 	.word	0xf0000fe4
   23ddc:	f0000fe8 	.word	0xf0000fe8

00023de0 <FifoInit>:
 * \param fifo      - the fifo to be configured
 * \param buf       - the buffer which will be attached to the fifo
 * \param buf_size  - the size of the buffer which will be attached to the fifo
 */
void FifoInit(app_fifo_t* fifo, uint8_t* buf, uint16_t buf_size)
{
   23de0:	b580      	push	{r7, lr}
   23de2:	b084      	sub	sp, #16
   23de4:	af00      	add	r7, sp, #0
   23de6:	60f8      	str	r0, [r7, #12]
   23de8:	60b9      	str	r1, [r7, #8]
   23dea:	4613      	mov	r3, r2
   23dec:	80fb      	strh	r3, [r7, #6]
    app_fifo_init(fifo, buf, buf_size);
   23dee:	88fb      	ldrh	r3, [r7, #6]
   23df0:	461a      	mov	r2, r3
   23df2:	68b9      	ldr	r1, [r7, #8]
   23df4:	68f8      	ldr	r0, [r7, #12]
   23df6:	f003 fc40 	bl	2767a <app_fifo_init>
}
   23dfa:	bf00      	nop
   23dfc:	3710      	adds	r7, #16
   23dfe:	46bd      	mov	sp, r7
   23e00:	bd80      	pop	{r7, pc}

00023e02 <FifoPut>:
 *
 * \param fifo - the FIFO where the byte is to be put
 * \param byte - the byte to be put
 */
inline void FifoPut(app_fifo_t* fifo, uint8_t byte)
{
   23e02:	b580      	push	{r7, lr}
   23e04:	b082      	sub	sp, #8
   23e06:	af00      	add	r7, sp, #0
   23e08:	6078      	str	r0, [r7, #4]
   23e0a:	460b      	mov	r3, r1
   23e0c:	70fb      	strb	r3, [r7, #3]
    app_fifo_put(fifo, byte);
   23e0e:	78fb      	ldrb	r3, [r7, #3]
   23e10:	4619      	mov	r1, r3
   23e12:	6878      	ldr	r0, [r7, #4]
   23e14:	f003 fc5c 	bl	276d0 <app_fifo_put>
}
   23e18:	bf00      	nop
   23e1a:	3708      	adds	r7, #8
   23e1c:	46bd      	mov	sp, r7
   23e1e:	bd80      	pop	{r7, pc}

00023e20 <NVIC_EnableIRQ>:
  \brief   Enable External Interrupt
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
   23e20:	b480      	push	{r7}
   23e22:	b083      	sub	sp, #12
   23e24:	af00      	add	r7, sp, #0
   23e26:	4603      	mov	r3, r0
   23e28:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   23e2a:	79fb      	ldrb	r3, [r7, #7]
   23e2c:	f003 021f 	and.w	r2, r3, #31
   23e30:	4906      	ldr	r1, [pc, #24]	; (23e4c <NVIC_EnableIRQ+0x2c>)
   23e32:	f997 3007 	ldrsb.w	r3, [r7, #7]
   23e36:	095b      	lsrs	r3, r3, #5
   23e38:	2001      	movs	r0, #1
   23e3a:	fa00 f202 	lsl.w	r2, r0, r2
   23e3e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   23e42:	bf00      	nop
   23e44:	370c      	adds	r7, #12
   23e46:	46bd      	mov	sp, r7
   23e48:	bc80      	pop	{r7}
   23e4a:	4770      	bx	lr
   23e4c:	e000e100 	.word	0xe000e100

00023e50 <NVIC_SetPriority>:
  \note    The priority cannot be set for every core interrupt.
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
   23e50:	b480      	push	{r7}
   23e52:	b083      	sub	sp, #12
   23e54:	af00      	add	r7, sp, #0
   23e56:	4603      	mov	r3, r0
   23e58:	6039      	str	r1, [r7, #0]
   23e5a:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) < 0)
   23e5c:	f997 3007 	ldrsb.w	r3, [r7, #7]
   23e60:	2b00      	cmp	r3, #0
   23e62:	da0b      	bge.n	23e7c <NVIC_SetPriority+0x2c>
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   23e64:	683b      	ldr	r3, [r7, #0]
   23e66:	b2da      	uxtb	r2, r3
   23e68:	490c      	ldr	r1, [pc, #48]	; (23e9c <NVIC_SetPriority+0x4c>)
   23e6a:	79fb      	ldrb	r3, [r7, #7]
   23e6c:	f003 030f 	and.w	r3, r3, #15
   23e70:	3b04      	subs	r3, #4
   23e72:	0152      	lsls	r2, r2, #5
   23e74:	b2d2      	uxtb	r2, r2
   23e76:	440b      	add	r3, r1
   23e78:	761a      	strb	r2, [r3, #24]
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
   23e7a:	e009      	b.n	23e90 <NVIC_SetPriority+0x40>
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   23e7c:	683b      	ldr	r3, [r7, #0]
   23e7e:	b2da      	uxtb	r2, r3
   23e80:	4907      	ldr	r1, [pc, #28]	; (23ea0 <NVIC_SetPriority+0x50>)
   23e82:	f997 3007 	ldrsb.w	r3, [r7, #7]
   23e86:	0152      	lsls	r2, r2, #5
   23e88:	b2d2      	uxtb	r2, r2
   23e8a:	440b      	add	r3, r1
   23e8c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
   23e90:	bf00      	nop
   23e92:	370c      	adds	r7, #12
   23e94:	46bd      	mov	sp, r7
   23e96:	bc80      	pop	{r7}
   23e98:	4770      	bx	lr
   23e9a:	bf00      	nop
   23e9c:	e000ed00 	.word	0xe000ed00
   23ea0:	e000e100 	.word	0xe000e100

00023ea4 <NVIC_GetPriority>:
  \param [in]   IRQn  Interrupt number.
  \return             Interrupt Priority.
                      Value is aligned automatically to the implemented priority bits of the microcontroller.
 */
__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
{
   23ea4:	b480      	push	{r7}
   23ea6:	b083      	sub	sp, #12
   23ea8:	af00      	add	r7, sp, #0
   23eaa:	4603      	mov	r3, r0
   23eac:	71fb      	strb	r3, [r7, #7]

  if ((int32_t)(IRQn) < 0)
   23eae:	f997 3007 	ldrsb.w	r3, [r7, #7]
   23eb2:	2b00      	cmp	r3, #0
   23eb4:	da0a      	bge.n	23ecc <NVIC_GetPriority+0x28>
  {
    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
   23eb6:	4a0c      	ldr	r2, [pc, #48]	; (23ee8 <NVIC_GetPriority+0x44>)
   23eb8:	79fb      	ldrb	r3, [r7, #7]
   23eba:	f003 030f 	and.w	r3, r3, #15
   23ebe:	3b04      	subs	r3, #4
   23ec0:	4413      	add	r3, r2
   23ec2:	7e1b      	ldrb	r3, [r3, #24]
   23ec4:	b2db      	uxtb	r3, r3
   23ec6:	095b      	lsrs	r3, r3, #5
   23ec8:	b2db      	uxtb	r3, r3
   23eca:	e008      	b.n	23ede <NVIC_GetPriority+0x3a>
  }
  else
  {
    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
   23ecc:	4a07      	ldr	r2, [pc, #28]	; (23eec <NVIC_GetPriority+0x48>)
   23ece:	f997 3007 	ldrsb.w	r3, [r7, #7]
   23ed2:	4413      	add	r3, r2
   23ed4:	f893 3300 	ldrb.w	r3, [r3, #768]	; 0x300
   23ed8:	b2db      	uxtb	r3, r3
   23eda:	095b      	lsrs	r3, r3, #5
   23edc:	b2db      	uxtb	r3, r3
  }
}
   23ede:	4618      	mov	r0, r3
   23ee0:	370c      	adds	r7, #12
   23ee2:	46bd      	mov	sp, r7
   23ee4:	bc80      	pop	{r7}
   23ee6:	4770      	bx	lr
   23ee8:	e000ed00 	.word	0xe000ed00
   23eec:	e000e100 	.word	0xe000e100

00023ef0 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
   23ef0:	b580      	push	{r7, lr}
   23ef2:	b082      	sub	sp, #8
   23ef4:	af00      	add	r7, sp, #0
   23ef6:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
   23ef8:	687b      	ldr	r3, [r7, #4]
   23efa:	3b01      	subs	r3, #1
   23efc:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
   23f00:	d301      	bcc.n	23f06 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
   23f02:	2301      	movs	r3, #1
   23f04:	e00f      	b.n	23f26 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
   23f06:	4a0a      	ldr	r2, [pc, #40]	; (23f30 <SysTick_Config+0x40>)
   23f08:	687b      	ldr	r3, [r7, #4]
   23f0a:	3b01      	subs	r3, #1
   23f0c:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
   23f0e:	2107      	movs	r1, #7
   23f10:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   23f14:	f7ff ff9c 	bl	23e50 <NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
   23f18:	4b05      	ldr	r3, [pc, #20]	; (23f30 <SysTick_Config+0x40>)
   23f1a:	2200      	movs	r2, #0
   23f1c:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
   23f1e:	4b04      	ldr	r3, [pc, #16]	; (23f30 <SysTick_Config+0x40>)
   23f20:	2207      	movs	r2, #7
   23f22:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
   23f24:	2300      	movs	r3, #0
}
   23f26:	4618      	mov	r0, r3
   23f28:	3708      	adds	r7, #8
   23f2a:	46bd      	mov	sp, r7
   23f2c:	bd80      	pop	{r7, pc}
   23f2e:	bf00      	nop
   23f30:	e000e010 	.word	0xe000e010

00023f34 <sd_softdevice_is_enabled>:
 *
 * @param[out]  p_softdevice_enabled If the SoftDevice is enabled: 1 else 0.
 *
 * @retval ::NRF_SUCCESS
 */
SVCALL(SD_SOFTDEVICE_IS_ENABLED, uint32_t, sd_softdevice_is_enabled(uint8_t * p_softdevice_enabled));
   23f34:	df12      	svc	18
   23f36:	4770      	bx	lr
   23f38:	bf00      	nop
   23f3a:	4618      	mov	r0, r3

00023f3c <__sd_nvic_app_accessible_irq>:
{
  __enable_irq();
}

__STATIC_INLINE uint32_t __sd_nvic_app_accessible_irq(IRQn_Type IRQn)
{
   23f3c:	b480      	push	{r7}
   23f3e:	b083      	sub	sp, #12
   23f40:	af00      	add	r7, sp, #0
   23f42:	4603      	mov	r3, r0
   23f44:	71fb      	strb	r3, [r7, #7]
  if (IRQn < 32)
   23f46:	f997 3007 	ldrsb.w	r3, [r7, #7]
   23f4a:	2b1f      	cmp	r3, #31
   23f4c:	dc0c      	bgt.n	23f68 <__sd_nvic_app_accessible_irq+0x2c>
  {
    return ((1UL<<IRQn) & __NRF_NVIC_APP_IRQS_0) != 0;
   23f4e:	f997 3007 	ldrsb.w	r3, [r7, #7]
   23f52:	4a10      	ldr	r2, [pc, #64]	; (23f94 <__sd_nvic_app_accessible_irq+0x58>)
   23f54:	fa22 f303 	lsr.w	r3, r2, r3
   23f58:	f003 0301 	and.w	r3, r3, #1
   23f5c:	2b00      	cmp	r3, #0
   23f5e:	bf14      	ite	ne
   23f60:	2301      	movne	r3, #1
   23f62:	2300      	moveq	r3, #0
   23f64:	b2db      	uxtb	r3, r3
   23f66:	e010      	b.n	23f8a <__sd_nvic_app_accessible_irq+0x4e>
  }
  else if (IRQn < 64)
   23f68:	f997 3007 	ldrsb.w	r3, [r7, #7]
   23f6c:	2b3f      	cmp	r3, #63	; 0x3f
   23f6e:	dc0b      	bgt.n	23f88 <__sd_nvic_app_accessible_irq+0x4c>
  {
    return ((1UL<<(IRQn-32)) & __NRF_NVIC_APP_IRQS_1) != 0;
   23f70:	f997 3007 	ldrsb.w	r3, [r7, #7]
   23f74:	3b20      	subs	r3, #32
   23f76:	2201      	movs	r2, #1
   23f78:	fa02 f303 	lsl.w	r3, r2, r3
   23f7c:	2b00      	cmp	r3, #0
   23f7e:	bf14      	ite	ne
   23f80:	2301      	movne	r3, #1
   23f82:	2300      	moveq	r3, #0
   23f84:	b2db      	uxtb	r3, r3
   23f86:	e000      	b.n	23f8a <__sd_nvic_app_accessible_irq+0x4e>
  }
  else
  {
    return 1;
   23f88:	2301      	movs	r3, #1
  }
}
   23f8a:	4618      	mov	r0, r3
   23f8c:	370c      	adds	r7, #12
   23f8e:	46bd      	mov	sp, r7
   23f90:	bc80      	pop	{r7}
   23f92:	4770      	bx	lr
   23f94:	bdff06fc 	.word	0xbdff06fc

00023f98 <__sd_nvic_is_app_accessible_priority>:

__STATIC_INLINE uint32_t __sd_nvic_is_app_accessible_priority(uint32_t priority)
{
   23f98:	b480      	push	{r7}
   23f9a:	b083      	sub	sp, #12
   23f9c:	af00      	add	r7, sp, #0
   23f9e:	6078      	str	r0, [r7, #4]
  if(priority >= (1 << __NVIC_PRIO_BITS))
   23fa0:	687b      	ldr	r3, [r7, #4]
   23fa2:	2b07      	cmp	r3, #7
   23fa4:	d901      	bls.n	23faa <__sd_nvic_is_app_accessible_priority+0x12>
  {
    return 0;
   23fa6:	2300      	movs	r3, #0
   23fa8:	e00b      	b.n	23fc2 <__sd_nvic_is_app_accessible_priority+0x2a>
  }
  if(   priority == 0
   23faa:	687b      	ldr	r3, [r7, #4]
   23fac:	2b00      	cmp	r3, #0
   23fae:	d005      	beq.n	23fbc <__sd_nvic_is_app_accessible_priority+0x24>
     || priority == 1
   23fb0:	687b      	ldr	r3, [r7, #4]
   23fb2:	2b01      	cmp	r3, #1
   23fb4:	d002      	beq.n	23fbc <__sd_nvic_is_app_accessible_priority+0x24>
     || priority == 4
   23fb6:	687b      	ldr	r3, [r7, #4]
   23fb8:	2b04      	cmp	r3, #4
   23fba:	d101      	bne.n	23fc0 <__sd_nvic_is_app_accessible_priority+0x28>
     )
  {
    return 0;
   23fbc:	2300      	movs	r3, #0
   23fbe:	e000      	b.n	23fc2 <__sd_nvic_is_app_accessible_priority+0x2a>
  }
  return 1;
   23fc0:	2301      	movs	r3, #1
}
   23fc2:	4618      	mov	r0, r3
   23fc4:	370c      	adds	r7, #12
   23fc6:	46bd      	mov	sp, r7
   23fc8:	bc80      	pop	{r7}
   23fca:	4770      	bx	lr

00023fcc <sd_nvic_EnableIRQ>:


__STATIC_INLINE uint32_t sd_nvic_EnableIRQ(IRQn_Type IRQn)
{
   23fcc:	b580      	push	{r7, lr}
   23fce:	b082      	sub	sp, #8
   23fd0:	af00      	add	r7, sp, #0
   23fd2:	4603      	mov	r3, r0
   23fd4:	71fb      	strb	r3, [r7, #7]
  if (!__sd_nvic_app_accessible_irq(IRQn))
   23fd6:	f997 3007 	ldrsb.w	r3, [r7, #7]
   23fda:	4618      	mov	r0, r3
   23fdc:	f7ff ffae 	bl	23f3c <__sd_nvic_app_accessible_irq>
   23fe0:	4603      	mov	r3, r0
   23fe2:	2b00      	cmp	r3, #0
   23fe4:	d102      	bne.n	23fec <sd_nvic_EnableIRQ+0x20>
  {
    return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
   23fe6:	f242 0301 	movw	r3, #8193	; 0x2001
   23fea:	e02d      	b.n	24048 <sd_nvic_EnableIRQ+0x7c>
  }
  if (!__sd_nvic_is_app_accessible_priority(NVIC_GetPriority(IRQn)))
   23fec:	f997 3007 	ldrsb.w	r3, [r7, #7]
   23ff0:	4618      	mov	r0, r3
   23ff2:	f7ff ff57 	bl	23ea4 <NVIC_GetPriority>
   23ff6:	4603      	mov	r3, r0
   23ff8:	4618      	mov	r0, r3
   23ffa:	f7ff ffcd 	bl	23f98 <__sd_nvic_is_app_accessible_priority>
   23ffe:	4603      	mov	r3, r0
   24000:	2b00      	cmp	r3, #0
   24002:	d102      	bne.n	2400a <sd_nvic_EnableIRQ+0x3e>
  {
    return NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED;
   24004:	f242 0302 	movw	r3, #8194	; 0x2002
   24008:	e01e      	b.n	24048 <sd_nvic_EnableIRQ+0x7c>
  }

  if (nrf_nvic_state.__cr_flag)
   2400a:	4b11      	ldr	r3, [pc, #68]	; (24050 <sd_nvic_EnableIRQ+0x84>)
   2400c:	689b      	ldr	r3, [r3, #8]
   2400e:	2b00      	cmp	r3, #0
   24010:	d014      	beq.n	2403c <sd_nvic_EnableIRQ+0x70>
  {
    nrf_nvic_state.__irq_masks[(uint32_t)((int32_t)IRQn) >> 5] |= (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F));
   24012:	f997 3007 	ldrsb.w	r3, [r7, #7]
   24016:	095b      	lsrs	r3, r3, #5
   24018:	4a0d      	ldr	r2, [pc, #52]	; (24050 <sd_nvic_EnableIRQ+0x84>)
   2401a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
   2401e:	79fb      	ldrb	r3, [r7, #7]
   24020:	f003 031f 	and.w	r3, r3, #31
   24024:	2101      	movs	r1, #1
   24026:	fa01 f303 	lsl.w	r3, r1, r3
   2402a:	4619      	mov	r1, r3
   2402c:	f997 3007 	ldrsb.w	r3, [r7, #7]
   24030:	095b      	lsrs	r3, r3, #5
   24032:	430a      	orrs	r2, r1
   24034:	4906      	ldr	r1, [pc, #24]	; (24050 <sd_nvic_EnableIRQ+0x84>)
   24036:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
   2403a:	e004      	b.n	24046 <sd_nvic_EnableIRQ+0x7a>
  }
  else
  {
    NVIC_EnableIRQ(IRQn);
   2403c:	f997 3007 	ldrsb.w	r3, [r7, #7]
   24040:	4618      	mov	r0, r3
   24042:	f7ff feed 	bl	23e20 <NVIC_EnableIRQ>
  }
  return NRF_SUCCESS;
   24046:	2300      	movs	r3, #0
}
   24048:	4618      	mov	r0, r3
   2404a:	3708      	adds	r7, #8
   2404c:	46bd      	mov	sp, r7
   2404e:	bd80      	pop	{r7, pc}
   24050:	2000512c 	.word	0x2000512c

00024054 <sd_nvic_SetPriority>:
    return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
  }
}

__STATIC_INLINE uint32_t sd_nvic_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
   24054:	b580      	push	{r7, lr}
   24056:	b082      	sub	sp, #8
   24058:	af00      	add	r7, sp, #0
   2405a:	4603      	mov	r3, r0
   2405c:	6039      	str	r1, [r7, #0]
   2405e:	71fb      	strb	r3, [r7, #7]
  if (!__sd_nvic_app_accessible_irq(IRQn))
   24060:	f997 3007 	ldrsb.w	r3, [r7, #7]
   24064:	4618      	mov	r0, r3
   24066:	f7ff ff69 	bl	23f3c <__sd_nvic_app_accessible_irq>
   2406a:	4603      	mov	r3, r0
   2406c:	2b00      	cmp	r3, #0
   2406e:	d102      	bne.n	24076 <sd_nvic_SetPriority+0x22>
  {
    return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
   24070:	f242 0301 	movw	r3, #8193	; 0x2001
   24074:	e00f      	b.n	24096 <sd_nvic_SetPriority+0x42>
  }

  if (!__sd_nvic_is_app_accessible_priority(priority))
   24076:	6838      	ldr	r0, [r7, #0]
   24078:	f7ff ff8e 	bl	23f98 <__sd_nvic_is_app_accessible_priority>
   2407c:	4603      	mov	r3, r0
   2407e:	2b00      	cmp	r3, #0
   24080:	d102      	bne.n	24088 <sd_nvic_SetPriority+0x34>
  {
    return NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED;
   24082:	f242 0302 	movw	r3, #8194	; 0x2002
   24086:	e006      	b.n	24096 <sd_nvic_SetPriority+0x42>
  }

  NVIC_SetPriority(IRQn, (uint32_t)priority);
   24088:	f997 3007 	ldrsb.w	r3, [r7, #7]
   2408c:	6839      	ldr	r1, [r7, #0]
   2408e:	4618      	mov	r0, r3
   24090:	f7ff fede 	bl	23e50 <NVIC_SetPriority>
  return NRF_SUCCESS;
   24094:	2300      	movs	r3, #0
}
   24096:	4618      	mov	r0, r3
   24098:	3708      	adds	r7, #8
   2409a:	46bd      	mov	sp, r7
   2409c:	bd80      	pop	{r7, pc}
	...

000240a0 <SysTick_Handler>:
static uint32_t systickCnt;
static bool		systickTimeoutFlag;


void SysTick_Handler()
{
   240a0:	b480      	push	{r7}
   240a2:	af00      	add	r7, sp, #0
	systickCnt--;
   240a4:	4b07      	ldr	r3, [pc, #28]	; (240c4 <SysTick_Handler+0x24>)
   240a6:	681b      	ldr	r3, [r3, #0]
   240a8:	3b01      	subs	r3, #1
   240aa:	4a06      	ldr	r2, [pc, #24]	; (240c4 <SysTick_Handler+0x24>)
   240ac:	6013      	str	r3, [r2, #0]
	if(systickCnt == 0)
   240ae:	4b05      	ldr	r3, [pc, #20]	; (240c4 <SysTick_Handler+0x24>)
   240b0:	681b      	ldr	r3, [r3, #0]
   240b2:	2b00      	cmp	r3, #0
   240b4:	d102      	bne.n	240bc <SysTick_Handler+0x1c>
	{
		systickTimeoutFlag = true;
   240b6:	4b04      	ldr	r3, [pc, #16]	; (240c8 <SysTick_Handler+0x28>)
   240b8:	2201      	movs	r2, #1
   240ba:	701a      	strb	r2, [r3, #0]
	}
}
   240bc:	bf00      	nop
   240be:	46bd      	mov	sp, r7
   240c0:	bc80      	pop	{r7}
   240c2:	4770      	bx	lr
   240c4:	20005138 	.word	0x20005138
   240c8:	2000513c 	.word	0x2000513c

000240cc <SystickInit>:

void SystickInit()
{
   240cc:	b580      	push	{r7, lr}
   240ce:	b082      	sub	sp, #8
   240d0:	af00      	add	r7, sp, #0
	SysTick_Config(SystemCoreClock/1000);
   240d2:	4b10      	ldr	r3, [pc, #64]	; (24114 <SystickInit+0x48>)
   240d4:	681b      	ldr	r3, [r3, #0]
   240d6:	4a10      	ldr	r2, [pc, #64]	; (24118 <SystickInit+0x4c>)
   240d8:	fba2 2303 	umull	r2, r3, r2, r3
   240dc:	099b      	lsrs	r3, r3, #6
   240de:	4618      	mov	r0, r3
   240e0:	f7ff ff06 	bl	23ef0 <SysTick_Config>

#if !SOFTDEVICE_ENABLED
	NVIC_SetPriority(SysTick_IRQn, 2);
	NVIC_EnableIRQ(SysTick_IRQn);
#else
	bool sdEnabled = false;
   240e4:	2300      	movs	r3, #0
   240e6:	70fb      	strb	r3, [r7, #3]
	sd_softdevice_is_enabled((uint8_t*)(&sdEnabled));
   240e8:	1cfb      	adds	r3, r7, #3
   240ea:	4618      	mov	r0, r3
   240ec:	f7ff ff22 	bl	23f34 <sd_softdevice_is_enabled>
	if(sdEnabled)
   240f0:	78fb      	ldrb	r3, [r7, #3]
   240f2:	2b00      	cmp	r3, #0
   240f4:	d00a      	beq.n	2410c <SystickInit+0x40>
	{
		uint32_t retval = sd_nvic_SetPriority(SysTick_IRQn, APPLICATION_IRQ_LOWEST_PRIORITY);
   240f6:	2107      	movs	r1, #7
   240f8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   240fc:	f7ff ffaa 	bl	24054 <sd_nvic_SetPriority>
   24100:	6078      	str	r0, [r7, #4]
		retval = sd_nvic_EnableIRQ(SysTick_IRQn);
   24102:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   24106:	f7ff ff61 	bl	23fcc <sd_nvic_EnableIRQ>
   2410a:	6078      	str	r0, [r7, #4]
	}

#endif
}
   2410c:	bf00      	nop
   2410e:	3708      	adds	r7, #8
   24110:	46bd      	mov	sp, r7
   24112:	bd80      	pop	{r7, pc}
   24114:	20005064 	.word	0x20005064
   24118:	10624dd3 	.word	0x10624dd3

0002411c <SD_flash_operation_callback>:
/**
*   @brief This function is a callback which is called in sys_evt_dispatch() function, after some data is stored or the page erased using sd_flash_xxx() function. It gives us a feedback when the operation is completed and if the data was stored successfully
*   @param uint32_t sys_evt - the number of event which is given by SWIO from softdevice
**/
void SD_flash_operation_callback(uint32_t sys_evt)
{
   2411c:	b580      	push	{r7, lr}
   2411e:	b084      	sub	sp, #16
   24120:	af00      	add	r7, sp, #0
   24122:	6078      	str	r0, [r7, #4]
    switch(sys_evt)
   24124:	687b      	ldr	r3, [r7, #4]
   24126:	2b02      	cmp	r3, #2
   24128:	d002      	beq.n	24130 <SD_flash_operation_callback+0x14>
   2412a:	2b03      	cmp	r3, #3
   2412c:	d026      	beq.n	2417c <SD_flash_operation_callback+0x60>
   2412e:	e048      	b.n	241c2 <SD_flash_operation_callback+0xa6>
    {
        case NRF_EVT_FLASH_OPERATION_SUCCESS:
        {
            switch(flash_write_or_erase_flag)
   24130:	4b27      	ldr	r3, [pc, #156]	; (241d0 <SD_flash_operation_callback+0xb4>)
   24132:	781b      	ldrb	r3, [r3, #0]
   24134:	2b0f      	cmp	r3, #15
   24136:	d002      	beq.n	2413e <SD_flash_operation_callback+0x22>
   24138:	2bf0      	cmp	r3, #240	; 0xf0
   2413a:	d016      	beq.n	2416a <SD_flash_operation_callback+0x4e>
   2413c:	e019      	b.n	24172 <SD_flash_operation_callback+0x56>
            {
                case FLASH_WRITE_OPERATION:
                {
                    uint32_t temp;
                    //  read what was just flashed
                    memcpy(&temp, last_flashed_data_pointer, sizeof(uint32_t));
   2413e:	4b25      	ldr	r3, [pc, #148]	; (241d4 <SD_flash_operation_callback+0xb8>)
   24140:	6819      	ldr	r1, [r3, #0]
   24142:	f107 030c 	add.w	r3, r7, #12
   24146:	2204      	movs	r2, #4
   24148:	4618      	mov	r0, r3
   2414a:	f003 fb5d 	bl	27808 <memcpy>
                    //  Check if data just read is identical as the last_flashed_data
                    if(last_flashed_data == temp)
   2414e:	4b22      	ldr	r3, [pc, #136]	; (241d8 <SD_flash_operation_callback+0xbc>)
   24150:	681a      	ldr	r2, [r3, #0]
   24152:	68fb      	ldr	r3, [r7, #12]
   24154:	429a      	cmp	r2, r3
   24156:	d103      	bne.n	24160 <SD_flash_operation_callback+0x44>
                    {
                        flash_operation_completed_flag = FLASH_OP_SUCCESS;  /// data ok
   24158:	4b20      	ldr	r3, [pc, #128]	; (241dc <SD_flash_operation_callback+0xc0>)
   2415a:	22ff      	movs	r2, #255	; 0xff
   2415c:	701a      	strb	r2, [r3, #0]
                    }
                    else
                    {
                        flash_operation_completed_flag = FLASH_OP_WRITE_ERROR;  /// data corrupted
                    }
                    break;
   2415e:	e00c      	b.n	2417a <SD_flash_operation_callback+0x5e>
                        flash_operation_completed_flag = FLASH_OP_WRITE_ERROR;  /// data corrupted
   24160:	4b1e      	ldr	r3, [pc, #120]	; (241dc <SD_flash_operation_callback+0xc0>)
   24162:	220f      	movs	r2, #15
   24164:	701a      	strb	r2, [r3, #0]
                    break;
   24166:	bf00      	nop
   24168:	e007      	b.n	2417a <SD_flash_operation_callback+0x5e>
                }
                case FLASH_ERASE_OPERATION:
                    flash_operation_completed_flag = FLASH_OP_SUCCESS;
   2416a:	4b1c      	ldr	r3, [pc, #112]	; (241dc <SD_flash_operation_callback+0xc0>)
   2416c:	22ff      	movs	r2, #255	; 0xff
   2416e:	701a      	strb	r2, [r3, #0]
                    break;
   24170:	e003      	b.n	2417a <SD_flash_operation_callback+0x5e>
                default:    //  If we do not want to check the stored data
                    flash_operation_completed_flag = FLASH_OP_SUCCESS;
   24172:	4b1a      	ldr	r3, [pc, #104]	; (241dc <SD_flash_operation_callback+0xc0>)
   24174:	22ff      	movs	r2, #255	; 0xff
   24176:	701a      	strb	r2, [r3, #0]
                    break;
   24178:	bf00      	nop
            }
            break;
   2417a:	e022      	b.n	241c2 <SD_flash_operation_callback+0xa6>
        }
        case NRF_EVT_FLASH_OPERATION_ERROR:
            switch(flash_write_or_erase_flag)
   2417c:	4b14      	ldr	r3, [pc, #80]	; (241d0 <SD_flash_operation_callback+0xb4>)
   2417e:	781b      	ldrb	r3, [r3, #0]
   24180:	2b0f      	cmp	r3, #15
   24182:	d118      	bne.n	241b6 <SD_flash_operation_callback+0x9a>
            {
                case FLASH_WRITE_OPERATION:
                    {
                        uint32_t temp;
                        //  read what was just flashed
                        memcpy(&temp, last_flashed_data_pointer, sizeof(uint32_t));
   24184:	4b13      	ldr	r3, [pc, #76]	; (241d4 <SD_flash_operation_callback+0xb8>)
   24186:	6819      	ldr	r1, [r3, #0]
   24188:	f107 0308 	add.w	r3, r7, #8
   2418c:	2204      	movs	r2, #4
   2418e:	4618      	mov	r0, r3
   24190:	f003 fb3a 	bl	27808 <memcpy>
                        //  If the data wasn't even stored
                        if(temp == 0xFFFFFFFF)
   24194:	68bb      	ldr	r3, [r7, #8]
   24196:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   2419a:	d103      	bne.n	241a4 <SD_flash_operation_callback+0x88>
                        {
                            flash_operation_completed_flag = FLASH_OPERATION_ERROR;
   2419c:	4b0f      	ldr	r3, [pc, #60]	; (241dc <SD_flash_operation_callback+0xc0>)
   2419e:	22a0      	movs	r2, #160	; 0xa0
   241a0:	701a      	strb	r2, [r3, #0]
                        if(temp != last_flashed_data)
                        {
                            flash_operation_completed_flag = FLASH_OP_WRITE_ERROR;
                        }
                    }
                    break;
   241a2:	e00c      	b.n	241be <SD_flash_operation_callback+0xa2>
                        if(temp != last_flashed_data)
   241a4:	68ba      	ldr	r2, [r7, #8]
   241a6:	4b0c      	ldr	r3, [pc, #48]	; (241d8 <SD_flash_operation_callback+0xbc>)
   241a8:	681b      	ldr	r3, [r3, #0]
   241aa:	429a      	cmp	r2, r3
   241ac:	d007      	beq.n	241be <SD_flash_operation_callback+0xa2>
                            flash_operation_completed_flag = FLASH_OP_WRITE_ERROR;
   241ae:	4b0b      	ldr	r3, [pc, #44]	; (241dc <SD_flash_operation_callback+0xc0>)
   241b0:	220f      	movs	r2, #15
   241b2:	701a      	strb	r2, [r3, #0]
                    break;
   241b4:	e003      	b.n	241be <SD_flash_operation_callback+0xa2>
                default:
                    flash_operation_completed_flag = FLASH_OP_ERASE_ERROR;
   241b6:	4b09      	ldr	r3, [pc, #36]	; (241dc <SD_flash_operation_callback+0xc0>)
   241b8:	22f0      	movs	r2, #240	; 0xf0
   241ba:	701a      	strb	r2, [r3, #0]
                    break;
   241bc:	e000      	b.n	241c0 <SD_flash_operation_callback+0xa4>
                    break;
   241be:	bf00      	nop
            }
            break;
   241c0:	bf00      	nop
    }
    flash_write_or_erase_flag = 0;  //  clear the flag
   241c2:	4b03      	ldr	r3, [pc, #12]	; (241d0 <SD_flash_operation_callback+0xb4>)
   241c4:	2200      	movs	r2, #0
   241c6:	701a      	strb	r2, [r3, #0]
}
   241c8:	bf00      	nop
   241ca:	3710      	adds	r7, #16
   241cc:	46bd      	mov	sp, r7
   241ce:	bd80      	pop	{r7, pc}
   241d0:	2000513d 	.word	0x2000513d
   241d4:	20005144 	.word	0x20005144
   241d8:	20005140 	.word	0x20005140
   241dc:	20005068 	.word	0x20005068

000241e0 <NVIC_EnableIRQ>:
{
   241e0:	b480      	push	{r7}
   241e2:	b083      	sub	sp, #12
   241e4:	af00      	add	r7, sp, #0
   241e6:	4603      	mov	r3, r0
   241e8:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   241ea:	79fb      	ldrb	r3, [r7, #7]
   241ec:	f003 021f 	and.w	r2, r3, #31
   241f0:	4906      	ldr	r1, [pc, #24]	; (2420c <NVIC_EnableIRQ+0x2c>)
   241f2:	f997 3007 	ldrsb.w	r3, [r7, #7]
   241f6:	095b      	lsrs	r3, r3, #5
   241f8:	2001      	movs	r0, #1
   241fa:	fa00 f202 	lsl.w	r2, r0, r2
   241fe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   24202:	bf00      	nop
   24204:	370c      	adds	r7, #12
   24206:	46bd      	mov	sp, r7
   24208:	bc80      	pop	{r7}
   2420a:	4770      	bx	lr
   2420c:	e000e100 	.word	0xe000e100

00024210 <NVIC_SetPriority>:
{
   24210:	b480      	push	{r7}
   24212:	b083      	sub	sp, #12
   24214:	af00      	add	r7, sp, #0
   24216:	4603      	mov	r3, r0
   24218:	6039      	str	r1, [r7, #0]
   2421a:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) < 0)
   2421c:	f997 3007 	ldrsb.w	r3, [r7, #7]
   24220:	2b00      	cmp	r3, #0
   24222:	da0b      	bge.n	2423c <NVIC_SetPriority+0x2c>
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   24224:	683b      	ldr	r3, [r7, #0]
   24226:	b2da      	uxtb	r2, r3
   24228:	490c      	ldr	r1, [pc, #48]	; (2425c <NVIC_SetPriority+0x4c>)
   2422a:	79fb      	ldrb	r3, [r7, #7]
   2422c:	f003 030f 	and.w	r3, r3, #15
   24230:	3b04      	subs	r3, #4
   24232:	0152      	lsls	r2, r2, #5
   24234:	b2d2      	uxtb	r2, r2
   24236:	440b      	add	r3, r1
   24238:	761a      	strb	r2, [r3, #24]
}
   2423a:	e009      	b.n	24250 <NVIC_SetPriority+0x40>
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   2423c:	683b      	ldr	r3, [r7, #0]
   2423e:	b2da      	uxtb	r2, r3
   24240:	4907      	ldr	r1, [pc, #28]	; (24260 <NVIC_SetPriority+0x50>)
   24242:	f997 3007 	ldrsb.w	r3, [r7, #7]
   24246:	0152      	lsls	r2, r2, #5
   24248:	b2d2      	uxtb	r2, r2
   2424a:	440b      	add	r3, r1
   2424c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
   24250:	bf00      	nop
   24252:	370c      	adds	r7, #12
   24254:	46bd      	mov	sp, r7
   24256:	bc80      	pop	{r7}
   24258:	4770      	bx	lr
   2425a:	bf00      	nop
   2425c:	e000ed00 	.word	0xe000ed00
   24260:	e000e100 	.word	0xe000e100

00024264 <NVIC_GetPriority>:
{
   24264:	b480      	push	{r7}
   24266:	b083      	sub	sp, #12
   24268:	af00      	add	r7, sp, #0
   2426a:	4603      	mov	r3, r0
   2426c:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) < 0)
   2426e:	f997 3007 	ldrsb.w	r3, [r7, #7]
   24272:	2b00      	cmp	r3, #0
   24274:	da0a      	bge.n	2428c <NVIC_GetPriority+0x28>
    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
   24276:	4a0c      	ldr	r2, [pc, #48]	; (242a8 <NVIC_GetPriority+0x44>)
   24278:	79fb      	ldrb	r3, [r7, #7]
   2427a:	f003 030f 	and.w	r3, r3, #15
   2427e:	3b04      	subs	r3, #4
   24280:	4413      	add	r3, r2
   24282:	7e1b      	ldrb	r3, [r3, #24]
   24284:	b2db      	uxtb	r3, r3
   24286:	095b      	lsrs	r3, r3, #5
   24288:	b2db      	uxtb	r3, r3
   2428a:	e008      	b.n	2429e <NVIC_GetPriority+0x3a>
    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
   2428c:	4a07      	ldr	r2, [pc, #28]	; (242ac <NVIC_GetPriority+0x48>)
   2428e:	f997 3007 	ldrsb.w	r3, [r7, #7]
   24292:	4413      	add	r3, r2
   24294:	f893 3300 	ldrb.w	r3, [r3, #768]	; 0x300
   24298:	b2db      	uxtb	r3, r3
   2429a:	095b      	lsrs	r3, r3, #5
   2429c:	b2db      	uxtb	r3, r3
}
   2429e:	4618      	mov	r0, r3
   242a0:	370c      	adds	r7, #12
   242a2:	46bd      	mov	sp, r7
   242a4:	bc80      	pop	{r7}
   242a6:	4770      	bx	lr
   242a8:	e000ed00 	.word	0xe000ed00
   242ac:	e000e100 	.word	0xe000e100

000242b0 <nrf_gpio_pin_port_decode>:
{
   242b0:	b480      	push	{r7}
   242b2:	b083      	sub	sp, #12
   242b4:	af00      	add	r7, sp, #0
   242b6:	6078      	str	r0, [r7, #4]
    return NRF_GPIO;
   242b8:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
}
   242bc:	4618      	mov	r0, r3
   242be:	370c      	adds	r7, #12
   242c0:	46bd      	mov	sp, r7
   242c2:	bc80      	pop	{r7}
   242c4:	4770      	bx	lr

000242c6 <nrf_gpio_pin_set>:
{
   242c6:	b580      	push	{r7, lr}
   242c8:	b084      	sub	sp, #16
   242ca:	af00      	add	r7, sp, #0
   242cc:	6078      	str	r0, [r7, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   242ce:	1d3b      	adds	r3, r7, #4
   242d0:	4618      	mov	r0, r3
   242d2:	f7ff ffed 	bl	242b0 <nrf_gpio_pin_port_decode>
   242d6:	60f8      	str	r0, [r7, #12]
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   242d8:	687b      	ldr	r3, [r7, #4]
   242da:	2201      	movs	r2, #1
   242dc:	fa02 f303 	lsl.w	r3, r2, r3
   242e0:	4619      	mov	r1, r3
   242e2:	68f8      	ldr	r0, [r7, #12]
   242e4:	f000 f819 	bl	2431a <nrf_gpio_port_out_set>
}
   242e8:	bf00      	nop
   242ea:	3710      	adds	r7, #16
   242ec:	46bd      	mov	sp, r7
   242ee:	bd80      	pop	{r7, pc}

000242f0 <nrf_gpio_pin_clear>:
{
   242f0:	b580      	push	{r7, lr}
   242f2:	b084      	sub	sp, #16
   242f4:	af00      	add	r7, sp, #0
   242f6:	6078      	str	r0, [r7, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   242f8:	1d3b      	adds	r3, r7, #4
   242fa:	4618      	mov	r0, r3
   242fc:	f7ff ffd8 	bl	242b0 <nrf_gpio_pin_port_decode>
   24300:	60f8      	str	r0, [r7, #12]
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   24302:	687b      	ldr	r3, [r7, #4]
   24304:	2201      	movs	r2, #1
   24306:	fa02 f303 	lsl.w	r3, r2, r3
   2430a:	4619      	mov	r1, r3
   2430c:	68f8      	ldr	r0, [r7, #12]
   2430e:	f000 f812 	bl	24336 <nrf_gpio_port_out_clear>
}
   24312:	bf00      	nop
   24314:	3710      	adds	r7, #16
   24316:	46bd      	mov	sp, r7
   24318:	bd80      	pop	{r7, pc}

0002431a <nrf_gpio_port_out_set>:
{
   2431a:	b480      	push	{r7}
   2431c:	b083      	sub	sp, #12
   2431e:	af00      	add	r7, sp, #0
   24320:	6078      	str	r0, [r7, #4]
   24322:	6039      	str	r1, [r7, #0]
    p_reg->OUTSET = set_mask;
   24324:	687b      	ldr	r3, [r7, #4]
   24326:	683a      	ldr	r2, [r7, #0]
   24328:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
}
   2432c:	bf00      	nop
   2432e:	370c      	adds	r7, #12
   24330:	46bd      	mov	sp, r7
   24332:	bc80      	pop	{r7}
   24334:	4770      	bx	lr

00024336 <nrf_gpio_port_out_clear>:
{
   24336:	b480      	push	{r7}
   24338:	b083      	sub	sp, #12
   2433a:	af00      	add	r7, sp, #0
   2433c:	6078      	str	r0, [r7, #4]
   2433e:	6039      	str	r1, [r7, #0]
    p_reg->OUTCLR = clr_mask;
   24340:	687b      	ldr	r3, [r7, #4]
   24342:	683a      	ldr	r2, [r7, #0]
   24344:	f8c3 250c 	str.w	r2, [r3, #1292]	; 0x50c
}
   24348:	bf00      	nop
   2434a:	370c      	adds	r7, #12
   2434c:	46bd      	mov	sp, r7
   2434e:	bc80      	pop	{r7}
   24350:	4770      	bx	lr
	...

00024354 <__sd_nvic_app_accessible_irq>:
{
   24354:	b480      	push	{r7}
   24356:	b083      	sub	sp, #12
   24358:	af00      	add	r7, sp, #0
   2435a:	4603      	mov	r3, r0
   2435c:	71fb      	strb	r3, [r7, #7]
  if (IRQn < 32)
   2435e:	f997 3007 	ldrsb.w	r3, [r7, #7]
   24362:	2b1f      	cmp	r3, #31
   24364:	dc0c      	bgt.n	24380 <__sd_nvic_app_accessible_irq+0x2c>
    return ((1UL<<IRQn) & __NRF_NVIC_APP_IRQS_0) != 0;
   24366:	f997 3007 	ldrsb.w	r3, [r7, #7]
   2436a:	4a10      	ldr	r2, [pc, #64]	; (243ac <__sd_nvic_app_accessible_irq+0x58>)
   2436c:	fa22 f303 	lsr.w	r3, r2, r3
   24370:	f003 0301 	and.w	r3, r3, #1
   24374:	2b00      	cmp	r3, #0
   24376:	bf14      	ite	ne
   24378:	2301      	movne	r3, #1
   2437a:	2300      	moveq	r3, #0
   2437c:	b2db      	uxtb	r3, r3
   2437e:	e010      	b.n	243a2 <__sd_nvic_app_accessible_irq+0x4e>
  else if (IRQn < 64)
   24380:	f997 3007 	ldrsb.w	r3, [r7, #7]
   24384:	2b3f      	cmp	r3, #63	; 0x3f
   24386:	dc0b      	bgt.n	243a0 <__sd_nvic_app_accessible_irq+0x4c>
    return ((1UL<<(IRQn-32)) & __NRF_NVIC_APP_IRQS_1) != 0;
   24388:	f997 3007 	ldrsb.w	r3, [r7, #7]
   2438c:	3b20      	subs	r3, #32
   2438e:	2201      	movs	r2, #1
   24390:	fa02 f303 	lsl.w	r3, r2, r3
   24394:	2b00      	cmp	r3, #0
   24396:	bf14      	ite	ne
   24398:	2301      	movne	r3, #1
   2439a:	2300      	moveq	r3, #0
   2439c:	b2db      	uxtb	r3, r3
   2439e:	e000      	b.n	243a2 <__sd_nvic_app_accessible_irq+0x4e>
    return 1;
   243a0:	2301      	movs	r3, #1
}
   243a2:	4618      	mov	r0, r3
   243a4:	370c      	adds	r7, #12
   243a6:	46bd      	mov	sp, r7
   243a8:	bc80      	pop	{r7}
   243aa:	4770      	bx	lr
   243ac:	bdff06fc 	.word	0xbdff06fc

000243b0 <__sd_nvic_is_app_accessible_priority>:
{
   243b0:	b480      	push	{r7}
   243b2:	b083      	sub	sp, #12
   243b4:	af00      	add	r7, sp, #0
   243b6:	6078      	str	r0, [r7, #4]
  if(priority >= (1 << __NVIC_PRIO_BITS))
   243b8:	687b      	ldr	r3, [r7, #4]
   243ba:	2b07      	cmp	r3, #7
   243bc:	d901      	bls.n	243c2 <__sd_nvic_is_app_accessible_priority+0x12>
    return 0;
   243be:	2300      	movs	r3, #0
   243c0:	e00b      	b.n	243da <__sd_nvic_is_app_accessible_priority+0x2a>
  if(   priority == 0
   243c2:	687b      	ldr	r3, [r7, #4]
   243c4:	2b00      	cmp	r3, #0
   243c6:	d005      	beq.n	243d4 <__sd_nvic_is_app_accessible_priority+0x24>
     || priority == 1
   243c8:	687b      	ldr	r3, [r7, #4]
   243ca:	2b01      	cmp	r3, #1
   243cc:	d002      	beq.n	243d4 <__sd_nvic_is_app_accessible_priority+0x24>
     || priority == 4
   243ce:	687b      	ldr	r3, [r7, #4]
   243d0:	2b04      	cmp	r3, #4
   243d2:	d101      	bne.n	243d8 <__sd_nvic_is_app_accessible_priority+0x28>
    return 0;
   243d4:	2300      	movs	r3, #0
   243d6:	e000      	b.n	243da <__sd_nvic_is_app_accessible_priority+0x2a>
  return 1;
   243d8:	2301      	movs	r3, #1
}
   243da:	4618      	mov	r0, r3
   243dc:	370c      	adds	r7, #12
   243de:	46bd      	mov	sp, r7
   243e0:	bc80      	pop	{r7}
   243e2:	4770      	bx	lr

000243e4 <sd_nvic_EnableIRQ>:
{
   243e4:	b580      	push	{r7, lr}
   243e6:	b082      	sub	sp, #8
   243e8:	af00      	add	r7, sp, #0
   243ea:	4603      	mov	r3, r0
   243ec:	71fb      	strb	r3, [r7, #7]
  if (!__sd_nvic_app_accessible_irq(IRQn))
   243ee:	f997 3007 	ldrsb.w	r3, [r7, #7]
   243f2:	4618      	mov	r0, r3
   243f4:	f7ff ffae 	bl	24354 <__sd_nvic_app_accessible_irq>
   243f8:	4603      	mov	r3, r0
   243fa:	2b00      	cmp	r3, #0
   243fc:	d102      	bne.n	24404 <sd_nvic_EnableIRQ+0x20>
    return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
   243fe:	f242 0301 	movw	r3, #8193	; 0x2001
   24402:	e02d      	b.n	24460 <sd_nvic_EnableIRQ+0x7c>
  if (!__sd_nvic_is_app_accessible_priority(NVIC_GetPriority(IRQn)))
   24404:	f997 3007 	ldrsb.w	r3, [r7, #7]
   24408:	4618      	mov	r0, r3
   2440a:	f7ff ff2b 	bl	24264 <NVIC_GetPriority>
   2440e:	4603      	mov	r3, r0
   24410:	4618      	mov	r0, r3
   24412:	f7ff ffcd 	bl	243b0 <__sd_nvic_is_app_accessible_priority>
   24416:	4603      	mov	r3, r0
   24418:	2b00      	cmp	r3, #0
   2441a:	d102      	bne.n	24422 <sd_nvic_EnableIRQ+0x3e>
    return NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED;
   2441c:	f242 0302 	movw	r3, #8194	; 0x2002
   24420:	e01e      	b.n	24460 <sd_nvic_EnableIRQ+0x7c>
  if (nrf_nvic_state.__cr_flag)
   24422:	4b11      	ldr	r3, [pc, #68]	; (24468 <sd_nvic_EnableIRQ+0x84>)
   24424:	689b      	ldr	r3, [r3, #8]
   24426:	2b00      	cmp	r3, #0
   24428:	d014      	beq.n	24454 <sd_nvic_EnableIRQ+0x70>
    nrf_nvic_state.__irq_masks[(uint32_t)((int32_t)IRQn) >> 5] |= (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F));
   2442a:	f997 3007 	ldrsb.w	r3, [r7, #7]
   2442e:	095b      	lsrs	r3, r3, #5
   24430:	4a0d      	ldr	r2, [pc, #52]	; (24468 <sd_nvic_EnableIRQ+0x84>)
   24432:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
   24436:	79fb      	ldrb	r3, [r7, #7]
   24438:	f003 031f 	and.w	r3, r3, #31
   2443c:	2101      	movs	r1, #1
   2443e:	fa01 f303 	lsl.w	r3, r1, r3
   24442:	4619      	mov	r1, r3
   24444:	f997 3007 	ldrsb.w	r3, [r7, #7]
   24448:	095b      	lsrs	r3, r3, #5
   2444a:	430a      	orrs	r2, r1
   2444c:	4906      	ldr	r1, [pc, #24]	; (24468 <sd_nvic_EnableIRQ+0x84>)
   2444e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
   24452:	e004      	b.n	2445e <sd_nvic_EnableIRQ+0x7a>
    NVIC_EnableIRQ(IRQn);
   24454:	f997 3007 	ldrsb.w	r3, [r7, #7]
   24458:	4618      	mov	r0, r3
   2445a:	f7ff fec1 	bl	241e0 <NVIC_EnableIRQ>
  return NRF_SUCCESS;
   2445e:	2300      	movs	r3, #0
}
   24460:	4618      	mov	r0, r3
   24462:	3708      	adds	r7, #8
   24464:	46bd      	mov	sp, r7
   24466:	bd80      	pop	{r7, pc}
   24468:	2000512c 	.word	0x2000512c

0002446c <sd_nvic_SetPriority>:
{
   2446c:	b580      	push	{r7, lr}
   2446e:	b082      	sub	sp, #8
   24470:	af00      	add	r7, sp, #0
   24472:	4603      	mov	r3, r0
   24474:	6039      	str	r1, [r7, #0]
   24476:	71fb      	strb	r3, [r7, #7]
  if (!__sd_nvic_app_accessible_irq(IRQn))
   24478:	f997 3007 	ldrsb.w	r3, [r7, #7]
   2447c:	4618      	mov	r0, r3
   2447e:	f7ff ff69 	bl	24354 <__sd_nvic_app_accessible_irq>
   24482:	4603      	mov	r3, r0
   24484:	2b00      	cmp	r3, #0
   24486:	d102      	bne.n	2448e <sd_nvic_SetPriority+0x22>
    return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
   24488:	f242 0301 	movw	r3, #8193	; 0x2001
   2448c:	e00f      	b.n	244ae <sd_nvic_SetPriority+0x42>
  if (!__sd_nvic_is_app_accessible_priority(priority))
   2448e:	6838      	ldr	r0, [r7, #0]
   24490:	f7ff ff8e 	bl	243b0 <__sd_nvic_is_app_accessible_priority>
   24494:	4603      	mov	r3, r0
   24496:	2b00      	cmp	r3, #0
   24498:	d102      	bne.n	244a0 <sd_nvic_SetPriority+0x34>
    return NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED;
   2449a:	f242 0302 	movw	r3, #8194	; 0x2002
   2449e:	e006      	b.n	244ae <sd_nvic_SetPriority+0x42>
  NVIC_SetPriority(IRQn, (uint32_t)priority);
   244a0:	f997 3007 	ldrsb.w	r3, [r7, #7]
   244a4:	6839      	ldr	r1, [r7, #0]
   244a6:	4618      	mov	r0, r3
   244a8:	f7ff feb2 	bl	24210 <NVIC_SetPriority>
  return NRF_SUCCESS;
   244ac:	2300      	movs	r3, #0
}
   244ae:	4618      	mov	r0, r3
   244b0:	3708      	adds	r7, #8
   244b2:	46bd      	mov	sp, r7
   244b4:	bd80      	pop	{r7, pc}
	...

000244b8 <NFCT_IRQHandler>:

uint8_t nfc_tx_buf[] = "Hello";


void NFCT_IRQHandler()
{
   244b8:	b580      	push	{r7, lr}
   244ba:	af00      	add	r7, sp, #0
    if (NRF_NFCT->EVENTS_FIELDDETECTED)
   244bc:	4b0d      	ldr	r3, [pc, #52]	; (244f4 <NFCT_IRQHandler+0x3c>)
   244be:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   244c2:	2b00      	cmp	r3, #0
   244c4:	d007      	beq.n	244d6 <NFCT_IRQHandler+0x1e>
    {
        NRF_NFCT->EVENTS_FIELDDETECTED = 0;
   244c6:	4b0b      	ldr	r3, [pc, #44]	; (244f4 <NFCT_IRQHandler+0x3c>)
   244c8:	2200      	movs	r2, #0
   244ca:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
        nrf_gpio_pin_clear(14);
   244ce:	200e      	movs	r0, #14
   244d0:	f7ff ff0e 	bl	242f0 <nrf_gpio_pin_clear>
    else if (NRF_NFCT->EVENTS_FIELDLOST)
    {
        NRF_NFCT->EVENTS_FIELDLOST = 0;
        nrf_gpio_pin_set(14);
    }
}
   244d4:	e00b      	b.n	244ee <NFCT_IRQHandler+0x36>
    else if (NRF_NFCT->EVENTS_FIELDLOST)
   244d6:	4b07      	ldr	r3, [pc, #28]	; (244f4 <NFCT_IRQHandler+0x3c>)
   244d8:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
   244dc:	2b00      	cmp	r3, #0
   244de:	d006      	beq.n	244ee <NFCT_IRQHandler+0x36>
        NRF_NFCT->EVENTS_FIELDLOST = 0;
   244e0:	4b04      	ldr	r3, [pc, #16]	; (244f4 <NFCT_IRQHandler+0x3c>)
   244e2:	2200      	movs	r2, #0
   244e4:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
        nrf_gpio_pin_set(14);
   244e8:	200e      	movs	r0, #14
   244ea:	f7ff feec 	bl	242c6 <nrf_gpio_pin_set>
}
   244ee:	bf00      	nop
   244f0:	bd80      	pop	{r7, pc}
   244f2:	bf00      	nop
   244f4:	40005000 	.word	0x40005000

000244f8 <NfcInit>:

void NfcInit()
{
   244f8:	b580      	push	{r7, lr}
   244fa:	af00      	add	r7, sp, #0
    sd_nvic_SetPriority(NFCT_IRQn, 3);
   244fc:	2103      	movs	r1, #3
   244fe:	2005      	movs	r0, #5
   24500:	f7ff ffb4 	bl	2446c <sd_nvic_SetPriority>
    sd_nvic_EnableIRQ(NFCT_IRQn);
   24504:	2005      	movs	r0, #5
   24506:	f7ff ff6d 	bl	243e4 <sd_nvic_EnableIRQ>
    NRF_NFCT->INTENSET = (NFCT_INTENSET_FIELDDETECTED_Set << NFCT_INTENSET_FIELDDETECTED_Pos) |
   2450a:	4b08      	ldr	r3, [pc, #32]	; (2452c <NfcInit+0x34>)
   2450c:	2206      	movs	r2, #6
   2450e:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
                         (NFCT_INTENSET_FIELDLOST_Set << NFCT_INTENSET_FIELDLOST_Pos);

    NRF_NFCT->TXD.AMOUNT = sizeof(nfc_tx_buf);
   24512:	4b06      	ldr	r3, [pc, #24]	; (2452c <NfcInit+0x34>)
   24514:	2206      	movs	r2, #6
   24516:	f8c3 251c 	str.w	r2, [r3, #1308]	; 0x51c

    NRF_NFCT->PACKETPTR = (uint32_t)nfc_tx_buf;
   2451a:	4b04      	ldr	r3, [pc, #16]	; (2452c <NfcInit+0x34>)
   2451c:	4a04      	ldr	r2, [pc, #16]	; (24530 <NfcInit+0x38>)
   2451e:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510

    NRF_NFCT->TASKS_SENSE = 1;
   24522:	4b02      	ldr	r3, [pc, #8]	; (2452c <NfcInit+0x34>)
   24524:	2201      	movs	r2, #1
   24526:	609a      	str	r2, [r3, #8]
}
   24528:	bf00      	nop
   2452a:	bd80      	pop	{r7, pc}
   2452c:	40005000 	.word	0x40005000
   24530:	2000506c 	.word	0x2000506c

00024534 <sd_ble_gap_ppcp_set>:
 *
 * @retval ::NRF_SUCCESS Peripheral Preferred Connection Parameters set successfully.
 * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
 * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
 */
SVCALL(SD_BLE_GAP_PPCP_SET, uint32_t, sd_ble_gap_ppcp_set(ble_gap_conn_params_t const *p_conn_params));
   24534:	df7a      	svc	122	; 0x7a
   24536:	4770      	bx	lr
   24538:	bf00      	nop
   2453a:	4618      	mov	r0, r3

0002453c <sd_ble_gap_device_name_set>:
 * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
 * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
 * @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.
 * @retval ::NRF_ERROR_FORBIDDEN Device name is not writable.
 */
SVCALL(SD_BLE_GAP_DEVICE_NAME_SET, uint32_t, sd_ble_gap_device_name_set(ble_gap_conn_sec_mode_t const *p_write_perm, uint8_t const *p_dev_name, uint16_t len));
   2453c:	df7c      	svc	124	; 0x7c
   2453e:	4770      	bx	lr
   24540:	bf00      	nop
   24542:	4618      	mov	r0, r3

00024544 <on_ble_evt>:
/**@brief Function for handling BLE Stack events common to both the central and peripheral roles.
 * @param[in] conn_handle Connection Handle.
 * @param[in] p_ble_evt  Bluetooth stack event.
 */
static void on_ble_evt(uint16_t conn_handle, ble_evt_t const * p_ble_evt)
{
   24544:	b580      	push	{r7, lr}
   24546:	b086      	sub	sp, #24
   24548:	af00      	add	r7, sp, #0
   2454a:	4603      	mov	r3, r0
   2454c:	6039      	str	r1, [r7, #0]
   2454e:	80fb      	strh	r3, [r7, #6]
    ret_code_t err_code;
    char passkey[BLE_GAP_PASSKEY_LEN + 1];
    uint16_t role = ble_conn_state_role(conn_handle);
   24550:	88fb      	ldrh	r3, [r7, #6]
   24552:	4618      	mov	r0, r3
   24554:	f002 fada 	bl	26b0c <ble_conn_state_role>
   24558:	4603      	mov	r3, r0
   2455a:	82fb      	strh	r3, [r7, #22]

    BleUartOnBleEvt(&m_ble_uart, p_ble_evt);
   2455c:	6839      	ldr	r1, [r7, #0]
   2455e:	480a      	ldr	r0, [pc, #40]	; (24588 <on_ble_evt+0x44>)
   24560:	f000 fb0f 	bl	24b82 <BleUartOnBleEvt>

    switch (p_ble_evt->header.evt_id)
   24564:	683b      	ldr	r3, [r7, #0]
   24566:	881b      	ldrh	r3, [r3, #0]
   24568:	2b11      	cmp	r3, #17
   2456a:	d004      	beq.n	24576 <on_ble_evt+0x32>
   2456c:	2b13      	cmp	r3, #19
   2456e:	d004      	beq.n	2457a <on_ble_evt+0x36>
   24570:	2b10      	cmp	r3, #16
   24572:	d004      	beq.n	2457e <on_ble_evt+0x3a>
//                          *((uint8_t *)&p_ble_evt->evt.gap_evt.params.auth_status.kdist_peer));
//            break;

        default:
            // No implementation needed.
            break;
   24574:	e004      	b.n	24580 <on_ble_evt+0x3c>
            break;
   24576:	bf00      	nop
   24578:	e002      	b.n	24580 <on_ble_evt+0x3c>
            break;
   2457a:	bf00      	nop
   2457c:	e000      	b.n	24580 <on_ble_evt+0x3c>
            break;
   2457e:	bf00      	nop
    }
}
   24580:	bf00      	nop
   24582:	3718      	adds	r7, #24
   24584:	46bd      	mov	sp, r7
   24586:	bd80      	pop	{r7, pc}
   24588:	20005388 	.word	0x20005388

0002458c <ble_evt_handler>:
 *
 * @param[in]   p_ble_evt   Bluetooth stack event.
 * @param[in]   p_context   Unused.
 */
static void ble_evt_handler(ble_evt_t const * p_ble_evt, void * p_context)
{
   2458c:	b580      	push	{r7, lr}
   2458e:	b084      	sub	sp, #16
   24590:	af00      	add	r7, sp, #0
   24592:	6078      	str	r0, [r7, #4]
   24594:	6039      	str	r1, [r7, #0]
    uint16_t conn_handle = p_ble_evt->evt.gap_evt.conn_handle;
   24596:	687b      	ldr	r3, [r7, #4]
   24598:	889b      	ldrh	r3, [r3, #4]
   2459a:	81fb      	strh	r3, [r7, #14]
    uint16_t role        = ble_conn_state_role(conn_handle);
   2459c:	89fb      	ldrh	r3, [r7, #14]
   2459e:	4618      	mov	r0, r3
   245a0:	f002 fab4 	bl	26b0c <ble_conn_state_role>
   245a4:	4603      	mov	r3, r0
   245a6:	81bb      	strh	r3, [r7, #12]

    on_ble_evt(conn_handle, p_ble_evt);
   245a8:	89fb      	ldrh	r3, [r7, #14]
   245aa:	6879      	ldr	r1, [r7, #4]
   245ac:	4618      	mov	r0, r3
   245ae:	f7ff ffc9 	bl	24544 <on_ble_evt>

    if (role == BLE_GAP_ROLE_PERIPH)
   245b2:	89bb      	ldrh	r3, [r7, #12]
   245b4:	2b01      	cmp	r3, #1
   245b6:	d102      	bne.n	245be <ble_evt_handler+0x32>
    {
        // Manages peripheral LEDs.
        on_ble_peripheral_evt(p_ble_evt);
   245b8:	6878      	ldr	r0, [r7, #4]
   245ba:	f000 f8cd 	bl	24758 <on_ble_peripheral_evt>
    }
}
   245be:	bf00      	nop
   245c0:	3710      	adds	r7, #16
   245c2:	46bd      	mov	sp, r7
   245c4:	bd80      	pop	{r7, pc}
	...

000245c8 <GapParamsInit>:
 *
 * @details This function sets up all the necessary GAP (Generic Access Profile) parameters of the
 *          device including the device name, appearance, and the preferred connection parameters.
 */
void GapParamsInit(void)
{
   245c8:	b580      	push	{r7, lr}
   245ca:	b086      	sub	sp, #24
   245cc:	af00      	add	r7, sp, #0
    ret_code_t              err_code;
    ble_gap_conn_params_t   gap_conn_params;
    ble_gap_conn_sec_mode_t sec_mode;

    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&sec_mode);
   245ce:	783b      	ldrb	r3, [r7, #0]
   245d0:	2201      	movs	r2, #1
   245d2:	f362 0303 	bfi	r3, r2, #0, #4
   245d6:	703b      	strb	r3, [r7, #0]
   245d8:	783b      	ldrb	r3, [r7, #0]
   245da:	2201      	movs	r2, #1
   245dc:	f362 1307 	bfi	r3, r2, #4, #4
   245e0:	703b      	strb	r3, [r7, #0]

    err_code = sd_ble_gap_device_name_set(&sec_mode,
                                          (const uint8_t *)DEVICE_NAME,
                                          strlen(DEVICE_NAME));
   245e2:	481b      	ldr	r0, [pc, #108]	; (24650 <GapParamsInit+0x88>)
   245e4:	f003 f9d8 	bl	27998 <strlen>
   245e8:	4603      	mov	r3, r0
    err_code = sd_ble_gap_device_name_set(&sec_mode,
   245ea:	b29a      	uxth	r2, r3
   245ec:	463b      	mov	r3, r7
   245ee:	4918      	ldr	r1, [pc, #96]	; (24650 <GapParamsInit+0x88>)
   245f0:	4618      	mov	r0, r3
   245f2:	f7ff ffa3 	bl	2453c <sd_ble_gap_device_name_set>
   245f6:	6178      	str	r0, [r7, #20]
    APP_ERROR_CHECK(err_code);
   245f8:	697b      	ldr	r3, [r7, #20]
   245fa:	613b      	str	r3, [r7, #16]
   245fc:	693b      	ldr	r3, [r7, #16]
   245fe:	2b00      	cmp	r3, #0
   24600:	d004      	beq.n	2460c <GapParamsInit+0x44>
   24602:	4a14      	ldr	r2, [pc, #80]	; (24654 <GapParamsInit+0x8c>)
   24604:	21c2      	movs	r1, #194	; 0xc2
   24606:	6938      	ldr	r0, [r7, #16]
   24608:	f001 fc48 	bl	25e9c <app_error_handler>

    memset(&gap_conn_params, 0, sizeof(gap_conn_params));
   2460c:	1d3b      	adds	r3, r7, #4
   2460e:	2208      	movs	r2, #8
   24610:	2100      	movs	r1, #0
   24612:	4618      	mov	r0, r3
   24614:	f7ff f802 	bl	2361c <memset>

    gap_conn_params.min_conn_interval = MIN_CONNECTION_INTERVAL;
   24618:	2306      	movs	r3, #6
   2461a:	80bb      	strh	r3, [r7, #4]
    gap_conn_params.max_conn_interval = MAX_CONNECTION_INTERVAL;
   2461c:	2318      	movs	r3, #24
   2461e:	80fb      	strh	r3, [r7, #6]
    gap_conn_params.slave_latency     = SLAVE_LATENCY;
   24620:	2300      	movs	r3, #0
   24622:	813b      	strh	r3, [r7, #8]
    gap_conn_params.conn_sup_timeout  = SUPERVISION_TIMEOUT;
   24624:	f44f 73c8 	mov.w	r3, #400	; 0x190
   24628:	817b      	strh	r3, [r7, #10]

    err_code = sd_ble_gap_ppcp_set(&gap_conn_params);
   2462a:	1d3b      	adds	r3, r7, #4
   2462c:	4618      	mov	r0, r3
   2462e:	f7ff ff81 	bl	24534 <sd_ble_gap_ppcp_set>
   24632:	6178      	str	r0, [r7, #20]
    APP_ERROR_CHECK(err_code);
   24634:	697b      	ldr	r3, [r7, #20]
   24636:	60fb      	str	r3, [r7, #12]
   24638:	68fb      	ldr	r3, [r7, #12]
   2463a:	2b00      	cmp	r3, #0
   2463c:	d004      	beq.n	24648 <GapParamsInit+0x80>
   2463e:	4a05      	ldr	r2, [pc, #20]	; (24654 <GapParamsInit+0x8c>)
   24640:	21cc      	movs	r1, #204	; 0xcc
   24642:	68f8      	ldr	r0, [r7, #12]
   24644:	f001 fc2a 	bl	25e9c <app_error_handler>
}
   24648:	bf00      	nop
   2464a:	3718      	adds	r7, #24
   2464c:	46bd      	mov	sp, r7
   2464e:	bd80      	pop	{r7, pc}
   24650:	00027a14 	.word	0x00027a14
   24654:	000279fc 	.word	0x000279fc

00024658 <GattInit>:


/**@brief Function for initializing the GATT module. */
void GattInit(void)
{
   24658:	b580      	push	{r7, lr}
   2465a:	b082      	sub	sp, #8
   2465c:	af00      	add	r7, sp, #0
    ret_code_t err_code = nrf_ble_gatt_init(&m_gatt, NULL);
   2465e:	2100      	movs	r1, #0
   24660:	4808      	ldr	r0, [pc, #32]	; (24684 <GattInit+0x2c>)
   24662:	f002 f8c7 	bl	267f4 <nrf_ble_gatt_init>
   24666:	6078      	str	r0, [r7, #4]
    APP_ERROR_CHECK(err_code);
   24668:	687b      	ldr	r3, [r7, #4]
   2466a:	603b      	str	r3, [r7, #0]
   2466c:	683b      	ldr	r3, [r7, #0]
   2466e:	2b00      	cmp	r3, #0
   24670:	d004      	beq.n	2467c <GattInit+0x24>
   24672:	4a05      	ldr	r2, [pc, #20]	; (24688 <GattInit+0x30>)
   24674:	21d4      	movs	r1, #212	; 0xd4
   24676:	6838      	ldr	r0, [r7, #0]
   24678:	f001 fc10 	bl	25e9c <app_error_handler>
}
   2467c:	bf00      	nop
   2467e:	3708      	adds	r7, #8
   24680:	46bd      	mov	sp, r7
   24682:	bd80      	pop	{r7, pc}
   24684:	20005148 	.word	0x20005148
   24688:	000279fc 	.word	0x000279fc

0002468c <BleStackInit>:
/**@brief Function for initializing the BLE stack.
 *
 * @details Initializes the SoftDevice and the BLE event interrupt.
 */
void BleStackInit(void)
{
   2468c:	b580      	push	{r7, lr}
   2468e:	b086      	sub	sp, #24
   24690:	af00      	add	r7, sp, #0
    ret_code_t err_code;

    err_code = nrf_sdh_enable_request();
   24692:	f001 fd03 	bl	2609c <nrf_sdh_enable_request>
   24696:	6178      	str	r0, [r7, #20]
    APP_ERROR_CHECK(err_code);
   24698:	697b      	ldr	r3, [r7, #20]
   2469a:	613b      	str	r3, [r7, #16]
   2469c:	693b      	ldr	r3, [r7, #16]
   2469e:	2b00      	cmp	r3, #0
   246a0:	d005      	beq.n	246ae <BleStackInit+0x22>
   246a2:	4a16      	ldr	r2, [pc, #88]	; (246fc <BleStackInit+0x70>)
   246a4:	f240 111f 	movw	r1, #287	; 0x11f
   246a8:	6938      	ldr	r0, [r7, #16]
   246aa:	f001 fbf7 	bl	25e9c <app_error_handler>

    // Configure the BLE stack using the default settings.
    // Fetch the start address of the application RAM.
    uint32_t ram_start = 0;
   246ae:	2300      	movs	r3, #0
   246b0:	607b      	str	r3, [r7, #4]
    err_code = nrf_sdh_ble_default_cfg_set(APP_BLE_CONN_CFG_TAG, &ram_start);
   246b2:	1d3b      	adds	r3, r7, #4
   246b4:	4619      	mov	r1, r3
   246b6:	2001      	movs	r0, #1
   246b8:	f001 fd90 	bl	261dc <nrf_sdh_ble_default_cfg_set>
   246bc:	6178      	str	r0, [r7, #20]
    APP_ERROR_CHECK(err_code);
   246be:	697b      	ldr	r3, [r7, #20]
   246c0:	60fb      	str	r3, [r7, #12]
   246c2:	68fb      	ldr	r3, [r7, #12]
   246c4:	2b00      	cmp	r3, #0
   246c6:	d005      	beq.n	246d4 <BleStackInit+0x48>
   246c8:	4a0c      	ldr	r2, [pc, #48]	; (246fc <BleStackInit+0x70>)
   246ca:	f240 1125 	movw	r1, #293	; 0x125
   246ce:	68f8      	ldr	r0, [r7, #12]
   246d0:	f001 fbe4 	bl	25e9c <app_error_handler>

    // Enable BLE stack.
    err_code = nrf_sdh_ble_enable(&ram_start);
   246d4:	1d3b      	adds	r3, r7, #4
   246d6:	4618      	mov	r0, r3
   246d8:	f001 fdfd 	bl	262d6 <nrf_sdh_ble_enable>
   246dc:	6178      	str	r0, [r7, #20]
    APP_ERROR_CHECK(err_code);
   246de:	697b      	ldr	r3, [r7, #20]
   246e0:	60bb      	str	r3, [r7, #8]
   246e2:	68bb      	ldr	r3, [r7, #8]
   246e4:	2b00      	cmp	r3, #0
   246e6:	d005      	beq.n	246f4 <BleStackInit+0x68>
   246e8:	4a04      	ldr	r2, [pc, #16]	; (246fc <BleStackInit+0x70>)
   246ea:	f240 1129 	movw	r1, #297	; 0x129
   246ee:	68b8      	ldr	r0, [r7, #8]
   246f0:	f001 fbd4 	bl	25e9c <app_error_handler>

    // Register a handler for BLE events.
    NRF_SDH_BLE_OBSERVER(m_ble_observer, APP_BLE_OBSERVER_PRIO, ble_evt_handler, NULL);
}
   246f4:	bf00      	nop
   246f6:	3718      	adds	r7, #24
   246f8:	46bd      	mov	sp, r7
   246fa:	bd80      	pop	{r7, pc}
   246fc:	000279fc 	.word	0x000279fc

00024700 <ServicesInit>:

/**@brief Function for initializing services that will be used by the application.
 */
void ServicesInit()
{
   24700:	b580      	push	{r7, lr}
   24702:	b086      	sub	sp, #24
   24704:	af00      	add	r7, sp, #0
    uint32_t                        err_code;
    ble_uart_init_t                 uart_init;

    //handler assignement
    uart_init.evt_handler = BleUartHandler;
   24706:	4b0b      	ldr	r3, [pc, #44]	; (24734 <ServicesInit+0x34>)
   24708:	607b      	str	r3, [r7, #4]
    err_code = BleUartServiceInit(&m_ble_uart, &uart_init);
   2470a:	1d3b      	adds	r3, r7, #4
   2470c:	4619      	mov	r1, r3
   2470e:	480a      	ldr	r0, [pc, #40]	; (24738 <ServicesInit+0x38>)
   24710:	f000 fdc0 	bl	25294 <BleUartServiceInit>
   24714:	6178      	str	r0, [r7, #20]
    APP_ERROR_CHECK(err_code);
   24716:	697b      	ldr	r3, [r7, #20]
   24718:	613b      	str	r3, [r7, #16]
   2471a:	693b      	ldr	r3, [r7, #16]
   2471c:	2b00      	cmp	r3, #0
   2471e:	d005      	beq.n	2472c <ServicesInit+0x2c>
   24720:	4a06      	ldr	r2, [pc, #24]	; (2473c <ServicesInit+0x3c>)
   24722:	f240 1139 	movw	r1, #313	; 0x139
   24726:	6938      	ldr	r0, [r7, #16]
   24728:	f001 fbb8 	bl	25e9c <app_error_handler>

}
   2472c:	bf00      	nop
   2472e:	3718      	adds	r7, #24
   24730:	46bd      	mov	sp, r7
   24732:	bd80      	pop	{r7, pc}
   24734:	00024ee9 	.word	0x00024ee9
   24738:	20005388 	.word	0x20005388
   2473c:	000279fc 	.word	0x000279fc

00024740 <sd_ble_gap_disconnect>:
SVCALL(SD_BLE_GAP_DISCONNECT, uint32_t, sd_ble_gap_disconnect(uint16_t conn_handle, uint8_t hci_status_code));
   24740:	df76      	svc	118	; 0x76
   24742:	4770      	bx	lr
   24744:	bf00      	nop
   24746:	4618      	mov	r0, r3

00024748 <sd_ble_gatts_rw_authorize_reply>:
 * @retval ::NRF_ERROR_INVALID_STATE   Invalid Connection State or no authorization request pending.
 * @retval ::NRF_ERROR_INVALID_PARAM   Authorization op invalid,
 *                                         handle supplied does not match requested handle,
 *                                         or invalid data to be written provided by the application.
 */
SVCALL(SD_BLE_GATTS_RW_AUTHORIZE_REPLY, uint32_t, sd_ble_gatts_rw_authorize_reply(uint16_t conn_handle, ble_gatts_rw_authorize_reply_params_t const *p_rw_authorize_reply_params));
   24748:	dfa8      	svc	168	; 0xa8
   2474a:	4770      	bx	lr
   2474c:	bf00      	nop
   2474e:	4618      	mov	r0, r3

00024750 <sd_ble_user_mem_reply>:
 * @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry.
 * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
 * @retval ::NRF_ERROR_INVALID_LENGTH Invalid user memory block length supplied.
 * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection state or no user memory request pending.
 */
SVCALL(SD_BLE_USER_MEM_REPLY, uint32_t, sd_ble_user_mem_reply(uint16_t conn_handle, ble_user_mem_block_t const *p_block));
   24750:	df66      	svc	102	; 0x66
   24752:	4770      	bx	lr
   24754:	bf00      	nop
   24756:	4618      	mov	r0, r3

00024758 <on_ble_peripheral_evt>:
 * LEDs used to report the status of the peripheral applications.
 *
 * @param[in] p_ble_evt  Bluetooth stack event.
 */
void on_ble_peripheral_evt(ble_evt_t const * p_ble_evt)
{
   24758:	b590      	push	{r4, r7, lr}
   2475a:	b091      	sub	sp, #68	; 0x44
   2475c:	af00      	add	r7, sp, #0
   2475e:	6078      	str	r0, [r7, #4]
    ret_code_t err_code;

    switch (p_ble_evt->header.evt_id)
   24760:	687b      	ldr	r3, [r7, #4]
   24762:	881b      	ldrh	r3, [r3, #0]
   24764:	2b11      	cmp	r3, #17
   24766:	d07a      	beq.n	2485e <on_ble_peripheral_evt+0x106>
   24768:	2b11      	cmp	r3, #17
   2476a:	dc04      	bgt.n	24776 <on_ble_peripheral_evt+0x1e>
   2476c:	2b01      	cmp	r3, #1
   2476e:	d02d      	beq.n	247cc <on_ble_peripheral_evt+0x74>
   24770:	2b10      	cmp	r3, #16
   24772:	d076      	beq.n	24862 <on_ble_peripheral_evt+0x10a>
            }
        } break; // BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST

        default:
            // No implementation needed.
            break;
   24774:	e07e      	b.n	24874 <on_ble_peripheral_evt+0x11c>
    switch (p_ble_evt->header.evt_id)
   24776:	2b51      	cmp	r3, #81	; 0x51
   24778:	d03a      	beq.n	247f0 <on_ble_peripheral_evt+0x98>
   2477a:	2b56      	cmp	r3, #86	; 0x56
   2477c:	d014      	beq.n	247a8 <on_ble_peripheral_evt+0x50>
   2477e:	2b3b      	cmp	r3, #59	; 0x3b
   24780:	d000      	beq.n	24784 <on_ble_peripheral_evt+0x2c>
            break;
   24782:	e077      	b.n	24874 <on_ble_peripheral_evt+0x11c>
            err_code = sd_ble_gap_disconnect(p_ble_evt->evt.gattc_evt.conn_handle,
   24784:	687b      	ldr	r3, [r7, #4]
   24786:	889b      	ldrh	r3, [r3, #4]
   24788:	2113      	movs	r1, #19
   2478a:	4618      	mov	r0, r3
   2478c:	f7ff ffd8 	bl	24740 <sd_ble_gap_disconnect>
   24790:	63f8      	str	r0, [r7, #60]	; 0x3c
            APP_ERROR_CHECK(err_code);
   24792:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   24794:	633b      	str	r3, [r7, #48]	; 0x30
   24796:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   24798:	2b00      	cmp	r3, #0
   2479a:	d064      	beq.n	24866 <on_ble_peripheral_evt+0x10e>
   2479c:	4a37      	ldr	r2, [pc, #220]	; (2487c <on_ble_peripheral_evt+0x124>)
   2479e:	2148      	movs	r1, #72	; 0x48
   247a0:	6b38      	ldr	r0, [r7, #48]	; 0x30
   247a2:	f001 fb7b 	bl	25e9c <app_error_handler>
            break;
   247a6:	e05e      	b.n	24866 <on_ble_peripheral_evt+0x10e>
            err_code = sd_ble_gap_disconnect(p_ble_evt->evt.gatts_evt.conn_handle,
   247a8:	687b      	ldr	r3, [r7, #4]
   247aa:	889b      	ldrh	r3, [r3, #4]
   247ac:	2113      	movs	r1, #19
   247ae:	4618      	mov	r0, r3
   247b0:	f7ff ffc6 	bl	24740 <sd_ble_gap_disconnect>
   247b4:	63f8      	str	r0, [r7, #60]	; 0x3c
            APP_ERROR_CHECK(err_code);
   247b6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   247b8:	63bb      	str	r3, [r7, #56]	; 0x38
   247ba:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   247bc:	2b00      	cmp	r3, #0
   247be:	d054      	beq.n	2486a <on_ble_peripheral_evt+0x112>
   247c0:	4a2e      	ldr	r2, [pc, #184]	; (2487c <on_ble_peripheral_evt+0x124>)
   247c2:	2150      	movs	r1, #80	; 0x50
   247c4:	6bb8      	ldr	r0, [r7, #56]	; 0x38
   247c6:	f001 fb69 	bl	25e9c <app_error_handler>
            break;
   247ca:	e04e      	b.n	2486a <on_ble_peripheral_evt+0x112>
            err_code = sd_ble_user_mem_reply(p_ble_evt->evt.gap_evt.conn_handle, NULL);
   247cc:	687b      	ldr	r3, [r7, #4]
   247ce:	889b      	ldrh	r3, [r3, #4]
   247d0:	2100      	movs	r1, #0
   247d2:	4618      	mov	r0, r3
   247d4:	f7ff ffbc 	bl	24750 <sd_ble_user_mem_reply>
   247d8:	63f8      	str	r0, [r7, #60]	; 0x3c
            APP_ERROR_CHECK(err_code);
   247da:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   247dc:	62fb      	str	r3, [r7, #44]	; 0x2c
   247de:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   247e0:	2b00      	cmp	r3, #0
   247e2:	d044      	beq.n	2486e <on_ble_peripheral_evt+0x116>
   247e4:	4a25      	ldr	r2, [pc, #148]	; (2487c <on_ble_peripheral_evt+0x124>)
   247e6:	2155      	movs	r1, #85	; 0x55
   247e8:	6af8      	ldr	r0, [r7, #44]	; 0x2c
   247ea:	f001 fb57 	bl	25e9c <app_error_handler>
            break;
   247ee:	e03e      	b.n	2486e <on_ble_peripheral_evt+0x116>
            req = p_ble_evt->evt.gatts_evt.params.authorize_request;
   247f0:	687b      	ldr	r3, [r7, #4]
   247f2:	f107 041c 	add.w	r4, r7, #28
   247f6:	3306      	adds	r3, #6
   247f8:	6818      	ldr	r0, [r3, #0]
   247fa:	6859      	ldr	r1, [r3, #4]
   247fc:	689a      	ldr	r2, [r3, #8]
   247fe:	68db      	ldr	r3, [r3, #12]
   24800:	c40f      	stmia	r4!, {r0, r1, r2, r3}
            if (req.type != BLE_GATTS_AUTHORIZE_TYPE_INVALID)
   24802:	7f3b      	ldrb	r3, [r7, #28]
   24804:	2b00      	cmp	r3, #0
   24806:	d034      	beq.n	24872 <on_ble_peripheral_evt+0x11a>
                if ((req.request.write.op == BLE_GATTS_OP_PREP_WRITE_REQ)     ||
   24808:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   2480c:	2b04      	cmp	r3, #4
   2480e:	d007      	beq.n	24820 <on_ble_peripheral_evt+0xc8>
                    (req.request.write.op == BLE_GATTS_OP_EXEC_WRITE_REQ_NOW) ||
   24810:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
                if ((req.request.write.op == BLE_GATTS_OP_PREP_WRITE_REQ)     ||
   24814:	2b06      	cmp	r3, #6
   24816:	d003      	beq.n	24820 <on_ble_peripheral_evt+0xc8>
                    (req.request.write.op == BLE_GATTS_OP_EXEC_WRITE_REQ_CANCEL))
   24818:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
                    (req.request.write.op == BLE_GATTS_OP_EXEC_WRITE_REQ_NOW) ||
   2481c:	2b05      	cmp	r3, #5
   2481e:	d128      	bne.n	24872 <on_ble_peripheral_evt+0x11a>
                    if (req.type == BLE_GATTS_AUTHORIZE_TYPE_WRITE)
   24820:	7f3b      	ldrb	r3, [r7, #28]
   24822:	2b02      	cmp	r3, #2
   24824:	d102      	bne.n	2482c <on_ble_peripheral_evt+0xd4>
                        auth_reply.type = BLE_GATTS_AUTHORIZE_TYPE_WRITE;
   24826:	2302      	movs	r3, #2
   24828:	733b      	strb	r3, [r7, #12]
   2482a:	e001      	b.n	24830 <on_ble_peripheral_evt+0xd8>
                        auth_reply.type = BLE_GATTS_AUTHORIZE_TYPE_READ;
   2482c:	2301      	movs	r3, #1
   2482e:	733b      	strb	r3, [r7, #12]
                    auth_reply.params.write.gatt_status = APP_FEATURE_NOT_SUPPORTED;
   24830:	f44f 73c1 	mov.w	r3, #386	; 0x182
   24834:	823b      	strh	r3, [r7, #16]
                    err_code = sd_ble_gatts_rw_authorize_reply(p_ble_evt->evt.gatts_evt.conn_handle,
   24836:	687b      	ldr	r3, [r7, #4]
   24838:	889b      	ldrh	r3, [r3, #4]
   2483a:	f107 020c 	add.w	r2, r7, #12
   2483e:	4611      	mov	r1, r2
   24840:	4618      	mov	r0, r3
   24842:	f7ff ff81 	bl	24748 <sd_ble_gatts_rw_authorize_reply>
   24846:	63f8      	str	r0, [r7, #60]	; 0x3c
                    APP_ERROR_CHECK(err_code);
   24848:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   2484a:	637b      	str	r3, [r7, #52]	; 0x34
   2484c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   2484e:	2b00      	cmp	r3, #0
   24850:	d00f      	beq.n	24872 <on_ble_peripheral_evt+0x11a>
   24852:	4a0a      	ldr	r2, [pc, #40]	; (2487c <on_ble_peripheral_evt+0x124>)
   24854:	2170      	movs	r1, #112	; 0x70
   24856:	6b78      	ldr	r0, [r7, #52]	; 0x34
   24858:	f001 fb20 	bl	25e9c <app_error_handler>
        } break; // BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST
   2485c:	e009      	b.n	24872 <on_ble_peripheral_evt+0x11a>
        break;
   2485e:	bf00      	nop
   24860:	e008      	b.n	24874 <on_ble_peripheral_evt+0x11c>
            break;
   24862:	bf00      	nop
   24864:	e006      	b.n	24874 <on_ble_peripheral_evt+0x11c>
            break;
   24866:	bf00      	nop
   24868:	e004      	b.n	24874 <on_ble_peripheral_evt+0x11c>
            break;
   2486a:	bf00      	nop
   2486c:	e002      	b.n	24874 <on_ble_peripheral_evt+0x11c>
            break;
   2486e:	bf00      	nop
   24870:	e000      	b.n	24874 <on_ble_peripheral_evt+0x11c>
        } break; // BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST
   24872:	bf00      	nop
    }
}
   24874:	bf00      	nop
   24876:	3744      	adds	r7, #68	; 0x44
   24878:	46bd      	mov	sp, r7
   2487a:	bd90      	pop	{r4, r7, pc}
   2487c:	00027a1c 	.word	0x00027a1c

00024880 <on_adv_evt>:
/**@brief Function for handling advertising events.
 *
 * @param[in] ble_adv_evt  Advertising event.
 */
void on_adv_evt(ble_adv_evt_t ble_adv_evt)
{
   24880:	b580      	push	{r7, lr}
   24882:	b084      	sub	sp, #16
   24884:	af00      	add	r7, sp, #0
   24886:	4603      	mov	r3, r0
   24888:	71fb      	strb	r3, [r7, #7]
    switch (ble_adv_evt)
   2488a:	79fb      	ldrb	r3, [r7, #7]
   2488c:	2b00      	cmp	r3, #0
   2488e:	d002      	beq.n	24896 <on_adv_evt+0x16>
   24890:	2b03      	cmp	r3, #3
   24892:	d010      	beq.n	248b6 <on_adv_evt+0x36>
            APP_ERROR_CHECK(err_code);
        } break;

        default:
            // No implementation needed.
            break;
   24894:	e012      	b.n	248bc <on_adv_evt+0x3c>
            ret_code_t err_code = ble_advertising_start(&m_advertising, BLE_ADV_MODE_FAST);
   24896:	2103      	movs	r1, #3
   24898:	480a      	ldr	r0, [pc, #40]	; (248c4 <on_adv_evt+0x44>)
   2489a:	f002 fc6f 	bl	2717c <ble_advertising_start>
   2489e:	60f8      	str	r0, [r7, #12]
            APP_ERROR_CHECK(err_code);
   248a0:	68fb      	ldr	r3, [r7, #12]
   248a2:	60bb      	str	r3, [r7, #8]
   248a4:	68bb      	ldr	r3, [r7, #8]
   248a6:	2b00      	cmp	r3, #0
   248a8:	d007      	beq.n	248ba <on_adv_evt+0x3a>
   248aa:	4a07      	ldr	r2, [pc, #28]	; (248c8 <on_adv_evt+0x48>)
   248ac:	218a      	movs	r1, #138	; 0x8a
   248ae:	68b8      	ldr	r0, [r7, #8]
   248b0:	f001 faf4 	bl	25e9c <app_error_handler>
        } break;
   248b4:	e001      	b.n	248ba <on_adv_evt+0x3a>
            break;
   248b6:	bf00      	nop
   248b8:	e000      	b.n	248bc <on_adv_evt+0x3c>
        } break;
   248ba:	bf00      	nop
    }
}
   248bc:	bf00      	nop
   248be:	3710      	adds	r7, #16
   248c0:	46bd      	mov	sp, r7
   248c2:	bd80      	pop	{r7, pc}
   248c4:	20005164 	.word	0x20005164
   248c8:	00027a1c 	.word	0x00027a1c

000248cc <AdvertisingInit>:
 *
 * @details Encodes the required advertising data and passes it to the stack.
 *          Also builds a structure to be passed to the stack when starting advertising.
 */
void AdvertisingInit(void)
{
   248cc:	b580      	push	{r7, lr}
   248ce:	b0aa      	sub	sp, #168	; 0xa8
   248d0:	af00      	add	r7, sp, #0
    ret_code_t             err_code;
    ble_advertising_init_t init;

    memset(&init, 0, sizeof(init));
   248d2:	463b      	mov	r3, r7
   248d4:	22a0      	movs	r2, #160	; 0xa0
   248d6:	2100      	movs	r1, #0
   248d8:	4618      	mov	r0, r3
   248da:	f7fe fe9f 	bl	2361c <memset>

    init.advdata.name_type               = BLE_ADVDATA_FULL_NAME;
   248de:	2302      	movs	r3, #2
   248e0:	703b      	strb	r3, [r7, #0]
    init.advdata.include_appearance      = true;
   248e2:	2301      	movs	r3, #1
   248e4:	70bb      	strb	r3, [r7, #2]
    init.advdata.flags                   = BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE;
   248e6:	2306      	movs	r3, #6
   248e8:	70fb      	strb	r3, [r7, #3]
    init.advdata.uuids_complete.uuid_cnt = sizeof(m_adv_uuids) / sizeof(m_adv_uuids[0]);
   248ea:	2301      	movs	r3, #1
   248ec:	823b      	strh	r3, [r7, #16]
    init.advdata.uuids_complete.p_uuids  = m_adv_uuids;
   248ee:	4b16      	ldr	r3, [pc, #88]	; (24948 <AdvertisingInit+0x7c>)
   248f0:	617b      	str	r3, [r7, #20]

    init.config.ble_adv_fast_enabled  = true;
   248f2:	2301      	movs	r3, #1
   248f4:	f887 307c 	strb.w	r3, [r7, #124]	; 0x7c
    init.config.ble_adv_fast_interval = ADV_INTERVAL;
   248f8:	f44f 63c8 	mov.w	r3, #1600	; 0x640
   248fc:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
    init.config.ble_adv_fast_timeout  = ADV_TIMEOUT_IN_SECONDS;
   24900:	2300      	movs	r3, #0
   24902:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c

    init.evt_handler = on_adv_evt;
   24906:	4b11      	ldr	r3, [pc, #68]	; (2494c <AdvertisingInit+0x80>)
   24908:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98

    err_code = ble_advertising_init(&m_advertising, &init);
   2490c:	463b      	mov	r3, r7
   2490e:	4619      	mov	r1, r3
   24910:	480f      	ldr	r0, [pc, #60]	; (24950 <AdvertisingInit+0x84>)
   24912:	f002 fb22 	bl	26f5a <ble_advertising_init>
   24916:	f8c7 00a4 	str.w	r0, [r7, #164]	; 0xa4
    APP_ERROR_CHECK(err_code);
   2491a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
   2491e:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
   24922:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
   24926:	2b00      	cmp	r3, #0
   24928:	d005      	beq.n	24936 <AdvertisingInit+0x6a>
   2492a:	4a0a      	ldr	r2, [pc, #40]	; (24954 <AdvertisingInit+0x88>)
   2492c:	21ad      	movs	r1, #173	; 0xad
   2492e:	f8d7 00a0 	ldr.w	r0, [r7, #160]	; 0xa0
   24932:	f001 fab3 	bl	25e9c <app_error_handler>

    ble_advertising_conn_cfg_tag_set(&m_advertising, APP_BLE_CONN_CFG_TAG);
   24936:	2101      	movs	r1, #1
   24938:	4805      	ldr	r0, [pc, #20]	; (24950 <AdvertisingInit+0x84>)
   2493a:	f002 faff 	bl	26f3c <ble_advertising_conn_cfg_tag_set>
}
   2493e:	bf00      	nop
   24940:	37a8      	adds	r7, #168	; 0xa8
   24942:	46bd      	mov	sp, r7
   24944:	bd80      	pop	{r7, pc}
   24946:	bf00      	nop
   24948:	20005074 	.word	0x20005074
   2494c:	00024881 	.word	0x00024881
   24950:	20005164 	.word	0x20005164
   24954:	00027a1c 	.word	0x00027a1c

00024958 <sd_ble_gatts_service_add>:
SVCALL(SD_BLE_GATTS_SERVICE_ADD, uint32_t, sd_ble_gatts_service_add(uint8_t type, ble_uuid_t const *p_uuid, uint16_t *p_handle));
   24958:	dfa0      	svc	160	; 0xa0
   2495a:	4770      	bx	lr
   2495c:	bf00      	nop
   2495e:	4618      	mov	r0, r3

00024960 <sd_ble_gatts_characteristic_add>:
SVCALL(SD_BLE_GATTS_CHARACTERISTIC_ADD, uint32_t, sd_ble_gatts_characteristic_add(uint16_t service_handle, ble_gatts_char_md_t const *p_char_md, ble_gatts_attr_t const *p_attr_char_value, ble_gatts_char_handles_t *p_handles));
   24960:	dfa2      	svc	162	; 0xa2
   24962:	4770      	bx	lr
   24964:	bf00      	nop
   24966:	4618      	mov	r0, r3

00024968 <sd_ble_gatts_value_set>:
SVCALL(SD_BLE_GATTS_VALUE_SET, uint32_t, sd_ble_gatts_value_set(uint16_t conn_handle, uint16_t handle, ble_gatts_value_t *p_value));
   24968:	dfa4      	svc	164	; 0xa4
   2496a:	4770      	bx	lr
   2496c:	bf00      	nop
   2496e:	4618      	mov	r0, r3

00024970 <sd_ble_gatts_hvx>:
SVCALL(SD_BLE_GATTS_HVX, uint32_t, sd_ble_gatts_hvx(uint16_t conn_handle, ble_gatts_hvx_params_t const *p_hvx_params));
   24970:	dfa6      	svc	166	; 0xa6
   24972:	4770      	bx	lr
   24974:	bf00      	nop
   24976:	4618      	mov	r0, r3

00024978 <sd_ble_uuid_vs_add>:
SVCALL(SD_BLE_UUID_VS_ADD, uint32_t, sd_ble_uuid_vs_add(ble_uuid128_t const *p_vs_uuid, uint8_t *p_uuid_type));
   24978:	df62      	svc	98	; 0x62
   2497a:	4770      	bx	lr
   2497c:	bf00      	nop
   2497e:	4618      	mov	r0, r3

00024980 <BleUartAddPendingTask>:

static app_fifo_t           ble_uart_pending_requests_fifo;
static uint8_t              ble_uart_pending_requests_fifo_buffer[16];

uint32_t BleUartAddPendingTask(ble_uart_communication_commands_e command)
{
   24980:	b580      	push	{r7, lr}
   24982:	b082      	sub	sp, #8
   24984:	af00      	add	r7, sp, #0
   24986:	4603      	mov	r3, r0
   24988:	71fb      	strb	r3, [r7, #7]
    FifoPut(&ble_uart_pending_requests_fifo, command);
   2498a:	79fb      	ldrb	r3, [r7, #7]
   2498c:	4619      	mov	r1, r3
   2498e:	4804      	ldr	r0, [pc, #16]	; (249a0 <BleUartAddPendingTask+0x20>)
   24990:	f7ff fa37 	bl	23e02 <FifoPut>

    return NRF_SUCCESS;
   24994:	2300      	movs	r3, #0
}
   24996:	4618      	mov	r0, r3
   24998:	3708      	adds	r7, #8
   2499a:	46bd      	mov	sp, r7
   2499c:	bd80      	pop	{r7, pc}
   2499e:	bf00      	nop
   249a0:	20005278 	.word	0x20005278

000249a4 <_OnConnect>:
 *
 * @param[in]   p_uart       Blood Pressure Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void _OnConnect(ble_uart_t * p_uart, ble_evt_t * p_ble_evt)
{
   249a4:	b480      	push	{r7}
   249a6:	b083      	sub	sp, #12
   249a8:	af00      	add	r7, sp, #0
   249aa:	6078      	str	r0, [r7, #4]
   249ac:	6039      	str	r1, [r7, #0]
    p_uart->conn_handle = p_ble_evt->evt.gatts_evt.conn_handle;
   249ae:	683b      	ldr	r3, [r7, #0]
   249b0:	889a      	ldrh	r2, [r3, #4]
   249b2:	687b      	ldr	r3, [r7, #4]
   249b4:	841a      	strh	r2, [r3, #32]
}
   249b6:	bf00      	nop
   249b8:	370c      	adds	r7, #12
   249ba:	46bd      	mov	sp, r7
   249bc:	bc80      	pop	{r7}
   249be:	4770      	bx	lr

000249c0 <_OnDisconnect>:
 *
 * @param[in]   p_uart       Blood Pressure Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void _OnDisconnect(ble_uart_t * p_uart, ble_evt_t * p_ble_evt)
{
   249c0:	b480      	push	{r7}
   249c2:	b083      	sub	sp, #12
   249c4:	af00      	add	r7, sp, #0
   249c6:	6078      	str	r0, [r7, #4]
   249c8:	6039      	str	r1, [r7, #0]
    UNUSED_PARAMETER(p_ble_evt);
    p_uart->conn_handle = BLE_CONN_HANDLE_INVALID;
   249ca:	687b      	ldr	r3, [r7, #4]
   249cc:	f64f 72ff 	movw	r2, #65535	; 0xffff
   249d0:	841a      	strh	r2, [r3, #32]
}
   249d2:	bf00      	nop
   249d4:	370c      	adds	r7, #12
   249d6:	46bd      	mov	sp, r7
   249d8:	bc80      	pop	{r7}
   249da:	4770      	bx	lr

000249dc <_OnTxCccdWrite>:
 *
 * @param[in]   p_uart         Data Transfer Service structure.
 * @param[in]   p_evt_write   Write event received from the BLE stack.
 */
static void _OnTxCccdWrite(ble_uart_t * p_uart, ble_gatts_evt_write_t * p_evt_write)
{
   249dc:	b590      	push	{r4, r7, lr}
   249de:	b087      	sub	sp, #28
   249e0:	af00      	add	r7, sp, #0
   249e2:	6078      	str	r0, [r7, #4]
   249e4:	6039      	str	r1, [r7, #0]
    if (p_evt_write->len == 2)
   249e6:	683b      	ldr	r3, [r7, #0]
   249e8:	895b      	ldrh	r3, [r3, #10]
   249ea:	2b02      	cmp	r3, #2
   249ec:	d11a      	bne.n	24a24 <_OnTxCccdWrite+0x48>
    {
        // CCCD written, update indication state
        if (p_uart->evt_handler != NULL)
   249ee:	687b      	ldr	r3, [r7, #4]
   249f0:	681b      	ldr	r3, [r3, #0]
   249f2:	2b00      	cmp	r3, #0
   249f4:	d016      	beq.n	24a24 <_OnTxCccdWrite+0x48>
        {
            ble_uart_evt_t evt;

            if (ble_srv_is_indication_enabled(p_evt_write->data))
   249f6:	683b      	ldr	r3, [r7, #0]
   249f8:	330c      	adds	r3, #12
   249fa:	4618      	mov	r0, r3
   249fc:	f002 f8d9 	bl	26bb2 <ble_srv_is_indication_enabled>
   24a00:	4603      	mov	r3, r0
   24a02:	2b00      	cmp	r3, #0
   24a04:	d002      	beq.n	24a0c <_OnTxCccdWrite+0x30>
            {
                evt.evt_type = BLE_UART_EVT_INDICATION_ENABLED;
   24a06:	2300      	movs	r3, #0
   24a08:	723b      	strb	r3, [r7, #8]
   24a0a:	e001      	b.n	24a10 <_OnTxCccdWrite+0x34>
            }
            else
            {
                evt.evt_type = BLE_UART_EVT_INDICATION_DISABLED;
   24a0c:	2301      	movs	r3, #1
   24a0e:	723b      	strb	r3, [r7, #8]
            }

            p_uart->evt_handler(p_uart, &evt, p_evt_write->data, 0);
   24a10:	687b      	ldr	r3, [r7, #4]
   24a12:	681c      	ldr	r4, [r3, #0]
   24a14:	683b      	ldr	r3, [r7, #0]
   24a16:	f103 020c 	add.w	r2, r3, #12
   24a1a:	f107 0108 	add.w	r1, r7, #8
   24a1e:	2300      	movs	r3, #0
   24a20:	6878      	ldr	r0, [r7, #4]
   24a22:	47a0      	blx	r4
        }
    }
}
   24a24:	bf00      	nop
   24a26:	371c      	adds	r7, #28
   24a28:	46bd      	mov	sp, r7
   24a2a:	bd90      	pop	{r4, r7, pc}

00024a2c <_OnDevEventsCccdWrite>:
 *
 * @param[in]   p_uart         Data Transfer Service structure.
 * @param[in]   p_evt_write   Write event received from the BLE stack.
 */
static void _OnDevEventsCccdWrite(ble_uart_t * p_uart, ble_gatts_evt_write_t * p_evt_write)
{
   24a2c:	b590      	push	{r4, r7, lr}
   24a2e:	b087      	sub	sp, #28
   24a30:	af00      	add	r7, sp, #0
   24a32:	6078      	str	r0, [r7, #4]
   24a34:	6039      	str	r1, [r7, #0]
    if (p_evt_write->len == 2)
   24a36:	683b      	ldr	r3, [r7, #0]
   24a38:	895b      	ldrh	r3, [r3, #10]
   24a3a:	2b02      	cmp	r3, #2
   24a3c:	d11a      	bne.n	24a74 <_OnDevEventsCccdWrite+0x48>
    {
        // CCCD written, update indication state
        if (p_uart->evt_handler != NULL)
   24a3e:	687b      	ldr	r3, [r7, #4]
   24a40:	681b      	ldr	r3, [r3, #0]
   24a42:	2b00      	cmp	r3, #0
   24a44:	d016      	beq.n	24a74 <_OnDevEventsCccdWrite+0x48>
        {
            ble_uart_evt_t evt;

            if (ble_srv_is_notification_enabled(p_evt_write->data))
   24a46:	683b      	ldr	r3, [r7, #0]
   24a48:	330c      	adds	r3, #12
   24a4a:	4618      	mov	r0, r3
   24a4c:	f002 f89c 	bl	26b88 <ble_srv_is_notification_enabled>
   24a50:	4603      	mov	r3, r0
   24a52:	2b00      	cmp	r3, #0
   24a54:	d002      	beq.n	24a5c <_OnDevEventsCccdWrite+0x30>
            {
                evt.evt_type = BLE_UART_EVT_NOTIFICATION_ENABLED;
   24a56:	2302      	movs	r3, #2
   24a58:	723b      	strb	r3, [r7, #8]
   24a5a:	e001      	b.n	24a60 <_OnDevEventsCccdWrite+0x34>
            }
            else
            {
                evt.evt_type = BLE_UART_EVT_NOTIFICATION_DISABLED;
   24a5c:	2303      	movs	r3, #3
   24a5e:	723b      	strb	r3, [r7, #8]
            }

            p_uart->evt_handler(p_uart, &evt, p_evt_write->data, 0);
   24a60:	687b      	ldr	r3, [r7, #4]
   24a62:	681c      	ldr	r4, [r3, #0]
   24a64:	683b      	ldr	r3, [r7, #0]
   24a66:	f103 020c 	add.w	r2, r3, #12
   24a6a:	f107 0108 	add.w	r1, r7, #8
   24a6e:	2300      	movs	r3, #0
   24a70:	6878      	ldr	r0, [r7, #4]
   24a72:	47a0      	blx	r4
        }
    }
}
   24a74:	bf00      	nop
   24a76:	371c      	adds	r7, #28
   24a78:	46bd      	mov	sp, r7
   24a7a:	bd90      	pop	{r4, r7, pc}

00024a7c <_OnRxWrite>:
 *
 * @param[in]   p_uart         Data Transfer Service structure.
 * @param[in]   p_evt_write   Write event received from the BLE stack.
 */
static void _OnRxWrite(ble_uart_t * p_uart, ble_gatts_evt_write_t * p_evt_write)
{
   24a7c:	b590      	push	{r4, r7, lr}
   24a7e:	b087      	sub	sp, #28
   24a80:	af00      	add	r7, sp, #0
   24a82:	6078      	str	r0, [r7, #4]
   24a84:	6039      	str	r1, [r7, #0]
    if (p_evt_write->len)
   24a86:	683b      	ldr	r3, [r7, #0]
   24a88:	895b      	ldrh	r3, [r3, #10]
   24a8a:	2b00      	cmp	r3, #0
   24a8c:	d011      	beq.n	24ab2 <_OnRxWrite+0x36>
    {
        // CCCD written, update indication state
        if (p_uart->evt_handler != NULL)
   24a8e:	687b      	ldr	r3, [r7, #4]
   24a90:	681b      	ldr	r3, [r3, #0]
   24a92:	2b00      	cmp	r3, #0
   24a94:	d00d      	beq.n	24ab2 <_OnRxWrite+0x36>
        {
            ble_uart_evt_t evt;
                        evt.evt_type = BLE_UART_EVT_RX_DATA_RECEIVED;
   24a96:	2306      	movs	r3, #6
   24a98:	723b      	strb	r3, [r7, #8]
            p_uart->evt_handler(p_uart, &evt, p_evt_write->data, p_evt_write->len);
   24a9a:	687b      	ldr	r3, [r7, #4]
   24a9c:	681c      	ldr	r4, [r3, #0]
   24a9e:	683b      	ldr	r3, [r7, #0]
   24aa0:	f103 020c 	add.w	r2, r3, #12
   24aa4:	683b      	ldr	r3, [r7, #0]
   24aa6:	895b      	ldrh	r3, [r3, #10]
   24aa8:	b2db      	uxtb	r3, r3
   24aaa:	f107 0108 	add.w	r1, r7, #8
   24aae:	6878      	ldr	r0, [r7, #4]
   24ab0:	47a0      	blx	r4
        }
    }
}
   24ab2:	bf00      	nop
   24ab4:	371c      	adds	r7, #28
   24ab6:	46bd      	mov	sp, r7
   24ab8:	bd90      	pop	{r4, r7, pc}
	...

00024abc <_OnWrite>:
 *
 * @param[in]   p_uart       Blood Pressure Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void _OnWrite(ble_uart_t * p_uart, ble_evt_t * p_ble_evt)
{
   24abc:	b580      	push	{r7, lr}
   24abe:	b084      	sub	sp, #16
   24ac0:	af00      	add	r7, sp, #0
   24ac2:	6078      	str	r0, [r7, #4]
   24ac4:	6039      	str	r1, [r7, #0]
    ble_gatts_evt_write_t * p_evt_write = &p_ble_evt->evt.gatts_evt.params.write;
   24ac6:	683b      	ldr	r3, [r7, #0]
   24ac8:	3306      	adds	r3, #6
   24aca:	60fb      	str	r3, [r7, #12]
    static uint8_t tx_enabled = 0;
    static uint8_t evt_enabled = 0;
    if (p_evt_write->handle == p_uart->tx_handles.cccd_handle) //Handle CCCD write to TX characteristic
   24acc:	68fb      	ldr	r3, [r7, #12]
   24ace:	881a      	ldrh	r2, [r3, #0]
   24ad0:	687b      	ldr	r3, [r7, #4]
   24ad2:	895b      	ldrh	r3, [r3, #10]
   24ad4:	429a      	cmp	r2, r3
   24ad6:	d106      	bne.n	24ae6 <_OnWrite+0x2a>
    {
        _OnTxCccdWrite(p_uart, p_evt_write);
   24ad8:	68f9      	ldr	r1, [r7, #12]
   24ada:	6878      	ldr	r0, [r7, #4]
   24adc:	f7ff ff7e 	bl	249dc <_OnTxCccdWrite>
        tx_enabled = 1;
   24ae0:	4b0e      	ldr	r3, [pc, #56]	; (24b1c <_OnWrite+0x60>)
   24ae2:	2201      	movs	r2, #1
   24ae4:	701a      	strb	r2, [r3, #0]
    }
    if (p_evt_write->handle == p_uart->dev_events_handles.cccd_handle) //Handle CCCD write to Device Events characteristic
   24ae6:	68fb      	ldr	r3, [r7, #12]
   24ae8:	881a      	ldrh	r2, [r3, #0]
   24aea:	687b      	ldr	r3, [r7, #4]
   24aec:	8b5b      	ldrh	r3, [r3, #26]
   24aee:	429a      	cmp	r2, r3
   24af0:	d106      	bne.n	24b00 <_OnWrite+0x44>
    {
        _OnDevEventsCccdWrite(p_uart, p_evt_write);
   24af2:	68f9      	ldr	r1, [r7, #12]
   24af4:	6878      	ldr	r0, [r7, #4]
   24af6:	f7ff ff99 	bl	24a2c <_OnDevEventsCccdWrite>
        evt_enabled = 1;
   24afa:	4b09      	ldr	r3, [pc, #36]	; (24b20 <_OnWrite+0x64>)
   24afc:	2201      	movs	r2, #1
   24afe:	701a      	strb	r2, [r3, #0]
    }
    if (p_evt_write->handle == p_uart->rx_handles.value_handle) //Handle VALUE write to RX characteristic
   24b00:	68fb      	ldr	r3, [r7, #12]
   24b02:	881a      	ldrh	r2, [r3, #0]
   24b04:	687b      	ldr	r3, [r7, #4]
   24b06:	89db      	ldrh	r3, [r3, #14]
   24b08:	429a      	cmp	r2, r3
   24b0a:	d103      	bne.n	24b14 <_OnWrite+0x58>
    {
        _OnRxWrite(p_uart, p_evt_write);
   24b0c:	68f9      	ldr	r1, [r7, #12]
   24b0e:	6878      	ldr	r0, [r7, #4]
   24b10:	f7ff ffb4 	bl	24a7c <_OnRxWrite>
    }
}
   24b14:	bf00      	nop
   24b16:	3710      	adds	r7, #16
   24b18:	46bd      	mov	sp, r7
   24b1a:	bd80      	pop	{r7, pc}
   24b1c:	20005298 	.word	0x20005298
   24b20:	20005299 	.word	0x20005299

00024b24 <_OnHvc>:
 *
 * @param[in]   p_uart       Blood Pressure Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void _OnHvc(ble_uart_t * p_uart, ble_evt_t * p_ble_evt)
{
   24b24:	b590      	push	{r4, r7, lr}
   24b26:	b089      	sub	sp, #36	; 0x24
   24b28:	af00      	add	r7, sp, #0
   24b2a:	6078      	str	r0, [r7, #4]
   24b2c:	6039      	str	r1, [r7, #0]
    ble_gatts_evt_hvc_t * p_hvc = &p_ble_evt->evt.gatts_evt.params.hvc;
   24b2e:	683b      	ldr	r3, [r7, #0]
   24b30:	3306      	adds	r3, #6
   24b32:	61fb      	str	r3, [r7, #28]

    if (p_hvc->handle == p_uart->tx_handles.value_handle)
   24b34:	69fb      	ldr	r3, [r7, #28]
   24b36:	881a      	ldrh	r2, [r3, #0]
   24b38:	687b      	ldr	r3, [r7, #4]
   24b3a:	88db      	ldrh	r3, [r3, #6]
   24b3c:	429a      	cmp	r2, r3
   24b3e:	d109      	bne.n	24b54 <_OnHvc+0x30>
    {
        ble_uart_evt_t evt;

        evt.evt_type = BLE_UART_EVT_INDICATION_CONFIRMED;
   24b40:	2305      	movs	r3, #5
   24b42:	733b      	strb	r3, [r7, #12]
        p_uart->evt_handler(p_uart, &evt, 0, 0);
   24b44:	687b      	ldr	r3, [r7, #4]
   24b46:	681c      	ldr	r4, [r3, #0]
   24b48:	f107 010c 	add.w	r1, r7, #12
   24b4c:	2300      	movs	r3, #0
   24b4e:	2200      	movs	r2, #0
   24b50:	6878      	ldr	r0, [r7, #4]
   24b52:	47a0      	blx	r4
    }
}
   24b54:	bf00      	nop
   24b56:	3724      	adds	r7, #36	; 0x24
   24b58:	46bd      	mov	sp, r7
   24b5a:	bd90      	pop	{r4, r7, pc}

00024b5c <_OnNotifyCompleted>:

static void _OnNotifyCompleted(ble_uart_t * p_uart, ble_evt_t * p_ble_evt)
{
   24b5c:	b590      	push	{r4, r7, lr}
   24b5e:	b087      	sub	sp, #28
   24b60:	af00      	add	r7, sp, #0
   24b62:	6078      	str	r0, [r7, #4]
   24b64:	6039      	str	r1, [r7, #0]

    //if (p_hvc->handle == p_uart->dev_events_handles.value_handle)
   // {
        ble_uart_evt_t evt;

        evt.evt_type = BLE_UART_EVT_NOTIFICATION_TRANSMITTED;
   24b66:	2304      	movs	r3, #4
   24b68:	723b      	strb	r3, [r7, #8]
        p_uart->evt_handler(p_uart, &evt, 0, 0);
   24b6a:	687b      	ldr	r3, [r7, #4]
   24b6c:	681c      	ldr	r4, [r3, #0]
   24b6e:	f107 0108 	add.w	r1, r7, #8
   24b72:	2300      	movs	r3, #0
   24b74:	2200      	movs	r2, #0
   24b76:	6878      	ldr	r0, [r7, #4]
   24b78:	47a0      	blx	r4
    //}
}
   24b7a:	bf00      	nop
   24b7c:	371c      	adds	r7, #28
   24b7e:	46bd      	mov	sp, r7
   24b80:	bd90      	pop	{r4, r7, pc}

00024b82 <BleUartOnBleEvt>:
 *
 * @param[in]   p_uart      Data Transfer Service structure.
 * @param[in]   p_ble_evt  Event received from the BLE stack.
 */
void BleUartOnBleEvt(ble_uart_t * p_uart, ble_evt_t const * p_ble_evt)
{
   24b82:	b580      	push	{r7, lr}
   24b84:	b084      	sub	sp, #16
   24b86:	af00      	add	r7, sp, #0
   24b88:	6078      	str	r0, [r7, #4]
   24b8a:	6039      	str	r1, [r7, #0]
    ble_evt_t* ble_evt = (ble_evt_t*)p_ble_evt;
   24b8c:	683b      	ldr	r3, [r7, #0]
   24b8e:	60fb      	str	r3, [r7, #12]
    switch (p_ble_evt->header.evt_id)
   24b90:	683b      	ldr	r3, [r7, #0]
   24b92:	881b      	ldrh	r3, [r3, #0]
   24b94:	2b50      	cmp	r3, #80	; 0x50
   24b96:	d017      	beq.n	24bc8 <BleUartOnBleEvt+0x46>
   24b98:	2b50      	cmp	r3, #80	; 0x50
   24b9a:	dc04      	bgt.n	24ba6 <BleUartOnBleEvt+0x24>
   24b9c:	2b10      	cmp	r3, #16
   24b9e:	d009      	beq.n	24bb4 <BleUartOnBleEvt+0x32>
   24ba0:	2b11      	cmp	r3, #17
   24ba2:	d00c      	beq.n	24bbe <BleUartOnBleEvt+0x3c>
        {
            break;
        }
        default:
            // No implementation needed.
            break;
   24ba4:	e020      	b.n	24be8 <BleUartOnBleEvt+0x66>
    switch (p_ble_evt->header.evt_id)
   24ba6:	2b56      	cmp	r3, #86	; 0x56
   24ba8:	d01d      	beq.n	24be6 <BleUartOnBleEvt+0x64>
   24baa:	2b57      	cmp	r3, #87	; 0x57
   24bac:	d016      	beq.n	24bdc <BleUartOnBleEvt+0x5a>
   24bae:	2b53      	cmp	r3, #83	; 0x53
   24bb0:	d00f      	beq.n	24bd2 <BleUartOnBleEvt+0x50>
            break;
   24bb2:	e019      	b.n	24be8 <BleUartOnBleEvt+0x66>
            _OnConnect(p_uart, ble_evt);
   24bb4:	68f9      	ldr	r1, [r7, #12]
   24bb6:	6878      	ldr	r0, [r7, #4]
   24bb8:	f7ff fef4 	bl	249a4 <_OnConnect>
            break;
   24bbc:	e014      	b.n	24be8 <BleUartOnBleEvt+0x66>
            _OnDisconnect(p_uart, ble_evt);
   24bbe:	68f9      	ldr	r1, [r7, #12]
   24bc0:	6878      	ldr	r0, [r7, #4]
   24bc2:	f7ff fefd 	bl	249c0 <_OnDisconnect>
            break;
   24bc6:	e00f      	b.n	24be8 <BleUartOnBleEvt+0x66>
            _OnWrite(p_uart, ble_evt);
   24bc8:	68f9      	ldr	r1, [r7, #12]
   24bca:	6878      	ldr	r0, [r7, #4]
   24bcc:	f7ff ff76 	bl	24abc <_OnWrite>
            break;
   24bd0:	e00a      	b.n	24be8 <BleUartOnBleEvt+0x66>
            _OnHvc(p_uart, ble_evt);
   24bd2:	68f9      	ldr	r1, [r7, #12]
   24bd4:	6878      	ldr	r0, [r7, #4]
   24bd6:	f7ff ffa5 	bl	24b24 <_OnHvc>
            break;
   24bda:	e005      	b.n	24be8 <BleUartOnBleEvt+0x66>
            _OnNotifyCompleted(p_uart, ble_evt);
   24bdc:	68f9      	ldr	r1, [r7, #12]
   24bde:	6878      	ldr	r0, [r7, #4]
   24be0:	f7ff ffbc 	bl	24b5c <_OnNotifyCompleted>
            break;
   24be4:	e000      	b.n	24be8 <BleUartOnBleEvt+0x66>
            break;
   24be6:	bf00      	nop
    }
}
   24be8:	bf00      	nop
   24bea:	3710      	adds	r7, #16
   24bec:	46bd      	mov	sp, r7
   24bee:	bd80      	pop	{r7, pc}

00024bf0 <_BleUartWaitTillPacketTxInProgress>:

/**
 * \brief This function blocks program execution until the single BLE packet is transmitted
 */
static void _BleUartWaitTillPacketTxInProgress()
{
   24bf0:	b480      	push	{r7}
   24bf2:	af00      	add	r7, sp, #0
    while(ble_tx_packet_in_progress)
   24bf4:	e000      	b.n	24bf8 <_BleUartWaitTillPacketTxInProgress+0x8>
  \details Wait For Event is a hint instruction that permits the processor to enter
    a low-power state until one of a number of events occurs.
 */
__attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
{
  __ASM volatile ("wfe");
   24bf6:	bf20      	wfe
   24bf8:	4b04      	ldr	r3, [pc, #16]	; (24c0c <_BleUartWaitTillPacketTxInProgress+0x1c>)
   24bfa:	781b      	ldrb	r3, [r3, #0]
   24bfc:	b2db      	uxtb	r3, r3
   24bfe:	2b00      	cmp	r3, #0
   24c00:	d1f9      	bne.n	24bf6 <_BleUartWaitTillPacketTxInProgress+0x6>
    {
        __WFE();
    }

    return;
   24c02:	bf00      	nop
}
   24c04:	46bd      	mov	sp, r7
   24c06:	bc80      	pop	{r7}
   24c08:	4770      	bx	lr
   24c0a:	bf00      	nop
   24c0c:	2000523c 	.word	0x2000523c

00024c10 <_BleUartNotifyWaitTillPacketInProgress>:

/**
 * \brief This function blocks program execution until the single BLE packet is transmitted
 */
static uint32_t  _BleUartNotifyWaitTillPacketInProgress()
{
   24c10:	b480      	push	{r7}
   24c12:	af00      	add	r7, sp, #0
//    RTCTimeout(NRF_RTC1, RTC_S_TO_TICKS(1));
    while(ble_notification_packet_in_progress)// && !timeout_flag)
   24c14:	e000      	b.n	24c18 <_BleUartNotifyWaitTillPacketInProgress+0x8>
   24c16:	bf20      	wfe
   24c18:	4b04      	ldr	r3, [pc, #16]	; (24c2c <_BleUartNotifyWaitTillPacketInProgress+0x1c>)
   24c1a:	781b      	ldrb	r3, [r3, #0]
   24c1c:	b2db      	uxtb	r3, r3
   24c1e:	2b00      	cmp	r3, #0
   24c20:	d1f9      	bne.n	24c16 <_BleUartNotifyWaitTillPacketInProgress+0x6>
//        timeout_flag = 0;
//        return NRF_ERROR_INTERNAL;
//    }
//
//    timeout_flag = 0;
    return NRF_SUCCESS;;
   24c22:	2300      	movs	r3, #0
}
   24c24:	4618      	mov	r0, r3
   24c26:	46bd      	mov	sp, r7
   24c28:	bc80      	pop	{r7}
   24c2a:	4770      	bx	lr
   24c2c:	2000523d 	.word	0x2000523d

00024c30 <_BleUartRxHandler>:
 *
 * \param p_data - pointer to the data sent from central to the device
 * \param data_size - size of data sent from central to the device
 */
static uint32_t _BleUartRxHandler(uint8_t* p_data, uint8_t data_size)
{
   24c30:	b580      	push	{r7, lr}
   24c32:	b084      	sub	sp, #16
   24c34:	af00      	add	r7, sp, #0
   24c36:	6078      	str	r0, [r7, #4]
   24c38:	460b      	mov	r3, r1
   24c3a:	70fb      	strb	r3, [r7, #3]
    uint8_t request_code = p_data[0];
   24c3c:	687b      	ldr	r3, [r7, #4]
   24c3e:	781b      	ldrb	r3, [r3, #0]
   24c40:	73fb      	strb	r3, [r7, #15]
    uint32_t err_code = 0;
   24c42:	2300      	movs	r3, #0
   24c44:	60bb      	str	r3, [r7, #8]

    BleUartAddPendingTask(E_TEST);
   24c46:	2000      	movs	r0, #0
   24c48:	f7ff fe9a 	bl	24980 <BleUartAddPendingTask>

    switch(request_code)
    {

        default:
            break;
   24c4c:	bf00      	nop
    }

    return NRF_SUCCESS;
   24c4e:	2300      	movs	r3, #0
}
   24c50:	4618      	mov	r0, r3
   24c52:	3710      	adds	r7, #16
   24c54:	46bd      	mov	sp, r7
   24c56:	bd80      	pop	{r7, pc}

00024c58 <_BleUartIndicateSendSinglePacket>:
 *  \param data - pointer to the data buffer
 *  \param data_size - size of data in the packet
 *
 */
static uint32_t _BleUartIndicateSendSinglePacket(ble_uart_t* p_uart, uint8_t* data, uint8_t actual_data_size)
{
   24c58:	b580      	push	{r7, lr}
   24c5a:	b08c      	sub	sp, #48	; 0x30
   24c5c:	af00      	add	r7, sp, #0
   24c5e:	60f8      	str	r0, [r7, #12]
   24c60:	60b9      	str	r1, [r7, #8]
   24c62:	4613      	mov	r3, r2
   24c64:	71fb      	strb	r3, [r7, #7]
    if(p_uart->conn_handle != BLE_CONN_HANDLE_INVALID)
   24c66:	68fb      	ldr	r3, [r7, #12]
   24c68:	8c1b      	ldrh	r3, [r3, #32]
   24c6a:	f64f 72ff 	movw	r2, #65535	; 0xffff
   24c6e:	4293      	cmp	r3, r2
   24c70:	d058      	beq.n	24d24 <_BleUartIndicateSendSinglePacket+0xcc>
        {
            uint16_t                hvx_len;
            ble_gatts_hvx_params_t  hvx_params;
            ble_gatts_value_t       value_params;
            uint32_t                err_code = 0;
   24c72:	2300      	movs	r3, #0
   24c74:	62fb      	str	r3, [r7, #44]	; 0x2c

            memset(&hvx_params, 0, sizeof(hvx_params));
   24c76:	f107 0318 	add.w	r3, r7, #24
   24c7a:	2210      	movs	r2, #16
   24c7c:	2100      	movs	r1, #0
   24c7e:	4618      	mov	r0, r3
   24c80:	f7fe fccc 	bl	2361c <memset>
            memset(&value_params,0,sizeof(value_params));
   24c84:	f107 0310 	add.w	r3, r7, #16
   24c88:	2208      	movs	r2, #8
   24c8a:	2100      	movs	r1, #0
   24c8c:	4618      	mov	r0, r3
   24c8e:	f7fe fcc5 	bl	2361c <memset>

            /// Copy the message to the buffer
            memcpy(ble_uart_tx_buffer+1, data, actual_data_size);
   24c92:	4827      	ldr	r0, [pc, #156]	; (24d30 <_BleUartIndicateSendSinglePacket+0xd8>)
   24c94:	79fb      	ldrb	r3, [r7, #7]
   24c96:	461a      	mov	r2, r3
   24c98:	68b9      	ldr	r1, [r7, #8]
   24c9a:	f002 fdb5 	bl	27808 <memcpy>

            //Fill structure with data size. This will avoid sending empty bytes when sending <20 bytes
            value_params.len = actual_data_size + 1;
   24c9e:	79fb      	ldrb	r3, [r7, #7]
   24ca0:	b29b      	uxth	r3, r3
   24ca2:	3301      	adds	r3, #1
   24ca4:	b29b      	uxth	r3, r3
   24ca6:	823b      	strh	r3, [r7, #16]
            value_params.offset = 0;
   24ca8:	2300      	movs	r3, #0
   24caa:	827b      	strh	r3, [r7, #18]
            value_params.p_value = NULL;
   24cac:	2300      	movs	r3, #0
   24cae:	617b      	str	r3, [r7, #20]

            err_code = sd_ble_gatts_value_set(p_uart->conn_handle, p_uart->tx_handles.value_handle, &value_params);
   24cb0:	68fb      	ldr	r3, [r7, #12]
   24cb2:	8c18      	ldrh	r0, [r3, #32]
   24cb4:	68fb      	ldr	r3, [r7, #12]
   24cb6:	88db      	ldrh	r3, [r3, #6]
   24cb8:	f107 0210 	add.w	r2, r7, #16
   24cbc:	4619      	mov	r1, r3
   24cbe:	f7ff fe53 	bl	24968 <sd_ble_gatts_value_set>
   24cc2:	62f8      	str	r0, [r7, #44]	; 0x2c

            hvx_len = actual_data_size + 1;
   24cc4:	79fb      	ldrb	r3, [r7, #7]
   24cc6:	b29b      	uxth	r3, r3
   24cc8:	3301      	adds	r3, #1
   24cca:	b29b      	uxth	r3, r3
   24ccc:	857b      	strh	r3, [r7, #42]	; 0x2a
            hvx_params.handle = p_uart->tx_handles.value_handle;
   24cce:	68fb      	ldr	r3, [r7, #12]
   24cd0:	88db      	ldrh	r3, [r3, #6]
   24cd2:	833b      	strh	r3, [r7, #24]
            hvx_params.type   = BLE_GATT_HVX_INDICATION;
   24cd4:	2302      	movs	r3, #2
   24cd6:	76bb      	strb	r3, [r7, #26]
            hvx_params.offset = 0;
   24cd8:	2300      	movs	r3, #0
   24cda:	83bb      	strh	r3, [r7, #28]
            hvx_params.p_len  = &hvx_len;
   24cdc:	f107 032a 	add.w	r3, r7, #42	; 0x2a
   24ce0:	623b      	str	r3, [r7, #32]
            hvx_params.p_data = ble_uart_tx_buffer;
   24ce2:	4b14      	ldr	r3, [pc, #80]	; (24d34 <_BleUartIndicateSendSinglePacket+0xdc>)
   24ce4:	627b      	str	r3, [r7, #36]	; 0x24

            _BleUartWaitTillPacketTxInProgress();
   24ce6:	f7ff ff83 	bl	24bf0 <_BleUartWaitTillPacketTxInProgress>
            /// Set the ble transmission flag high to indicate ongoing transmission
            ble_tx_packet_in_progress = true;
   24cea:	4b13      	ldr	r3, [pc, #76]	; (24d38 <_BleUartIndicateSendSinglePacket+0xe0>)
   24cec:	2201      	movs	r2, #1
   24cee:	701a      	strb	r2, [r3, #0]
            /// Send the data
            err_code = sd_ble_gatts_hvx(p_uart->conn_handle, &hvx_params);
   24cf0:	68fb      	ldr	r3, [r7, #12]
   24cf2:	8c1b      	ldrh	r3, [r3, #32]
   24cf4:	f107 0218 	add.w	r2, r7, #24
   24cf8:	4611      	mov	r1, r2
   24cfa:	4618      	mov	r0, r3
   24cfc:	f7ff fe38 	bl	24970 <sd_ble_gatts_hvx>
   24d00:	62f8      	str	r0, [r7, #44]	; 0x2c

            ble_uart_tx_data_size -= actual_data_size;
   24d02:	4b0e      	ldr	r3, [pc, #56]	; (24d3c <_BleUartIndicateSendSinglePacket+0xe4>)
   24d04:	881b      	ldrh	r3, [r3, #0]
   24d06:	b29a      	uxth	r2, r3
   24d08:	79fb      	ldrb	r3, [r7, #7]
   24d0a:	b29b      	uxth	r3, r3
   24d0c:	1ad3      	subs	r3, r2, r3
   24d0e:	b29a      	uxth	r2, r3
   24d10:	4b0a      	ldr	r3, [pc, #40]	; (24d3c <_BleUartIndicateSendSinglePacket+0xe4>)
   24d12:	801a      	strh	r2, [r3, #0]
            ble_current_data_ptr += actual_data_size;
   24d14:	4b0a      	ldr	r3, [pc, #40]	; (24d40 <_BleUartIndicateSendSinglePacket+0xe8>)
   24d16:	681a      	ldr	r2, [r3, #0]
   24d18:	79fb      	ldrb	r3, [r7, #7]
   24d1a:	4413      	add	r3, r2
   24d1c:	4a08      	ldr	r2, [pc, #32]	; (24d40 <_BleUartIndicateSendSinglePacket+0xe8>)
   24d1e:	6013      	str	r3, [r2, #0]

            return NRF_SUCCESS;
   24d20:	2300      	movs	r3, #0
   24d22:	e000      	b.n	24d26 <_BleUartIndicateSendSinglePacket+0xce>
        }

    return NRF_ERROR_INVALID_STATE;
   24d24:	2308      	movs	r3, #8
}
   24d26:	4618      	mov	r0, r3
   24d28:	3730      	adds	r7, #48	; 0x30
   24d2a:	46bd      	mov	sp, r7
   24d2c:	bd80      	pop	{r7, pc}
   24d2e:	bf00      	nop
   24d30:	20005241 	.word	0x20005241
   24d34:	20005240 	.word	0x20005240
   24d38:	2000523c 	.word	0x2000523c
   24d3c:	20005268 	.word	0x20005268
   24d40:	20005270 	.word	0x20005270

00024d44 <_BleUartIndicateSendNextPacket>:
 *
 *          \return NRF_SUCCESS - if the packet was successfully send
 *                  NRF_ERROR_INVALID_STATE - if the device is not in the BLE connection
 */
static uint32_t _BleUartIndicateSendNextPacket(ble_uart_t* p_uart)
{
   24d44:	b580      	push	{r7, lr}
   24d46:	b084      	sub	sp, #16
   24d48:	af00      	add	r7, sp, #0
   24d4a:	6078      	str	r0, [r7, #4]
    uint32_t err_code = 0;
   24d4c:	2300      	movs	r3, #0
   24d4e:	60fb      	str	r3, [r7, #12]
    if(ble_uart_tx_data_size > 19)
   24d50:	4b0e      	ldr	r3, [pc, #56]	; (24d8c <_BleUartIndicateSendNextPacket+0x48>)
   24d52:	881b      	ldrh	r3, [r3, #0]
   24d54:	b29b      	uxth	r3, r3
   24d56:	2b13      	cmp	r3, #19
   24d58:	d908      	bls.n	24d6c <_BleUartIndicateSendNextPacket+0x28>
        err_code = _BleUartIndicateSendSinglePacket(p_uart, ble_current_data_ptr, 19);
   24d5a:	4b0d      	ldr	r3, [pc, #52]	; (24d90 <_BleUartIndicateSendNextPacket+0x4c>)
   24d5c:	681b      	ldr	r3, [r3, #0]
   24d5e:	2213      	movs	r2, #19
   24d60:	4619      	mov	r1, r3
   24d62:	6878      	ldr	r0, [r7, #4]
   24d64:	f7ff ff78 	bl	24c58 <_BleUartIndicateSendSinglePacket>
   24d68:	60f8      	str	r0, [r7, #12]
   24d6a:	e00a      	b.n	24d82 <_BleUartIndicateSendNextPacket+0x3e>
    else
        err_code = _BleUartIndicateSendSinglePacket(p_uart, ble_current_data_ptr, ble_uart_tx_data_size);
   24d6c:	4b08      	ldr	r3, [pc, #32]	; (24d90 <_BleUartIndicateSendNextPacket+0x4c>)
   24d6e:	6819      	ldr	r1, [r3, #0]
   24d70:	4b06      	ldr	r3, [pc, #24]	; (24d8c <_BleUartIndicateSendNextPacket+0x48>)
   24d72:	881b      	ldrh	r3, [r3, #0]
   24d74:	b29b      	uxth	r3, r3
   24d76:	b2db      	uxtb	r3, r3
   24d78:	461a      	mov	r2, r3
   24d7a:	6878      	ldr	r0, [r7, #4]
   24d7c:	f7ff ff6c 	bl	24c58 <_BleUartIndicateSendSinglePacket>
   24d80:	60f8      	str	r0, [r7, #12]

    return err_code;
   24d82:	68fb      	ldr	r3, [r7, #12]
}
   24d84:	4618      	mov	r0, r3
   24d86:	3710      	adds	r7, #16
   24d88:	46bd      	mov	sp, r7
   24d8a:	bd80      	pop	{r7, pc}
   24d8c:	20005268 	.word	0x20005268
   24d90:	20005270 	.word	0x20005270

00024d94 <_BleUartNotifySendSinglePacket>:
 *  \param data - pointer to the data buffer
 *  \param data_size - size of data in the packet
 *
 */
static uint32_t _BleUartNotifySendSinglePacket(ble_uart_t* p_uart, uint8_t* data, uint8_t data_size)
{
   24d94:	b580      	push	{r7, lr}
   24d96:	b08c      	sub	sp, #48	; 0x30
   24d98:	af00      	add	r7, sp, #0
   24d9a:	60f8      	str	r0, [r7, #12]
   24d9c:	60b9      	str	r1, [r7, #8]
   24d9e:	4613      	mov	r3, r2
   24da0:	71fb      	strb	r3, [r7, #7]
    if(p_uart->conn_handle != BLE_CONN_HANDLE_INVALID)
   24da2:	68fb      	ldr	r3, [r7, #12]
   24da4:	8c1b      	ldrh	r3, [r3, #32]
   24da6:	f64f 72ff 	movw	r2, #65535	; 0xffff
   24daa:	4293      	cmp	r3, r2
   24dac:	d064      	beq.n	24e78 <_BleUartNotifySendSinglePacket+0xe4>
        {
            uint16_t                hvx_len;
            ble_gatts_hvx_params_t  hvx_params;
            ble_gatts_value_t       value_params;
            uint32_t                err_code = 0;
   24dae:	2300      	movs	r3, #0
   24db0:	62fb      	str	r3, [r7, #44]	; 0x2c

            memset(&hvx_params, 0, sizeof(hvx_params));
   24db2:	f107 0318 	add.w	r3, r7, #24
   24db6:	2210      	movs	r2, #16
   24db8:	2100      	movs	r1, #0
   24dba:	4618      	mov	r0, r3
   24dbc:	f7fe fc2e 	bl	2361c <memset>
            memset(&value_params,0,sizeof(value_params));
   24dc0:	f107 0310 	add.w	r3, r7, #16
   24dc4:	2208      	movs	r2, #8
   24dc6:	2100      	movs	r1, #0
   24dc8:	4618      	mov	r0, r3
   24dca:	f7fe fc27 	bl	2361c <memset>

            /// Copy the message to the buffer
            memcpy(ble_uart_tx_buffer+1, data, data_size);
   24dce:	482d      	ldr	r0, [pc, #180]	; (24e84 <_BleUartNotifySendSinglePacket+0xf0>)
   24dd0:	79fb      	ldrb	r3, [r7, #7]
   24dd2:	461a      	mov	r2, r3
   24dd4:	68b9      	ldr	r1, [r7, #8]
   24dd6:	f002 fd17 	bl	27808 <memcpy>

            //Fill structure with data size. This will avoid sending empty bytes when sending <20 bytes
            value_params.len = data_size + 1;
   24dda:	79fb      	ldrb	r3, [r7, #7]
   24ddc:	b29b      	uxth	r3, r3
   24dde:	3301      	adds	r3, #1
   24de0:	b29b      	uxth	r3, r3
   24de2:	823b      	strh	r3, [r7, #16]
            value_params.offset = 0;
   24de4:	2300      	movs	r3, #0
   24de6:	827b      	strh	r3, [r7, #18]
            value_params.p_value = NULL;
   24de8:	2300      	movs	r3, #0
   24dea:	617b      	str	r3, [r7, #20]

            err_code = sd_ble_gatts_value_set(p_uart->conn_handle, p_uart->dev_events_handles.value_handle, &value_params);
   24dec:	68fb      	ldr	r3, [r7, #12]
   24dee:	8c18      	ldrh	r0, [r3, #32]
   24df0:	68fb      	ldr	r3, [r7, #12]
   24df2:	8adb      	ldrh	r3, [r3, #22]
   24df4:	f107 0210 	add.w	r2, r7, #16
   24df8:	4619      	mov	r1, r3
   24dfa:	f7ff fdb5 	bl	24968 <sd_ble_gatts_value_set>
   24dfe:	62f8      	str	r0, [r7, #44]	; 0x2c

            hvx_len = data_size + 1;
   24e00:	79fb      	ldrb	r3, [r7, #7]
   24e02:	b29b      	uxth	r3, r3
   24e04:	3301      	adds	r3, #1
   24e06:	b29b      	uxth	r3, r3
   24e08:	857b      	strh	r3, [r7, #42]	; 0x2a
            hvx_params.handle = p_uart->dev_events_handles.value_handle;
   24e0a:	68fb      	ldr	r3, [r7, #12]
   24e0c:	8adb      	ldrh	r3, [r3, #22]
   24e0e:	833b      	strh	r3, [r7, #24]
            hvx_params.type   = BLE_GATT_HVX_NOTIFICATION;
   24e10:	2301      	movs	r3, #1
   24e12:	76bb      	strb	r3, [r7, #26]
            hvx_params.offset = 0;
   24e14:	2300      	movs	r3, #0
   24e16:	83bb      	strh	r3, [r7, #28]
            hvx_params.p_len  = &hvx_len;
   24e18:	f107 032a 	add.w	r3, r7, #42	; 0x2a
   24e1c:	623b      	str	r3, [r7, #32]
            hvx_params.p_data = ble_uart_tx_buffer;
   24e1e:	4b1a      	ldr	r3, [pc, #104]	; (24e88 <_BleUartNotifySendSinglePacket+0xf4>)
   24e20:	627b      	str	r3, [r7, #36]	; 0x24


            /// Set the ble transmission flag high to indicate ongoing transmission
            ble_notification_packet_in_progress = true;
   24e22:	4b1a      	ldr	r3, [pc, #104]	; (24e8c <_BleUartNotifySendSinglePacket+0xf8>)
   24e24:	2201      	movs	r2, #1
   24e26:	701a      	strb	r2, [r3, #0]
            /// Send the data
            err_code = sd_ble_gatts_hvx(p_uart->conn_handle, &hvx_params);
   24e28:	68fb      	ldr	r3, [r7, #12]
   24e2a:	8c1b      	ldrh	r3, [r3, #32]
   24e2c:	f107 0218 	add.w	r2, r7, #24
   24e30:	4611      	mov	r1, r2
   24e32:	4618      	mov	r0, r3
   24e34:	f7ff fd9c 	bl	24970 <sd_ble_gatts_hvx>
   24e38:	62f8      	str	r0, [r7, #44]	; 0x2c

            err_code = _BleUartNotifyWaitTillPacketInProgress();
   24e3a:	f7ff fee9 	bl	24c10 <_BleUartNotifyWaitTillPacketInProgress>
   24e3e:	62f8      	str	r0, [r7, #44]	; 0x2c
            /// If error occured, retransmit the packet
            if(err_code != NRF_SUCCESS)
   24e40:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   24e42:	2b00      	cmp	r3, #0
   24e44:	d007      	beq.n	24e56 <_BleUartNotifySendSinglePacket+0xc2>
            {
                sd_ble_gatts_hvx(p_uart->conn_handle, &hvx_params);
   24e46:	68fb      	ldr	r3, [r7, #12]
   24e48:	8c1b      	ldrh	r3, [r3, #32]
   24e4a:	f107 0218 	add.w	r2, r7, #24
   24e4e:	4611      	mov	r1, r2
   24e50:	4618      	mov	r0, r3
   24e52:	f7ff fd8d 	bl	24970 <sd_ble_gatts_hvx>
            }

            ble_uart_tx_data_size -= data_size;
   24e56:	4b0e      	ldr	r3, [pc, #56]	; (24e90 <_BleUartNotifySendSinglePacket+0xfc>)
   24e58:	881b      	ldrh	r3, [r3, #0]
   24e5a:	b29a      	uxth	r2, r3
   24e5c:	79fb      	ldrb	r3, [r7, #7]
   24e5e:	b29b      	uxth	r3, r3
   24e60:	1ad3      	subs	r3, r2, r3
   24e62:	b29a      	uxth	r2, r3
   24e64:	4b0a      	ldr	r3, [pc, #40]	; (24e90 <_BleUartNotifySendSinglePacket+0xfc>)
   24e66:	801a      	strh	r2, [r3, #0]
            ble_current_data_ptr += data_size;
   24e68:	4b0a      	ldr	r3, [pc, #40]	; (24e94 <_BleUartNotifySendSinglePacket+0x100>)
   24e6a:	681a      	ldr	r2, [r3, #0]
   24e6c:	79fb      	ldrb	r3, [r7, #7]
   24e6e:	4413      	add	r3, r2
   24e70:	4a08      	ldr	r2, [pc, #32]	; (24e94 <_BleUartNotifySendSinglePacket+0x100>)
   24e72:	6013      	str	r3, [r2, #0]

            return NRF_SUCCESS;
   24e74:	2300      	movs	r3, #0
   24e76:	e000      	b.n	24e7a <_BleUartNotifySendSinglePacket+0xe6>
        }

    return NRF_ERROR_INVALID_STATE;
   24e78:	2308      	movs	r3, #8
}
   24e7a:	4618      	mov	r0, r3
   24e7c:	3730      	adds	r7, #48	; 0x30
   24e7e:	46bd      	mov	sp, r7
   24e80:	bd80      	pop	{r7, pc}
   24e82:	bf00      	nop
   24e84:	20005241 	.word	0x20005241
   24e88:	20005240 	.word	0x20005240
   24e8c:	2000523d 	.word	0x2000523d
   24e90:	20005268 	.word	0x20005268
   24e94:	20005270 	.word	0x20005270

00024e98 <_BleUartNotifySendNextPacket>:
 *
 *          \return NRF_SUCCESS - if the packet was successfully send
 *                  NRF_ERROR_INVALID_STATE - if the device is not in the BLE connection
 */
static uint32_t _BleUartNotifySendNextPacket(ble_uart_t* p_uart)
{
   24e98:	b580      	push	{r7, lr}
   24e9a:	b084      	sub	sp, #16
   24e9c:	af00      	add	r7, sp, #0
   24e9e:	6078      	str	r0, [r7, #4]
    uint32_t err_code = 0;
   24ea0:	2300      	movs	r3, #0
   24ea2:	60fb      	str	r3, [r7, #12]
    if(ble_uart_tx_data_size > 19)
   24ea4:	4b0e      	ldr	r3, [pc, #56]	; (24ee0 <_BleUartNotifySendNextPacket+0x48>)
   24ea6:	881b      	ldrh	r3, [r3, #0]
   24ea8:	b29b      	uxth	r3, r3
   24eaa:	2b13      	cmp	r3, #19
   24eac:	d908      	bls.n	24ec0 <_BleUartNotifySendNextPacket+0x28>
        err_code = _BleUartNotifySendSinglePacket(p_uart, ble_current_data_ptr, 19);
   24eae:	4b0d      	ldr	r3, [pc, #52]	; (24ee4 <_BleUartNotifySendNextPacket+0x4c>)
   24eb0:	681b      	ldr	r3, [r3, #0]
   24eb2:	2213      	movs	r2, #19
   24eb4:	4619      	mov	r1, r3
   24eb6:	6878      	ldr	r0, [r7, #4]
   24eb8:	f7ff ff6c 	bl	24d94 <_BleUartNotifySendSinglePacket>
   24ebc:	60f8      	str	r0, [r7, #12]
   24ebe:	e00a      	b.n	24ed6 <_BleUartNotifySendNextPacket+0x3e>
    else
        err_code = _BleUartNotifySendSinglePacket(p_uart, ble_current_data_ptr, ble_uart_tx_data_size);
   24ec0:	4b08      	ldr	r3, [pc, #32]	; (24ee4 <_BleUartNotifySendNextPacket+0x4c>)
   24ec2:	6819      	ldr	r1, [r3, #0]
   24ec4:	4b06      	ldr	r3, [pc, #24]	; (24ee0 <_BleUartNotifySendNextPacket+0x48>)
   24ec6:	881b      	ldrh	r3, [r3, #0]
   24ec8:	b29b      	uxth	r3, r3
   24eca:	b2db      	uxtb	r3, r3
   24ecc:	461a      	mov	r2, r3
   24ece:	6878      	ldr	r0, [r7, #4]
   24ed0:	f7ff ff60 	bl	24d94 <_BleUartNotifySendSinglePacket>
   24ed4:	60f8      	str	r0, [r7, #12]

    return err_code;
   24ed6:	68fb      	ldr	r3, [r7, #12]
}
   24ed8:	4618      	mov	r0, r3
   24eda:	3710      	adds	r7, #16
   24edc:	46bd      	mov	sp, r7
   24ede:	bd80      	pop	{r7, pc}
   24ee0:	20005268 	.word	0x20005268
   24ee4:	20005270 	.word	0x20005270

00024ee8 <BleUartHandler>:

/**
 * \brief This is the Handler assigned to the BLE Uart Service. It should be attached in services_init function.
 */
void BleUartHandler(ble_uart_t * p_uart, ble_uart_evt_t * p_evt, ble_uart_data_t p_data, uint8_t data_size)
{
   24ee8:	b580      	push	{r7, lr}
   24eea:	b084      	sub	sp, #16
   24eec:	af00      	add	r7, sp, #0
   24eee:	60f8      	str	r0, [r7, #12]
   24ef0:	60b9      	str	r1, [r7, #8]
   24ef2:	607a      	str	r2, [r7, #4]
   24ef4:	70fb      	strb	r3, [r7, #3]
    switch (p_evt->evt_type)
   24ef6:	68bb      	ldr	r3, [r7, #8]
   24ef8:	781b      	ldrb	r3, [r3, #0]
   24efa:	2b06      	cmp	r3, #6
   24efc:	d84a      	bhi.n	24f94 <BleUartHandler+0xac>
   24efe:	a201      	add	r2, pc, #4	; (adr r2, 24f04 <BleUartHandler+0x1c>)
   24f00:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   24f04:	00024f95 	.word	0x00024f95
   24f08:	00024f95 	.word	0x00024f95
   24f0c:	00024f95 	.word	0x00024f95
   24f10:	00024f95 	.word	0x00024f95
   24f14:	00024f55 	.word	0x00024f55
   24f18:	00024f21 	.word	0x00024f21
   24f1c:	00024f89 	.word	0x00024f89
            break;

        case BLE_UART_EVT_INDICATION_CONFIRMED:
        {
           ///  Clear the flag to indicate that transmission has ended
           ble_tx_packet_in_progress = false;
   24f20:	4b1f      	ldr	r3, [pc, #124]	; (24fa0 <BleUartHandler+0xb8>)
   24f22:	2200      	movs	r2, #0
   24f24:	701a      	strb	r2, [r3, #0]
            /// If there is more data to be send, send next packet
           if(ble_uart_tx_data_size > 0)
   24f26:	4b1f      	ldr	r3, [pc, #124]	; (24fa4 <BleUartHandler+0xbc>)
   24f28:	881b      	ldrh	r3, [r3, #0]
   24f2a:	b29b      	uxth	r3, r3
   24f2c:	2b00      	cmp	r3, #0
   24f2e:	d003      	beq.n	24f38 <BleUartHandler+0x50>
               _BleUartIndicateSendNextPacket(p_uart);
   24f30:	68f8      	ldr	r0, [r7, #12]
   24f32:	f7ff ff07 	bl	24d44 <_BleUartIndicateSendNextPacket>
                   ///  Free the data resources
                   free(ble_data_ptr);
               }
               ble_tx_in_progress = false;
           }
            break;
   24f36:	e02e      	b.n	24f96 <BleUartHandler+0xae>
               if(ble_uart_data_dynamically_allocated)
   24f38:	4b1b      	ldr	r3, [pc, #108]	; (24fa8 <BleUartHandler+0xc0>)
   24f3a:	781b      	ldrb	r3, [r3, #0]
   24f3c:	b2db      	uxtb	r3, r3
   24f3e:	2b00      	cmp	r3, #0
   24f40:	d004      	beq.n	24f4c <BleUartHandler+0x64>
                   free(ble_data_ptr);
   24f42:	4b1a      	ldr	r3, [pc, #104]	; (24fac <BleUartHandler+0xc4>)
   24f44:	681b      	ldr	r3, [r3, #0]
   24f46:	4618      	mov	r0, r3
   24f48:	f002 fc56 	bl	277f8 <free>
               ble_tx_in_progress = false;
   24f4c:	4b18      	ldr	r3, [pc, #96]	; (24fb0 <BleUartHandler+0xc8>)
   24f4e:	2200      	movs	r2, #0
   24f50:	701a      	strb	r2, [r3, #0]
            break;
   24f52:	e020      	b.n	24f96 <BleUartHandler+0xae>
        case BLE_UART_EVT_NOTIFICATION_ENABLED:
            break;
        case BLE_UART_EVT_NOTIFICATION_TRANSMITTED:
        {
           ///  Clear the flag to indicate that transmission has ended
           ble_notification_packet_in_progress = false;
   24f54:	4b17      	ldr	r3, [pc, #92]	; (24fb4 <BleUartHandler+0xcc>)
   24f56:	2200      	movs	r2, #0
   24f58:	701a      	strb	r2, [r3, #0]
            /// If there is more data to be send, send next packet
            if(ble_uart_tx_data_size > 0)
   24f5a:	4b12      	ldr	r3, [pc, #72]	; (24fa4 <BleUartHandler+0xbc>)
   24f5c:	881b      	ldrh	r3, [r3, #0]
   24f5e:	b29b      	uxth	r3, r3
   24f60:	2b00      	cmp	r3, #0
   24f62:	d003      	beq.n	24f6c <BleUartHandler+0x84>
               _BleUartNotifySendNextPacket(p_uart);
   24f64:	68f8      	ldr	r0, [r7, #12]
   24f66:	f7ff ff97 	bl	24e98 <_BleUartNotifySendNextPacket>
                   ///  Free the data resources
                   free(ble_data_ptr);
               }
               ble_notification_in_progress = false;
            }
            break;
   24f6a:	e014      	b.n	24f96 <BleUartHandler+0xae>
               if(ble_uart_data_dynamically_allocated)
   24f6c:	4b0e      	ldr	r3, [pc, #56]	; (24fa8 <BleUartHandler+0xc0>)
   24f6e:	781b      	ldrb	r3, [r3, #0]
   24f70:	b2db      	uxtb	r3, r3
   24f72:	2b00      	cmp	r3, #0
   24f74:	d004      	beq.n	24f80 <BleUartHandler+0x98>
                   free(ble_data_ptr);
   24f76:	4b0d      	ldr	r3, [pc, #52]	; (24fac <BleUartHandler+0xc4>)
   24f78:	681b      	ldr	r3, [r3, #0]
   24f7a:	4618      	mov	r0, r3
   24f7c:	f002 fc3c 	bl	277f8 <free>
               ble_notification_in_progress = false;
   24f80:	4b0d      	ldr	r3, [pc, #52]	; (24fb8 <BleUartHandler+0xd0>)
   24f82:	2200      	movs	r2, #0
   24f84:	701a      	strb	r2, [r3, #0]
            break;
   24f86:	e006      	b.n	24f96 <BleUartHandler+0xae>
        }
        case BLE_UART_EVT_RX_DATA_RECEIVED:
            _BleUartRxHandler(p_data, data_size);
   24f88:	78fb      	ldrb	r3, [r7, #3]
   24f8a:	4619      	mov	r1, r3
   24f8c:	6878      	ldr	r0, [r7, #4]
   24f8e:	f7ff fe4f 	bl	24c30 <_BleUartRxHandler>
            break;
   24f92:	e000      	b.n	24f96 <BleUartHandler+0xae>
        default:
            // No implementation needed.
            break;
   24f94:	bf00      	nop
    }
}
   24f96:	bf00      	nop
   24f98:	3710      	adds	r7, #16
   24f9a:	46bd      	mov	sp, r7
   24f9c:	bd80      	pop	{r7, pc}
   24f9e:	bf00      	nop
   24fa0:	2000523c 	.word	0x2000523c
   24fa4:	20005268 	.word	0x20005268
   24fa8:	20005274 	.word	0x20005274
   24fac:	2000526c 	.word	0x2000526c
   24fb0:	20005385 	.word	0x20005385
   24fb4:	2000523d 	.word	0x2000523d
   24fb8:	20005384 	.word	0x20005384

00024fbc <UartTxCharAdd>:
 * @param[in]   p_uart_init   Information needed to initialize the service.
 *
 * @return      NRF_SUCCESS on success, otherwise an error code.
 */
static uint32_t UartTxCharAdd(ble_uart_t * p_uart, const ble_uart_init_t * p_uart_init)
{
   24fbc:	b580      	push	{r7, lr}
   24fbe:	b090      	sub	sp, #64	; 0x40
   24fc0:	af00      	add	r7, sp, #0
   24fc2:	6078      	str	r0, [r7, #4]
   24fc4:	6039      	str	r1, [r7, #0]
    ble_gatts_attr_t    attr_char_value;
    ble_uuid_t          ble_uuid;
    ble_gatts_attr_md_t attr_md;

    // Clear char_md structure
    memset(&char_md, 0, sizeof(char_md));
   24fc6:	f107 0324 	add.w	r3, r7, #36	; 0x24
   24fca:	221c      	movs	r2, #28
   24fcc:	2100      	movs	r1, #0
   24fce:	4618      	mov	r0, r3
   24fd0:	f7fe fb24 	bl	2361c <memset>

        //  Set indicate avaliability
    char_md.char_props.indicate  = 1;
   24fd4:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   24fd8:	f043 0320 	orr.w	r3, r3, #32
   24fdc:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
        //  Setup descriptor
#ifdef LIGHT_CHARACTERISTICS
    char_md.p_char_user_desc = NULL;
#else
    // Human-friendly descriptor to debug
    char_md.p_char_user_desc = (uint8_t*)"Tx";
   24fe0:	4b31      	ldr	r3, [pc, #196]	; (250a8 <UartTxCharAdd+0xec>)
   24fe2:	62bb      	str	r3, [r7, #40]	; 0x28
    char_md.char_user_desc_size = 2;
   24fe4:	2302      	movs	r3, #2
   24fe6:	85fb      	strh	r3, [r7, #46]	; 0x2e
    char_md.char_user_desc_max_size = 20;
   24fe8:	2314      	movs	r3, #20
   24fea:	85bb      	strh	r3, [r7, #44]	; 0x2c
#endif
    char_md.p_char_pf        = NULL;
   24fec:	2300      	movs	r3, #0
   24fee:	633b      	str	r3, [r7, #48]	; 0x30
    char_md.p_user_desc_md   = NULL;
   24ff0:	2300      	movs	r3, #0
   24ff2:	637b      	str	r3, [r7, #52]	; 0x34
    char_md.p_cccd_md        = NULL;
   24ff4:	2300      	movs	r3, #0
   24ff6:	63bb      	str	r3, [r7, #56]	; 0x38
    char_md.p_sccd_md        = NULL;
   24ff8:	2300      	movs	r3, #0
   24ffa:	63fb      	str	r3, [r7, #60]	; 0x3c

    //  Inform the characteristic that it will have a custom vendor UUID
    ble_uuid.type = p_uart->uuid_type;
   24ffc:	687b      	ldr	r3, [r7, #4]
   24ffe:	7f9b      	ldrb	r3, [r3, #30]
   25000:	73bb      	strb	r3, [r7, #14]
    //  Set the 16-bit UUID for the characteristic
    ble_uuid.uuid = TX_CHAR_UUID;
   25002:	2303      	movs	r3, #3
   25004:	81bb      	strh	r3, [r7, #12]

    memset(&attr_md, 0, sizeof(attr_md));
   25006:	f107 0308 	add.w	r3, r7, #8
   2500a:	2203      	movs	r2, #3
   2500c:	2100      	movs	r1, #0
   2500e:	4618      	mov	r0, r3
   25010:	f7fe fb04 	bl	2361c <memset>

    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attr_md.read_perm);
   25014:	7a3b      	ldrb	r3, [r7, #8]
   25016:	2201      	movs	r2, #1
   25018:	f362 0303 	bfi	r3, r2, #0, #4
   2501c:	723b      	strb	r3, [r7, #8]
   2501e:	7a3b      	ldrb	r3, [r7, #8]
   25020:	2201      	movs	r2, #1
   25022:	f362 1307 	bfi	r3, r2, #4, #4
   25026:	723b      	strb	r3, [r7, #8]
    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attr_md.write_perm);
   25028:	7a7b      	ldrb	r3, [r7, #9]
   2502a:	2201      	movs	r2, #1
   2502c:	f362 0303 	bfi	r3, r2, #0, #4
   25030:	727b      	strb	r3, [r7, #9]
   25032:	7a7b      	ldrb	r3, [r7, #9]
   25034:	2201      	movs	r2, #1
   25036:	f362 1307 	bfi	r3, r2, #4, #4
   2503a:	727b      	strb	r3, [r7, #9]
    attr_md.vloc       = BLE_GATTS_VLOC_USER;
   2503c:	7abb      	ldrb	r3, [r7, #10]
   2503e:	2202      	movs	r2, #2
   25040:	f362 0342 	bfi	r3, r2, #1, #2
   25044:	72bb      	strb	r3, [r7, #10]
    attr_md.rd_auth    = 0;
   25046:	7abb      	ldrb	r3, [r7, #10]
   25048:	f36f 03c3 	bfc	r3, #3, #1
   2504c:	72bb      	strb	r3, [r7, #10]
    attr_md.wr_auth    = 0;
   2504e:	7abb      	ldrb	r3, [r7, #10]
   25050:	f36f 1304 	bfc	r3, #4, #1
   25054:	72bb      	strb	r3, [r7, #10]
    attr_md.vlen       = 1;
   25056:	7abb      	ldrb	r3, [r7, #10]
   25058:	f043 0301 	orr.w	r3, r3, #1
   2505c:	72bb      	strb	r3, [r7, #10]

    memset(&attr_char_value, 0, sizeof(attr_char_value));
   2505e:	f107 0310 	add.w	r3, r7, #16
   25062:	2214      	movs	r2, #20
   25064:	2100      	movs	r1, #0
   25066:	4618      	mov	r0, r3
   25068:	f7fe fad8 	bl	2361c <memset>

    attr_char_value.p_uuid       = &ble_uuid;
   2506c:	f107 030c 	add.w	r3, r7, #12
   25070:	613b      	str	r3, [r7, #16]
    attr_char_value.p_attr_md    = &attr_md;
   25072:	f107 0308 	add.w	r3, r7, #8
   25076:	617b      	str	r3, [r7, #20]
    attr_char_value.init_len     = sizeof(ble_uart_tx_buffer);
   25078:	2314      	movs	r3, #20
   2507a:	833b      	strh	r3, [r7, #24]
    attr_char_value.init_offs    = 0;
   2507c:	2300      	movs	r3, #0
   2507e:	837b      	strh	r3, [r7, #26]
    attr_char_value.max_len      = sizeof(ble_uart_tx_buffer);
   25080:	2314      	movs	r3, #20
   25082:	83bb      	strh	r3, [r7, #28]
    attr_char_value.p_value      = ble_uart_tx_buffer;
   25084:	4b09      	ldr	r3, [pc, #36]	; (250ac <UartTxCharAdd+0xf0>)
   25086:	623b      	str	r3, [r7, #32]


    return sd_ble_gatts_characteristic_add(p_uart->service_handle,
   25088:	687b      	ldr	r3, [r7, #4]
   2508a:	8898      	ldrh	r0, [r3, #4]
   2508c:	687b      	ldr	r3, [r7, #4]
   2508e:	3306      	adds	r3, #6
   25090:	f107 0210 	add.w	r2, r7, #16
   25094:	f107 0124 	add.w	r1, r7, #36	; 0x24
   25098:	f7ff fc62 	bl	24960 <sd_ble_gatts_characteristic_add>
   2509c:	4603      	mov	r3, r0
                                           &char_md,
                                           &attr_char_value,
                                           &p_uart->tx_handles);
}
   2509e:	4618      	mov	r0, r3
   250a0:	3740      	adds	r7, #64	; 0x40
   250a2:	46bd      	mov	sp, r7
   250a4:	bd80      	pop	{r7, pc}
   250a6:	bf00      	nop
   250a8:	00027a60 	.word	0x00027a60
   250ac:	20005240 	.word	0x20005240

000250b0 <UartRxCharAdd>:
 * @param[in]   p_uart_init   Information needed to initialize the service.
 *
 * @return      NRF_SUCCESS on success, otherwise an error code.
 */
static uint32_t UartRxCharAdd(ble_uart_t * p_uart, const ble_uart_init_t * p_uart_init)
{
   250b0:	b580      	push	{r7, lr}
   250b2:	b090      	sub	sp, #64	; 0x40
   250b4:	af00      	add	r7, sp, #0
   250b6:	6078      	str	r0, [r7, #4]
   250b8:	6039      	str	r1, [r7, #0]
    ble_gatts_attr_t    attr_char_value;
    ble_uuid_t          ble_uuid;
    ble_gatts_attr_md_t attr_md;

        // clear the fields of char_md structure
    memset(&char_md, 0, sizeof(char_md));
   250ba:	f107 0324 	add.w	r3, r7, #36	; 0x24
   250be:	221c      	movs	r2, #28
   250c0:	2100      	movs	r1, #0
   250c2:	4618      	mov	r0, r3
   250c4:	f7fe faaa 	bl	2361c <memset>

    //  Set the read availability
    char_md.char_props.write    = 1;
   250c8:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   250cc:	f043 0308 	orr.w	r3, r3, #8
   250d0:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24


    char_md.p_char_user_desc  = NULL;
   250d4:	2300      	movs	r3, #0
   250d6:	62bb      	str	r3, [r7, #40]	; 0x28
    char_md.char_user_desc_max_size = 20;
   250d8:	2314      	movs	r3, #20
   250da:	85bb      	strh	r3, [r7, #44]	; 0x2c
    char_md.char_user_desc_size = 0;
   250dc:	2300      	movs	r3, #0
   250de:	85fb      	strh	r3, [r7, #46]	; 0x2e
    char_md.p_char_pf         = NULL;
   250e0:	2300      	movs	r3, #0
   250e2:	633b      	str	r3, [r7, #48]	; 0x30
    char_md.p_user_desc_md    = NULL;
   250e4:	2300      	movs	r3, #0
   250e6:	637b      	str	r3, [r7, #52]	; 0x34
    char_md.p_cccd_md         = NULL;
   250e8:	2300      	movs	r3, #0
   250ea:	63bb      	str	r3, [r7, #56]	; 0x38
    char_md.p_sccd_md         = NULL;
   250ec:	2300      	movs	r3, #0
   250ee:	63fb      	str	r3, [r7, #60]	; 0x3c

    //  Inform the characteristic that it will have a custom vendor UUID
    ble_uuid.type = p_uart->uuid_type;
   250f0:	687b      	ldr	r3, [r7, #4]
   250f2:	7f9b      	ldrb	r3, [r3, #30]
   250f4:	73bb      	strb	r3, [r7, #14]
    //  Set the 16-bit UUID for the characteristic
    ble_uuid.uuid = RX_CHAR_UUID;
   250f6:	2302      	movs	r3, #2
   250f8:	81bb      	strh	r3, [r7, #12]

    memset(&attr_md, 0, sizeof(attr_md));
   250fa:	f107 0308 	add.w	r3, r7, #8
   250fe:	2203      	movs	r2, #3
   25100:	2100      	movs	r1, #0
   25102:	4618      	mov	r0, r3
   25104:	f7fe fa8a 	bl	2361c <memset>

    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attr_md.read_perm);
   25108:	7a3b      	ldrb	r3, [r7, #8]
   2510a:	2201      	movs	r2, #1
   2510c:	f362 0303 	bfi	r3, r2, #0, #4
   25110:	723b      	strb	r3, [r7, #8]
   25112:	7a3b      	ldrb	r3, [r7, #8]
   25114:	2201      	movs	r2, #1
   25116:	f362 1307 	bfi	r3, r2, #4, #4
   2511a:	723b      	strb	r3, [r7, #8]
    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attr_md.write_perm);
   2511c:	7a7b      	ldrb	r3, [r7, #9]
   2511e:	2201      	movs	r2, #1
   25120:	f362 0303 	bfi	r3, r2, #0, #4
   25124:	727b      	strb	r3, [r7, #9]
   25126:	7a7b      	ldrb	r3, [r7, #9]
   25128:	2201      	movs	r2, #1
   2512a:	f362 1307 	bfi	r3, r2, #4, #4
   2512e:	727b      	strb	r3, [r7, #9]
    attr_md.vloc       = BLE_GATTS_VLOC_USER;
   25130:	7abb      	ldrb	r3, [r7, #10]
   25132:	2202      	movs	r2, #2
   25134:	f362 0342 	bfi	r3, r2, #1, #2
   25138:	72bb      	strb	r3, [r7, #10]
    attr_md.rd_auth    = 0;
   2513a:	7abb      	ldrb	r3, [r7, #10]
   2513c:	f36f 03c3 	bfc	r3, #3, #1
   25140:	72bb      	strb	r3, [r7, #10]
    attr_md.wr_auth    = 0;
   25142:	7abb      	ldrb	r3, [r7, #10]
   25144:	f36f 1304 	bfc	r3, #4, #1
   25148:	72bb      	strb	r3, [r7, #10]
    attr_md.vlen       = 0;
   2514a:	7abb      	ldrb	r3, [r7, #10]
   2514c:	f36f 0300 	bfc	r3, #0, #1
   25150:	72bb      	strb	r3, [r7, #10]

    memset(&attr_char_value, 0, sizeof(attr_char_value));
   25152:	f107 0310 	add.w	r3, r7, #16
   25156:	2214      	movs	r2, #20
   25158:	2100      	movs	r1, #0
   2515a:	4618      	mov	r0, r3
   2515c:	f7fe fa5e 	bl	2361c <memset>

    attr_char_value.p_uuid    = &ble_uuid;
   25160:	f107 030c 	add.w	r3, r7, #12
   25164:	613b      	str	r3, [r7, #16]
    attr_char_value.p_attr_md = &attr_md;
   25166:	f107 0308 	add.w	r3, r7, #8
   2516a:	617b      	str	r3, [r7, #20]
    attr_char_value.init_len  = sizeof(ble_uart_rx_buffer);
   2516c:	2314      	movs	r3, #20
   2516e:	833b      	strh	r3, [r7, #24]
    attr_char_value.init_offs = 0;
   25170:	2300      	movs	r3, #0
   25172:	837b      	strh	r3, [r7, #26]
    attr_char_value.max_len   = sizeof(ble_uart_rx_buffer);
   25174:	2314      	movs	r3, #20
   25176:	83bb      	strh	r3, [r7, #28]
    attr_char_value.p_value   = ble_uart_rx_buffer;
   25178:	4b08      	ldr	r3, [pc, #32]	; (2519c <UartRxCharAdd+0xec>)
   2517a:	623b      	str	r3, [r7, #32]

    return sd_ble_gatts_characteristic_add(p_uart->service_handle, &char_md,
   2517c:	687b      	ldr	r3, [r7, #4]
   2517e:	8898      	ldrh	r0, [r3, #4]
   25180:	687b      	ldr	r3, [r7, #4]
   25182:	330e      	adds	r3, #14
   25184:	f107 0210 	add.w	r2, r7, #16
   25188:	f107 0124 	add.w	r1, r7, #36	; 0x24
   2518c:	f7ff fbe8 	bl	24960 <sd_ble_gatts_characteristic_add>
   25190:	4603      	mov	r3, r0
                                               &attr_char_value,
                                               &p_uart->rx_handles);
}
   25192:	4618      	mov	r0, r3
   25194:	3740      	adds	r7, #64	; 0x40
   25196:	46bd      	mov	sp, r7
   25198:	bd80      	pop	{r7, pc}
   2519a:	bf00      	nop
   2519c:	20005254 	.word	0x20005254

000251a0 <UartDeviceEventsCharAdd>:
 * @param[in]   p_uart_init   Information needed to initialize the service.
 *
 * @return      NRF_SUCCESS on success, otherwise an error code.
 */
static uint32_t UartDeviceEventsCharAdd(ble_uart_t * p_uart, const ble_uart_init_t * p_uart_init)
{
   251a0:	b580      	push	{r7, lr}
   251a2:	b090      	sub	sp, #64	; 0x40
   251a4:	af00      	add	r7, sp, #0
   251a6:	6078      	str	r0, [r7, #4]
   251a8:	6039      	str	r1, [r7, #0]
    ble_gatts_attr_t    attr_char_value;
    ble_uuid_t          ble_uuid;
    ble_gatts_attr_md_t attr_md;

    // Clear char_md structure
    memset(&char_md, 0, sizeof(char_md));
   251aa:	f107 0324 	add.w	r3, r7, #36	; 0x24
   251ae:	221c      	movs	r2, #28
   251b0:	2100      	movs	r1, #0
   251b2:	4618      	mov	r0, r3
   251b4:	f7fe fa32 	bl	2361c <memset>

        //  Set indicate avaliability
    char_md.char_props.notify  = 1;
   251b8:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   251bc:	f043 0310 	orr.w	r3, r3, #16
   251c0:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
        //  Setup descriptor
#ifdef LIGHT_CHARACTERISTICS
    char_md.p_char_user_desc = NULL;
#else
    // Human-friendly descriptor to debug
    char_md.p_char_user_desc = (uint8_t*)"Events";
   251c4:	4b31      	ldr	r3, [pc, #196]	; (2528c <UartDeviceEventsCharAdd+0xec>)
   251c6:	62bb      	str	r3, [r7, #40]	; 0x28
    char_md.char_user_desc_size = sizeof("Events");
   251c8:	2307      	movs	r3, #7
   251ca:	85fb      	strh	r3, [r7, #46]	; 0x2e
    char_md.char_user_desc_max_size = 20;
   251cc:	2314      	movs	r3, #20
   251ce:	85bb      	strh	r3, [r7, #44]	; 0x2c
#endif
    char_md.p_char_pf        = NULL;
   251d0:	2300      	movs	r3, #0
   251d2:	633b      	str	r3, [r7, #48]	; 0x30
    char_md.p_user_desc_md   = NULL;
   251d4:	2300      	movs	r3, #0
   251d6:	637b      	str	r3, [r7, #52]	; 0x34
    char_md.p_cccd_md        = NULL;
   251d8:	2300      	movs	r3, #0
   251da:	63bb      	str	r3, [r7, #56]	; 0x38
    char_md.p_sccd_md        = NULL;
   251dc:	2300      	movs	r3, #0
   251de:	63fb      	str	r3, [r7, #60]	; 0x3c

    //  Inform the characteristic that it will have a custom vendor UUID
    ble_uuid.type = p_uart->uuid_type;
   251e0:	687b      	ldr	r3, [r7, #4]
   251e2:	7f9b      	ldrb	r3, [r3, #30]
   251e4:	73bb      	strb	r3, [r7, #14]
    //  Set the 16-bit UUID for the characteristic
    ble_uuid.uuid = DEV_EVENTS_UUID;
   251e6:	2304      	movs	r3, #4
   251e8:	81bb      	strh	r3, [r7, #12]

    memset(&attr_md, 0, sizeof(attr_md));
   251ea:	f107 0308 	add.w	r3, r7, #8
   251ee:	2203      	movs	r2, #3
   251f0:	2100      	movs	r1, #0
   251f2:	4618      	mov	r0, r3
   251f4:	f7fe fa12 	bl	2361c <memset>

    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attr_md.read_perm);
   251f8:	7a3b      	ldrb	r3, [r7, #8]
   251fa:	2201      	movs	r2, #1
   251fc:	f362 0303 	bfi	r3, r2, #0, #4
   25200:	723b      	strb	r3, [r7, #8]
   25202:	7a3b      	ldrb	r3, [r7, #8]
   25204:	2201      	movs	r2, #1
   25206:	f362 1307 	bfi	r3, r2, #4, #4
   2520a:	723b      	strb	r3, [r7, #8]
    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attr_md.write_perm);
   2520c:	7a7b      	ldrb	r3, [r7, #9]
   2520e:	2201      	movs	r2, #1
   25210:	f362 0303 	bfi	r3, r2, #0, #4
   25214:	727b      	strb	r3, [r7, #9]
   25216:	7a7b      	ldrb	r3, [r7, #9]
   25218:	2201      	movs	r2, #1
   2521a:	f362 1307 	bfi	r3, r2, #4, #4
   2521e:	727b      	strb	r3, [r7, #9]
    attr_md.vloc       = BLE_GATTS_VLOC_USER;                   /*< Set the characteristics buffer on the user's side of RAM **/
   25220:	7abb      	ldrb	r3, [r7, #10]
   25222:	2202      	movs	r2, #2
   25224:	f362 0342 	bfi	r3, r2, #1, #2
   25228:	72bb      	strb	r3, [r7, #10]
    attr_md.rd_auth    = 0;                                     /*< Read authentication */
   2522a:	7abb      	ldrb	r3, [r7, #10]
   2522c:	f36f 03c3 	bfc	r3, #3, #1
   25230:	72bb      	strb	r3, [r7, #10]
    attr_md.wr_auth    = 0;
   25232:	7abb      	ldrb	r3, [r7, #10]
   25234:	f36f 1304 	bfc	r3, #4, #1
   25238:	72bb      	strb	r3, [r7, #10]
    attr_md.vlen       = 1;                                     /*< Various length **/
   2523a:	7abb      	ldrb	r3, [r7, #10]
   2523c:	f043 0301 	orr.w	r3, r3, #1
   25240:	72bb      	strb	r3, [r7, #10]

    memset(&attr_char_value, 0, sizeof(attr_char_value));
   25242:	f107 0310 	add.w	r3, r7, #16
   25246:	2214      	movs	r2, #20
   25248:	2100      	movs	r1, #0
   2524a:	4618      	mov	r0, r3
   2524c:	f7fe f9e6 	bl	2361c <memset>

    attr_char_value.p_uuid       = &ble_uuid;
   25250:	f107 030c 	add.w	r3, r7, #12
   25254:	613b      	str	r3, [r7, #16]
    attr_char_value.p_attr_md    = &attr_md;
   25256:	f107 0308 	add.w	r3, r7, #8
   2525a:	617b      	str	r3, [r7, #20]
    attr_char_value.init_len     = 20;
   2525c:	2314      	movs	r3, #20
   2525e:	833b      	strh	r3, [r7, #24]
    attr_char_value.init_offs    = 0;
   25260:	2300      	movs	r3, #0
   25262:	837b      	strh	r3, [r7, #26]
    attr_char_value.max_len      = 20;
   25264:	2314      	movs	r3, #20
   25266:	83bb      	strh	r3, [r7, #28]
    attr_char_value.p_value      = ble_uart_tx_buffer;
   25268:	4b09      	ldr	r3, [pc, #36]	; (25290 <UartDeviceEventsCharAdd+0xf0>)
   2526a:	623b      	str	r3, [r7, #32]


    return sd_ble_gatts_characteristic_add(p_uart->service_handle,
   2526c:	687b      	ldr	r3, [r7, #4]
   2526e:	8898      	ldrh	r0, [r3, #4]
   25270:	687b      	ldr	r3, [r7, #4]
   25272:	3316      	adds	r3, #22
   25274:	f107 0210 	add.w	r2, r7, #16
   25278:	f107 0124 	add.w	r1, r7, #36	; 0x24
   2527c:	f7ff fb70 	bl	24960 <sd_ble_gatts_characteristic_add>
   25280:	4603      	mov	r3, r0
                                           &char_md,
                                           &attr_char_value,
                                           &p_uart->dev_events_handles);
}
   25282:	4618      	mov	r0, r3
   25284:	3740      	adds	r7, #64	; 0x40
   25286:	46bd      	mov	sp, r7
   25288:	bd80      	pop	{r7, pc}
   2528a:	bf00      	nop
   2528c:	00027a64 	.word	0x00027a64
   25290:	20005240 	.word	0x20005240

00025294 <BleUartServiceInit>:
 * @param[in]   p_uart_init  Information needed to initialize the service.
 *
 * @return      NRF_SUCCESS on successful initialization of service, otherwise an error code.
 */
uint32_t BleUartServiceInit(ble_uart_t * p_uart, const ble_uart_init_t * p_uart_init)
{
   25294:	b590      	push	{r4, r7, lr}
   25296:	b089      	sub	sp, #36	; 0x24
   25298:	af00      	add	r7, sp, #0
   2529a:	6078      	str	r0, [r7, #4]
   2529c:	6039      	str	r1, [r7, #0]
    uint32_t   err_code;
    ble_uuid128_t base_uuid = SECUCAR_UUID_BASE;
   2529e:	4b2c      	ldr	r3, [pc, #176]	; (25350 <BleUartServiceInit+0xbc>)
   252a0:	f107 040c 	add.w	r4, r7, #12
   252a4:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
   252a6:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

    /// Initialize the fifo for arguments
//    Fifo_Init(&ble_uart_argument_fifo, ble_uart_arg_buffer, sizeof(ble_uart_arg_buffer));

    // Initialize service structure
    p_uart->evt_handler = p_uart_init->evt_handler;
   252aa:	683b      	ldr	r3, [r7, #0]
   252ac:	681a      	ldr	r2, [r3, #0]
   252ae:	687b      	ldr	r3, [r7, #4]
   252b0:	601a      	str	r2, [r3, #0]
    p_uart->conn_handle = BLE_CONN_HANDLE_INVALID;
   252b2:	687b      	ldr	r3, [r7, #4]
   252b4:	f64f 72ff 	movw	r2, #65535	; 0xffff
   252b8:	841a      	strh	r2, [r3, #32]

    // Assign base UUID
    err_code = sd_ble_uuid_vs_add(&base_uuid, &(p_uart->uuid_type));
   252ba:	687b      	ldr	r3, [r7, #4]
   252bc:	f103 021e 	add.w	r2, r3, #30
   252c0:	f107 030c 	add.w	r3, r7, #12
   252c4:	4611      	mov	r1, r2
   252c6:	4618      	mov	r0, r3
   252c8:	f7ff fb56 	bl	24978 <sd_ble_uuid_vs_add>
   252cc:	61f8      	str	r0, [r7, #28]
    if(err_code != NRF_SUCCESS)
   252ce:	69fb      	ldr	r3, [r7, #28]
   252d0:	2b00      	cmp	r3, #0
   252d2:	d001      	beq.n	252d8 <BleUartServiceInit+0x44>
    {
            return err_code;
   252d4:	69fb      	ldr	r3, [r7, #28]
   252d6:	e036      	b.n	25346 <BleUartServiceInit+0xb2>
    }


    ble_uuid_t ble_uuid;
    //  Set the vendor specific UUID to the newly created service (?)
    ble_uuid.type = p_uart->uuid_type;
   252d8:	687b      	ldr	r3, [r7, #4]
   252da:	7f9b      	ldrb	r3, [r3, #30]
   252dc:	72bb      	strb	r3, [r7, #10]
    //  Set the 16-bit UUID
    ble_uuid.uuid = BLE_UART_SERVICE_UUID;
   252de:	2301      	movs	r3, #1
   252e0:	813b      	strh	r3, [r7, #8]
    //  Add the service and create a service_handle to it
    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &(p_uart->service_handle));
   252e2:	687b      	ldr	r3, [r7, #4]
   252e4:	1d1a      	adds	r2, r3, #4
   252e6:	f107 0308 	add.w	r3, r7, #8
   252ea:	4619      	mov	r1, r3
   252ec:	2001      	movs	r0, #1
   252ee:	f7ff fb33 	bl	24958 <sd_ble_gatts_service_add>
   252f2:	61f8      	str	r0, [r7, #28]
    if(err_code != NRF_SUCCESS)
   252f4:	69fb      	ldr	r3, [r7, #28]
   252f6:	2b00      	cmp	r3, #0
   252f8:	d001      	beq.n	252fe <BleUartServiceInit+0x6a>
    {
        return err_code;
   252fa:	69fb      	ldr	r3, [r7, #28]
   252fc:	e023      	b.n	25346 <BleUartServiceInit+0xb2>
    }

    // Add measurement characteristic
    err_code = UartRxCharAdd(p_uart, p_uart_init);
   252fe:	6839      	ldr	r1, [r7, #0]
   25300:	6878      	ldr	r0, [r7, #4]
   25302:	f7ff fed5 	bl	250b0 <UartRxCharAdd>
   25306:	61f8      	str	r0, [r7, #28]
    if (err_code != NRF_SUCCESS)
   25308:	69fb      	ldr	r3, [r7, #28]
   2530a:	2b00      	cmp	r3, #0
   2530c:	d001      	beq.n	25312 <BleUartServiceInit+0x7e>
    {
        return err_code;
   2530e:	69fb      	ldr	r3, [r7, #28]
   25310:	e019      	b.n	25346 <BleUartServiceInit+0xb2>
    }

    // Add feature characteristic
    err_code = UartTxCharAdd(p_uart, p_uart_init);
   25312:	6839      	ldr	r1, [r7, #0]
   25314:	6878      	ldr	r0, [r7, #4]
   25316:	f7ff fe51 	bl	24fbc <UartTxCharAdd>
   2531a:	61f8      	str	r0, [r7, #28]
    if (err_code != NRF_SUCCESS)
   2531c:	69fb      	ldr	r3, [r7, #28]
   2531e:	2b00      	cmp	r3, #0
   25320:	d001      	beq.n	25326 <BleUartServiceInit+0x92>
    {
        return err_code;
   25322:	69fb      	ldr	r3, [r7, #28]
   25324:	e00f      	b.n	25346 <BleUartServiceInit+0xb2>
    }

    err_code = UartDeviceEventsCharAdd(p_uart, p_uart_init);
   25326:	6839      	ldr	r1, [r7, #0]
   25328:	6878      	ldr	r0, [r7, #4]
   2532a:	f7ff ff39 	bl	251a0 <UartDeviceEventsCharAdd>
   2532e:	61f8      	str	r0, [r7, #28]
    if (err_code != NRF_SUCCESS)
   25330:	69fb      	ldr	r3, [r7, #28]
   25332:	2b00      	cmp	r3, #0
   25334:	d001      	beq.n	2533a <BleUartServiceInit+0xa6>
    {
        return err_code;
   25336:	69fb      	ldr	r3, [r7, #28]
   25338:	e005      	b.n	25346 <BleUartServiceInit+0xb2>
    }

    FifoInit(&ble_uart_pending_requests_fifo, ble_uart_pending_requests_fifo_buffer, sizeof(ble_uart_pending_requests_fifo_buffer));
   2533a:	2210      	movs	r2, #16
   2533c:	4905      	ldr	r1, [pc, #20]	; (25354 <BleUartServiceInit+0xc0>)
   2533e:	4806      	ldr	r0, [pc, #24]	; (25358 <BleUartServiceInit+0xc4>)
   25340:	f7fe fd4e 	bl	23de0 <FifoInit>
    return NRF_SUCCESS;
   25344:	2300      	movs	r3, #0
}
   25346:	4618      	mov	r0, r3
   25348:	3724      	adds	r7, #36	; 0x24
   2534a:	46bd      	mov	sp, r7
   2534c:	bd90      	pop	{r4, r7, pc}
   2534e:	bf00      	nop
   25350:	00027a6c 	.word	0x00027a6c
   25354:	20005288 	.word	0x20005288
   25358:	20005278 	.word	0x20005278

0002535c <sd_ble_gap_addr_get>:
SVCALL(SD_BLE_GAP_ADDR_GET, uint32_t, sd_ble_gap_addr_get(ble_gap_addr_t *p_addr));
   2535c:	df6d      	svc	109	; 0x6d
   2535e:	4770      	bx	lr
   25360:	bf00      	nop
   25362:	4618      	mov	r0, r3

00025364 <sd_ble_gap_adv_data_set>:
SVCALL(SD_BLE_GAP_ADV_DATA_SET, uint32_t, sd_ble_gap_adv_data_set(uint8_t const *p_data, uint8_t dlen, uint8_t const *p_sr_data, uint8_t srdlen));
   25364:	df72      	svc	114	; 0x72
   25366:	4770      	bx	lr
   25368:	bf00      	nop
   2536a:	4618      	mov	r0, r3

0002536c <sd_ble_gap_appearance_get>:
SVCALL(SD_BLE_GAP_APPEARANCE_GET, uint32_t, sd_ble_gap_appearance_get(uint16_t *p_appearance));
   2536c:	df79      	svc	121	; 0x79
   2536e:	4770      	bx	lr
   25370:	bf00      	nop
   25372:	4618      	mov	r0, r3

00025374 <sd_ble_gap_device_name_get>:
 *
 * @retval ::NRF_SUCCESS GAP device name retrieved successfully.
 * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
 * @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.
 */
SVCALL(SD_BLE_GAP_DEVICE_NAME_GET, uint32_t, sd_ble_gap_device_name_get(uint8_t *p_dev_name, uint16_t *p_len));
   25374:	df7d      	svc	125	; 0x7d
   25376:	4770      	bx	lr
   25378:	bf00      	nop
   2537a:	4618      	mov	r0, r3

0002537c <sd_ble_uuid_encode>:
SVCALL(SD_BLE_UUID_ENCODE, uint32_t, sd_ble_uuid_encode(ble_uuid_t const *p_uuid, uint8_t *p_uuid_le_len, uint8_t *p_uuid_le));
   2537c:	df64      	svc	100	; 0x64
   2537e:	4770      	bx	lr
   25380:	bf00      	nop
   25382:	4618      	mov	r0, r3

00025384 <uint16_encode>:
 * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
 *
 * @return      Number of bytes written.
 */
static __INLINE uint8_t uint16_encode(uint16_t value, uint8_t * p_encoded_data)
{
   25384:	b480      	push	{r7}
   25386:	b083      	sub	sp, #12
   25388:	af00      	add	r7, sp, #0
   2538a:	4603      	mov	r3, r0
   2538c:	6039      	str	r1, [r7, #0]
   2538e:	80fb      	strh	r3, [r7, #6]
    p_encoded_data[0] = (uint8_t) ((value & 0x00FF) >> 0);
   25390:	88fb      	ldrh	r3, [r7, #6]
   25392:	b2da      	uxtb	r2, r3
   25394:	683b      	ldr	r3, [r7, #0]
   25396:	701a      	strb	r2, [r3, #0]
    p_encoded_data[1] = (uint8_t) ((value & 0xFF00) >> 8);
   25398:	88fb      	ldrh	r3, [r7, #6]
   2539a:	0a1b      	lsrs	r3, r3, #8
   2539c:	b29a      	uxth	r2, r3
   2539e:	683b      	ldr	r3, [r7, #0]
   253a0:	3301      	adds	r3, #1
   253a2:	b2d2      	uxtb	r2, r2
   253a4:	701a      	strb	r2, [r3, #0]
    return sizeof(uint16_t);
   253a6:	2302      	movs	r3, #2
}
   253a8:	4618      	mov	r0, r3
   253aa:	370c      	adds	r7, #12
   253ac:	46bd      	mov	sp, r7
   253ae:	bc80      	pop	{r7}
   253b0:	4770      	bx	lr

000253b2 <ble_device_addr_encode>:
#define AD_TYPE_BLE_DEVICE_ADDR_TYPE_RANDOM 1UL

static uint32_t ble_device_addr_encode(uint8_t  * p_encoded_data,
                                       uint16_t * p_offset,
                                       uint16_t   max_size)
{
   253b2:	b580      	push	{r7, lr}
   253b4:	b088      	sub	sp, #32
   253b6:	af00      	add	r7, sp, #0
   253b8:	60f8      	str	r0, [r7, #12]
   253ba:	60b9      	str	r1, [r7, #8]
   253bc:	4613      	mov	r3, r2
   253be:	80fb      	strh	r3, [r7, #6]
    uint32_t err_code;
    ble_gap_addr_t device_addr;

    // Check for buffer overflow.
    if (((*p_offset) + AD_TYPE_BLE_DEVICE_ADDR_SIZE) > max_size)
   253c0:	68bb      	ldr	r3, [r7, #8]
   253c2:	881b      	ldrh	r3, [r3, #0]
   253c4:	f103 0209 	add.w	r2, r3, #9
   253c8:	88fb      	ldrh	r3, [r7, #6]
   253ca:	429a      	cmp	r2, r3
   253cc:	d901      	bls.n	253d2 <ble_device_addr_encode+0x20>
    {
        return NRF_ERROR_DATA_SIZE;
   253ce:	230c      	movs	r3, #12
   253d0:	e052      	b.n	25478 <ble_device_addr_encode+0xc6>
    }

    // Get BLE address.
    #if (NRF_SD_BLE_API_VERSION >= 3)
        err_code = sd_ble_gap_addr_get(&device_addr);
   253d2:	f107 0314 	add.w	r3, r7, #20
   253d6:	4618      	mov	r0, r3
   253d8:	f7ff ffc0 	bl	2535c <sd_ble_gap_addr_get>
   253dc:	61f8      	str	r0, [r7, #28]
    #else
        err_code = sd_ble_gap_address_get(&device_addr);
    #endif
    VERIFY_SUCCESS(err_code);
   253de:	69fb      	ldr	r3, [r7, #28]
   253e0:	2b00      	cmp	r3, #0
   253e2:	d001      	beq.n	253e8 <ble_device_addr_encode+0x36>
   253e4:	69fb      	ldr	r3, [r7, #28]
   253e6:	e047      	b.n	25478 <ble_device_addr_encode+0xc6>

    // Encode LE Bluetooth Device Address.
    p_encoded_data[*p_offset]  = (uint8_t)(AD_TYPE_FIELD_SIZE +
   253e8:	68bb      	ldr	r3, [r7, #8]
   253ea:	881b      	ldrh	r3, [r3, #0]
   253ec:	461a      	mov	r2, r3
   253ee:	68fb      	ldr	r3, [r7, #12]
   253f0:	4413      	add	r3, r2
   253f2:	2208      	movs	r2, #8
   253f4:	701a      	strb	r2, [r3, #0]
                                               AD_TYPE_BLE_DEVICE_ADDR_DATA_SIZE);
    *p_offset                 += AD_LENGTH_FIELD_SIZE;
   253f6:	68bb      	ldr	r3, [r7, #8]
   253f8:	881b      	ldrh	r3, [r3, #0]
   253fa:	3301      	adds	r3, #1
   253fc:	b29a      	uxth	r2, r3
   253fe:	68bb      	ldr	r3, [r7, #8]
   25400:	801a      	strh	r2, [r3, #0]
    p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_LE_BLUETOOTH_DEVICE_ADDRESS;
   25402:	68bb      	ldr	r3, [r7, #8]
   25404:	881b      	ldrh	r3, [r3, #0]
   25406:	461a      	mov	r2, r3
   25408:	68fb      	ldr	r3, [r7, #12]
   2540a:	4413      	add	r3, r2
   2540c:	221b      	movs	r2, #27
   2540e:	701a      	strb	r2, [r3, #0]
    *p_offset                 += AD_TYPE_FIELD_SIZE;
   25410:	68bb      	ldr	r3, [r7, #8]
   25412:	881b      	ldrh	r3, [r3, #0]
   25414:	3301      	adds	r3, #1
   25416:	b29a      	uxth	r2, r3
   25418:	68bb      	ldr	r3, [r7, #8]
   2541a:	801a      	strh	r2, [r3, #0]
    memcpy(&p_encoded_data[*p_offset], &device_addr.addr[0], BLE_GAP_ADDR_LEN);
   2541c:	68bb      	ldr	r3, [r7, #8]
   2541e:	881b      	ldrh	r3, [r3, #0]
   25420:	461a      	mov	r2, r3
   25422:	68fb      	ldr	r3, [r7, #12]
   25424:	1898      	adds	r0, r3, r2
   25426:	f107 0314 	add.w	r3, r7, #20
   2542a:	3301      	adds	r3, #1
   2542c:	2206      	movs	r2, #6
   2542e:	4619      	mov	r1, r3
   25430:	f002 f9ea 	bl	27808 <memcpy>
    *p_offset                 += BLE_GAP_ADDR_LEN;
   25434:	68bb      	ldr	r3, [r7, #8]
   25436:	881b      	ldrh	r3, [r3, #0]
   25438:	3306      	adds	r3, #6
   2543a:	b29a      	uxth	r2, r3
   2543c:	68bb      	ldr	r3, [r7, #8]
   2543e:	801a      	strh	r2, [r3, #0]
    if (BLE_GAP_ADDR_TYPE_PUBLIC == device_addr.addr_type)
   25440:	7d3b      	ldrb	r3, [r7, #20]
   25442:	f023 0301 	bic.w	r3, r3, #1
   25446:	b2db      	uxtb	r3, r3
   25448:	2b00      	cmp	r3, #0
   2544a:	d107      	bne.n	2545c <ble_device_addr_encode+0xaa>
    {
        p_encoded_data[*p_offset] = AD_TYPE_BLE_DEVICE_ADDR_TYPE_PUBLIC;
   2544c:	68bb      	ldr	r3, [r7, #8]
   2544e:	881b      	ldrh	r3, [r3, #0]
   25450:	461a      	mov	r2, r3
   25452:	68fb      	ldr	r3, [r7, #12]
   25454:	4413      	add	r3, r2
   25456:	2200      	movs	r2, #0
   25458:	701a      	strb	r2, [r3, #0]
   2545a:	e006      	b.n	2546a <ble_device_addr_encode+0xb8>
    }
    else
    {
        p_encoded_data[*p_offset] = AD_TYPE_BLE_DEVICE_ADDR_TYPE_RANDOM;
   2545c:	68bb      	ldr	r3, [r7, #8]
   2545e:	881b      	ldrh	r3, [r3, #0]
   25460:	461a      	mov	r2, r3
   25462:	68fb      	ldr	r3, [r7, #12]
   25464:	4413      	add	r3, r2
   25466:	2201      	movs	r2, #1
   25468:	701a      	strb	r2, [r3, #0]
    }
    *p_offset += AD_TYPE_BLE_DEVICE_ADDR_TYPE_SIZE;
   2546a:	68bb      	ldr	r3, [r7, #8]
   2546c:	881b      	ldrh	r3, [r3, #0]
   2546e:	3301      	adds	r3, #1
   25470:	b29a      	uxth	r2, r3
   25472:	68bb      	ldr	r3, [r7, #8]
   25474:	801a      	strh	r2, [r3, #0]

    return NRF_SUCCESS;
   25476:	2300      	movs	r3, #0
}
   25478:	4618      	mov	r0, r3
   2547a:	3720      	adds	r7, #32
   2547c:	46bd      	mov	sp, r7
   2547e:	bd80      	pop	{r7, pc}

00025480 <name_encode>:

static uint32_t name_encode(const ble_advdata_t * p_advdata,
                            uint8_t             * p_encoded_data,
                            uint16_t            * p_offset,
                            uint16_t              max_size)
{
   25480:	b580      	push	{r7, lr}
   25482:	b088      	sub	sp, #32
   25484:	af00      	add	r7, sp, #0
   25486:	60f8      	str	r0, [r7, #12]
   25488:	60b9      	str	r1, [r7, #8]
   2548a:	607a      	str	r2, [r7, #4]
   2548c:	807b      	strh	r3, [r7, #2]
    uint16_t actual_length;
    uint8_t  adv_data_format;


    // Validate parameters
    if ((BLE_ADVDATA_SHORT_NAME == p_advdata->name_type) && (0 == p_advdata->short_name_len))
   2548e:	68fb      	ldr	r3, [r7, #12]
   25490:	781b      	ldrb	r3, [r3, #0]
   25492:	2b01      	cmp	r3, #1
   25494:	d105      	bne.n	254a2 <name_encode+0x22>
   25496:	68fb      	ldr	r3, [r7, #12]
   25498:	785b      	ldrb	r3, [r3, #1]
   2549a:	2b00      	cmp	r3, #0
   2549c:	d101      	bne.n	254a2 <name_encode+0x22>
    {
        return NRF_ERROR_INVALID_PARAM;
   2549e:	2307      	movs	r3, #7
   254a0:	e077      	b.n	25592 <name_encode+0x112>
    }

    // Check for buffer overflow.
    if ( (((*p_offset) + AD_DATA_OFFSET) > max_size) ||
   254a2:	687b      	ldr	r3, [r7, #4]
   254a4:	881b      	ldrh	r3, [r3, #0]
   254a6:	1c9a      	adds	r2, r3, #2
   254a8:	887b      	ldrh	r3, [r7, #2]
   254aa:	429a      	cmp	r2, r3
   254ac:	d80d      	bhi.n	254ca <name_encode+0x4a>
         ( (BLE_ADVDATA_SHORT_NAME == p_advdata->name_type) &&
   254ae:	68fb      	ldr	r3, [r7, #12]
   254b0:	781b      	ldrb	r3, [r3, #0]
    if ( (((*p_offset) + AD_DATA_OFFSET) > max_size) ||
   254b2:	2b01      	cmp	r3, #1
   254b4:	d10b      	bne.n	254ce <name_encode+0x4e>
           (((*p_offset) + AD_DATA_OFFSET + p_advdata->short_name_len) > max_size)))
   254b6:	687b      	ldr	r3, [r7, #4]
   254b8:	881b      	ldrh	r3, [r3, #0]
   254ba:	461a      	mov	r2, r3
   254bc:	68fb      	ldr	r3, [r7, #12]
   254be:	785b      	ldrb	r3, [r3, #1]
   254c0:	4413      	add	r3, r2
   254c2:	1c9a      	adds	r2, r3, #2
   254c4:	887b      	ldrh	r3, [r7, #2]
         ( (BLE_ADVDATA_SHORT_NAME == p_advdata->name_type) &&
   254c6:	429a      	cmp	r2, r3
   254c8:	d901      	bls.n	254ce <name_encode+0x4e>
    {
        return NRF_ERROR_DATA_SIZE;
   254ca:	230c      	movs	r3, #12
   254cc:	e061      	b.n	25592 <name_encode+0x112>
    }

    rem_adv_data_len = max_size - (*p_offset) - AD_DATA_OFFSET;
   254ce:	687b      	ldr	r3, [r7, #4]
   254d0:	881b      	ldrh	r3, [r3, #0]
   254d2:	887a      	ldrh	r2, [r7, #2]
   254d4:	1ad3      	subs	r3, r2, r3
   254d6:	b29b      	uxth	r3, r3
   254d8:	3b02      	subs	r3, #2
   254da:	83bb      	strh	r3, [r7, #28]
    actual_length    = rem_adv_data_len;
   254dc:	8bbb      	ldrh	r3, [r7, #28]
   254de:	82fb      	strh	r3, [r7, #22]

    // Get GAP device name and length
    err_code = sd_ble_gap_device_name_get(&p_encoded_data[(*p_offset) + AD_DATA_OFFSET],
   254e0:	687b      	ldr	r3, [r7, #4]
   254e2:	881b      	ldrh	r3, [r3, #0]
   254e4:	3302      	adds	r3, #2
   254e6:	68ba      	ldr	r2, [r7, #8]
   254e8:	4413      	add	r3, r2
   254ea:	f107 0216 	add.w	r2, r7, #22
   254ee:	4611      	mov	r1, r2
   254f0:	4618      	mov	r0, r3
   254f2:	f7ff ff3f 	bl	25374 <sd_ble_gap_device_name_get>
   254f6:	61b8      	str	r0, [r7, #24]
                                          &actual_length);
    VERIFY_SUCCESS(err_code);
   254f8:	69bb      	ldr	r3, [r7, #24]
   254fa:	2b00      	cmp	r3, #0
   254fc:	d001      	beq.n	25502 <name_encode+0x82>
   254fe:	69bb      	ldr	r3, [r7, #24]
   25500:	e047      	b.n	25592 <name_encode+0x112>

    // Check if device intend to use short name and it can fit available data size.
    if ((p_advdata->name_type == BLE_ADVDATA_FULL_NAME) && (actual_length <= rem_adv_data_len))
   25502:	68fb      	ldr	r3, [r7, #12]
   25504:	781b      	ldrb	r3, [r3, #0]
   25506:	2b02      	cmp	r3, #2
   25508:	d106      	bne.n	25518 <name_encode+0x98>
   2550a:	8afb      	ldrh	r3, [r7, #22]
   2550c:	8bba      	ldrh	r2, [r7, #28]
   2550e:	429a      	cmp	r2, r3
   25510:	d302      	bcc.n	25518 <name_encode+0x98>
    {
        // Complete device name can fit, setting Complete Name in Adv Data.
        adv_data_format = BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME;
   25512:	2309      	movs	r3, #9
   25514:	77fb      	strb	r3, [r7, #31]
   25516:	e012      	b.n	2553e <name_encode+0xbe>
    }
    else
    {
        // Else short name needs to be used. Or application has requested use of short name.
        adv_data_format = BLE_GAP_AD_TYPE_SHORT_LOCAL_NAME;
   25518:	2308      	movs	r3, #8
   2551a:	77fb      	strb	r3, [r7, #31]

        // If application has set a preference on the short name size, it needs to be considered,
        // else fit what can be fit.
        if ((BLE_ADVDATA_SHORT_NAME == p_advdata->name_type) &&
   2551c:	68fb      	ldr	r3, [r7, #12]
   2551e:	781b      	ldrb	r3, [r3, #0]
   25520:	2b01      	cmp	r3, #1
   25522:	d10a      	bne.n	2553a <name_encode+0xba>
                (p_advdata->short_name_len <= rem_adv_data_len))
   25524:	68fb      	ldr	r3, [r7, #12]
   25526:	785b      	ldrb	r3, [r3, #1]
   25528:	b29b      	uxth	r3, r3
        if ((BLE_ADVDATA_SHORT_NAME == p_advdata->name_type) &&
   2552a:	8bba      	ldrh	r2, [r7, #28]
   2552c:	429a      	cmp	r2, r3
   2552e:	d304      	bcc.n	2553a <name_encode+0xba>
        {
            // Short name fits available size.
            actual_length = p_advdata->short_name_len;
   25530:	68fb      	ldr	r3, [r7, #12]
   25532:	785b      	ldrb	r3, [r3, #1]
   25534:	b29b      	uxth	r3, r3
   25536:	82fb      	strh	r3, [r7, #22]
   25538:	e001      	b.n	2553e <name_encode+0xbe>
        }
        // Else whatever can fit the data buffer will be packed.
        else
        {
            actual_length = rem_adv_data_len;
   2553a:	8bbb      	ldrh	r3, [r7, #28]
   2553c:	82fb      	strh	r3, [r7, #22]
        }
    }

    // There is only 1 byte intended to encode length which is (actual_length + AD_TYPE_FIELD_SIZE)
    if (actual_length > (0x00FF - AD_TYPE_FIELD_SIZE))
   2553e:	8afb      	ldrh	r3, [r7, #22]
   25540:	2bfe      	cmp	r3, #254	; 0xfe
   25542:	d901      	bls.n	25548 <name_encode+0xc8>
    {
        return NRF_ERROR_DATA_SIZE;
   25544:	230c      	movs	r3, #12
   25546:	e024      	b.n	25592 <name_encode+0x112>
    }

    // Complete name field in encoded data.
    p_encoded_data[*p_offset]  = (uint8_t)(AD_TYPE_FIELD_SIZE + actual_length);
   25548:	8afb      	ldrh	r3, [r7, #22]
   2554a:	b2da      	uxtb	r2, r3
   2554c:	687b      	ldr	r3, [r7, #4]
   2554e:	881b      	ldrh	r3, [r3, #0]
   25550:	4619      	mov	r1, r3
   25552:	68bb      	ldr	r3, [r7, #8]
   25554:	440b      	add	r3, r1
   25556:	3201      	adds	r2, #1
   25558:	b2d2      	uxtb	r2, r2
   2555a:	701a      	strb	r2, [r3, #0]
    *p_offset                 += AD_LENGTH_FIELD_SIZE;
   2555c:	687b      	ldr	r3, [r7, #4]
   2555e:	881b      	ldrh	r3, [r3, #0]
   25560:	3301      	adds	r3, #1
   25562:	b29a      	uxth	r2, r3
   25564:	687b      	ldr	r3, [r7, #4]
   25566:	801a      	strh	r2, [r3, #0]
    p_encoded_data[*p_offset]  = adv_data_format;
   25568:	687b      	ldr	r3, [r7, #4]
   2556a:	881b      	ldrh	r3, [r3, #0]
   2556c:	461a      	mov	r2, r3
   2556e:	68bb      	ldr	r3, [r7, #8]
   25570:	4413      	add	r3, r2
   25572:	7ffa      	ldrb	r2, [r7, #31]
   25574:	701a      	strb	r2, [r3, #0]
    *p_offset                 += AD_TYPE_FIELD_SIZE;
   25576:	687b      	ldr	r3, [r7, #4]
   25578:	881b      	ldrh	r3, [r3, #0]
   2557a:	3301      	adds	r3, #1
   2557c:	b29a      	uxth	r2, r3
   2557e:	687b      	ldr	r3, [r7, #4]
   25580:	801a      	strh	r2, [r3, #0]
    *p_offset                 += actual_length;
   25582:	687b      	ldr	r3, [r7, #4]
   25584:	881a      	ldrh	r2, [r3, #0]
   25586:	8afb      	ldrh	r3, [r7, #22]
   25588:	4413      	add	r3, r2
   2558a:	b29a      	uxth	r2, r3
   2558c:	687b      	ldr	r3, [r7, #4]
   2558e:	801a      	strh	r2, [r3, #0]

    return NRF_SUCCESS;
   25590:	2300      	movs	r3, #0
}
   25592:	4618      	mov	r0, r3
   25594:	3720      	adds	r7, #32
   25596:	46bd      	mov	sp, r7
   25598:	bd80      	pop	{r7, pc}

0002559a <appearance_encode>:


static uint32_t appearance_encode(uint8_t  * p_encoded_data,
                                  uint16_t * p_offset,
                                  uint16_t   max_size)
{
   2559a:	b580      	push	{r7, lr}
   2559c:	b086      	sub	sp, #24
   2559e:	af00      	add	r7, sp, #0
   255a0:	60f8      	str	r0, [r7, #12]
   255a2:	60b9      	str	r1, [r7, #8]
   255a4:	4613      	mov	r3, r2
   255a6:	80fb      	strh	r3, [r7, #6]
    uint32_t err_code;
    uint16_t appearance;

    // Check for buffer overflow.
    if (((*p_offset) + AD_TYPE_APPEARANCE_SIZE) > max_size)
   255a8:	68bb      	ldr	r3, [r7, #8]
   255aa:	881b      	ldrh	r3, [r3, #0]
   255ac:	1d1a      	adds	r2, r3, #4
   255ae:	88fb      	ldrh	r3, [r7, #6]
   255b0:	429a      	cmp	r2, r3
   255b2:	d901      	bls.n	255b8 <appearance_encode+0x1e>
    {
        return NRF_ERROR_DATA_SIZE;
   255b4:	230c      	movs	r3, #12
   255b6:	e038      	b.n	2562a <appearance_encode+0x90>
    }

    // Get GAP appearance field.
    err_code = sd_ble_gap_appearance_get(&appearance);
   255b8:	f107 0312 	add.w	r3, r7, #18
   255bc:	4618      	mov	r0, r3
   255be:	f7ff fed5 	bl	2536c <sd_ble_gap_appearance_get>
   255c2:	6178      	str	r0, [r7, #20]
    VERIFY_SUCCESS(err_code);
   255c4:	697b      	ldr	r3, [r7, #20]
   255c6:	2b00      	cmp	r3, #0
   255c8:	d001      	beq.n	255ce <appearance_encode+0x34>
   255ca:	697b      	ldr	r3, [r7, #20]
   255cc:	e02d      	b.n	2562a <appearance_encode+0x90>

    // Encode Length, AD Type and Appearance.
    p_encoded_data[*p_offset]  = (uint8_t)(AD_TYPE_FIELD_SIZE + AD_TYPE_APPEARANCE_DATA_SIZE);
   255ce:	68bb      	ldr	r3, [r7, #8]
   255d0:	881b      	ldrh	r3, [r3, #0]
   255d2:	461a      	mov	r2, r3
   255d4:	68fb      	ldr	r3, [r7, #12]
   255d6:	4413      	add	r3, r2
   255d8:	2203      	movs	r2, #3
   255da:	701a      	strb	r2, [r3, #0]
    *p_offset                 += AD_LENGTH_FIELD_SIZE;
   255dc:	68bb      	ldr	r3, [r7, #8]
   255de:	881b      	ldrh	r3, [r3, #0]
   255e0:	3301      	adds	r3, #1
   255e2:	b29a      	uxth	r2, r3
   255e4:	68bb      	ldr	r3, [r7, #8]
   255e6:	801a      	strh	r2, [r3, #0]
    p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_APPEARANCE;
   255e8:	68bb      	ldr	r3, [r7, #8]
   255ea:	881b      	ldrh	r3, [r3, #0]
   255ec:	461a      	mov	r2, r3
   255ee:	68fb      	ldr	r3, [r7, #12]
   255f0:	4413      	add	r3, r2
   255f2:	2219      	movs	r2, #25
   255f4:	701a      	strb	r2, [r3, #0]
    *p_offset                 += AD_TYPE_FIELD_SIZE;
   255f6:	68bb      	ldr	r3, [r7, #8]
   255f8:	881b      	ldrh	r3, [r3, #0]
   255fa:	3301      	adds	r3, #1
   255fc:	b29a      	uxth	r2, r3
   255fe:	68bb      	ldr	r3, [r7, #8]
   25600:	801a      	strh	r2, [r3, #0]
    *p_offset                 += uint16_encode(appearance, &p_encoded_data[*p_offset]);
   25602:	8a7a      	ldrh	r2, [r7, #18]
   25604:	68bb      	ldr	r3, [r7, #8]
   25606:	881b      	ldrh	r3, [r3, #0]
   25608:	4619      	mov	r1, r3
   2560a:	68fb      	ldr	r3, [r7, #12]
   2560c:	440b      	add	r3, r1
   2560e:	4619      	mov	r1, r3
   25610:	4610      	mov	r0, r2
   25612:	f7ff feb7 	bl	25384 <uint16_encode>
   25616:	4603      	mov	r3, r0
   25618:	4619      	mov	r1, r3
   2561a:	68bb      	ldr	r3, [r7, #8]
   2561c:	881a      	ldrh	r2, [r3, #0]
   2561e:	b28b      	uxth	r3, r1
   25620:	4413      	add	r3, r2
   25622:	b29a      	uxth	r2, r3
   25624:	68bb      	ldr	r3, [r7, #8]
   25626:	801a      	strh	r2, [r3, #0]

    return NRF_SUCCESS;
   25628:	2300      	movs	r3, #0
}
   2562a:	4618      	mov	r0, r3
   2562c:	3718      	adds	r7, #24
   2562e:	46bd      	mov	sp, r7
   25630:	bd80      	pop	{r7, pc}

00025632 <flags_encode>:

static uint32_t flags_encode(int8_t     flags,
                             uint8_t  * p_encoded_data,
                             uint16_t * p_offset,
                             uint16_t   max_size)
{
   25632:	b480      	push	{r7}
   25634:	b085      	sub	sp, #20
   25636:	af00      	add	r7, sp, #0
   25638:	60b9      	str	r1, [r7, #8]
   2563a:	607a      	str	r2, [r7, #4]
   2563c:	461a      	mov	r2, r3
   2563e:	4603      	mov	r3, r0
   25640:	73fb      	strb	r3, [r7, #15]
   25642:	4613      	mov	r3, r2
   25644:	81bb      	strh	r3, [r7, #12]
    // Check for buffer overflow.
    if (((*p_offset) + AD_TYPE_FLAGS_SIZE) > max_size)
   25646:	687b      	ldr	r3, [r7, #4]
   25648:	881b      	ldrh	r3, [r3, #0]
   2564a:	1cda      	adds	r2, r3, #3
   2564c:	89bb      	ldrh	r3, [r7, #12]
   2564e:	429a      	cmp	r2, r3
   25650:	d901      	bls.n	25656 <flags_encode+0x24>
    {
        return NRF_ERROR_DATA_SIZE;
   25652:	230c      	movs	r3, #12
   25654:	e027      	b.n	256a6 <flags_encode+0x74>
    }

    // Encode flags.
    p_encoded_data[*p_offset]  = (uint8_t)(AD_TYPE_FIELD_SIZE + AD_TYPE_FLAGS_DATA_SIZE);
   25656:	687b      	ldr	r3, [r7, #4]
   25658:	881b      	ldrh	r3, [r3, #0]
   2565a:	461a      	mov	r2, r3
   2565c:	68bb      	ldr	r3, [r7, #8]
   2565e:	4413      	add	r3, r2
   25660:	2202      	movs	r2, #2
   25662:	701a      	strb	r2, [r3, #0]
    *p_offset                 += AD_LENGTH_FIELD_SIZE;
   25664:	687b      	ldr	r3, [r7, #4]
   25666:	881b      	ldrh	r3, [r3, #0]
   25668:	3301      	adds	r3, #1
   2566a:	b29a      	uxth	r2, r3
   2566c:	687b      	ldr	r3, [r7, #4]
   2566e:	801a      	strh	r2, [r3, #0]
    p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_FLAGS;
   25670:	687b      	ldr	r3, [r7, #4]
   25672:	881b      	ldrh	r3, [r3, #0]
   25674:	461a      	mov	r2, r3
   25676:	68bb      	ldr	r3, [r7, #8]
   25678:	4413      	add	r3, r2
   2567a:	2201      	movs	r2, #1
   2567c:	701a      	strb	r2, [r3, #0]
    *p_offset                 += AD_TYPE_FIELD_SIZE;
   2567e:	687b      	ldr	r3, [r7, #4]
   25680:	881b      	ldrh	r3, [r3, #0]
   25682:	3301      	adds	r3, #1
   25684:	b29a      	uxth	r2, r3
   25686:	687b      	ldr	r3, [r7, #4]
   25688:	801a      	strh	r2, [r3, #0]
    p_encoded_data[*p_offset]  = flags;
   2568a:	687b      	ldr	r3, [r7, #4]
   2568c:	881b      	ldrh	r3, [r3, #0]
   2568e:	461a      	mov	r2, r3
   25690:	68bb      	ldr	r3, [r7, #8]
   25692:	4413      	add	r3, r2
   25694:	7bfa      	ldrb	r2, [r7, #15]
   25696:	701a      	strb	r2, [r3, #0]
    *p_offset                 += AD_TYPE_FLAGS_DATA_SIZE;
   25698:	687b      	ldr	r3, [r7, #4]
   2569a:	881b      	ldrh	r3, [r3, #0]
   2569c:	3301      	adds	r3, #1
   2569e:	b29a      	uxth	r2, r3
   256a0:	687b      	ldr	r3, [r7, #4]
   256a2:	801a      	strh	r2, [r3, #0]

    return NRF_SUCCESS;
   256a4:	2300      	movs	r3, #0
}
   256a6:	4618      	mov	r0, r3
   256a8:	3714      	adds	r7, #20
   256aa:	46bd      	mov	sp, r7
   256ac:	bc80      	pop	{r7}
   256ae:	4770      	bx	lr

000256b0 <tx_power_level_encode>:

static uint32_t tx_power_level_encode(int8_t     tx_power_level,
                                      uint8_t  * p_encoded_data,
                                      uint16_t * p_offset,
                                      uint16_t   max_size)
{
   256b0:	b480      	push	{r7}
   256b2:	b085      	sub	sp, #20
   256b4:	af00      	add	r7, sp, #0
   256b6:	60b9      	str	r1, [r7, #8]
   256b8:	607a      	str	r2, [r7, #4]
   256ba:	461a      	mov	r2, r3
   256bc:	4603      	mov	r3, r0
   256be:	73fb      	strb	r3, [r7, #15]
   256c0:	4613      	mov	r3, r2
   256c2:	81bb      	strh	r3, [r7, #12]
    // Check for buffer overflow.
    if (((*p_offset) + AD_TYPE_TX_POWER_LEVEL_SIZE) > max_size)
   256c4:	687b      	ldr	r3, [r7, #4]
   256c6:	881b      	ldrh	r3, [r3, #0]
   256c8:	1cda      	adds	r2, r3, #3
   256ca:	89bb      	ldrh	r3, [r7, #12]
   256cc:	429a      	cmp	r2, r3
   256ce:	d901      	bls.n	256d4 <tx_power_level_encode+0x24>
    {
        return NRF_ERROR_DATA_SIZE;
   256d0:	230c      	movs	r3, #12
   256d2:	e027      	b.n	25724 <tx_power_level_encode+0x74>
    }

    // Encode TX Power Level.
    p_encoded_data[*p_offset]  = (uint8_t)(AD_TYPE_FIELD_SIZE +
   256d4:	687b      	ldr	r3, [r7, #4]
   256d6:	881b      	ldrh	r3, [r3, #0]
   256d8:	461a      	mov	r2, r3
   256da:	68bb      	ldr	r3, [r7, #8]
   256dc:	4413      	add	r3, r2
   256de:	2202      	movs	r2, #2
   256e0:	701a      	strb	r2, [r3, #0]
                                                  AD_TYPE_TX_POWER_LEVEL_DATA_SIZE);
    *p_offset                 += AD_LENGTH_FIELD_SIZE;
   256e2:	687b      	ldr	r3, [r7, #4]
   256e4:	881b      	ldrh	r3, [r3, #0]
   256e6:	3301      	adds	r3, #1
   256e8:	b29a      	uxth	r2, r3
   256ea:	687b      	ldr	r3, [r7, #4]
   256ec:	801a      	strh	r2, [r3, #0]
    p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_TX_POWER_LEVEL;
   256ee:	687b      	ldr	r3, [r7, #4]
   256f0:	881b      	ldrh	r3, [r3, #0]
   256f2:	461a      	mov	r2, r3
   256f4:	68bb      	ldr	r3, [r7, #8]
   256f6:	4413      	add	r3, r2
   256f8:	220a      	movs	r2, #10
   256fa:	701a      	strb	r2, [r3, #0]
    *p_offset                 += AD_TYPE_FIELD_SIZE;
   256fc:	687b      	ldr	r3, [r7, #4]
   256fe:	881b      	ldrh	r3, [r3, #0]
   25700:	3301      	adds	r3, #1
   25702:	b29a      	uxth	r2, r3
   25704:	687b      	ldr	r3, [r7, #4]
   25706:	801a      	strh	r2, [r3, #0]
    p_encoded_data[*p_offset]  = tx_power_level;
   25708:	687b      	ldr	r3, [r7, #4]
   2570a:	881b      	ldrh	r3, [r3, #0]
   2570c:	461a      	mov	r2, r3
   2570e:	68bb      	ldr	r3, [r7, #8]
   25710:	4413      	add	r3, r2
   25712:	7bfa      	ldrb	r2, [r7, #15]
   25714:	701a      	strb	r2, [r3, #0]
    *p_offset                 += AD_TYPE_TX_POWER_LEVEL_DATA_SIZE;
   25716:	687b      	ldr	r3, [r7, #4]
   25718:	881b      	ldrh	r3, [r3, #0]
   2571a:	3301      	adds	r3, #1
   2571c:	b29a      	uxth	r2, r3
   2571e:	687b      	ldr	r3, [r7, #4]
   25720:	801a      	strh	r2, [r3, #0]

    return NRF_SUCCESS;
   25722:	2300      	movs	r3, #0
}
   25724:	4618      	mov	r0, r3
   25726:	3714      	adds	r7, #20
   25728:	46bd      	mov	sp, r7
   2572a:	bc80      	pop	{r7}
   2572c:	4770      	bx	lr

0002572e <uuid_list_sized_encode>:
                                       uint8_t                         adv_type,
                                       uint8_t                         uuid_size,
                                       uint8_t                       * p_encoded_data,
                                       uint16_t                      * p_offset,
                                       uint16_t                        max_size)
{
   2572e:	b580      	push	{r7, lr}
   25730:	b08a      	sub	sp, #40	; 0x28
   25732:	af00      	add	r7, sp, #0
   25734:	60f8      	str	r0, [r7, #12]
   25736:	607b      	str	r3, [r7, #4]
   25738:	460b      	mov	r3, r1
   2573a:	72fb      	strb	r3, [r7, #11]
   2573c:	4613      	mov	r3, r2
   2573e:	72bb      	strb	r3, [r7, #10]
    int      i;
    bool     is_heading_written = false;
   25740:	2300      	movs	r3, #0
   25742:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    uint16_t start_pos          = *p_offset;
   25746:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   25748:	881b      	ldrh	r3, [r3, #0]
   2574a:	843b      	strh	r3, [r7, #32]
    uint16_t length;

    for (i = 0; i < p_uuid_list->uuid_cnt; i++)
   2574c:	2300      	movs	r3, #0
   2574e:	627b      	str	r3, [r7, #36]	; 0x24
   25750:	e068      	b.n	25824 <uuid_list_sized_encode+0xf6>
    {
        uint32_t   err_code;
        uint8_t    encoded_size;
        ble_uuid_t uuid = p_uuid_list->p_uuids[i];
   25752:	68fb      	ldr	r3, [r7, #12]
   25754:	685a      	ldr	r2, [r3, #4]
   25756:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   25758:	009b      	lsls	r3, r3, #2
   2575a:	441a      	add	r2, r3
   2575c:	f107 0310 	add.w	r3, r7, #16
   25760:	6810      	ldr	r0, [r2, #0]
   25762:	6018      	str	r0, [r3, #0]

        // Find encoded uuid size.
        err_code = sd_ble_uuid_encode(&uuid, &encoded_size, NULL);
   25764:	f107 0116 	add.w	r1, r7, #22
   25768:	f107 0310 	add.w	r3, r7, #16
   2576c:	2200      	movs	r2, #0
   2576e:	4618      	mov	r0, r3
   25770:	f7ff fe04 	bl	2537c <sd_ble_uuid_encode>
   25774:	61b8      	str	r0, [r7, #24]
        VERIFY_SUCCESS(err_code);
   25776:	69bb      	ldr	r3, [r7, #24]
   25778:	2b00      	cmp	r3, #0
   2577a:	d001      	beq.n	25780 <uuid_list_sized_encode+0x52>
   2577c:	69bb      	ldr	r3, [r7, #24]
   2577e:	e06e      	b.n	2585e <uuid_list_sized_encode+0x130>

        // Check size.
        if (encoded_size == uuid_size)
   25780:	7dbb      	ldrb	r3, [r7, #22]
   25782:	7aba      	ldrb	r2, [r7, #10]
   25784:	429a      	cmp	r2, r3
   25786:	d14a      	bne.n	2581e <uuid_list_sized_encode+0xf0>
        {
            uint8_t heading_bytes = (is_heading_written) ? 0 : AD_DATA_OFFSET;
   25788:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   2578c:	2b00      	cmp	r3, #0
   2578e:	d001      	beq.n	25794 <uuid_list_sized_encode+0x66>
   25790:	2300      	movs	r3, #0
   25792:	e000      	b.n	25796 <uuid_list_sized_encode+0x68>
   25794:	2302      	movs	r3, #2
   25796:	75fb      	strb	r3, [r7, #23]

            // Check for buffer overflow
            if (((*p_offset) + encoded_size + heading_bytes) > max_size)
   25798:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   2579a:	881b      	ldrh	r3, [r3, #0]
   2579c:	461a      	mov	r2, r3
   2579e:	7dbb      	ldrb	r3, [r7, #22]
   257a0:	441a      	add	r2, r3
   257a2:	7dfb      	ldrb	r3, [r7, #23]
   257a4:	441a      	add	r2, r3
   257a6:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
   257a8:	429a      	cmp	r2, r3
   257aa:	dd01      	ble.n	257b0 <uuid_list_sized_encode+0x82>
            {
                return NRF_ERROR_DATA_SIZE;
   257ac:	230c      	movs	r3, #12
   257ae:	e056      	b.n	2585e <uuid_list_sized_encode+0x130>
            }

            if (!is_heading_written)
   257b0:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   257b4:	f083 0301 	eor.w	r3, r3, #1
   257b8:	b2db      	uxtb	r3, r3
   257ba:	2b00      	cmp	r3, #0
   257bc:	d015      	beq.n	257ea <uuid_list_sized_encode+0xbc>
            {
                // Write AD structure heading.
                *p_offset                 += AD_LENGTH_FIELD_SIZE;
   257be:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   257c0:	881b      	ldrh	r3, [r3, #0]
   257c2:	3301      	adds	r3, #1
   257c4:	b29a      	uxth	r2, r3
   257c6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   257c8:	801a      	strh	r2, [r3, #0]
                p_encoded_data[*p_offset]  = adv_type;
   257ca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   257cc:	881b      	ldrh	r3, [r3, #0]
   257ce:	461a      	mov	r2, r3
   257d0:	687b      	ldr	r3, [r7, #4]
   257d2:	4413      	add	r3, r2
   257d4:	7afa      	ldrb	r2, [r7, #11]
   257d6:	701a      	strb	r2, [r3, #0]
                *p_offset                 += AD_TYPE_FIELD_SIZE;
   257d8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   257da:	881b      	ldrh	r3, [r3, #0]
   257dc:	3301      	adds	r3, #1
   257de:	b29a      	uxth	r2, r3
   257e0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   257e2:	801a      	strh	r2, [r3, #0]
                is_heading_written         = true;
   257e4:	2301      	movs	r3, #1
   257e6:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
            }

            // Write UUID.
            err_code = sd_ble_uuid_encode(&uuid, &encoded_size, &p_encoded_data[*p_offset]);
   257ea:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   257ec:	881b      	ldrh	r3, [r3, #0]
   257ee:	461a      	mov	r2, r3
   257f0:	687b      	ldr	r3, [r7, #4]
   257f2:	441a      	add	r2, r3
   257f4:	f107 0116 	add.w	r1, r7, #22
   257f8:	f107 0310 	add.w	r3, r7, #16
   257fc:	4618      	mov	r0, r3
   257fe:	f7ff fdbd 	bl	2537c <sd_ble_uuid_encode>
   25802:	61b8      	str	r0, [r7, #24]
            VERIFY_SUCCESS(err_code);
   25804:	69bb      	ldr	r3, [r7, #24]
   25806:	2b00      	cmp	r3, #0
   25808:	d001      	beq.n	2580e <uuid_list_sized_encode+0xe0>
   2580a:	69bb      	ldr	r3, [r7, #24]
   2580c:	e027      	b.n	2585e <uuid_list_sized_encode+0x130>
            *p_offset += encoded_size;
   2580e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   25810:	881a      	ldrh	r2, [r3, #0]
   25812:	7dbb      	ldrb	r3, [r7, #22]
   25814:	b29b      	uxth	r3, r3
   25816:	4413      	add	r3, r2
   25818:	b29a      	uxth	r2, r3
   2581a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   2581c:	801a      	strh	r2, [r3, #0]
    for (i = 0; i < p_uuid_list->uuid_cnt; i++)
   2581e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   25820:	3301      	adds	r3, #1
   25822:	627b      	str	r3, [r7, #36]	; 0x24
   25824:	68fb      	ldr	r3, [r7, #12]
   25826:	881b      	ldrh	r3, [r3, #0]
   25828:	461a      	mov	r2, r3
   2582a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   2582c:	4293      	cmp	r3, r2
   2582e:	db90      	blt.n	25752 <uuid_list_sized_encode+0x24>
        }
    }

    if (is_heading_written)
   25830:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   25834:	2b00      	cmp	r3, #0
   25836:	d011      	beq.n	2585c <uuid_list_sized_encode+0x12e>
    {
        // Write length.
        length = (*p_offset) - (start_pos + AD_LENGTH_FIELD_SIZE);
   25838:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   2583a:	881a      	ldrh	r2, [r3, #0]
   2583c:	8c3b      	ldrh	r3, [r7, #32]
   2583e:	1ad3      	subs	r3, r2, r3
   25840:	b29b      	uxth	r3, r3
   25842:	3b01      	subs	r3, #1
   25844:	83fb      	strh	r3, [r7, #30]
        // There is only 1 byte intended to encode length
        if (length > 0x00FF)
   25846:	8bfb      	ldrh	r3, [r7, #30]
   25848:	2bff      	cmp	r3, #255	; 0xff
   2584a:	d901      	bls.n	25850 <uuid_list_sized_encode+0x122>
        {
            return NRF_ERROR_DATA_SIZE;
   2584c:	230c      	movs	r3, #12
   2584e:	e006      	b.n	2585e <uuid_list_sized_encode+0x130>
        }
        p_encoded_data[start_pos] = (uint8_t)length;
   25850:	8c3b      	ldrh	r3, [r7, #32]
   25852:	687a      	ldr	r2, [r7, #4]
   25854:	4413      	add	r3, r2
   25856:	8bfa      	ldrh	r2, [r7, #30]
   25858:	b2d2      	uxtb	r2, r2
   2585a:	701a      	strb	r2, [r3, #0]
    }

    return NRF_SUCCESS;
   2585c:	2300      	movs	r3, #0
}
   2585e:	4618      	mov	r0, r3
   25860:	3728      	adds	r7, #40	; 0x28
   25862:	46bd      	mov	sp, r7
   25864:	bd80      	pop	{r7, pc}

00025866 <uuid_list_encode>:
                                 uint8_t                         adv_type_16,
                                 uint8_t                         adv_type_128,
                                 uint8_t                       * p_encoded_data,
                                 uint16_t                      * p_offset,
                                 uint16_t                        max_size)
{
   25866:	b580      	push	{r7, lr}
   25868:	b088      	sub	sp, #32
   2586a:	af02      	add	r7, sp, #8
   2586c:	60f8      	str	r0, [r7, #12]
   2586e:	607b      	str	r3, [r7, #4]
   25870:	460b      	mov	r3, r1
   25872:	72fb      	strb	r3, [r7, #11]
   25874:	4613      	mov	r3, r2
   25876:	72bb      	strb	r3, [r7, #10]
    uint32_t err_code;

    // Encode 16 bit UUIDs.
    err_code = uuid_list_sized_encode(p_uuid_list,
   25878:	7af9      	ldrb	r1, [r7, #11]
   2587a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   2587c:	9301      	str	r3, [sp, #4]
   2587e:	6a3b      	ldr	r3, [r7, #32]
   25880:	9300      	str	r3, [sp, #0]
   25882:	687b      	ldr	r3, [r7, #4]
   25884:	2202      	movs	r2, #2
   25886:	68f8      	ldr	r0, [r7, #12]
   25888:	f7ff ff51 	bl	2572e <uuid_list_sized_encode>
   2588c:	6178      	str	r0, [r7, #20]
                                      adv_type_16,
                                      sizeof(uint16_le_t),
                                      p_encoded_data,
                                      p_offset,
                                      max_size);
    VERIFY_SUCCESS(err_code);
   2588e:	697b      	ldr	r3, [r7, #20]
   25890:	2b00      	cmp	r3, #0
   25892:	d001      	beq.n	25898 <uuid_list_encode+0x32>
   25894:	697b      	ldr	r3, [r7, #20]
   25896:	e010      	b.n	258ba <uuid_list_encode+0x54>

    // Encode 128 bit UUIDs.
    err_code = uuid_list_sized_encode(p_uuid_list,
   25898:	7ab9      	ldrb	r1, [r7, #10]
   2589a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   2589c:	9301      	str	r3, [sp, #4]
   2589e:	6a3b      	ldr	r3, [r7, #32]
   258a0:	9300      	str	r3, [sp, #0]
   258a2:	687b      	ldr	r3, [r7, #4]
   258a4:	2210      	movs	r2, #16
   258a6:	68f8      	ldr	r0, [r7, #12]
   258a8:	f7ff ff41 	bl	2572e <uuid_list_sized_encode>
   258ac:	6178      	str	r0, [r7, #20]
                                      adv_type_128,
                                      sizeof(ble_uuid128_t),
                                      p_encoded_data,
                                      p_offset,
                                      max_size);
    VERIFY_SUCCESS(err_code);
   258ae:	697b      	ldr	r3, [r7, #20]
   258b0:	2b00      	cmp	r3, #0
   258b2:	d001      	beq.n	258b8 <uuid_list_encode+0x52>
   258b4:	697b      	ldr	r3, [r7, #20]
   258b6:	e000      	b.n	258ba <uuid_list_encode+0x54>

    return NRF_SUCCESS;
   258b8:	2300      	movs	r3, #0
}
   258ba:	4618      	mov	r0, r3
   258bc:	3718      	adds	r7, #24
   258be:	46bd      	mov	sp, r7
   258c0:	bd80      	pop	{r7, pc}

000258c2 <conn_int_check>:


static uint32_t conn_int_check(const ble_advdata_conn_int_t *p_conn_int)
{
   258c2:	b480      	push	{r7}
   258c4:	b083      	sub	sp, #12
   258c6:	af00      	add	r7, sp, #0
   258c8:	6078      	str	r0, [r7, #4]
    // Check Minimum Connection Interval.
    if ((p_conn_int->min_conn_interval < 0x0006) ||
   258ca:	687b      	ldr	r3, [r7, #4]
   258cc:	881b      	ldrh	r3, [r3, #0]
   258ce:	2b05      	cmp	r3, #5
   258d0:	d90a      	bls.n	258e8 <conn_int_check+0x26>
        (
            (p_conn_int->min_conn_interval > 0x0c80) &&
   258d2:	687b      	ldr	r3, [r7, #4]
   258d4:	881b      	ldrh	r3, [r3, #0]
    if ((p_conn_int->min_conn_interval < 0x0006) ||
   258d6:	f5b3 6f48 	cmp.w	r3, #3200	; 0xc80
   258da:	d907      	bls.n	258ec <conn_int_check+0x2a>
            (p_conn_int->min_conn_interval != 0xffff)
   258dc:	687b      	ldr	r3, [r7, #4]
   258de:	881b      	ldrh	r3, [r3, #0]
            (p_conn_int->min_conn_interval > 0x0c80) &&
   258e0:	f64f 72ff 	movw	r2, #65535	; 0xffff
   258e4:	4293      	cmp	r3, r2
   258e6:	d001      	beq.n	258ec <conn_int_check+0x2a>
        )
       )
    {
        return NRF_ERROR_INVALID_PARAM;
   258e8:	2307      	movs	r3, #7
   258ea:	e025      	b.n	25938 <conn_int_check+0x76>
    }

    // Check Maximum Connection Interval.
    if ((p_conn_int->max_conn_interval < 0x0006) ||
   258ec:	687b      	ldr	r3, [r7, #4]
   258ee:	885b      	ldrh	r3, [r3, #2]
   258f0:	2b05      	cmp	r3, #5
   258f2:	d90a      	bls.n	2590a <conn_int_check+0x48>
        (
            (p_conn_int->max_conn_interval > 0x0c80) &&
   258f4:	687b      	ldr	r3, [r7, #4]
   258f6:	885b      	ldrh	r3, [r3, #2]
    if ((p_conn_int->max_conn_interval < 0x0006) ||
   258f8:	f5b3 6f48 	cmp.w	r3, #3200	; 0xc80
   258fc:	d907      	bls.n	2590e <conn_int_check+0x4c>
            (p_conn_int->max_conn_interval != 0xffff)
   258fe:	687b      	ldr	r3, [r7, #4]
   25900:	885b      	ldrh	r3, [r3, #2]
            (p_conn_int->max_conn_interval > 0x0c80) &&
   25902:	f64f 72ff 	movw	r2, #65535	; 0xffff
   25906:	4293      	cmp	r3, r2
   25908:	d001      	beq.n	2590e <conn_int_check+0x4c>
        )
       )
    {
        return NRF_ERROR_INVALID_PARAM;
   2590a:	2307      	movs	r3, #7
   2590c:	e014      	b.n	25938 <conn_int_check+0x76>
    }

    // Make sure Minimum Connection Interval is not bigger than Maximum Connection Interval.
    if ((p_conn_int->min_conn_interval != 0xffff) &&
   2590e:	687b      	ldr	r3, [r7, #4]
   25910:	881b      	ldrh	r3, [r3, #0]
   25912:	f64f 72ff 	movw	r2, #65535	; 0xffff
   25916:	4293      	cmp	r3, r2
   25918:	d00d      	beq.n	25936 <conn_int_check+0x74>
        (p_conn_int->max_conn_interval != 0xffff) &&
   2591a:	687b      	ldr	r3, [r7, #4]
   2591c:	885b      	ldrh	r3, [r3, #2]
    if ((p_conn_int->min_conn_interval != 0xffff) &&
   2591e:	f64f 72ff 	movw	r2, #65535	; 0xffff
   25922:	4293      	cmp	r3, r2
   25924:	d007      	beq.n	25936 <conn_int_check+0x74>
        (p_conn_int->min_conn_interval > p_conn_int->max_conn_interval)
   25926:	687b      	ldr	r3, [r7, #4]
   25928:	881a      	ldrh	r2, [r3, #0]
   2592a:	687b      	ldr	r3, [r7, #4]
   2592c:	885b      	ldrh	r3, [r3, #2]
        (p_conn_int->max_conn_interval != 0xffff) &&
   2592e:	429a      	cmp	r2, r3
   25930:	d901      	bls.n	25936 <conn_int_check+0x74>
        )
    {
        return NRF_ERROR_INVALID_PARAM;
   25932:	2307      	movs	r3, #7
   25934:	e000      	b.n	25938 <conn_int_check+0x76>
    }

    return NRF_SUCCESS;
   25936:	2300      	movs	r3, #0
}
   25938:	4618      	mov	r0, r3
   2593a:	370c      	adds	r7, #12
   2593c:	46bd      	mov	sp, r7
   2593e:	bc80      	pop	{r7}
   25940:	4770      	bx	lr

00025942 <conn_int_encode>:

static uint32_t conn_int_encode(const ble_advdata_conn_int_t * p_conn_int,
                                uint8_t                      * p_encoded_data,
                                uint16_t                     * p_offset,
                                uint16_t                       max_size)
{
   25942:	b580      	push	{r7, lr}
   25944:	b086      	sub	sp, #24
   25946:	af00      	add	r7, sp, #0
   25948:	60f8      	str	r0, [r7, #12]
   2594a:	60b9      	str	r1, [r7, #8]
   2594c:	607a      	str	r2, [r7, #4]
   2594e:	807b      	strh	r3, [r7, #2]
    uint32_t err_code;

    // Check for buffer overflow.
    if (((*p_offset) + AD_TYPE_CONN_INT_SIZE) > max_size)
   25950:	687b      	ldr	r3, [r7, #4]
   25952:	881b      	ldrh	r3, [r3, #0]
   25954:	1d9a      	adds	r2, r3, #6
   25956:	887b      	ldrh	r3, [r7, #2]
   25958:	429a      	cmp	r2, r3
   2595a:	d901      	bls.n	25960 <conn_int_encode+0x1e>
    {
        return NRF_ERROR_DATA_SIZE;
   2595c:	230c      	movs	r3, #12
   2595e:	e04b      	b.n	259f8 <conn_int_encode+0xb6>
    }

    // Check parameters.
    err_code = conn_int_check(p_conn_int);
   25960:	68f8      	ldr	r0, [r7, #12]
   25962:	f7ff ffae 	bl	258c2 <conn_int_check>
   25966:	6178      	str	r0, [r7, #20]
    VERIFY_SUCCESS(err_code);
   25968:	697b      	ldr	r3, [r7, #20]
   2596a:	2b00      	cmp	r3, #0
   2596c:	d001      	beq.n	25972 <conn_int_encode+0x30>
   2596e:	697b      	ldr	r3, [r7, #20]
   25970:	e042      	b.n	259f8 <conn_int_encode+0xb6>

    // Encode Length and AD Type.
    p_encoded_data[*p_offset]  = (uint8_t)(AD_TYPE_FIELD_SIZE + AD_TYPE_CONN_INT_DATA_SIZE);
   25972:	687b      	ldr	r3, [r7, #4]
   25974:	881b      	ldrh	r3, [r3, #0]
   25976:	461a      	mov	r2, r3
   25978:	68bb      	ldr	r3, [r7, #8]
   2597a:	4413      	add	r3, r2
   2597c:	2205      	movs	r2, #5
   2597e:	701a      	strb	r2, [r3, #0]
    *p_offset                 += AD_LENGTH_FIELD_SIZE;
   25980:	687b      	ldr	r3, [r7, #4]
   25982:	881b      	ldrh	r3, [r3, #0]
   25984:	3301      	adds	r3, #1
   25986:	b29a      	uxth	r2, r3
   25988:	687b      	ldr	r3, [r7, #4]
   2598a:	801a      	strh	r2, [r3, #0]
    p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_SLAVE_CONNECTION_INTERVAL_RANGE;
   2598c:	687b      	ldr	r3, [r7, #4]
   2598e:	881b      	ldrh	r3, [r3, #0]
   25990:	461a      	mov	r2, r3
   25992:	68bb      	ldr	r3, [r7, #8]
   25994:	4413      	add	r3, r2
   25996:	2212      	movs	r2, #18
   25998:	701a      	strb	r2, [r3, #0]
    *p_offset                 += AD_TYPE_FIELD_SIZE;
   2599a:	687b      	ldr	r3, [r7, #4]
   2599c:	881b      	ldrh	r3, [r3, #0]
   2599e:	3301      	adds	r3, #1
   259a0:	b29a      	uxth	r2, r3
   259a2:	687b      	ldr	r3, [r7, #4]
   259a4:	801a      	strh	r2, [r3, #0]

    // Encode Minimum and Maximum Connection Intervals.
    *p_offset += uint16_encode(p_conn_int->min_conn_interval, &p_encoded_data[*p_offset]);
   259a6:	68fb      	ldr	r3, [r7, #12]
   259a8:	881a      	ldrh	r2, [r3, #0]
   259aa:	687b      	ldr	r3, [r7, #4]
   259ac:	881b      	ldrh	r3, [r3, #0]
   259ae:	4619      	mov	r1, r3
   259b0:	68bb      	ldr	r3, [r7, #8]
   259b2:	440b      	add	r3, r1
   259b4:	4619      	mov	r1, r3
   259b6:	4610      	mov	r0, r2
   259b8:	f7ff fce4 	bl	25384 <uint16_encode>
   259bc:	4603      	mov	r3, r0
   259be:	4619      	mov	r1, r3
   259c0:	687b      	ldr	r3, [r7, #4]
   259c2:	881a      	ldrh	r2, [r3, #0]
   259c4:	b28b      	uxth	r3, r1
   259c6:	4413      	add	r3, r2
   259c8:	b29a      	uxth	r2, r3
   259ca:	687b      	ldr	r3, [r7, #4]
   259cc:	801a      	strh	r2, [r3, #0]
    *p_offset += uint16_encode(p_conn_int->max_conn_interval, &p_encoded_data[*p_offset]);
   259ce:	68fb      	ldr	r3, [r7, #12]
   259d0:	885a      	ldrh	r2, [r3, #2]
   259d2:	687b      	ldr	r3, [r7, #4]
   259d4:	881b      	ldrh	r3, [r3, #0]
   259d6:	4619      	mov	r1, r3
   259d8:	68bb      	ldr	r3, [r7, #8]
   259da:	440b      	add	r3, r1
   259dc:	4619      	mov	r1, r3
   259de:	4610      	mov	r0, r2
   259e0:	f7ff fcd0 	bl	25384 <uint16_encode>
   259e4:	4603      	mov	r3, r0
   259e6:	4619      	mov	r1, r3
   259e8:	687b      	ldr	r3, [r7, #4]
   259ea:	881a      	ldrh	r2, [r3, #0]
   259ec:	b28b      	uxth	r3, r1
   259ee:	4413      	add	r3, r2
   259f0:	b29a      	uxth	r2, r3
   259f2:	687b      	ldr	r3, [r7, #4]
   259f4:	801a      	strh	r2, [r3, #0]

    return NRF_SUCCESS;
   259f6:	2300      	movs	r3, #0
}
   259f8:	4618      	mov	r0, r3
   259fa:	3718      	adds	r7, #24
   259fc:	46bd      	mov	sp, r7
   259fe:	bd80      	pop	{r7, pc}

00025a00 <manuf_specific_data_encode>:

static uint32_t manuf_specific_data_encode(const ble_advdata_manuf_data_t * p_manuf_sp_data,
                                           uint8_t                        * p_encoded_data,
                                           uint16_t                       * p_offset,
                                           uint16_t                         max_size)
{
   25a00:	b580      	push	{r7, lr}
   25a02:	b086      	sub	sp, #24
   25a04:	af00      	add	r7, sp, #0
   25a06:	60f8      	str	r0, [r7, #12]
   25a08:	60b9      	str	r1, [r7, #8]
   25a0a:	607a      	str	r2, [r7, #4]
   25a0c:	807b      	strh	r3, [r7, #2]
    uint32_t data_size = AD_TYPE_MANUF_SPEC_DATA_ID_SIZE + p_manuf_sp_data->data.size;
   25a0e:	68fb      	ldr	r3, [r7, #12]
   25a10:	889b      	ldrh	r3, [r3, #4]
   25a12:	3302      	adds	r3, #2
   25a14:	617b      	str	r3, [r7, #20]

    // Check for buffer overflow.
    if (((*p_offset) + AD_DATA_OFFSET + data_size) > max_size)
   25a16:	687b      	ldr	r3, [r7, #4]
   25a18:	881b      	ldrh	r3, [r3, #0]
   25a1a:	461a      	mov	r2, r3
   25a1c:	697b      	ldr	r3, [r7, #20]
   25a1e:	4413      	add	r3, r2
   25a20:	1c9a      	adds	r2, r3, #2
   25a22:	887b      	ldrh	r3, [r7, #2]
   25a24:	429a      	cmp	r2, r3
   25a26:	d901      	bls.n	25a2c <manuf_specific_data_encode+0x2c>
    {
        return NRF_ERROR_DATA_SIZE;
   25a28:	230c      	movs	r3, #12
   25a2a:	e054      	b.n	25ad6 <manuf_specific_data_encode+0xd6>
    }

    // There is only 1 byte intended to encode length which is (data_size + AD_TYPE_FIELD_SIZE)
    if (data_size > (0x00FF - AD_TYPE_FIELD_SIZE))
   25a2c:	697b      	ldr	r3, [r7, #20]
   25a2e:	2bfe      	cmp	r3, #254	; 0xfe
   25a30:	d901      	bls.n	25a36 <manuf_specific_data_encode+0x36>
    {
        return NRF_ERROR_DATA_SIZE;
   25a32:	230c      	movs	r3, #12
   25a34:	e04f      	b.n	25ad6 <manuf_specific_data_encode+0xd6>
    }

    // Encode Length and AD Type.
    p_encoded_data[*p_offset]  = (uint8_t)(AD_TYPE_FIELD_SIZE + data_size);
   25a36:	697b      	ldr	r3, [r7, #20]
   25a38:	b2da      	uxtb	r2, r3
   25a3a:	687b      	ldr	r3, [r7, #4]
   25a3c:	881b      	ldrh	r3, [r3, #0]
   25a3e:	4619      	mov	r1, r3
   25a40:	68bb      	ldr	r3, [r7, #8]
   25a42:	440b      	add	r3, r1
   25a44:	3201      	adds	r2, #1
   25a46:	b2d2      	uxtb	r2, r2
   25a48:	701a      	strb	r2, [r3, #0]
    *p_offset                 += AD_LENGTH_FIELD_SIZE;
   25a4a:	687b      	ldr	r3, [r7, #4]
   25a4c:	881b      	ldrh	r3, [r3, #0]
   25a4e:	3301      	adds	r3, #1
   25a50:	b29a      	uxth	r2, r3
   25a52:	687b      	ldr	r3, [r7, #4]
   25a54:	801a      	strh	r2, [r3, #0]
    p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA;
   25a56:	687b      	ldr	r3, [r7, #4]
   25a58:	881b      	ldrh	r3, [r3, #0]
   25a5a:	461a      	mov	r2, r3
   25a5c:	68bb      	ldr	r3, [r7, #8]
   25a5e:	4413      	add	r3, r2
   25a60:	22ff      	movs	r2, #255	; 0xff
   25a62:	701a      	strb	r2, [r3, #0]
    *p_offset                 += AD_TYPE_FIELD_SIZE;
   25a64:	687b      	ldr	r3, [r7, #4]
   25a66:	881b      	ldrh	r3, [r3, #0]
   25a68:	3301      	adds	r3, #1
   25a6a:	b29a      	uxth	r2, r3
   25a6c:	687b      	ldr	r3, [r7, #4]
   25a6e:	801a      	strh	r2, [r3, #0]

    // Encode Company Identifier.
    *p_offset += uint16_encode(p_manuf_sp_data->company_identifier, &p_encoded_data[*p_offset]);
   25a70:	68fb      	ldr	r3, [r7, #12]
   25a72:	881a      	ldrh	r2, [r3, #0]
   25a74:	687b      	ldr	r3, [r7, #4]
   25a76:	881b      	ldrh	r3, [r3, #0]
   25a78:	4619      	mov	r1, r3
   25a7a:	68bb      	ldr	r3, [r7, #8]
   25a7c:	440b      	add	r3, r1
   25a7e:	4619      	mov	r1, r3
   25a80:	4610      	mov	r0, r2
   25a82:	f7ff fc7f 	bl	25384 <uint16_encode>
   25a86:	4603      	mov	r3, r0
   25a88:	4619      	mov	r1, r3
   25a8a:	687b      	ldr	r3, [r7, #4]
   25a8c:	881a      	ldrh	r2, [r3, #0]
   25a8e:	b28b      	uxth	r3, r1
   25a90:	4413      	add	r3, r2
   25a92:	b29a      	uxth	r2, r3
   25a94:	687b      	ldr	r3, [r7, #4]
   25a96:	801a      	strh	r2, [r3, #0]

    // Encode additional manufacturer specific data.
    if (p_manuf_sp_data->data.size > 0)
   25a98:	68fb      	ldr	r3, [r7, #12]
   25a9a:	889b      	ldrh	r3, [r3, #4]
   25a9c:	2b00      	cmp	r3, #0
   25a9e:	d019      	beq.n	25ad4 <manuf_specific_data_encode+0xd4>
    {
        if (p_manuf_sp_data->data.p_data == NULL)
   25aa0:	68fb      	ldr	r3, [r7, #12]
   25aa2:	689b      	ldr	r3, [r3, #8]
   25aa4:	2b00      	cmp	r3, #0
   25aa6:	d101      	bne.n	25aac <manuf_specific_data_encode+0xac>
        {
            return NRF_ERROR_INVALID_PARAM;
   25aa8:	2307      	movs	r3, #7
   25aaa:	e014      	b.n	25ad6 <manuf_specific_data_encode+0xd6>
        }
        memcpy(&p_encoded_data[*p_offset], p_manuf_sp_data->data.p_data, p_manuf_sp_data->data.size);
   25aac:	687b      	ldr	r3, [r7, #4]
   25aae:	881b      	ldrh	r3, [r3, #0]
   25ab0:	461a      	mov	r2, r3
   25ab2:	68bb      	ldr	r3, [r7, #8]
   25ab4:	1898      	adds	r0, r3, r2
   25ab6:	68fb      	ldr	r3, [r7, #12]
   25ab8:	6899      	ldr	r1, [r3, #8]
   25aba:	68fb      	ldr	r3, [r7, #12]
   25abc:	889b      	ldrh	r3, [r3, #4]
   25abe:	461a      	mov	r2, r3
   25ac0:	f001 fea2 	bl	27808 <memcpy>
        *p_offset += p_manuf_sp_data->data.size;
   25ac4:	687b      	ldr	r3, [r7, #4]
   25ac6:	881a      	ldrh	r2, [r3, #0]
   25ac8:	68fb      	ldr	r3, [r7, #12]
   25aca:	889b      	ldrh	r3, [r3, #4]
   25acc:	4413      	add	r3, r2
   25ace:	b29a      	uxth	r2, r3
   25ad0:	687b      	ldr	r3, [r7, #4]
   25ad2:	801a      	strh	r2, [r3, #0]
    }

    return NRF_SUCCESS;
   25ad4:	2300      	movs	r3, #0
}
   25ad6:	4618      	mov	r0, r3
   25ad8:	3718      	adds	r7, #24
   25ada:	46bd      	mov	sp, r7
   25adc:	bd80      	pop	{r7, pc}

00025ade <service_data_encode>:
// Implemented only for 16-bit UUIDs
static uint32_t service_data_encode(const ble_advdata_t * p_advdata,
                                    uint8_t             * p_encoded_data,
                                    uint16_t            * p_offset,
                                    uint16_t              max_size)
{
   25ade:	b580      	push	{r7, lr}
   25ae0:	b088      	sub	sp, #32
   25ae2:	af00      	add	r7, sp, #0
   25ae4:	60f8      	str	r0, [r7, #12]
   25ae6:	60b9      	str	r1, [r7, #8]
   25ae8:	607a      	str	r2, [r7, #4]
   25aea:	807b      	strh	r3, [r7, #2]
    uint8_t i;

    // Check parameter consistency.
    if (p_advdata->p_service_data_array == NULL)
   25aec:	68fb      	ldr	r3, [r7, #12]
   25aee:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   25af0:	2b00      	cmp	r3, #0
   25af2:	d101      	bne.n	25af8 <service_data_encode+0x1a>
    {
        return NRF_ERROR_INVALID_PARAM;
   25af4:	2307      	movs	r3, #7
   25af6:	e06d      	b.n	25bd4 <service_data_encode+0xf6>
    }

    for (i = 0; i < p_advdata->service_data_count; i++)
   25af8:	2300      	movs	r3, #0
   25afa:	77fb      	strb	r3, [r7, #31]
   25afc:	e063      	b.n	25bc6 <service_data_encode+0xe8>
    {
        ble_advdata_service_data_t * p_service_data;
        uint32_t                     data_size;

        p_service_data = &p_advdata->p_service_data_array[i];
   25afe:	68fb      	ldr	r3, [r7, #12]
   25b00:	6a99      	ldr	r1, [r3, #40]	; 0x28
   25b02:	7ffa      	ldrb	r2, [r7, #31]
   25b04:	4613      	mov	r3, r2
   25b06:	005b      	lsls	r3, r3, #1
   25b08:	4413      	add	r3, r2
   25b0a:	009b      	lsls	r3, r3, #2
   25b0c:	440b      	add	r3, r1
   25b0e:	61bb      	str	r3, [r7, #24]
        // For now implemented only for 16-bit UUIDs
        data_size      = AD_TYPE_SERV_DATA_16BIT_UUID_SIZE + p_service_data->data.size;
   25b10:	69bb      	ldr	r3, [r7, #24]
   25b12:	889b      	ldrh	r3, [r3, #4]
   25b14:	3302      	adds	r3, #2
   25b16:	617b      	str	r3, [r7, #20]

        // There is only 1 byte intended to encode length which is (data_size + AD_TYPE_FIELD_SIZE)
        if (data_size > (0x00FF - AD_TYPE_FIELD_SIZE))
   25b18:	697b      	ldr	r3, [r7, #20]
   25b1a:	2bfe      	cmp	r3, #254	; 0xfe
   25b1c:	d901      	bls.n	25b22 <service_data_encode+0x44>
        {
            return NRF_ERROR_DATA_SIZE;
   25b1e:	230c      	movs	r3, #12
   25b20:	e058      	b.n	25bd4 <service_data_encode+0xf6>
        }

        // Encode Length and AD Type.
        p_encoded_data[*p_offset]  = (uint8_t)(AD_TYPE_FIELD_SIZE + data_size);
   25b22:	697b      	ldr	r3, [r7, #20]
   25b24:	b2da      	uxtb	r2, r3
   25b26:	687b      	ldr	r3, [r7, #4]
   25b28:	881b      	ldrh	r3, [r3, #0]
   25b2a:	4619      	mov	r1, r3
   25b2c:	68bb      	ldr	r3, [r7, #8]
   25b2e:	440b      	add	r3, r1
   25b30:	3201      	adds	r2, #1
   25b32:	b2d2      	uxtb	r2, r2
   25b34:	701a      	strb	r2, [r3, #0]
        *p_offset                 += AD_LENGTH_FIELD_SIZE;
   25b36:	687b      	ldr	r3, [r7, #4]
   25b38:	881b      	ldrh	r3, [r3, #0]
   25b3a:	3301      	adds	r3, #1
   25b3c:	b29a      	uxth	r2, r3
   25b3e:	687b      	ldr	r3, [r7, #4]
   25b40:	801a      	strh	r2, [r3, #0]
        p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_SERVICE_DATA;
   25b42:	687b      	ldr	r3, [r7, #4]
   25b44:	881b      	ldrh	r3, [r3, #0]
   25b46:	461a      	mov	r2, r3
   25b48:	68bb      	ldr	r3, [r7, #8]
   25b4a:	4413      	add	r3, r2
   25b4c:	2216      	movs	r2, #22
   25b4e:	701a      	strb	r2, [r3, #0]
        *p_offset                 += AD_TYPE_FIELD_SIZE;
   25b50:	687b      	ldr	r3, [r7, #4]
   25b52:	881b      	ldrh	r3, [r3, #0]
   25b54:	3301      	adds	r3, #1
   25b56:	b29a      	uxth	r2, r3
   25b58:	687b      	ldr	r3, [r7, #4]
   25b5a:	801a      	strh	r2, [r3, #0]

        // Encode service 16-bit UUID.
        *p_offset += uint16_encode(p_service_data->service_uuid, &p_encoded_data[*p_offset]);
   25b5c:	69bb      	ldr	r3, [r7, #24]
   25b5e:	881a      	ldrh	r2, [r3, #0]
   25b60:	687b      	ldr	r3, [r7, #4]
   25b62:	881b      	ldrh	r3, [r3, #0]
   25b64:	4619      	mov	r1, r3
   25b66:	68bb      	ldr	r3, [r7, #8]
   25b68:	440b      	add	r3, r1
   25b6a:	4619      	mov	r1, r3
   25b6c:	4610      	mov	r0, r2
   25b6e:	f7ff fc09 	bl	25384 <uint16_encode>
   25b72:	4603      	mov	r3, r0
   25b74:	4619      	mov	r1, r3
   25b76:	687b      	ldr	r3, [r7, #4]
   25b78:	881a      	ldrh	r2, [r3, #0]
   25b7a:	b28b      	uxth	r3, r1
   25b7c:	4413      	add	r3, r2
   25b7e:	b29a      	uxth	r2, r3
   25b80:	687b      	ldr	r3, [r7, #4]
   25b82:	801a      	strh	r2, [r3, #0]

        // Encode additional service data.
        if (p_service_data->data.size > 0)
   25b84:	69bb      	ldr	r3, [r7, #24]
   25b86:	889b      	ldrh	r3, [r3, #4]
   25b88:	2b00      	cmp	r3, #0
   25b8a:	d019      	beq.n	25bc0 <service_data_encode+0xe2>
        {
            if (p_service_data->data.p_data == NULL)
   25b8c:	69bb      	ldr	r3, [r7, #24]
   25b8e:	689b      	ldr	r3, [r3, #8]
   25b90:	2b00      	cmp	r3, #0
   25b92:	d101      	bne.n	25b98 <service_data_encode+0xba>
            {
                return NRF_ERROR_INVALID_PARAM;
   25b94:	2307      	movs	r3, #7
   25b96:	e01d      	b.n	25bd4 <service_data_encode+0xf6>
            }
            memcpy(&p_encoded_data[*p_offset], p_service_data->data.p_data, p_service_data->data.size);
   25b98:	687b      	ldr	r3, [r7, #4]
   25b9a:	881b      	ldrh	r3, [r3, #0]
   25b9c:	461a      	mov	r2, r3
   25b9e:	68bb      	ldr	r3, [r7, #8]
   25ba0:	1898      	adds	r0, r3, r2
   25ba2:	69bb      	ldr	r3, [r7, #24]
   25ba4:	6899      	ldr	r1, [r3, #8]
   25ba6:	69bb      	ldr	r3, [r7, #24]
   25ba8:	889b      	ldrh	r3, [r3, #4]
   25baa:	461a      	mov	r2, r3
   25bac:	f001 fe2c 	bl	27808 <memcpy>
            *p_offset += p_service_data->data.size;
   25bb0:	687b      	ldr	r3, [r7, #4]
   25bb2:	881a      	ldrh	r2, [r3, #0]
   25bb4:	69bb      	ldr	r3, [r7, #24]
   25bb6:	889b      	ldrh	r3, [r3, #4]
   25bb8:	4413      	add	r3, r2
   25bba:	b29a      	uxth	r2, r3
   25bbc:	687b      	ldr	r3, [r7, #4]
   25bbe:	801a      	strh	r2, [r3, #0]
    for (i = 0; i < p_advdata->service_data_count; i++)
   25bc0:	7ffb      	ldrb	r3, [r7, #31]
   25bc2:	3301      	adds	r3, #1
   25bc4:	77fb      	strb	r3, [r7, #31]
   25bc6:	68fb      	ldr	r3, [r7, #12]
   25bc8:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
   25bcc:	7ffa      	ldrb	r2, [r7, #31]
   25bce:	429a      	cmp	r2, r3
   25bd0:	d395      	bcc.n	25afe <service_data_encode+0x20>
        }
    }

    return NRF_SUCCESS;
   25bd2:	2300      	movs	r3, #0
}
   25bd4:	4618      	mov	r0, r3
   25bd6:	3720      	adds	r7, #32
   25bd8:	46bd      	mov	sp, r7
   25bda:	bd80      	pop	{r7, pc}

00025bdc <ble_advdata_encode>:

uint32_t ble_advdata_encode(ble_advdata_t const * const p_advdata,
                            uint8_t             * const p_encoded_data,
                            uint16_t            * const p_len)
{
   25bdc:	b580      	push	{r7, lr}
   25bde:	b088      	sub	sp, #32
   25be0:	af02      	add	r7, sp, #8
   25be2:	60f8      	str	r0, [r7, #12]
   25be4:	60b9      	str	r1, [r7, #8]
   25be6:	607a      	str	r2, [r7, #4]
    uint32_t err_code = NRF_SUCCESS;
   25be8:	2300      	movs	r3, #0
   25bea:	617b      	str	r3, [r7, #20]
    uint16_t max_size = *p_len;
   25bec:	687b      	ldr	r3, [r7, #4]
   25bee:	881b      	ldrh	r3, [r3, #0]
   25bf0:	827b      	strh	r3, [r7, #18]
    *p_len = 0;
   25bf2:	687b      	ldr	r3, [r7, #4]
   25bf4:	2200      	movs	r2, #0
   25bf6:	801a      	strh	r2, [r3, #0]

    // Encode LE Bluetooth Device Address
    if (p_advdata->include_ble_device_addr)
   25bf8:	68fb      	ldr	r3, [r7, #12]
   25bfa:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
   25bfe:	2b00      	cmp	r3, #0
   25c00:	d00b      	beq.n	25c1a <ble_advdata_encode+0x3e>
    {
        err_code = ble_device_addr_encode(p_encoded_data, p_len, max_size);
   25c02:	8a7b      	ldrh	r3, [r7, #18]
   25c04:	461a      	mov	r2, r3
   25c06:	6879      	ldr	r1, [r7, #4]
   25c08:	68b8      	ldr	r0, [r7, #8]
   25c0a:	f7ff fbd2 	bl	253b2 <ble_device_addr_encode>
   25c0e:	6178      	str	r0, [r7, #20]
        VERIFY_SUCCESS(err_code);
   25c10:	697b      	ldr	r3, [r7, #20]
   25c12:	2b00      	cmp	r3, #0
   25c14:	d001      	beq.n	25c1a <ble_advdata_encode+0x3e>
   25c16:	697b      	ldr	r3, [r7, #20]
   25c18:	e0ba      	b.n	25d90 <ble_advdata_encode+0x1b4>
    }

    // Encode appearance.
    if (p_advdata->include_appearance)
   25c1a:	68fb      	ldr	r3, [r7, #12]
   25c1c:	789b      	ldrb	r3, [r3, #2]
   25c1e:	2b00      	cmp	r3, #0
   25c20:	d00b      	beq.n	25c3a <ble_advdata_encode+0x5e>
    {
        err_code = appearance_encode(p_encoded_data, p_len, max_size);
   25c22:	8a7b      	ldrh	r3, [r7, #18]
   25c24:	461a      	mov	r2, r3
   25c26:	6879      	ldr	r1, [r7, #4]
   25c28:	68b8      	ldr	r0, [r7, #8]
   25c2a:	f7ff fcb6 	bl	2559a <appearance_encode>
   25c2e:	6178      	str	r0, [r7, #20]
        VERIFY_SUCCESS(err_code);
   25c30:	697b      	ldr	r3, [r7, #20]
   25c32:	2b00      	cmp	r3, #0
   25c34:	d001      	beq.n	25c3a <ble_advdata_encode+0x5e>
   25c36:	697b      	ldr	r3, [r7, #20]
   25c38:	e0aa      	b.n	25d90 <ble_advdata_encode+0x1b4>
    }

    //Encode Flags
    if (p_advdata->flags != 0 )
   25c3a:	68fb      	ldr	r3, [r7, #12]
   25c3c:	78db      	ldrb	r3, [r3, #3]
   25c3e:	2b00      	cmp	r3, #0
   25c40:	d00d      	beq.n	25c5e <ble_advdata_encode+0x82>
    {
        err_code = flags_encode(p_advdata->flags, p_encoded_data, p_len, max_size);
   25c42:	68fb      	ldr	r3, [r7, #12]
   25c44:	78db      	ldrb	r3, [r3, #3]
   25c46:	b258      	sxtb	r0, r3
   25c48:	8a7b      	ldrh	r3, [r7, #18]
   25c4a:	687a      	ldr	r2, [r7, #4]
   25c4c:	68b9      	ldr	r1, [r7, #8]
   25c4e:	f7ff fcf0 	bl	25632 <flags_encode>
   25c52:	6178      	str	r0, [r7, #20]
        VERIFY_SUCCESS(err_code);
   25c54:	697b      	ldr	r3, [r7, #20]
   25c56:	2b00      	cmp	r3, #0
   25c58:	d001      	beq.n	25c5e <ble_advdata_encode+0x82>
   25c5a:	697b      	ldr	r3, [r7, #20]
   25c5c:	e098      	b.n	25d90 <ble_advdata_encode+0x1b4>
    }

    // Encode TX power level.
    if (p_advdata->p_tx_power_level != NULL)
   25c5e:	68fb      	ldr	r3, [r7, #12]
   25c60:	685b      	ldr	r3, [r3, #4]
   25c62:	2b00      	cmp	r3, #0
   25c64:	d00e      	beq.n	25c84 <ble_advdata_encode+0xa8>
    {
        err_code = tx_power_level_encode(*p_advdata->p_tx_power_level,
   25c66:	68fb      	ldr	r3, [r7, #12]
   25c68:	685b      	ldr	r3, [r3, #4]
   25c6a:	f993 0000 	ldrsb.w	r0, [r3]
   25c6e:	8a7b      	ldrh	r3, [r7, #18]
   25c70:	687a      	ldr	r2, [r7, #4]
   25c72:	68b9      	ldr	r1, [r7, #8]
   25c74:	f7ff fd1c 	bl	256b0 <tx_power_level_encode>
   25c78:	6178      	str	r0, [r7, #20]
                                         p_encoded_data,
                                         p_len,
                                         max_size);
        VERIFY_SUCCESS(err_code);
   25c7a:	697b      	ldr	r3, [r7, #20]
   25c7c:	2b00      	cmp	r3, #0
   25c7e:	d001      	beq.n	25c84 <ble_advdata_encode+0xa8>
   25c80:	697b      	ldr	r3, [r7, #20]
   25c82:	e085      	b.n	25d90 <ble_advdata_encode+0x1b4>
    }

    // Encode 'more available' uuid list.
    if (p_advdata->uuids_more_available.uuid_cnt > 0)
   25c84:	68fb      	ldr	r3, [r7, #12]
   25c86:	891b      	ldrh	r3, [r3, #8]
   25c88:	2b00      	cmp	r3, #0
   25c8a:	d011      	beq.n	25cb0 <ble_advdata_encode+0xd4>
    {
        err_code = uuid_list_encode(&p_advdata->uuids_more_available,
   25c8c:	68fb      	ldr	r3, [r7, #12]
   25c8e:	f103 0008 	add.w	r0, r3, #8
   25c92:	8a7b      	ldrh	r3, [r7, #18]
   25c94:	9301      	str	r3, [sp, #4]
   25c96:	687b      	ldr	r3, [r7, #4]
   25c98:	9300      	str	r3, [sp, #0]
   25c9a:	68bb      	ldr	r3, [r7, #8]
   25c9c:	2206      	movs	r2, #6
   25c9e:	2102      	movs	r1, #2
   25ca0:	f7ff fde1 	bl	25866 <uuid_list_encode>
   25ca4:	6178      	str	r0, [r7, #20]
                                    BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_MORE_AVAILABLE,
                                    BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_MORE_AVAILABLE,
                                    p_encoded_data,
                                    p_len,
                                    max_size);
        VERIFY_SUCCESS(err_code);
   25ca6:	697b      	ldr	r3, [r7, #20]
   25ca8:	2b00      	cmp	r3, #0
   25caa:	d001      	beq.n	25cb0 <ble_advdata_encode+0xd4>
   25cac:	697b      	ldr	r3, [r7, #20]
   25cae:	e06f      	b.n	25d90 <ble_advdata_encode+0x1b4>
    }

    // Encode 'complete' uuid list.
    if (p_advdata->uuids_complete.uuid_cnt > 0)
   25cb0:	68fb      	ldr	r3, [r7, #12]
   25cb2:	8a1b      	ldrh	r3, [r3, #16]
   25cb4:	2b00      	cmp	r3, #0
   25cb6:	d011      	beq.n	25cdc <ble_advdata_encode+0x100>
    {
        err_code = uuid_list_encode(&p_advdata->uuids_complete,
   25cb8:	68fb      	ldr	r3, [r7, #12]
   25cba:	f103 0010 	add.w	r0, r3, #16
   25cbe:	8a7b      	ldrh	r3, [r7, #18]
   25cc0:	9301      	str	r3, [sp, #4]
   25cc2:	687b      	ldr	r3, [r7, #4]
   25cc4:	9300      	str	r3, [sp, #0]
   25cc6:	68bb      	ldr	r3, [r7, #8]
   25cc8:	2207      	movs	r2, #7
   25cca:	2103      	movs	r1, #3
   25ccc:	f7ff fdcb 	bl	25866 <uuid_list_encode>
   25cd0:	6178      	str	r0, [r7, #20]
                                    BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_COMPLETE,
                                    BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_COMPLETE,
                                    p_encoded_data,
                                    p_len,
                                    max_size);
        VERIFY_SUCCESS(err_code);
   25cd2:	697b      	ldr	r3, [r7, #20]
   25cd4:	2b00      	cmp	r3, #0
   25cd6:	d001      	beq.n	25cdc <ble_advdata_encode+0x100>
   25cd8:	697b      	ldr	r3, [r7, #20]
   25cda:	e059      	b.n	25d90 <ble_advdata_encode+0x1b4>
    }

    // Encode 'solicited service' uuid list.
    if (p_advdata->uuids_solicited.uuid_cnt > 0)
   25cdc:	68fb      	ldr	r3, [r7, #12]
   25cde:	8b1b      	ldrh	r3, [r3, #24]
   25ce0:	2b00      	cmp	r3, #0
   25ce2:	d011      	beq.n	25d08 <ble_advdata_encode+0x12c>
    {
        err_code = uuid_list_encode(&p_advdata->uuids_solicited,
   25ce4:	68fb      	ldr	r3, [r7, #12]
   25ce6:	f103 0018 	add.w	r0, r3, #24
   25cea:	8a7b      	ldrh	r3, [r7, #18]
   25cec:	9301      	str	r3, [sp, #4]
   25cee:	687b      	ldr	r3, [r7, #4]
   25cf0:	9300      	str	r3, [sp, #0]
   25cf2:	68bb      	ldr	r3, [r7, #8]
   25cf4:	2215      	movs	r2, #21
   25cf6:	2114      	movs	r1, #20
   25cf8:	f7ff fdb5 	bl	25866 <uuid_list_encode>
   25cfc:	6178      	str	r0, [r7, #20]
                                    BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_16BIT,
                                    BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_128BIT,
                                    p_encoded_data,
                                    p_len,
                                    max_size);
        VERIFY_SUCCESS(err_code);
   25cfe:	697b      	ldr	r3, [r7, #20]
   25d00:	2b00      	cmp	r3, #0
   25d02:	d001      	beq.n	25d08 <ble_advdata_encode+0x12c>
   25d04:	697b      	ldr	r3, [r7, #20]
   25d06:	e043      	b.n	25d90 <ble_advdata_encode+0x1b4>
    }

    // Encode Slave Connection Interval Range.
    if (p_advdata->p_slave_conn_int != NULL)
   25d08:	68fb      	ldr	r3, [r7, #12]
   25d0a:	6a1b      	ldr	r3, [r3, #32]
   25d0c:	2b00      	cmp	r3, #0
   25d0e:	d00c      	beq.n	25d2a <ble_advdata_encode+0x14e>
    {
        err_code = conn_int_encode(p_advdata->p_slave_conn_int, p_encoded_data, p_len, max_size);
   25d10:	68fb      	ldr	r3, [r7, #12]
   25d12:	6a18      	ldr	r0, [r3, #32]
   25d14:	8a7b      	ldrh	r3, [r7, #18]
   25d16:	687a      	ldr	r2, [r7, #4]
   25d18:	68b9      	ldr	r1, [r7, #8]
   25d1a:	f7ff fe12 	bl	25942 <conn_int_encode>
   25d1e:	6178      	str	r0, [r7, #20]
        VERIFY_SUCCESS(err_code);
   25d20:	697b      	ldr	r3, [r7, #20]
   25d22:	2b00      	cmp	r3, #0
   25d24:	d001      	beq.n	25d2a <ble_advdata_encode+0x14e>
   25d26:	697b      	ldr	r3, [r7, #20]
   25d28:	e032      	b.n	25d90 <ble_advdata_encode+0x1b4>
    }

    // Encode Manufacturer Specific Data.
    if (p_advdata->p_manuf_specific_data != NULL)
   25d2a:	68fb      	ldr	r3, [r7, #12]
   25d2c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   25d2e:	2b00      	cmp	r3, #0
   25d30:	d00c      	beq.n	25d4c <ble_advdata_encode+0x170>
    {
        err_code = manuf_specific_data_encode(p_advdata->p_manuf_specific_data,
   25d32:	68fb      	ldr	r3, [r7, #12]
   25d34:	6a58      	ldr	r0, [r3, #36]	; 0x24
   25d36:	8a7b      	ldrh	r3, [r7, #18]
   25d38:	687a      	ldr	r2, [r7, #4]
   25d3a:	68b9      	ldr	r1, [r7, #8]
   25d3c:	f7ff fe60 	bl	25a00 <manuf_specific_data_encode>
   25d40:	6178      	str	r0, [r7, #20]
                                              p_encoded_data,
                                              p_len,
                                              max_size);
        VERIFY_SUCCESS(err_code);
   25d42:	697b      	ldr	r3, [r7, #20]
   25d44:	2b00      	cmp	r3, #0
   25d46:	d001      	beq.n	25d4c <ble_advdata_encode+0x170>
   25d48:	697b      	ldr	r3, [r7, #20]
   25d4a:	e021      	b.n	25d90 <ble_advdata_encode+0x1b4>
    }

    // Encode Service Data.
    if (p_advdata->service_data_count > 0)
   25d4c:	68fb      	ldr	r3, [r7, #12]
   25d4e:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
   25d52:	2b00      	cmp	r3, #0
   25d54:	d00b      	beq.n	25d6e <ble_advdata_encode+0x192>
    {
        err_code = service_data_encode(p_advdata, p_encoded_data, p_len, max_size);
   25d56:	8a7b      	ldrh	r3, [r7, #18]
   25d58:	687a      	ldr	r2, [r7, #4]
   25d5a:	68b9      	ldr	r1, [r7, #8]
   25d5c:	68f8      	ldr	r0, [r7, #12]
   25d5e:	f7ff febe 	bl	25ade <service_data_encode>
   25d62:	6178      	str	r0, [r7, #20]
        VERIFY_SUCCESS(err_code);
   25d64:	697b      	ldr	r3, [r7, #20]
   25d66:	2b00      	cmp	r3, #0
   25d68:	d001      	beq.n	25d6e <ble_advdata_encode+0x192>
   25d6a:	697b      	ldr	r3, [r7, #20]
   25d6c:	e010      	b.n	25d90 <ble_advdata_encode+0x1b4>
    }

    // Encode name. WARNING: it is encoded last on purpose since too long device name is truncated.
    if (p_advdata->name_type != BLE_ADVDATA_NO_NAME)
   25d6e:	68fb      	ldr	r3, [r7, #12]
   25d70:	781b      	ldrb	r3, [r3, #0]
   25d72:	2b00      	cmp	r3, #0
   25d74:	d00b      	beq.n	25d8e <ble_advdata_encode+0x1b2>
    {
        err_code = name_encode(p_advdata, p_encoded_data, p_len, max_size);
   25d76:	8a7b      	ldrh	r3, [r7, #18]
   25d78:	687a      	ldr	r2, [r7, #4]
   25d7a:	68b9      	ldr	r1, [r7, #8]
   25d7c:	68f8      	ldr	r0, [r7, #12]
   25d7e:	f7ff fb7f 	bl	25480 <name_encode>
   25d82:	6178      	str	r0, [r7, #20]
        VERIFY_SUCCESS(err_code);
   25d84:	697b      	ldr	r3, [r7, #20]
   25d86:	2b00      	cmp	r3, #0
   25d88:	d001      	beq.n	25d8e <ble_advdata_encode+0x1b2>
   25d8a:	697b      	ldr	r3, [r7, #20]
   25d8c:	e000      	b.n	25d90 <ble_advdata_encode+0x1b4>
    }

    return err_code;
   25d8e:	697b      	ldr	r3, [r7, #20]
}
   25d90:	4618      	mov	r0, r3
   25d92:	3718      	adds	r7, #24
   25d94:	46bd      	mov	sp, r7
   25d96:	bd80      	pop	{r7, pc}

00025d98 <advdata_check>:


static uint32_t advdata_check(const ble_advdata_t * p_advdata)
{
   25d98:	b480      	push	{r7}
   25d9a:	b083      	sub	sp, #12
   25d9c:	af00      	add	r7, sp, #0
   25d9e:	6078      	str	r0, [r7, #4]
    // Flags must be included in advertising data, and the BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED flag must be set.
    if (
        ((p_advdata->flags & BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED) == 0)
   25da0:	687b      	ldr	r3, [r7, #4]
   25da2:	78db      	ldrb	r3, [r3, #3]
   25da4:	f003 0304 	and.w	r3, r3, #4
    if (
   25da8:	2b00      	cmp	r3, #0
   25daa:	d101      	bne.n	25db0 <advdata_check+0x18>
       )
    {
        return NRF_ERROR_INVALID_PARAM;
   25dac:	2307      	movs	r3, #7
   25dae:	e000      	b.n	25db2 <advdata_check+0x1a>
    }

    return NRF_SUCCESS;
   25db0:	2300      	movs	r3, #0
}
   25db2:	4618      	mov	r0, r3
   25db4:	370c      	adds	r7, #12
   25db6:	46bd      	mov	sp, r7
   25db8:	bc80      	pop	{r7}
   25dba:	4770      	bx	lr

00025dbc <srdata_check>:


static uint32_t srdata_check(const ble_advdata_t * p_srdata)
{
   25dbc:	b480      	push	{r7}
   25dbe:	b083      	sub	sp, #12
   25dc0:	af00      	add	r7, sp, #0
   25dc2:	6078      	str	r0, [r7, #4]
    // Flags shall not be included in the scan response data.
    if (p_srdata->flags)
   25dc4:	687b      	ldr	r3, [r7, #4]
   25dc6:	78db      	ldrb	r3, [r3, #3]
   25dc8:	2b00      	cmp	r3, #0
   25dca:	d001      	beq.n	25dd0 <srdata_check+0x14>
    {
        return NRF_ERROR_INVALID_PARAM;
   25dcc:	2307      	movs	r3, #7
   25dce:	e000      	b.n	25dd2 <srdata_check+0x16>
    }

    return NRF_SUCCESS;
   25dd0:	2300      	movs	r3, #0
}
   25dd2:	4618      	mov	r0, r3
   25dd4:	370c      	adds	r7, #12
   25dd6:	46bd      	mov	sp, r7
   25dd8:	bc80      	pop	{r7}
   25dda:	4770      	bx	lr

00025ddc <ble_advdata_set>:


uint32_t ble_advdata_set(const ble_advdata_t * p_advdata, const ble_advdata_t * p_srdata)
{
   25ddc:	b580      	push	{r7, lr}
   25dde:	b096      	sub	sp, #88	; 0x58
   25de0:	af00      	add	r7, sp, #0
   25de2:	6078      	str	r0, [r7, #4]
   25de4:	6039      	str	r1, [r7, #0]
    uint32_t  err_code;
    uint16_t  len_advdata = BLE_GAP_ADV_MAX_SIZE;
   25de6:	231f      	movs	r3, #31
   25de8:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
    uint16_t  len_srdata  = BLE_GAP_ADV_MAX_SIZE;
   25dec:	231f      	movs	r3, #31
   25dee:	f8a7 3048 	strh.w	r3, [r7, #72]	; 0x48
    uint8_t   encoded_srdata[BLE_GAP_ADV_MAX_SIZE];
    uint8_t * p_encoded_advdata;
    uint8_t * p_encoded_srdata;

    // Encode advertising data (if supplied).
    if (p_advdata != NULL)
   25df2:	687b      	ldr	r3, [r7, #4]
   25df4:	2b00      	cmp	r3, #0
   25df6:	d01a      	beq.n	25e2e <ble_advdata_set+0x52>
    {
        err_code = advdata_check(p_advdata);
   25df8:	6878      	ldr	r0, [r7, #4]
   25dfa:	f7ff ffcd 	bl	25d98 <advdata_check>
   25dfe:	64f8      	str	r0, [r7, #76]	; 0x4c
        VERIFY_SUCCESS(err_code);
   25e00:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   25e02:	2b00      	cmp	r3, #0
   25e04:	d001      	beq.n	25e0a <ble_advdata_set+0x2e>
   25e06:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   25e08:	e044      	b.n	25e94 <ble_advdata_set+0xb8>

        err_code = ble_advdata_encode(p_advdata, encoded_advdata, &len_advdata);
   25e0a:	f107 024a 	add.w	r2, r7, #74	; 0x4a
   25e0e:	f107 0328 	add.w	r3, r7, #40	; 0x28
   25e12:	4619      	mov	r1, r3
   25e14:	6878      	ldr	r0, [r7, #4]
   25e16:	f7ff fee1 	bl	25bdc <ble_advdata_encode>
   25e1a:	64f8      	str	r0, [r7, #76]	; 0x4c
        VERIFY_SUCCESS(err_code);
   25e1c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   25e1e:	2b00      	cmp	r3, #0
   25e20:	d001      	beq.n	25e26 <ble_advdata_set+0x4a>
   25e22:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   25e24:	e036      	b.n	25e94 <ble_advdata_set+0xb8>
        p_encoded_advdata = encoded_advdata;
   25e26:	f107 0328 	add.w	r3, r7, #40	; 0x28
   25e2a:	657b      	str	r3, [r7, #84]	; 0x54
   25e2c:	e004      	b.n	25e38 <ble_advdata_set+0x5c>
    }
    else
    {
        p_encoded_advdata = NULL;
   25e2e:	2300      	movs	r3, #0
   25e30:	657b      	str	r3, [r7, #84]	; 0x54
        len_advdata = 0;
   25e32:	2300      	movs	r3, #0
   25e34:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
    }

    // Encode scan response data (if supplied).
    if (p_srdata != NULL)
   25e38:	683b      	ldr	r3, [r7, #0]
   25e3a:	2b00      	cmp	r3, #0
   25e3c:	d01a      	beq.n	25e74 <ble_advdata_set+0x98>
    {
        err_code = srdata_check(p_srdata);
   25e3e:	6838      	ldr	r0, [r7, #0]
   25e40:	f7ff ffbc 	bl	25dbc <srdata_check>
   25e44:	64f8      	str	r0, [r7, #76]	; 0x4c
        VERIFY_SUCCESS(err_code);
   25e46:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   25e48:	2b00      	cmp	r3, #0
   25e4a:	d001      	beq.n	25e50 <ble_advdata_set+0x74>
   25e4c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   25e4e:	e021      	b.n	25e94 <ble_advdata_set+0xb8>

        err_code = ble_advdata_encode(p_srdata, encoded_srdata, &len_srdata);
   25e50:	f107 0248 	add.w	r2, r7, #72	; 0x48
   25e54:	f107 0308 	add.w	r3, r7, #8
   25e58:	4619      	mov	r1, r3
   25e5a:	6838      	ldr	r0, [r7, #0]
   25e5c:	f7ff febe 	bl	25bdc <ble_advdata_encode>
   25e60:	64f8      	str	r0, [r7, #76]	; 0x4c
        VERIFY_SUCCESS(err_code);
   25e62:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   25e64:	2b00      	cmp	r3, #0
   25e66:	d001      	beq.n	25e6c <ble_advdata_set+0x90>
   25e68:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   25e6a:	e013      	b.n	25e94 <ble_advdata_set+0xb8>
        p_encoded_srdata = encoded_srdata;
   25e6c:	f107 0308 	add.w	r3, r7, #8
   25e70:	653b      	str	r3, [r7, #80]	; 0x50
   25e72:	e004      	b.n	25e7e <ble_advdata_set+0xa2>
    }
    else
    {
        p_encoded_srdata = NULL;
   25e74:	2300      	movs	r3, #0
   25e76:	653b      	str	r3, [r7, #80]	; 0x50
        len_srdata = 0;
   25e78:	2300      	movs	r3, #0
   25e7a:	f8a7 3048 	strh.w	r3, [r7, #72]	; 0x48
    }

    // Pass encoded advertising data and/or scan response data to the stack.
    return sd_ble_gap_adv_data_set(p_encoded_advdata, len_advdata, p_encoded_srdata, len_srdata);
   25e7e:	f8b7 304a 	ldrh.w	r3, [r7, #74]	; 0x4a
   25e82:	b2d9      	uxtb	r1, r3
   25e84:	f8b7 3048 	ldrh.w	r3, [r7, #72]	; 0x48
   25e88:	b2db      	uxtb	r3, r3
   25e8a:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   25e8c:	6d78      	ldr	r0, [r7, #84]	; 0x54
   25e8e:	f7ff fa69 	bl	25364 <sd_ble_gap_adv_data_set>
   25e92:	4603      	mov	r3, r0
}
   25e94:	4618      	mov	r0, r3
   25e96:	3758      	adds	r7, #88	; 0x58
   25e98:	46bd      	mov	sp, r7
   25e9a:	bd80      	pop	{r7, pc}

00025e9c <app_error_handler>:
 * @param[in] p_file_name Pointer to the file name.
 */

/*lint -save -e14 */
void app_error_handler(ret_code_t error_code, uint32_t line_num, const uint8_t * p_file_name)
{
   25e9c:	b580      	push	{r7, lr}
   25e9e:	b088      	sub	sp, #32
   25ea0:	af00      	add	r7, sp, #0
   25ea2:	60f8      	str	r0, [r7, #12]
   25ea4:	60b9      	str	r1, [r7, #8]
   25ea6:	607a      	str	r2, [r7, #4]
    error_info_t error_info =
   25ea8:	68bb      	ldr	r3, [r7, #8]
   25eaa:	b29b      	uxth	r3, r3
   25eac:	82bb      	strh	r3, [r7, #20]
   25eae:	687b      	ldr	r3, [r7, #4]
   25eb0:	61bb      	str	r3, [r7, #24]
   25eb2:	68fb      	ldr	r3, [r7, #12]
   25eb4:	61fb      	str	r3, [r7, #28]
    {
        .line_num    = line_num,
        .p_file_name = p_file_name,
        .err_code    = error_code,
    };
    app_error_fault_handler(NRF_FAULT_ID_SDK_ERROR, 0, (uint32_t)(&error_info));
   25eb6:	f107 0314 	add.w	r3, r7, #20
   25eba:	461a      	mov	r2, r3
   25ebc:	2100      	movs	r1, #0
   25ebe:	f244 0001 	movw	r0, #16385	; 0x4001
   25ec2:	f000 f851 	bl	25f68 <app_error_fault_handler>

    UNUSED_VARIABLE(error_info);
}
   25ec6:	bf00      	nop
   25ec8:	3720      	adds	r7, #32
   25eca:	46bd      	mov	sp, r7
   25ecc:	bd80      	pop	{r7, pc}
	...

00025ed0 <app_error_save_and_stop>:
    UNUSED_VARIABLE(error_info);
}


void app_error_save_and_stop(uint32_t id, uint32_t pc, uint32_t info)
{
   25ed0:	b480      	push	{r7}
   25ed2:	b087      	sub	sp, #28
   25ed4:	af00      	add	r7, sp, #0
   25ed6:	60f8      	str	r0, [r7, #12]
   25ed8:	60b9      	str	r1, [r7, #8]
   25eda:	607a      	str	r2, [r7, #4]
        const uint8_t * p_file_name;
    } m_error_data = {0};

    // The following variable helps Keil keep the call stack visible, in addition, it can be set to
    // 0 in the debugger to continue executing code after the error check.
    volatile bool loop = true;
   25edc:	2301      	movs	r3, #1
   25ede:	75fb      	strb	r3, [r7, #23]
    UNUSED_VARIABLE(loop);
   25ee0:	7dfb      	ldrb	r3, [r7, #23]

    m_error_data.fault_id   = id;
   25ee2:	4a20      	ldr	r2, [pc, #128]	; (25f64 <app_error_save_and_stop+0x94>)
   25ee4:	68fb      	ldr	r3, [r7, #12]
   25ee6:	6013      	str	r3, [r2, #0]
    m_error_data.pc         = pc;
   25ee8:	4a1e      	ldr	r2, [pc, #120]	; (25f64 <app_error_save_and_stop+0x94>)
   25eea:	68bb      	ldr	r3, [r7, #8]
   25eec:	6053      	str	r3, [r2, #4]
    m_error_data.error_info = info;
   25eee:	4a1d      	ldr	r2, [pc, #116]	; (25f64 <app_error_save_and_stop+0x94>)
   25ef0:	687b      	ldr	r3, [r7, #4]
   25ef2:	6093      	str	r3, [r2, #8]

    switch (id)
   25ef4:	68fb      	ldr	r3, [r7, #12]
   25ef6:	f244 0201 	movw	r2, #16385	; 0x4001
   25efa:	4293      	cmp	r3, r2
   25efc:	d012      	beq.n	25f24 <app_error_save_and_stop+0x54>
   25efe:	f244 0202 	movw	r2, #16386	; 0x4002
   25f02:	4293      	cmp	r3, r2
   25f04:	d122      	bne.n	25f4c <app_error_save_and_stop+0x7c>
    {
        case NRF_FAULT_ID_SDK_ASSERT:
            m_error_data.p_assert_info = (assert_info_t *)info;
   25f06:	687b      	ldr	r3, [r7, #4]
   25f08:	4a16      	ldr	r2, [pc, #88]	; (25f64 <app_error_save_and_stop+0x94>)
   25f0a:	60d3      	str	r3, [r2, #12]
            m_error_data.line_num      = m_error_data.p_assert_info->line_num;
   25f0c:	4b15      	ldr	r3, [pc, #84]	; (25f64 <app_error_save_and_stop+0x94>)
   25f0e:	68db      	ldr	r3, [r3, #12]
   25f10:	881b      	ldrh	r3, [r3, #0]
   25f12:	461a      	mov	r2, r3
   25f14:	4b13      	ldr	r3, [pc, #76]	; (25f64 <app_error_save_and_stop+0x94>)
   25f16:	619a      	str	r2, [r3, #24]
            m_error_data.p_file_name   = m_error_data.p_assert_info->p_file_name;
   25f18:	4b12      	ldr	r3, [pc, #72]	; (25f64 <app_error_save_and_stop+0x94>)
   25f1a:	68db      	ldr	r3, [r3, #12]
   25f1c:	685b      	ldr	r3, [r3, #4]
   25f1e:	4a11      	ldr	r2, [pc, #68]	; (25f64 <app_error_save_and_stop+0x94>)
   25f20:	61d3      	str	r3, [r2, #28]
            break;
   25f22:	e013      	b.n	25f4c <app_error_save_and_stop+0x7c>

        case NRF_FAULT_ID_SDK_ERROR:
            m_error_data.p_error_info = (error_info_t *)info;
   25f24:	687b      	ldr	r3, [r7, #4]
   25f26:	4a0f      	ldr	r2, [pc, #60]	; (25f64 <app_error_save_and_stop+0x94>)
   25f28:	6113      	str	r3, [r2, #16]
            m_error_data.err_code     = m_error_data.p_error_info->err_code;
   25f2a:	4b0e      	ldr	r3, [pc, #56]	; (25f64 <app_error_save_and_stop+0x94>)
   25f2c:	691b      	ldr	r3, [r3, #16]
   25f2e:	689b      	ldr	r3, [r3, #8]
   25f30:	4a0c      	ldr	r2, [pc, #48]	; (25f64 <app_error_save_and_stop+0x94>)
   25f32:	6153      	str	r3, [r2, #20]
            m_error_data.line_num     = m_error_data.p_error_info->line_num;
   25f34:	4b0b      	ldr	r3, [pc, #44]	; (25f64 <app_error_save_and_stop+0x94>)
   25f36:	691b      	ldr	r3, [r3, #16]
   25f38:	881b      	ldrh	r3, [r3, #0]
   25f3a:	461a      	mov	r2, r3
   25f3c:	4b09      	ldr	r3, [pc, #36]	; (25f64 <app_error_save_and_stop+0x94>)
   25f3e:	619a      	str	r2, [r3, #24]
            m_error_data.p_file_name  = m_error_data.p_error_info->p_file_name;
   25f40:	4b08      	ldr	r3, [pc, #32]	; (25f64 <app_error_save_and_stop+0x94>)
   25f42:	691b      	ldr	r3, [r3, #16]
   25f44:	685b      	ldr	r3, [r3, #4]
   25f46:	4a07      	ldr	r2, [pc, #28]	; (25f64 <app_error_save_and_stop+0x94>)
   25f48:	61d3      	str	r3, [r2, #28]
            break;
   25f4a:	bf00      	nop
  __ASM volatile ("cpsid i" : : : "memory");
   25f4c:	b672      	cpsid	i

    UNUSED_VARIABLE(m_error_data);

    // If printing is disrupted, remove the irq calls, or set the loop variable to 0 in the debugger.
    __disable_irq();
    while (loop);
   25f4e:	bf00      	nop
   25f50:	7dfb      	ldrb	r3, [r7, #23]
   25f52:	b2db      	uxtb	r3, r3
   25f54:	2b00      	cmp	r3, #0
   25f56:	d1fb      	bne.n	25f50 <app_error_save_and_stop+0x80>
  __ASM volatile ("cpsie i" : : : "memory");
   25f58:	b662      	cpsie	i

    __enable_irq();
}
   25f5a:	bf00      	nop
   25f5c:	371c      	adds	r7, #28
   25f5e:	46bd      	mov	sp, r7
   25f60:	bc80      	pop	{r7}
   25f62:	4770      	bx	lr
   25f64:	2000529c 	.word	0x2000529c

00025f68 <app_error_fault_handler>:
/**
 * Function is implemented as weak so that it can be overwritten by custom application error handler
 * when needed.
 */
__WEAK void app_error_fault_handler(uint32_t id, uint32_t pc, uint32_t info)
{
   25f68:	b580      	push	{r7, lr}
   25f6a:	b084      	sub	sp, #16
   25f6c:	af00      	add	r7, sp, #0
   25f6e:	60f8      	str	r0, [r7, #12]
   25f70:	60b9      	str	r1, [r7, #8]
   25f72:	607a      	str	r2, [r7, #4]
    // On assert, the system can only recover with a reset.
#ifndef DEBUG
    NVIC_SystemReset();
#else
    app_error_save_and_stop(id, pc, info);
   25f74:	687a      	ldr	r2, [r7, #4]
   25f76:	68b9      	ldr	r1, [r7, #8]
   25f78:	68f8      	ldr	r0, [r7, #12]
   25f7a:	f7ff ffa9 	bl	25ed0 <app_error_save_and_stop>
#endif // DEBUG
}
   25f7e:	bf00      	nop
   25f80:	3710      	adds	r7, #16
   25f82:	46bd      	mov	sp, r7
   25f84:	bd80      	pop	{r7, pc}
	...

00025f88 <NVIC_EnableIRQ>:
{
   25f88:	b480      	push	{r7}
   25f8a:	b083      	sub	sp, #12
   25f8c:	af00      	add	r7, sp, #0
   25f8e:	4603      	mov	r3, r0
   25f90:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   25f92:	79fb      	ldrb	r3, [r7, #7]
   25f94:	f003 021f 	and.w	r2, r3, #31
   25f98:	4906      	ldr	r1, [pc, #24]	; (25fb4 <NVIC_EnableIRQ+0x2c>)
   25f9a:	f997 3007 	ldrsb.w	r3, [r7, #7]
   25f9e:	095b      	lsrs	r3, r3, #5
   25fa0:	2001      	movs	r0, #1
   25fa2:	fa00 f202 	lsl.w	r2, r0, r2
   25fa6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   25faa:	bf00      	nop
   25fac:	370c      	adds	r7, #12
   25fae:	46bd      	mov	sp, r7
   25fb0:	bc80      	pop	{r7}
   25fb2:	4770      	bx	lr
   25fb4:	e000e100 	.word	0xe000e100

00025fb8 <nrf_section_iter_get>:
 * @param[in]   p_iter  Pointer to the iterator.
 *
 * @retval  Pointer to the element or NULL if iterator points end of the set.
 */
static inline void * nrf_section_iter_get(nrf_section_iter_t const * p_iter)
{
   25fb8:	b480      	push	{r7}
   25fba:	b083      	sub	sp, #12
   25fbc:	af00      	add	r7, sp, #0
   25fbe:	6078      	str	r0, [r7, #4]
    ASSERT(p_iter);
    return p_iter->p_item;
   25fc0:	687b      	ldr	r3, [r7, #4]
   25fc2:	685b      	ldr	r3, [r3, #4]
}
   25fc4:	4618      	mov	r0, r3
   25fc6:	370c      	adds	r7, #12
   25fc8:	46bd      	mov	sp, r7
   25fca:	bc80      	pop	{r7}
   25fcc:	4770      	bx	lr

00025fce <sd_softdevice_enable>:
SVCALL(SD_SOFTDEVICE_ENABLE, uint32_t, sd_softdevice_enable(nrf_clock_lf_cfg_t const * p_clock_lf_cfg, nrf_fault_handler_t fault_handler));
   25fce:	df10      	svc	16
   25fd0:	4770      	bx	lr
   25fd2:	bf00      	nop
   25fd4:	4618      	mov	r0, r3
	...

00025fd8 <sdh_request_observer_notify>:
/**@brief   Function for notifying request observers.
 *
 * @param[in]   evt     Type of request event.
 */
static ret_code_t sdh_request_observer_notify(nrf_sdh_req_evt_t req)
{
   25fd8:	b580      	push	{r7, lr}
   25fda:	b086      	sub	sp, #24
   25fdc:	af00      	add	r7, sp, #0
   25fde:	4603      	mov	r3, r0
   25fe0:	71fb      	strb	r3, [r7, #7]
    nrf_section_iter_t iter;

    NRF_LOG_DEBUG("State request: 0x%08X", req);

    for (nrf_section_iter_init(&iter, &sdh_req_observers);
   25fe2:	f107 0308 	add.w	r3, r7, #8
   25fe6:	4915      	ldr	r1, [pc, #84]	; (2603c <sdh_request_observer_notify+0x64>)
   25fe8:	4618      	mov	r0, r3
   25fea:	f000 fa23 	bl	26434 <nrf_section_iter_init>
   25fee:	e018      	b.n	26022 <sdh_request_observer_notify+0x4a>
         nrf_section_iter_next(&iter))
    {
        nrf_sdh_req_observer_t    * p_observer;
        nrf_sdh_req_evt_handler_t   handler;

        p_observer = (nrf_sdh_req_observer_t *) nrf_section_iter_get(&iter);
   25ff0:	f107 0308 	add.w	r3, r7, #8
   25ff4:	4618      	mov	r0, r3
   25ff6:	f7ff ffdf 	bl	25fb8 <nrf_section_iter_get>
   25ffa:	6178      	str	r0, [r7, #20]
        handler    = p_observer->handler;
   25ffc:	697b      	ldr	r3, [r7, #20]
   25ffe:	681b      	ldr	r3, [r3, #0]
   26000:	613b      	str	r3, [r7, #16]

        if (handler(req, p_observer->p_context))
   26002:	697b      	ldr	r3, [r7, #20]
   26004:	6859      	ldr	r1, [r3, #4]
   26006:	79fa      	ldrb	r2, [r7, #7]
   26008:	693b      	ldr	r3, [r7, #16]
   2600a:	4610      	mov	r0, r2
   2600c:	4798      	blx	r3
   2600e:	4603      	mov	r3, r0
   26010:	2b00      	cmp	r3, #0
   26012:	d101      	bne.n	26018 <sdh_request_observer_notify+0x40>
        }
        else
        {
            // Process is stopped.
            NRF_LOG_DEBUG("Notify observer 0x%08X => blocking", p_observer);
            return NRF_ERROR_BUSY;
   26014:	2311      	movs	r3, #17
   26016:	e00d      	b.n	26034 <sdh_request_observer_notify+0x5c>
         nrf_section_iter_next(&iter))
   26018:	f107 0308 	add.w	r3, r7, #8
   2601c:	4618      	mov	r0, r3
   2601e:	f000 fa25 	bl	2646c <nrf_section_iter_next>
         nrf_section_iter_get(&iter) != NULL;
   26022:	f107 0308 	add.w	r3, r7, #8
   26026:	4618      	mov	r0, r3
   26028:	f7ff ffc6 	bl	25fb8 <nrf_section_iter_get>
   2602c:	4603      	mov	r3, r0
    for (nrf_section_iter_init(&iter, &sdh_req_observers);
   2602e:	2b00      	cmp	r3, #0
   26030:	d1de      	bne.n	25ff0 <sdh_request_observer_notify+0x18>
        }
    }
    return NRF_SUCCESS;
   26032:	2300      	movs	r3, #0
}
   26034:	4618      	mov	r0, r3
   26036:	3718      	adds	r7, #24
   26038:	46bd      	mov	sp, r7
   2603a:	bd80      	pop	{r7, pc}
   2603c:	00027a7c 	.word	0x00027a7c

00026040 <sdh_state_observer_notify>:
/**@brief   Function for stage request observers.
 *
 * @param[in]   evt Type of stage event.
 */
static void sdh_state_observer_notify(nrf_sdh_state_evt_t evt)
{
   26040:	b580      	push	{r7, lr}
   26042:	b086      	sub	sp, #24
   26044:	af00      	add	r7, sp, #0
   26046:	4603      	mov	r3, r0
   26048:	71fb      	strb	r3, [r7, #7]
    nrf_section_iter_t iter;

    NRF_LOG_DEBUG("State change: 0x%08X", evt);

    for (nrf_section_iter_init(&iter, &sdh_state_observers);
   2604a:	f107 0308 	add.w	r3, r7, #8
   2604e:	4912      	ldr	r1, [pc, #72]	; (26098 <sdh_state_observer_notify+0x58>)
   26050:	4618      	mov	r0, r3
   26052:	f000 f9ef 	bl	26434 <nrf_section_iter_init>
   26056:	e013      	b.n	26080 <sdh_state_observer_notify+0x40>
         nrf_section_iter_next(&iter))
    {
        nrf_sdh_state_observer_t    * p_observer;
        nrf_sdh_state_evt_handler_t   handler;

        p_observer = (nrf_sdh_state_observer_t *) nrf_section_iter_get(&iter);
   26058:	f107 0308 	add.w	r3, r7, #8
   2605c:	4618      	mov	r0, r3
   2605e:	f7ff ffab 	bl	25fb8 <nrf_section_iter_get>
   26062:	6178      	str	r0, [r7, #20]
        handler    = p_observer->handler;
   26064:	697b      	ldr	r3, [r7, #20]
   26066:	681b      	ldr	r3, [r3, #0]
   26068:	613b      	str	r3, [r7, #16]

        handler(evt, p_observer->p_context);
   2606a:	697b      	ldr	r3, [r7, #20]
   2606c:	6859      	ldr	r1, [r3, #4]
   2606e:	79fa      	ldrb	r2, [r7, #7]
   26070:	693b      	ldr	r3, [r7, #16]
   26072:	4610      	mov	r0, r2
   26074:	4798      	blx	r3
         nrf_section_iter_next(&iter))
   26076:	f107 0308 	add.w	r3, r7, #8
   2607a:	4618      	mov	r0, r3
   2607c:	f000 f9f6 	bl	2646c <nrf_section_iter_next>
         nrf_section_iter_get(&iter) != NULL;
   26080:	f107 0308 	add.w	r3, r7, #8
   26084:	4618      	mov	r0, r3
   26086:	f7ff ff97 	bl	25fb8 <nrf_section_iter_get>
   2608a:	4603      	mov	r3, r0
    for (nrf_section_iter_init(&iter, &sdh_state_observers);
   2608c:	2b00      	cmp	r3, #0
   2608e:	d1e3      	bne.n	26058 <sdh_state_observer_notify+0x18>
    }
}
   26090:	bf00      	nop
   26092:	3718      	adds	r7, #24
   26094:	46bd      	mov	sp, r7
   26096:	bd80      	pop	{r7, pc}
   26098:	00027a88 	.word	0x00027a88

0002609c <nrf_sdh_enable_request>:


ret_code_t nrf_sdh_enable_request(void)
{
   2609c:	b580      	push	{r7, lr}
   2609e:	b082      	sub	sp, #8
   260a0:	af00      	add	r7, sp, #0
    ret_code_t ret_code;

    if (m_nrf_sdh_enabled)
   260a2:	4b1b      	ldr	r3, [pc, #108]	; (26110 <nrf_sdh_enable_request+0x74>)
   260a4:	781b      	ldrb	r3, [r3, #0]
   260a6:	2b00      	cmp	r3, #0
   260a8:	d001      	beq.n	260ae <nrf_sdh_enable_request+0x12>
    {
        return NRF_ERROR_INVALID_STATE;
   260aa:	2308      	movs	r3, #8
   260ac:	e02b      	b.n	26106 <nrf_sdh_enable_request+0x6a>
    }

    m_nrf_sdh_continue = true;
   260ae:	4b19      	ldr	r3, [pc, #100]	; (26114 <nrf_sdh_enable_request+0x78>)
   260b0:	2201      	movs	r2, #1
   260b2:	701a      	strb	r2, [r3, #0]

    // Notify observers about SoftDevice enable request.
    if (sdh_request_observer_notify(NRF_SDH_EVT_ENABLE_REQUEST) == NRF_ERROR_BUSY)
   260b4:	2000      	movs	r0, #0
   260b6:	f7ff ff8f 	bl	25fd8 <sdh_request_observer_notify>
   260ba:	4603      	mov	r3, r0
   260bc:	2b11      	cmp	r3, #17
   260be:	d101      	bne.n	260c4 <nrf_sdh_enable_request+0x28>
    {
        // Enable process was stopped.
        return NRF_SUCCESS;
   260c0:	2300      	movs	r3, #0
   260c2:	e020      	b.n	26106 <nrf_sdh_enable_request+0x6a>
    }

    // Notify observers about starting SoftDevice enable process.
    sdh_state_observer_notify(NRF_SDH_EVT_STATE_ENABLE_PREPARE);
   260c4:	2000      	movs	r0, #0
   260c6:	f7ff ffbb 	bl	26040 <sdh_state_observer_notify>

    nrf_clock_lf_cfg_t const clock_lf_cfg =
   260ca:	4b13      	ldr	r3, [pc, #76]	; (26118 <nrf_sdh_enable_request+0x7c>)
   260cc:	681b      	ldr	r3, [r3, #0]
   260ce:	603b      	str	r3, [r7, #0]
    };

    #ifdef ANT_LICENSE_KEY
        ret_code = sd_softdevice_enable(&clock_lf_cfg, app_error_fault_handler, ANT_LICENSE_KEY);
    #else
        ret_code = sd_softdevice_enable(&clock_lf_cfg, app_error_fault_handler);
   260d0:	463b      	mov	r3, r7
   260d2:	4912      	ldr	r1, [pc, #72]	; (2611c <nrf_sdh_enable_request+0x80>)
   260d4:	4618      	mov	r0, r3
   260d6:	f7ff ff7a 	bl	25fce <sd_softdevice_enable>
   260da:	6078      	str	r0, [r7, #4]
    #endif

    if (ret_code != NRF_SUCCESS)
   260dc:	687b      	ldr	r3, [r7, #4]
   260de:	2b00      	cmp	r3, #0
   260e0:	d001      	beq.n	260e6 <nrf_sdh_enable_request+0x4a>
    {
        return ret_code;
   260e2:	687b      	ldr	r3, [r7, #4]
   260e4:	e00f      	b.n	26106 <nrf_sdh_enable_request+0x6a>
    }

    m_nrf_sdh_enabled   = true;
   260e6:	4b0a      	ldr	r3, [pc, #40]	; (26110 <nrf_sdh_enable_request+0x74>)
   260e8:	2201      	movs	r2, #1
   260ea:	701a      	strb	r2, [r3, #0]
    m_nrf_sdh_continue  = false;
   260ec:	4b09      	ldr	r3, [pc, #36]	; (26114 <nrf_sdh_enable_request+0x78>)
   260ee:	2200      	movs	r2, #0
   260f0:	701a      	strb	r2, [r3, #0]
    m_nrf_sdh_suspended = false;
   260f2:	4b0b      	ldr	r3, [pc, #44]	; (26120 <nrf_sdh_enable_request+0x84>)
   260f4:	2200      	movs	r2, #0
   260f6:	701a      	strb	r2, [r3, #0]
    {
        return ret_code;
    }
#else
    //In case of serialization, NVIC must be accessed directly.
    NVIC_EnableIRQ(SD_EVT_IRQn);
   260f8:	2016      	movs	r0, #22
   260fa:	f7ff ff45 	bl	25f88 <NVIC_EnableIRQ>
#endif

    // Notify observers about a finished SoftDevice enable process.
    sdh_state_observer_notify(NRF_SDH_EVT_STATE_ENABLED);
   260fe:	2001      	movs	r0, #1
   26100:	f7ff ff9e 	bl	26040 <sdh_state_observer_notify>

    return NRF_SUCCESS;
   26104:	2300      	movs	r3, #0
}
   26106:	4618      	mov	r0, r3
   26108:	3708      	adds	r7, #8
   2610a:	46bd      	mov	sp, r7
   2610c:	bd80      	pop	{r7, pc}
   2610e:	bf00      	nop
   26110:	200052bc 	.word	0x200052bc
   26114:	200052be 	.word	0x200052be
   26118:	00027aa0 	.word	0x00027aa0
   2611c:	00025f69 	.word	0x00025f69
   26120:	200052bd 	.word	0x200052bd

00026124 <nrf_sdh_evts_poll>:
    return (!m_nrf_sdh_enabled) || (m_nrf_sdh_suspended);
}


void nrf_sdh_evts_poll(void)
{
   26124:	b580      	push	{r7, lr}
   26126:	b084      	sub	sp, #16
   26128:	af00      	add	r7, sp, #0
    nrf_section_iter_t iter;

    // Notify observers about pending SoftDevice event.
    for (nrf_section_iter_init(&iter, &sdh_stack_observers);
   2612a:	463b      	mov	r3, r7
   2612c:	4910      	ldr	r1, [pc, #64]	; (26170 <nrf_sdh_evts_poll+0x4c>)
   2612e:	4618      	mov	r0, r3
   26130:	f000 f980 	bl	26434 <nrf_section_iter_init>
   26134:	e010      	b.n	26158 <nrf_sdh_evts_poll+0x34>
         nrf_section_iter_next(&iter))
    {
        nrf_sdh_stack_observer_t    * p_observer;
        nrf_sdh_stack_evt_handler_t   handler;

        p_observer = (nrf_sdh_stack_observer_t *) nrf_section_iter_get(&iter);
   26136:	463b      	mov	r3, r7
   26138:	4618      	mov	r0, r3
   2613a:	f7ff ff3d 	bl	25fb8 <nrf_section_iter_get>
   2613e:	60f8      	str	r0, [r7, #12]
        handler    = p_observer->handler;
   26140:	68fb      	ldr	r3, [r7, #12]
   26142:	681b      	ldr	r3, [r3, #0]
   26144:	60bb      	str	r3, [r7, #8]

        handler(p_observer->p_context);
   26146:	68fb      	ldr	r3, [r7, #12]
   26148:	685a      	ldr	r2, [r3, #4]
   2614a:	68bb      	ldr	r3, [r7, #8]
   2614c:	4610      	mov	r0, r2
   2614e:	4798      	blx	r3
         nrf_section_iter_next(&iter))
   26150:	463b      	mov	r3, r7
   26152:	4618      	mov	r0, r3
   26154:	f000 f98a 	bl	2646c <nrf_section_iter_next>
         nrf_section_iter_get(&iter) != NULL;
   26158:	463b      	mov	r3, r7
   2615a:	4618      	mov	r0, r3
   2615c:	f7ff ff2c 	bl	25fb8 <nrf_section_iter_get>
   26160:	4603      	mov	r3, r0
    for (nrf_section_iter_init(&iter, &sdh_stack_observers);
   26162:	2b00      	cmp	r3, #0
   26164:	d1e7      	bne.n	26136 <nrf_sdh_evts_poll+0x12>
    }
}
   26166:	bf00      	nop
   26168:	3710      	adds	r7, #16
   2616a:	46bd      	mov	sp, r7
   2616c:	bd80      	pop	{r7, pc}
   2616e:	bf00      	nop
   26170:	00027a94 	.word	0x00027a94

00026174 <SWI2_EGU2_IRQHandler>:


#if (NRF_SDH_DISPATCH_MODEL == NRF_SDH_DISPATCH_MODEL_INTERRUPT)

void SD_EVT_IRQHandler(void)
{
   26174:	b580      	push	{r7, lr}
   26176:	af00      	add	r7, sp, #0
    nrf_sdh_evts_poll();
   26178:	f7ff ffd4 	bl	26124 <nrf_sdh_evts_poll>
}
   2617c:	bf00      	nop
   2617e:	bd80      	pop	{r7, pc}

00026180 <sd_ble_enable>:
SVCALL(SD_BLE_ENABLE, uint32_t, sd_ble_enable(uint32_t * p_app_ram_base));
   26180:	df60      	svc	96	; 0x60
   26182:	4770      	bx	lr
   26184:	bf00      	nop
   26186:	4618      	mov	r0, r3

00026188 <sd_ble_cfg_set>:
SVCALL(SD_BLE_CFG_SET, uint32_t, sd_ble_cfg_set(uint32_t cfg_id, ble_cfg_t const * p_cfg, uint32_t app_ram_base));
   26188:	df69      	svc	105	; 0x69
   2618a:	4770      	bx	lr
   2618c:	bf00      	nop
   2618e:	4618      	mov	r0, r3

00026190 <sd_ble_evt_get>:
SVCALL(SD_BLE_EVT_GET, uint32_t, sd_ble_evt_get(uint8_t *p_dest, uint16_t *p_len));
   26190:	df61      	svc	97	; 0x61
   26192:	4770      	bx	lr
   26194:	bf00      	nop
   26196:	4618      	mov	r0, r3

00026198 <nrf_section_iter_get>:
{
   26198:	b480      	push	{r7}
   2619a:	b083      	sub	sp, #12
   2619c:	af00      	add	r7, sp, #0
   2619e:	6078      	str	r0, [r7, #4]
    return p_iter->p_item;
   261a0:	687b      	ldr	r3, [r7, #4]
   261a2:	685b      	ldr	r3, [r3, #4]
}
   261a4:	4618      	mov	r0, r3
   261a6:	370c      	adds	r7, #12
   261a8:	46bd      	mov	sp, r7
   261aa:	bc80      	pop	{r7}
   261ac:	4770      	bx	lr
	...

000261b0 <nrf_sdh_ble_app_ram_start_get>:
#define RAM_START       0x20000000
#define APP_RAM_START   (uint32_t)m_ram_start


ret_code_t nrf_sdh_ble_app_ram_start_get(uint32_t * p_app_ram_start)
{
   261b0:	b480      	push	{r7}
   261b2:	b083      	sub	sp, #12
   261b4:	af00      	add	r7, sp, #0
   261b6:	6078      	str	r0, [r7, #4]
    if (p_app_ram_start == NULL)
   261b8:	687b      	ldr	r3, [r7, #4]
   261ba:	2b00      	cmp	r3, #0
   261bc:	d101      	bne.n	261c2 <nrf_sdh_ble_app_ram_start_get+0x12>
    {
        return NRF_ERROR_NULL;
   261be:	230e      	movs	r3, #14
   261c0:	e004      	b.n	261cc <nrf_sdh_ble_app_ram_start_get+0x1c>
    }

    *p_app_ram_start = APP_RAM_START;
   261c2:	4b05      	ldr	r3, [pc, #20]	; (261d8 <nrf_sdh_ble_app_ram_start_get+0x28>)
   261c4:	461a      	mov	r2, r3
   261c6:	687b      	ldr	r3, [r7, #4]
   261c8:	601a      	str	r2, [r3, #0]

    return NRF_SUCCESS;
   261ca:	2300      	movs	r3, #0
}
   261cc:	4618      	mov	r0, r3
   261ce:	370c      	adds	r7, #12
   261d0:	46bd      	mov	sp, r7
   261d2:	bc80      	pop	{r7}
   261d4:	4770      	bx	lr
   261d6:	bf00      	nop
   261d8:	20005000 	.word	0x20005000

000261dc <nrf_sdh_ble_default_cfg_set>:


ret_code_t nrf_sdh_ble_default_cfg_set(uint8_t conn_cfg_tag, uint32_t * p_ram_start)
{
   261dc:	b580      	push	{r7, lr}
   261de:	b088      	sub	sp, #32
   261e0:	af00      	add	r7, sp, #0
   261e2:	4603      	mov	r3, r0
   261e4:	6039      	str	r1, [r7, #0]
   261e6:	71fb      	strb	r3, [r7, #7]
    uint32_t ret_code;

    ret_code = nrf_sdh_ble_app_ram_start_get(p_ram_start);
   261e8:	6838      	ldr	r0, [r7, #0]
   261ea:	f7ff ffe1 	bl	261b0 <nrf_sdh_ble_app_ram_start_get>
   261ee:	61f8      	str	r0, [r7, #28]
    if (ret_code != NRF_SUCCESS)
   261f0:	69fb      	ldr	r3, [r7, #28]
   261f2:	2b00      	cmp	r3, #0
   261f4:	d001      	beq.n	261fa <nrf_sdh_ble_default_cfg_set+0x1e>
    {
        return ret_code;
   261f6:	69fb      	ldr	r3, [r7, #28]
   261f8:	e069      	b.n	262ce <nrf_sdh_ble_default_cfg_set+0xf2>
    // message will be printed to the user suggesting the correct value.
    ble_cfg_t ble_cfg;

#if (NRF_SDH_BLE_TOTAL_LINK_COUNT != 0)
    // Configure the connection count.
    memset(&ble_cfg, 0, sizeof(ble_cfg));
   261fa:	f107 0310 	add.w	r3, r7, #16
   261fe:	220c      	movs	r2, #12
   26200:	2100      	movs	r1, #0
   26202:	4618      	mov	r0, r3
   26204:	f7fd fa0a 	bl	2361c <memset>
    ble_cfg.conn_cfg.conn_cfg_tag                     = conn_cfg_tag;
   26208:	79fb      	ldrb	r3, [r7, #7]
   2620a:	743b      	strb	r3, [r7, #16]
    ble_cfg.conn_cfg.params.gap_conn_cfg.conn_count   = NRF_SDH_BLE_TOTAL_LINK_COUNT;
   2620c:	2302      	movs	r3, #2
   2620e:	74bb      	strb	r3, [r7, #18]
    ble_cfg.conn_cfg.params.gap_conn_cfg.event_length = NRF_SDH_BLE_GAP_EVENT_LENGTH;
   26210:	2303      	movs	r3, #3
   26212:	82bb      	strh	r3, [r7, #20]

    ret_code = sd_ble_cfg_set(BLE_CONN_CFG_GAP, &ble_cfg, *p_ram_start);
   26214:	683b      	ldr	r3, [r7, #0]
   26216:	681a      	ldr	r2, [r3, #0]
   26218:	f107 0310 	add.w	r3, r7, #16
   2621c:	4619      	mov	r1, r3
   2621e:	2020      	movs	r0, #32
   26220:	f7ff ffb2 	bl	26188 <sd_ble_cfg_set>
   26224:	61f8      	str	r0, [r7, #28]
                      nrf_strerror_get(ret_code));

    }

    // Configure the connection roles.
    memset(&ble_cfg, 0, sizeof(ble_cfg));
   26226:	f107 0310 	add.w	r3, r7, #16
   2622a:	220c      	movs	r2, #12
   2622c:	2100      	movs	r1, #0
   2622e:	4618      	mov	r0, r3
   26230:	f7fd f9f4 	bl	2361c <memset>
    ble_cfg.gap_cfg.role_count_cfg.periph_role_count  = NRF_SDH_BLE_PERIPHERAL_LINK_COUNT;
   26234:	2301      	movs	r3, #1
   26236:	743b      	strb	r3, [r7, #16]
    ble_cfg.gap_cfg.role_count_cfg.central_role_count = NRF_SDH_BLE_CENTRAL_LINK_COUNT;
   26238:	2301      	movs	r3, #1
   2623a:	747b      	strb	r3, [r7, #17]
    ble_cfg.gap_cfg.role_count_cfg.central_sec_count  = NRF_SDH_BLE_CENTRAL_LINK_COUNT ?
   2623c:	2301      	movs	r3, #1
   2623e:	74bb      	strb	r3, [r7, #18]
                                                        BLE_GAP_ROLE_COUNT_CENTRAL_SEC_DEFAULT : 0;

    ret_code = sd_ble_cfg_set(BLE_GAP_CFG_ROLE_COUNT, &ble_cfg, *p_ram_start);
   26240:	683b      	ldr	r3, [r7, #0]
   26242:	681a      	ldr	r2, [r3, #0]
   26244:	f107 0310 	add.w	r3, r7, #16
   26248:	4619      	mov	r1, r3
   2624a:	2040      	movs	r0, #64	; 0x40
   2624c:	f7ff ff9c 	bl	26188 <sd_ble_cfg_set>
   26250:	61f8      	str	r0, [r7, #28]
#endif

#endif  // NRF_SDH_BLE_TOTAL_LINK_COUNT

    // Configure number of custom UUIDS.
    memset(&ble_cfg, 0, sizeof(ble_cfg));
   26252:	f107 0310 	add.w	r3, r7, #16
   26256:	220c      	movs	r2, #12
   26258:	2100      	movs	r1, #0
   2625a:	4618      	mov	r0, r3
   2625c:	f7fd f9de 	bl	2361c <memset>
    ble_cfg.common_cfg.vs_uuid_cfg.vs_uuid_count = NRF_SDH_BLE_VS_UUID_COUNT;
   26260:	2301      	movs	r3, #1
   26262:	743b      	strb	r3, [r7, #16]

    ret_code = sd_ble_cfg_set(BLE_COMMON_CFG_VS_UUID, &ble_cfg, *p_ram_start);
   26264:	683b      	ldr	r3, [r7, #0]
   26266:	681a      	ldr	r2, [r3, #0]
   26268:	f107 0310 	add.w	r3, r7, #16
   2626c:	4619      	mov	r1, r3
   2626e:	2001      	movs	r0, #1
   26270:	f7ff ff8a 	bl	26188 <sd_ble_cfg_set>
   26274:	61f8      	str	r0, [r7, #28]
        NRF_LOG_ERROR("sd_ble_cfg_set() returned %s when attempting to set BLE_COMMON_CFG_VS_UUID.",
                      nrf_strerror_get(ret_code));
    }

    // Configure the GATTS attribute table.
    memset(&ble_cfg, 0x00, sizeof(ble_cfg));
   26276:	f107 0310 	add.w	r3, r7, #16
   2627a:	220c      	movs	r2, #12
   2627c:	2100      	movs	r1, #0
   2627e:	4618      	mov	r0, r3
   26280:	f7fd f9cc 	bl	2361c <memset>
    ble_gatts_cfg_attr_tab_size_t table =
   26284:	f44f 63b0 	mov.w	r3, #1408	; 0x580
   26288:	60fb      	str	r3, [r7, #12]
    {
        .attr_tab_size = NRF_SDH_BLE_GATTS_ATTR_TAB_SIZE
    };
    ble_cfg.gatts_cfg.attr_tab_size = table;
   2628a:	68fb      	ldr	r3, [r7, #12]
   2628c:	613b      	str	r3, [r7, #16]

    ret_code = sd_ble_cfg_set(BLE_GATTS_CFG_ATTR_TAB_SIZE, &ble_cfg, *p_ram_start);
   2628e:	683b      	ldr	r3, [r7, #0]
   26290:	681a      	ldr	r2, [r3, #0]
   26292:	f107 0310 	add.w	r3, r7, #16
   26296:	4619      	mov	r1, r3
   26298:	20a1      	movs	r0, #161	; 0xa1
   2629a:	f7ff ff75 	bl	26188 <sd_ble_cfg_set>
   2629e:	61f8      	str	r0, [r7, #28]
        NRF_LOG_ERROR("sd_ble_cfg_set() returned %s when attempting to set BLE_GATTS_CFG_ATTR_TAB_SIZE.",
                      nrf_strerror_get(ret_code));
    }

    // Configure Service Changed characteristic.
    memset(&ble_cfg, 0x00, sizeof(ble_cfg));
   262a0:	f107 0310 	add.w	r3, r7, #16
   262a4:	220c      	movs	r2, #12
   262a6:	2100      	movs	r1, #0
   262a8:	4618      	mov	r0, r3
   262aa:	f7fd f9b7 	bl	2361c <memset>
    ble_gatts_cfg_service_changed_t sc =
   262ae:	7a3b      	ldrb	r3, [r7, #8]
   262b0:	f36f 0300 	bfc	r3, #0, #1
   262b4:	723b      	strb	r3, [r7, #8]
    {
        .service_changed = NRF_SDH_BLE_SERVICE_CHANGED
    };
    ble_cfg.gatts_cfg.service_changed = sc;
   262b6:	7a3b      	ldrb	r3, [r7, #8]
   262b8:	743b      	strb	r3, [r7, #16]

    ret_code = sd_ble_cfg_set(BLE_GATTS_CFG_SERVICE_CHANGED, &ble_cfg, *p_ram_start);
   262ba:	683b      	ldr	r3, [r7, #0]
   262bc:	681a      	ldr	r2, [r3, #0]
   262be:	f107 0310 	add.w	r3, r7, #16
   262c2:	4619      	mov	r1, r3
   262c4:	20a0      	movs	r0, #160	; 0xa0
   262c6:	f7ff ff5f 	bl	26188 <sd_ble_cfg_set>
   262ca:	61f8      	str	r0, [r7, #28]
    {
        NRF_LOG_ERROR("sd_ble_cfg_set() returned %s when attempting to set BLE_GATTS_CFG_SERVICE_CHANGED.",
                      nrf_strerror_get(ret_code));
    }

    return NRF_SUCCESS;
   262cc:	2300      	movs	r3, #0
}
   262ce:	4618      	mov	r0, r3
   262d0:	3720      	adds	r7, #32
   262d2:	46bd      	mov	sp, r7
   262d4:	bd80      	pop	{r7, pc}

000262d6 <nrf_sdh_ble_enable>:
    return RAM_START + ram_total_size;
}


ret_code_t nrf_sdh_ble_enable(uint32_t * const p_app_ram_start)
{
   262d6:	b580      	push	{r7, lr}
   262d8:	b084      	sub	sp, #16
   262da:	af00      	add	r7, sp, #0
   262dc:	6078      	str	r0, [r7, #4]
    uint32_t const app_ram_start = *p_app_ram_start;
   262de:	687b      	ldr	r3, [r7, #4]
   262e0:	681b      	ldr	r3, [r3, #0]
   262e2:	60fb      	str	r3, [r7, #12]

    NRF_LOG_DEBUG("RAM starts at 0x%x", *p_app_ram_start);

    ret_code_t ret_code = sd_ble_enable(p_app_ram_start);
   262e4:	6878      	ldr	r0, [r7, #4]
   262e6:	f7ff ff4b 	bl	26180 <sd_ble_enable>
   262ea:	60b8      	str	r0, [r7, #8]
    if (ret_code != NRF_SUCCESS)
    {
        NRF_LOG_ERROR("sd_ble_enable() returned %s.", nrf_strerror_get(ret_code));
    }

    return ret_code;
   262ec:	68bb      	ldr	r3, [r7, #8]
}
   262ee:	4618      	mov	r0, r3
   262f0:	3710      	adds	r7, #16
   262f2:	46bd      	mov	sp, r7
   262f4:	bd80      	pop	{r7, pc}
	...

000262f8 <nrf_sdh_ble_evts_poll>:
/**@brief       Function for polling BLE events.
 *
 * @param[in]   p_context   Context of the observer.
 */
static void nrf_sdh_ble_evts_poll(void * p_context)
{
   262f8:	b580      	push	{r7, lr}
   262fa:	b098      	sub	sp, #96	; 0x60
   262fc:	af00      	add	r7, sp, #0
   262fe:	6078      	str	r0, [r7, #4]
    while (true)
    {
        __ALIGN(4) uint8_t evt_buffer[NRF_SDH_BLE_EVT_BUF_SIZE];

        ble_evt_t * p_ble_evt;
        uint16_t    evt_len = (uint16_t)sizeof(evt_buffer);
   26300:	2338      	movs	r3, #56	; 0x38
   26302:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

        ret_code = sd_ble_evt_get(evt_buffer, &evt_len);
   26306:	f107 024e 	add.w	r2, r7, #78	; 0x4e
   2630a:	f107 030c 	add.w	r3, r7, #12
   2630e:	4611      	mov	r1, r2
   26310:	4618      	mov	r0, r3
   26312:	f7ff ff3d 	bl	26190 <sd_ble_evt_get>
   26316:	65f8      	str	r0, [r7, #92]	; 0x5c
        if (ret_code != NRF_SUCCESS)
   26318:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   2631a:	2b00      	cmp	r3, #0
   2631c:	d003      	beq.n	26326 <nrf_sdh_ble_evts_poll+0x2e>

            handler(p_ble_evt, p_observer->p_context);
        }
    }

    if (ret_code != NRF_ERROR_NOT_FOUND)
   2631e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   26320:	2b05      	cmp	r3, #5
   26322:	d127      	bne.n	26374 <nrf_sdh_ble_evts_poll+0x7c>
    {
        APP_ERROR_HANDLER(ret_code);
    }
}
   26324:	e02c      	b.n	26380 <nrf_sdh_ble_evts_poll+0x88>
        p_ble_evt = (ble_evt_t *)evt_buffer;
   26326:	f107 030c 	add.w	r3, r7, #12
   2632a:	65bb      	str	r3, [r7, #88]	; 0x58
        for (nrf_section_iter_init(&iter, &sdh_ble_observers);
   2632c:	f107 0344 	add.w	r3, r7, #68	; 0x44
   26330:	4915      	ldr	r1, [pc, #84]	; (26388 <nrf_sdh_ble_evts_poll+0x90>)
   26332:	4618      	mov	r0, r3
   26334:	f000 f87e 	bl	26434 <nrf_section_iter_init>
   26338:	e013      	b.n	26362 <nrf_sdh_ble_evts_poll+0x6a>
            p_observer = (nrf_sdh_ble_evt_observer_t *)nrf_section_iter_get(&iter);
   2633a:	f107 0344 	add.w	r3, r7, #68	; 0x44
   2633e:	4618      	mov	r0, r3
   26340:	f7ff ff2a 	bl	26198 <nrf_section_iter_get>
   26344:	6578      	str	r0, [r7, #84]	; 0x54
            handler    = p_observer->handler;
   26346:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   26348:	681b      	ldr	r3, [r3, #0]
   2634a:	653b      	str	r3, [r7, #80]	; 0x50
            handler(p_ble_evt, p_observer->p_context);
   2634c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   2634e:	685a      	ldr	r2, [r3, #4]
   26350:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   26352:	4611      	mov	r1, r2
   26354:	6db8      	ldr	r0, [r7, #88]	; 0x58
   26356:	4798      	blx	r3
             nrf_section_iter_next(&iter))
   26358:	f107 0344 	add.w	r3, r7, #68	; 0x44
   2635c:	4618      	mov	r0, r3
   2635e:	f000 f885 	bl	2646c <nrf_section_iter_next>
             nrf_section_iter_get(&iter) != NULL;
   26362:	f107 0344 	add.w	r3, r7, #68	; 0x44
   26366:	4618      	mov	r0, r3
   26368:	f7ff ff16 	bl	26198 <nrf_section_iter_get>
   2636c:	4603      	mov	r3, r0
        for (nrf_section_iter_init(&iter, &sdh_ble_observers);
   2636e:	2b00      	cmp	r3, #0
   26370:	d1e3      	bne.n	2633a <nrf_sdh_ble_evts_poll+0x42>
    {
   26372:	e7c5      	b.n	26300 <nrf_sdh_ble_evts_poll+0x8>
        APP_ERROR_HANDLER(ret_code);
   26374:	4a05      	ldr	r2, [pc, #20]	; (2638c <nrf_sdh_ble_evts_poll+0x94>)
   26376:	f240 1123 	movw	r1, #291	; 0x123
   2637a:	6df8      	ldr	r0, [r7, #92]	; 0x5c
   2637c:	f7ff fd8e 	bl	25e9c <app_error_handler>
}
   26380:	bf00      	nop
   26382:	3760      	adds	r7, #96	; 0x60
   26384:	46bd      	mov	sp, r7
   26386:	bd80      	pop	{r7, pc}
   26388:	00027aa4 	.word	0x00027aa4
   2638c:	00027ab0 	.word	0x00027ab0

00026390 <nrf_section_iter_get>:
{
   26390:	b480      	push	{r7}
   26392:	b083      	sub	sp, #12
   26394:	af00      	add	r7, sp, #0
   26396:	6078      	str	r0, [r7, #4]
    return p_iter->p_item;
   26398:	687b      	ldr	r3, [r7, #4]
   2639a:	685b      	ldr	r3, [r3, #4]
}
   2639c:	4618      	mov	r0, r3
   2639e:	370c      	adds	r7, #12
   263a0:	46bd      	mov	sp, r7
   263a2:	bc80      	pop	{r7}
   263a4:	4770      	bx	lr

000263a6 <sd_evt_get>:
 * @param[out] p_evt_id Set to one of the values in @ref NRF_SOC_EVTS, if any events are pending.
 *
 * @retval ::NRF_SUCCESS An event was pending. The event id is written in the p_evt_id parameter.
 * @retval ::NRF_ERROR_NOT_FOUND No pending events.
 */
SVCALL(SD_EVT_GET, uint32_t, sd_evt_get(uint32_t * p_evt_id));
   263a6:	df48      	svc	72	; 0x48
   263a8:	4770      	bx	lr
   263aa:	bf00      	nop
   263ac:	4618      	mov	r0, r3
	...

000263b0 <nrf_sdh_soc_evts_poll>:
/**@brief   Function for polling SoC events.
 *
 * @param[in]   p_context   Context of the observer.
 */
static void nrf_sdh_soc_evts_poll(void * p_context)
{
   263b0:	b580      	push	{r7, lr}
   263b2:	b088      	sub	sp, #32
   263b4:	af00      	add	r7, sp, #0
   263b6:	6078      	str	r0, [r7, #4]

    while (true)
    {
        uint32_t evt_id;

        ret_code = sd_evt_get(&evt_id);
   263b8:	f107 0310 	add.w	r3, r7, #16
   263bc:	4618      	mov	r0, r3
   263be:	f7ff fff2 	bl	263a6 <sd_evt_get>
   263c2:	61f8      	str	r0, [r7, #28]
        if (ret_code != NRF_SUCCESS)
   263c4:	69fb      	ldr	r3, [r7, #28]
   263c6:	2b00      	cmp	r3, #0
   263c8:	d003      	beq.n	263d2 <nrf_sdh_soc_evts_poll+0x22>

            handler(evt_id, p_observer->p_context);
        }
    }

    if (ret_code != NRF_ERROR_NOT_FOUND)
   263ca:	69fb      	ldr	r3, [r7, #28]
   263cc:	2b05      	cmp	r3, #5
   263ce:	d124      	bne.n	2641a <nrf_sdh_soc_evts_poll+0x6a>
    {
        APP_ERROR_HANDLER(ret_code);
    }
}
   263d0:	e028      	b.n	26424 <nrf_sdh_soc_evts_poll+0x74>
        for (nrf_section_iter_init(&iter, &sdh_soc_observers);
   263d2:	f107 0308 	add.w	r3, r7, #8
   263d6:	4915      	ldr	r1, [pc, #84]	; (2642c <nrf_sdh_soc_evts_poll+0x7c>)
   263d8:	4618      	mov	r0, r3
   263da:	f000 f82b 	bl	26434 <nrf_section_iter_init>
   263de:	e013      	b.n	26408 <nrf_sdh_soc_evts_poll+0x58>
            p_observer = (nrf_sdh_soc_evt_observer_t *) nrf_section_iter_get(&iter);
   263e0:	f107 0308 	add.w	r3, r7, #8
   263e4:	4618      	mov	r0, r3
   263e6:	f7ff ffd3 	bl	26390 <nrf_section_iter_get>
   263ea:	61b8      	str	r0, [r7, #24]
            handler    = p_observer->handler;
   263ec:	69bb      	ldr	r3, [r7, #24]
   263ee:	681b      	ldr	r3, [r3, #0]
   263f0:	617b      	str	r3, [r7, #20]
            handler(evt_id, p_observer->p_context);
   263f2:	693a      	ldr	r2, [r7, #16]
   263f4:	69bb      	ldr	r3, [r7, #24]
   263f6:	6859      	ldr	r1, [r3, #4]
   263f8:	697b      	ldr	r3, [r7, #20]
   263fa:	4610      	mov	r0, r2
   263fc:	4798      	blx	r3
             nrf_section_iter_next(&iter))
   263fe:	f107 0308 	add.w	r3, r7, #8
   26402:	4618      	mov	r0, r3
   26404:	f000 f832 	bl	2646c <nrf_section_iter_next>
             nrf_section_iter_get(&iter) != NULL;
   26408:	f107 0308 	add.w	r3, r7, #8
   2640c:	4618      	mov	r0, r3
   2640e:	f7ff ffbf 	bl	26390 <nrf_section_iter_get>
   26412:	4603      	mov	r3, r0
        for (nrf_section_iter_init(&iter, &sdh_soc_observers);
   26414:	2b00      	cmp	r3, #0
   26416:	d1e3      	bne.n	263e0 <nrf_sdh_soc_evts_poll+0x30>
    {
   26418:	e7ce      	b.n	263b8 <nrf_sdh_soc_evts_poll+0x8>
        APP_ERROR_HANDLER(ret_code);
   2641a:	4a05      	ldr	r2, [pc, #20]	; (26430 <nrf_sdh_soc_evts_poll+0x80>)
   2641c:	216b      	movs	r1, #107	; 0x6b
   2641e:	69f8      	ldr	r0, [r7, #28]
   26420:	f7ff fd3c 	bl	25e9c <app_error_handler>
}
   26424:	bf00      	nop
   26426:	3720      	adds	r7, #32
   26428:	46bd      	mov	sp, r7
   2642a:	bd80      	pop	{r7, pc}
   2642c:	00027aec 	.word	0x00027aec
   26430:	00027af8 	.word	0x00027af8

00026434 <nrf_section_iter_init>:
}
#endif


void nrf_section_iter_init(nrf_section_iter_t * p_iter, nrf_section_set_t const * p_set)
{
   26434:	b480      	push	{r7}
   26436:	b083      	sub	sp, #12
   26438:	af00      	add	r7, sp, #0
   2643a:	6078      	str	r0, [r7, #4]
   2643c:	6039      	str	r1, [r7, #0]
    ASSERT(p_iter != NULL);
    ASSERT(p_set  != NULL);

    p_iter->p_set = p_set;
   2643e:	687b      	ldr	r3, [r7, #4]
   26440:	683a      	ldr	r2, [r7, #0]
   26442:	601a      	str	r2, [r3, #0]

#if defined(__GNUC__)
    p_iter->p_item = p_iter->p_set->section.p_start;
   26444:	687b      	ldr	r3, [r7, #4]
   26446:	681b      	ldr	r3, [r3, #0]
   26448:	681a      	ldr	r2, [r3, #0]
   2644a:	687b      	ldr	r3, [r7, #4]
   2644c:	605a      	str	r2, [r3, #4]
    if (p_iter->p_item == p_iter->p_set->section.p_end)
   2644e:	687b      	ldr	r3, [r7, #4]
   26450:	685a      	ldr	r2, [r3, #4]
   26452:	687b      	ldr	r3, [r7, #4]
   26454:	681b      	ldr	r3, [r3, #0]
   26456:	685b      	ldr	r3, [r3, #4]
   26458:	429a      	cmp	r2, r3
   2645a:	d102      	bne.n	26462 <nrf_section_iter_init+0x2e>
    {
        p_iter->p_item = NULL;
   2645c:	687b      	ldr	r3, [r7, #4]
   2645e:	2200      	movs	r2, #0
   26460:	605a      	str	r2, [r3, #4]
    }
#else
    p_iter->p_section = p_set->p_first;
    nrf_section_iter_item_set(p_iter);
#endif
}
   26462:	bf00      	nop
   26464:	370c      	adds	r7, #12
   26466:	46bd      	mov	sp, r7
   26468:	bc80      	pop	{r7}
   2646a:	4770      	bx	lr

0002646c <nrf_section_iter_next>:

void nrf_section_iter_next(nrf_section_iter_t * p_iter)
{
   2646c:	b480      	push	{r7}
   2646e:	b083      	sub	sp, #12
   26470:	af00      	add	r7, sp, #0
   26472:	6078      	str	r0, [r7, #4]
    ASSERT(p_iter        != NULL);
    ASSERT(p_iter->p_set != NULL);

    if (p_iter->p_item == NULL)
   26474:	687b      	ldr	r3, [r7, #4]
   26476:	685b      	ldr	r3, [r3, #4]
   26478:	2b00      	cmp	r3, #0
   2647a:	d014      	beq.n	264a6 <nrf_section_iter_next+0x3a>
    {
        return;
    }

    p_iter->p_item = (void *)((size_t)(p_iter->p_item) + p_iter->p_set->item_size);
   2647c:	687b      	ldr	r3, [r7, #4]
   2647e:	685b      	ldr	r3, [r3, #4]
   26480:	461a      	mov	r2, r3
   26482:	687b      	ldr	r3, [r7, #4]
   26484:	681b      	ldr	r3, [r3, #0]
   26486:	689b      	ldr	r3, [r3, #8]
   26488:	4413      	add	r3, r2
   2648a:	461a      	mov	r2, r3
   2648c:	687b      	ldr	r3, [r7, #4]
   2648e:	605a      	str	r2, [r3, #4]

#if defined(__GNUC__)
    if (p_iter->p_item == p_iter->p_set->section.p_end)
   26490:	687b      	ldr	r3, [r7, #4]
   26492:	685a      	ldr	r2, [r3, #4]
   26494:	687b      	ldr	r3, [r7, #4]
   26496:	681b      	ldr	r3, [r3, #0]
   26498:	685b      	ldr	r3, [r3, #4]
   2649a:	429a      	cmp	r2, r3
   2649c:	d104      	bne.n	264a8 <nrf_section_iter_next+0x3c>
    {
        p_iter->p_item = NULL;
   2649e:	687b      	ldr	r3, [r7, #4]
   264a0:	2200      	movs	r2, #0
   264a2:	605a      	str	r2, [r3, #4]
   264a4:	e000      	b.n	264a8 <nrf_section_iter_next+0x3c>
        return;
   264a6:	bf00      	nop
    {
        p_iter->p_section++;
        nrf_section_iter_item_set(p_iter);
    }
#endif
}
   264a8:	370c      	adds	r7, #12
   264aa:	46bd      	mov	sp, r7
   264ac:	bc80      	pop	{r7}
   264ae:	4770      	bx	lr

000264b0 <sd_ble_gap_data_length_update>:
 * @retval ::NRF_ERROR_RESOURCES The requested parameters can not be accommodated. Inspect
 *                               p_dl_limitation so see where the limitation is.
 * @retval ::NRF_ERROR_BUSY Peer has already initiated a Data Length Update Procedure. Process the
 *                          pending @ref BLE_GAP_EVT_DATA_LENGTH_UPDATE_REQUEST event to respond.
 */
SVCALL(SD_BLE_GAP_DATA_LENGTH_UPDATE, uint32_t, sd_ble_gap_data_length_update(uint16_t conn_handle, ble_gap_data_length_params_t const *p_dl_params, ble_gap_data_length_limitation_t *p_dl_limitation));
   264b0:	df90      	svc	144	; 0x90
   264b2:	4770      	bx	lr
   264b4:	bf00      	nop
   264b6:	4618      	mov	r0, r3

000264b8 <sd_ble_gattc_exchange_mtu_request>:
 * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle.
 * @retval ::NRF_ERROR_INVALID_STATE Invalid connection state or an ATT_MTU exchange was already requested once.
 * @retval ::NRF_ERROR_INVALID_PARAM Invalid Client RX MTU size supplied.
 * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
 */
SVCALL(SD_BLE_GATTC_EXCHANGE_MTU_REQUEST, uint32_t, sd_ble_gattc_exchange_mtu_request(uint16_t conn_handle, uint16_t client_rx_mtu));
   264b8:	df9e      	svc	158	; 0x9e
   264ba:	4770      	bx	lr
   264bc:	bf00      	nop
   264be:	4618      	mov	r0, r3

000264c0 <sd_ble_gatts_exchange_mtu_reply>:
 * @retval ::NRF_SUCCESS Successfully sent response to the client.
 * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
 * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State or no ATT_MTU exchange request pending.
 * @retval ::NRF_ERROR_INVALID_PARAM Invalid Server RX MTU size supplied.
 */
SVCALL(SD_BLE_GATTS_EXCHANGE_MTU_REPLY, uint32_t, sd_ble_gatts_exchange_mtu_reply(uint16_t conn_handle, uint16_t server_rx_mtu));
   264c0:	dfad      	svc	173	; 0xad
   264c2:	4770      	bx	lr
   264c4:	bf00      	nop
   264c6:	4618      	mov	r0, r3

000264c8 <link_init>:
STATIC_ASSERT(NRF_SDH_BLE_GATT_MAX_MTU_SIZE + L2CAP_HDR_LEN <= 255);


/**@brief Initialize a link's parameters to defaults. */
static void link_init(nrf_ble_gatt_link_t * p_link)
{
   264c8:	b480      	push	{r7}
   264ca:	b083      	sub	sp, #12
   264cc:	af00      	add	r7, sp, #0
   264ce:	6078      	str	r0, [r7, #4]
    p_link->att_mtu_desired            = NRF_SDH_BLE_GATT_MAX_MTU_SIZE;
   264d0:	687b      	ldr	r3, [r7, #4]
   264d2:	2217      	movs	r2, #23
   264d4:	801a      	strh	r2, [r3, #0]
    p_link->att_mtu_effective          = BLE_GATT_ATT_MTU_DEFAULT;
   264d6:	687b      	ldr	r3, [r7, #4]
   264d8:	2217      	movs	r2, #23
   264da:	805a      	strh	r2, [r3, #2]
    p_link->att_mtu_exchange_pending   = false;
   264dc:	687b      	ldr	r3, [r7, #4]
   264de:	2200      	movs	r2, #0
   264e0:	711a      	strb	r2, [r3, #4]
    p_link->att_mtu_exchange_requested = false;
   264e2:	687b      	ldr	r3, [r7, #4]
   264e4:	2200      	movs	r2, #0
   264e6:	715a      	strb	r2, [r3, #5]
    p_link->data_length_desired        = NRF_SDH_BLE_GATT_MAX_MTU_SIZE + L2CAP_HDR_LEN;
   264e8:	687b      	ldr	r3, [r7, #4]
   264ea:	221b      	movs	r2, #27
   264ec:	719a      	strb	r2, [r3, #6]
    p_link->data_length_effective      = BLE_GATT_ATT_MTU_DEFAULT + L2CAP_HDR_LEN;
   264ee:	687b      	ldr	r3, [r7, #4]
   264f0:	221b      	movs	r2, #27
   264f2:	71da      	strb	r2, [r3, #7]
}
   264f4:	bf00      	nop
   264f6:	370c      	adds	r7, #12
   264f8:	46bd      	mov	sp, r7
   264fa:	bc80      	pop	{r7}
   264fc:	4770      	bx	lr

000264fe <data_length_update>:
 *          When the peer requests a data length update, sd_ble_gap_data_length_update()
 *          is called directly in response to the BLE_GAP_EVT_DATA_LENGTH_UPDATE event in
 *          on_data_length_update_evt().
 */
static void data_length_update(uint16_t conn_handle, nrf_ble_gatt_t const * p_gatt)
{
   264fe:	b580      	push	{r7, lr}
   26500:	b086      	sub	sp, #24
   26502:	af00      	add	r7, sp, #0
   26504:	4603      	mov	r3, r0
   26506:	6039      	str	r1, [r7, #0]
   26508:	80fb      	strh	r3, [r7, #6]
                  p_gatt->links[conn_handle].data_length_desired, conn_handle);

    ble_gap_data_length_params_t const dlp =
    {
        .max_rx_octets  = p_gatt->links[conn_handle].data_length_desired,
        .max_tx_octets  = p_gatt->links[conn_handle].data_length_desired,
   2650a:	88fb      	ldrh	r3, [r7, #6]
   2650c:	683a      	ldr	r2, [r7, #0]
   2650e:	00db      	lsls	r3, r3, #3
   26510:	4413      	add	r3, r2
   26512:	7b1b      	ldrb	r3, [r3, #12]
   26514:	b29b      	uxth	r3, r3
    ble_gap_data_length_params_t const dlp =
   26516:	81bb      	strh	r3, [r7, #12]
        .max_rx_octets  = p_gatt->links[conn_handle].data_length_desired,
   26518:	88fb      	ldrh	r3, [r7, #6]
   2651a:	683a      	ldr	r2, [r7, #0]
   2651c:	00db      	lsls	r3, r3, #3
   2651e:	4413      	add	r3, r2
   26520:	7b1b      	ldrb	r3, [r3, #12]
   26522:	b29b      	uxth	r3, r3
    ble_gap_data_length_params_t const dlp =
   26524:	81fb      	strh	r3, [r7, #14]
   26526:	2300      	movs	r3, #0
   26528:	823b      	strh	r3, [r7, #16]
   2652a:	2300      	movs	r3, #0
   2652c:	827b      	strh	r3, [r7, #18]
        .max_rx_time_us = BLE_GAP_DATA_LENGTH_AUTO,
        .max_tx_time_us = BLE_GAP_DATA_LENGTH_AUTO,
    };

    ret_code_t err_code = sd_ble_gap_data_length_update(conn_handle, &dlp, NULL);
   2652e:	f107 010c 	add.w	r1, r7, #12
   26532:	88fb      	ldrh	r3, [r7, #6]
   26534:	2200      	movs	r2, #0
   26536:	4618      	mov	r0, r3
   26538:	f7ff ffba 	bl	264b0 <sd_ble_gap_data_length_update>
   2653c:	6178      	str	r0, [r7, #20]
    {
        NRF_LOG_ERROR("sd_ble_gap_data_length_update() (request)"
                      " on connection 0x%x returned unexpected value 0x%x.",
                      conn_handle, err_code);
    }
}
   2653e:	bf00      	nop
   26540:	3718      	adds	r7, #24
   26542:	46bd      	mov	sp, r7
   26544:	bd80      	pop	{r7, pc}

00026546 <on_connected_evt>:
 *
 * @param[in]   p_gatt      GATT structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_connected_evt(nrf_ble_gatt_t * p_gatt, ble_evt_t const * p_ble_evt)
{
   26546:	b580      	push	{r7, lr}
   26548:	b086      	sub	sp, #24
   2654a:	af00      	add	r7, sp, #0
   2654c:	6078      	str	r0, [r7, #4]
   2654e:	6039      	str	r1, [r7, #0]
    ret_code_t            err_code;
    uint16_t              conn_handle = p_ble_evt->evt.common_evt.conn_handle;
   26550:	683b      	ldr	r3, [r7, #0]
   26552:	889b      	ldrh	r3, [r3, #4]
   26554:	82fb      	strh	r3, [r7, #22]
    nrf_ble_gatt_link_t * p_link      = &p_gatt->links[conn_handle];
   26556:	8afb      	ldrh	r3, [r7, #22]
   26558:	00db      	lsls	r3, r3, #3
   2655a:	687a      	ldr	r2, [r7, #4]
   2655c:	4413      	add	r3, r2
   2655e:	3306      	adds	r3, #6
   26560:	613b      	str	r3, [r7, #16]

    // Update the link desired settings to reflect the current global settings.

    p_link->data_length_desired = p_gatt->data_length;
   26562:	687b      	ldr	r3, [r7, #4]
   26564:	791a      	ldrb	r2, [r3, #4]
   26566:	693b      	ldr	r3, [r7, #16]
   26568:	719a      	strb	r2, [r3, #6]

    switch (p_ble_evt->evt.gap_evt.params.connected.role)
   2656a:	683b      	ldr	r3, [r7, #0]
   2656c:	7bdb      	ldrb	r3, [r3, #15]
   2656e:	2b01      	cmp	r3, #1
   26570:	d002      	beq.n	26578 <on_connected_evt+0x32>
   26572:	2b02      	cmp	r3, #2
   26574:	d005      	beq.n	26582 <on_connected_evt+0x3c>
            p_link->att_mtu_desired = p_gatt->att_mtu_desired_central;
            break;

        default:
            // Ignore.
            break;
   26576:	e009      	b.n	2658c <on_connected_evt+0x46>
            p_link->att_mtu_desired = p_gatt->att_mtu_desired_periph;
   26578:	687b      	ldr	r3, [r7, #4]
   2657a:	881a      	ldrh	r2, [r3, #0]
   2657c:	693b      	ldr	r3, [r7, #16]
   2657e:	801a      	strh	r2, [r3, #0]
            break;
   26580:	e004      	b.n	2658c <on_connected_evt+0x46>
            p_link->att_mtu_desired = p_gatt->att_mtu_desired_central;
   26582:	687b      	ldr	r3, [r7, #4]
   26584:	885a      	ldrh	r2, [r3, #2]
   26586:	693b      	ldr	r3, [r7, #16]
   26588:	801a      	strh	r2, [r3, #0]
            break;
   2658a:	bf00      	nop
    }

    // Begin an ATT MTU exchange if necessary.
    if (p_link->att_mtu_desired > p_link->att_mtu_effective)
   2658c:	693b      	ldr	r3, [r7, #16]
   2658e:	881a      	ldrh	r2, [r3, #0]
   26590:	693b      	ldr	r3, [r7, #16]
   26592:	885b      	ldrh	r3, [r3, #2]
   26594:	429a      	cmp	r2, r3
   26596:	d914      	bls.n	265c2 <on_connected_evt+0x7c>
    {
        NRF_LOG_DEBUG("Requesting to update ATT MTU to %u bytes on connection 0x%x.",
                      p_link->att_mtu_desired, conn_handle);

        err_code = sd_ble_gattc_exchange_mtu_request(conn_handle, p_link->att_mtu_desired);
   26598:	693b      	ldr	r3, [r7, #16]
   2659a:	881a      	ldrh	r2, [r3, #0]
   2659c:	8afb      	ldrh	r3, [r7, #22]
   2659e:	4611      	mov	r1, r2
   265a0:	4618      	mov	r0, r3
   265a2:	f7ff ff89 	bl	264b8 <sd_ble_gattc_exchange_mtu_request>
   265a6:	60f8      	str	r0, [r7, #12]

        if (err_code == NRF_SUCCESS)
   265a8:	68fb      	ldr	r3, [r7, #12]
   265aa:	2b00      	cmp	r3, #0
   265ac:	d103      	bne.n	265b6 <on_connected_evt+0x70>
        {
            p_link->att_mtu_exchange_requested = true;
   265ae:	693b      	ldr	r3, [r7, #16]
   265b0:	2201      	movs	r2, #1
   265b2:	715a      	strb	r2, [r3, #5]
   265b4:	e005      	b.n	265c2 <on_connected_evt+0x7c>
        }
        else if (err_code == NRF_ERROR_BUSY)
   265b6:	68fb      	ldr	r3, [r7, #12]
   265b8:	2b11      	cmp	r3, #17
   265ba:	d102      	bne.n	265c2 <on_connected_evt+0x7c>
        {
            p_link->att_mtu_exchange_pending = true;
   265bc:	693b      	ldr	r3, [r7, #16]
   265be:	2201      	movs	r2, #1
   265c0:	711a      	strb	r2, [r3, #4]
                          err_code);
        }
    }

    // Send a data length update request if necessary.
    if (p_link->data_length_desired > p_link->data_length_effective)
   265c2:	693b      	ldr	r3, [r7, #16]
   265c4:	799a      	ldrb	r2, [r3, #6]
   265c6:	693b      	ldr	r3, [r7, #16]
   265c8:	79db      	ldrb	r3, [r3, #7]
   265ca:	429a      	cmp	r2, r3
   265cc:	d904      	bls.n	265d8 <on_connected_evt+0x92>
    {
        data_length_update(conn_handle, p_gatt);
   265ce:	8afb      	ldrh	r3, [r7, #22]
   265d0:	6879      	ldr	r1, [r7, #4]
   265d2:	4618      	mov	r0, r3
   265d4:	f7ff ff93 	bl	264fe <data_length_update>
    }
}
   265d8:	bf00      	nop
   265da:	3718      	adds	r7, #24
   265dc:	46bd      	mov	sp, r7
   265de:	bd80      	pop	{r7, pc}

000265e0 <on_disconnected_evt>:


static void on_disconnected_evt(nrf_ble_gatt_t * p_gatt, ble_evt_t const * p_ble_evt)
{
   265e0:	b580      	push	{r7, lr}
   265e2:	b082      	sub	sp, #8
   265e4:	af00      	add	r7, sp, #0
   265e6:	6078      	str	r0, [r7, #4]
   265e8:	6039      	str	r1, [r7, #0]
    // Reset connection parameters.
    link_init(&p_gatt->links[p_ble_evt->evt.gap_evt.conn_handle]);
   265ea:	683b      	ldr	r3, [r7, #0]
   265ec:	889b      	ldrh	r3, [r3, #4]
   265ee:	00db      	lsls	r3, r3, #3
   265f0:	687a      	ldr	r2, [r7, #4]
   265f2:	4413      	add	r3, r2
   265f4:	3306      	adds	r3, #6
   265f6:	4618      	mov	r0, r3
   265f8:	f7ff ff66 	bl	264c8 <link_init>
}
   265fc:	bf00      	nop
   265fe:	3708      	adds	r7, #8
   26600:	46bd      	mov	sp, r7
   26602:	bd80      	pop	{r7, pc}

00026604 <on_exchange_mtu_rsp_evt>:
 *
 * @param[in]   p_gatt      GATT structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_exchange_mtu_rsp_evt(nrf_ble_gatt_t * p_gatt, ble_evt_t const * p_ble_evt)
{
   26604:	b580      	push	{r7, lr}
   26606:	b086      	sub	sp, #24
   26608:	af00      	add	r7, sp, #0
   2660a:	6078      	str	r0, [r7, #4]
   2660c:	6039      	str	r1, [r7, #0]
    uint16_t conn_handle   = p_ble_evt->evt.gattc_evt.conn_handle;
   2660e:	683b      	ldr	r3, [r7, #0]
   26610:	889b      	ldrh	r3, [r3, #4]
   26612:	82fb      	strh	r3, [r7, #22]
    uint16_t server_rx_mtu = p_ble_evt->evt.gattc_evt.params.exchange_mtu_rsp.server_rx_mtu;
   26614:	683b      	ldr	r3, [r7, #0]
   26616:	895b      	ldrh	r3, [r3, #10]
   26618:	82bb      	strh	r3, [r7, #20]

    nrf_ble_gatt_link_t * p_link = &p_gatt->links[conn_handle];
   2661a:	8afb      	ldrh	r3, [r7, #22]
   2661c:	00db      	lsls	r3, r3, #3
   2661e:	687a      	ldr	r2, [r7, #4]
   26620:	4413      	add	r3, r2
   26622:	3306      	adds	r3, #6
   26624:	613b      	str	r3, [r7, #16]

    // Determine the lowest MTU between our own desired MTU and the peer's.
    // The MTU may not be less than BLE_GATT_ATT_MTU_DEFAULT.
    p_link->att_mtu_effective = MIN(server_rx_mtu, p_link->att_mtu_desired);
   26626:	693b      	ldr	r3, [r7, #16]
   26628:	881b      	ldrh	r3, [r3, #0]
   2662a:	8aba      	ldrh	r2, [r7, #20]
   2662c:	4293      	cmp	r3, r2
   2662e:	bf28      	it	cs
   26630:	4613      	movcs	r3, r2
   26632:	b29a      	uxth	r2, r3
   26634:	693b      	ldr	r3, [r7, #16]
   26636:	805a      	strh	r2, [r3, #2]
    p_link->att_mtu_effective = MAX(p_link->att_mtu_effective, BLE_GATT_ATT_MTU_DEFAULT);
   26638:	693b      	ldr	r3, [r7, #16]
   2663a:	885b      	ldrh	r3, [r3, #2]
   2663c:	2b17      	cmp	r3, #23
   2663e:	bf38      	it	cc
   26640:	2317      	movcc	r3, #23
   26642:	b29a      	uxth	r2, r3
   26644:	693b      	ldr	r3, [r7, #16]
   26646:	805a      	strh	r2, [r3, #2]
    NRF_LOG_DEBUG("ATT MTU updated to %u bytes on connection 0x%x (response).",
                  p_link->att_mtu_effective, conn_handle);

    // Trigger an event indicating that the ATT MTU size has changed.
    // Send an event to the application only if an ATT MTU exchange was requested.
    if ((p_gatt->evt_handler != NULL) && (p_link->att_mtu_exchange_requested))
   26648:	687b      	ldr	r3, [r7, #4]
   2664a:	699b      	ldr	r3, [r3, #24]
   2664c:	2b00      	cmp	r3, #0
   2664e:	d012      	beq.n	26676 <on_exchange_mtu_rsp_evt+0x72>
   26650:	693b      	ldr	r3, [r7, #16]
   26652:	795b      	ldrb	r3, [r3, #5]
   26654:	2b00      	cmp	r3, #0
   26656:	d00e      	beq.n	26676 <on_exchange_mtu_rsp_evt+0x72>
    {
        nrf_ble_gatt_evt_t const evt =
   26658:	f640 2377 	movw	r3, #2679	; 0xa77
   2665c:	813b      	strh	r3, [r7, #8]
   2665e:	8afb      	ldrh	r3, [r7, #22]
   26660:	817b      	strh	r3, [r7, #10]
        {
            .evt_id                   = NRF_BLE_GATT_EVT_ATT_MTU_UPDATED,
            .conn_handle              = conn_handle,
            .params.att_mtu_effective = p_link->att_mtu_effective,
   26662:	693b      	ldr	r3, [r7, #16]
   26664:	885b      	ldrh	r3, [r3, #2]
        nrf_ble_gatt_evt_t const evt =
   26666:	81bb      	strh	r3, [r7, #12]
        };

        p_gatt->evt_handler(p_gatt, &evt);
   26668:	687b      	ldr	r3, [r7, #4]
   2666a:	699b      	ldr	r3, [r3, #24]
   2666c:	f107 0208 	add.w	r2, r7, #8
   26670:	4611      	mov	r1, r2
   26672:	6878      	ldr	r0, [r7, #4]
   26674:	4798      	blx	r3
    }

    p_link->att_mtu_exchange_requested = false;
   26676:	693b      	ldr	r3, [r7, #16]
   26678:	2200      	movs	r2, #0
   2667a:	715a      	strb	r2, [r3, #5]
    p_link->att_mtu_exchange_pending   = false;
   2667c:	693b      	ldr	r3, [r7, #16]
   2667e:	2200      	movs	r2, #0
   26680:	711a      	strb	r2, [r3, #4]
}
   26682:	bf00      	nop
   26684:	3718      	adds	r7, #24
   26686:	46bd      	mov	sp, r7
   26688:	bd80      	pop	{r7, pc}

0002668a <on_exchange_mtu_request_evt>:
 *
 * @param[in]   p_gatt      GATT structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_exchange_mtu_request_evt(nrf_ble_gatt_t * p_gatt, ble_evt_t const * p_ble_evt)
{
   2668a:	b580      	push	{r7, lr}
   2668c:	b088      	sub	sp, #32
   2668e:	af00      	add	r7, sp, #0
   26690:	6078      	str	r0, [r7, #4]
   26692:	6039      	str	r1, [r7, #0]
    ret_code_t err_code;
    uint16_t   conn_handle = p_ble_evt->evt.gatts_evt.conn_handle;
   26694:	683b      	ldr	r3, [r7, #0]
   26696:	889b      	ldrh	r3, [r3, #4]
   26698:	83fb      	strh	r3, [r7, #30]
    uint16_t   client_mtu  = p_ble_evt->evt.gatts_evt.params.exchange_mtu_request.client_rx_mtu;
   2669a:	683b      	ldr	r3, [r7, #0]
   2669c:	88db      	ldrh	r3, [r3, #6]
   2669e:	83bb      	strh	r3, [r7, #28]

    nrf_ble_gatt_link_t * p_link = &p_gatt->links[conn_handle];
   266a0:	8bfb      	ldrh	r3, [r7, #30]
   266a2:	00db      	lsls	r3, r3, #3
   266a4:	687a      	ldr	r2, [r7, #4]
   266a6:	4413      	add	r3, r2
   266a8:	3306      	adds	r3, #6
   266aa:	61bb      	str	r3, [r7, #24]

    NRF_LOG_DEBUG("Peer on connection 0x%x requested an ATT MTU of %u bytes.",
                  conn_handle, client_mtu);

    client_mtu = MAX(client_mtu, BLE_GATT_ATT_MTU_DEFAULT);
   266ac:	8bbb      	ldrh	r3, [r7, #28]
   266ae:	2b17      	cmp	r3, #23
   266b0:	bf38      	it	cc
   266b2:	2317      	movcc	r3, #23
   266b4:	83bb      	strh	r3, [r7, #28]
    p_link->att_mtu_effective = MIN(client_mtu, p_link->att_mtu_desired);
   266b6:	69bb      	ldr	r3, [r7, #24]
   266b8:	881b      	ldrh	r3, [r3, #0]
   266ba:	8bba      	ldrh	r2, [r7, #28]
   266bc:	4293      	cmp	r3, r2
   266be:	bf28      	it	cs
   266c0:	4613      	movcs	r3, r2
   266c2:	b29a      	uxth	r2, r3
   266c4:	69bb      	ldr	r3, [r7, #24]
   266c6:	805a      	strh	r2, [r3, #2]
    p_link->att_mtu_exchange_pending = false;
   266c8:	69bb      	ldr	r3, [r7, #24]
   266ca:	2200      	movs	r2, #0
   266cc:	711a      	strb	r2, [r3, #4]

    NRF_LOG_DEBUG("Updating ATT MTU to %u bytes (desired: %u) on connection 0x%x.",
                  p_link->att_mtu_effective, p_link->att_mtu_desired, conn_handle);

    err_code = sd_ble_gatts_exchange_mtu_reply(conn_handle, p_link->att_mtu_desired);
   266ce:	69bb      	ldr	r3, [r7, #24]
   266d0:	881a      	ldrh	r2, [r3, #0]
   266d2:	8bfb      	ldrh	r3, [r7, #30]
   266d4:	4611      	mov	r1, r2
   266d6:	4618      	mov	r0, r3
   266d8:	f7ff fef2 	bl	264c0 <sd_ble_gatts_exchange_mtu_reply>
   266dc:	6178      	str	r0, [r7, #20]
    }

    // If an ATT_MTU exchange was requested to the peer, defer sending
    // the data length update request and the event to the application until
    // the response for that request is received.
    if (p_link->att_mtu_exchange_requested)
   266de:	69bb      	ldr	r3, [r7, #24]
   266e0:	795b      	ldrb	r3, [r3, #5]
   266e2:	2b00      	cmp	r3, #0
   266e4:	d113      	bne.n	2670e <on_exchange_mtu_request_evt+0x84>
    {
        return;
    }

    // The ATT MTU exchange has finished. Send an event to the application.
    if (p_gatt->evt_handler != NULL)
   266e6:	687b      	ldr	r3, [r7, #4]
   266e8:	699b      	ldr	r3, [r3, #24]
   266ea:	2b00      	cmp	r3, #0
   266ec:	d010      	beq.n	26710 <on_exchange_mtu_request_evt+0x86>
    {
        nrf_ble_gatt_evt_t const evt =
   266ee:	f640 2377 	movw	r3, #2679	; 0xa77
   266f2:	81bb      	strh	r3, [r7, #12]
   266f4:	8bfb      	ldrh	r3, [r7, #30]
   266f6:	81fb      	strh	r3, [r7, #14]
        {
            .evt_id                   = NRF_BLE_GATT_EVT_ATT_MTU_UPDATED,
            .conn_handle              = conn_handle,
            .params.att_mtu_effective = p_link->att_mtu_effective,
   266f8:	69bb      	ldr	r3, [r7, #24]
   266fa:	885b      	ldrh	r3, [r3, #2]
        nrf_ble_gatt_evt_t const evt =
   266fc:	823b      	strh	r3, [r7, #16]
        };

        p_gatt->evt_handler(p_gatt, &evt);
   266fe:	687b      	ldr	r3, [r7, #4]
   26700:	699b      	ldr	r3, [r3, #24]
   26702:	f107 020c 	add.w	r2, r7, #12
   26706:	4611      	mov	r1, r2
   26708:	6878      	ldr	r0, [r7, #4]
   2670a:	4798      	blx	r3
   2670c:	e000      	b.n	26710 <on_exchange_mtu_request_evt+0x86>
        return;
   2670e:	bf00      	nop
    }
}
   26710:	3720      	adds	r7, #32
   26712:	46bd      	mov	sp, r7
   26714:	bd80      	pop	{r7, pc}

00026716 <on_data_length_update_evt>:
 *
 * @param[in]   p_gatt      GATT structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_data_length_update_evt(nrf_ble_gatt_t * p_gatt, ble_evt_t const * p_ble_evt)
{
   26716:	b5b0      	push	{r4, r5, r7, lr}
   26718:	b092      	sub	sp, #72	; 0x48
   2671a:	af00      	add	r7, sp, #0
   2671c:	6078      	str	r0, [r7, #4]
   2671e:	6039      	str	r1, [r7, #0]
    ble_gap_evt_t const gap_evt     = p_ble_evt->evt.gap_evt;
   26720:	683b      	ldr	r3, [r7, #0]
   26722:	f107 0410 	add.w	r4, r7, #16
   26726:	1d1d      	adds	r5, r3, #4
   26728:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   2672a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   2672c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   2672e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   26730:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   26732:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   26734:	682b      	ldr	r3, [r5, #0]
   26736:	6023      	str	r3, [r4, #0]
    uint16_t      const conn_handle = gap_evt.conn_handle;
   26738:	8a3b      	ldrh	r3, [r7, #16]
   2673a:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46

    // Update the connection data length.
    p_gatt->links[conn_handle].data_length_effective =
        gap_evt.params.data_length_update.effective_params.max_tx_octets;
   2673e:	8aba      	ldrh	r2, [r7, #20]
    p_gatt->links[conn_handle].data_length_effective =
   26740:	f8b7 3046 	ldrh.w	r3, [r7, #70]	; 0x46
   26744:	b2d1      	uxtb	r1, r2
   26746:	687a      	ldr	r2, [r7, #4]
   26748:	00db      	lsls	r3, r3, #3
   2674a:	4413      	add	r3, r2
   2674c:	460a      	mov	r2, r1
   2674e:	735a      	strb	r2, [r3, #13]
    NRF_LOG_DEBUG("max_rx_time: %u",
                  gap_evt.params.data_length_update.effective_params.max_rx_time_us);
    NRF_LOG_DEBUG("max_tx_time: %u",
                  gap_evt.params.data_length_update.effective_params.max_tx_time_us);

    if (p_gatt->evt_handler != NULL)
   26750:	687b      	ldr	r3, [r7, #4]
   26752:	699b      	ldr	r3, [r3, #24]
   26754:	2b00      	cmp	r3, #0
   26756:	d018      	beq.n	2678a <on_data_length_update_evt+0x74>
    {
        nrf_ble_gatt_evt_t const evt =
   26758:	f107 0308 	add.w	r3, r7, #8
   2675c:	2200      	movs	r2, #0
   2675e:	601a      	str	r2, [r3, #0]
   26760:	809a      	strh	r2, [r3, #4]
   26762:	f64d 237a 	movw	r3, #55930	; 0xda7a
   26766:	813b      	strh	r3, [r7, #8]
   26768:	f8b7 3046 	ldrh.w	r3, [r7, #70]	; 0x46
   2676c:	817b      	strh	r3, [r7, #10]
        {
            .evt_id             = NRF_BLE_GATT_EVT_DATA_LENGTH_UPDATED,
            .conn_handle        = conn_handle,
            .params.data_length = p_gatt->links[conn_handle].data_length_effective,
   2676e:	f8b7 3046 	ldrh.w	r3, [r7, #70]	; 0x46
   26772:	687a      	ldr	r2, [r7, #4]
   26774:	00db      	lsls	r3, r3, #3
   26776:	4413      	add	r3, r2
   26778:	7b5b      	ldrb	r3, [r3, #13]
        nrf_ble_gatt_evt_t const evt =
   2677a:	733b      	strb	r3, [r7, #12]
        };

        p_gatt->evt_handler(p_gatt, &evt);
   2677c:	687b      	ldr	r3, [r7, #4]
   2677e:	699b      	ldr	r3, [r3, #24]
   26780:	f107 0208 	add.w	r2, r7, #8
   26784:	4611      	mov	r1, r2
   26786:	6878      	ldr	r0, [r7, #4]
   26788:	4798      	blx	r3
    }
}
   2678a:	bf00      	nop
   2678c:	3748      	adds	r7, #72	; 0x48
   2678e:	46bd      	mov	sp, r7
   26790:	bdb0      	pop	{r4, r5, r7, pc}

00026792 <on_data_length_update_request_evt>:
 *
 * @param[in]   p_gatt      GATT structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_data_length_update_request_evt(nrf_ble_gatt_t * p_gatt, ble_evt_t const * p_ble_evt)
{
   26792:	b580      	push	{r7, lr}
   26794:	b088      	sub	sp, #32
   26796:	af00      	add	r7, sp, #0
   26798:	6078      	str	r0, [r7, #4]
   2679a:	6039      	str	r1, [r7, #0]
    ret_code_t err_code;

    ble_gap_evt_t       const * p_gap_evt = &p_ble_evt->evt.gap_evt;
   2679c:	683b      	ldr	r3, [r7, #0]
   2679e:	3304      	adds	r3, #4
   267a0:	61fb      	str	r3, [r7, #28]
    nrf_ble_gatt_link_t       * p_link    = &p_gatt->links[p_gap_evt->conn_handle];
   267a2:	69fb      	ldr	r3, [r7, #28]
   267a4:	881b      	ldrh	r3, [r3, #0]
   267a6:	00db      	lsls	r3, r3, #3
   267a8:	687a      	ldr	r2, [r7, #4]
   267aa:	4413      	add	r3, r2
   267ac:	3306      	adds	r3, #6
   267ae:	61bb      	str	r3, [r7, #24]

    uint8_t const data_length_peer =
        p_gap_evt->params.data_length_update_request.peer_params.max_tx_octets;
   267b0:	69fb      	ldr	r3, [r7, #28]
   267b2:	889b      	ldrh	r3, [r3, #4]
    uint8_t const data_length_peer =
   267b4:	75fb      	strb	r3, [r7, #23]

    NRF_LOG_DEBUG("Peer on connection 0x%x requested a data length of %u bytes.",
                  p_gap_evt->conn_handle, data_length_peer);

    uint8_t const data_length = MIN(p_link->data_length_desired, data_length_peer);
   267b6:	69bb      	ldr	r3, [r7, #24]
   267b8:	799b      	ldrb	r3, [r3, #6]
   267ba:	7dfa      	ldrb	r2, [r7, #23]
   267bc:	4293      	cmp	r3, r2
   267be:	bf28      	it	cs
   267c0:	4613      	movcs	r3, r2
   267c2:	75bb      	strb	r3, [r7, #22]

    ble_gap_data_length_params_t const dlp =
   267c4:	f107 0308 	add.w	r3, r7, #8
   267c8:	2200      	movs	r2, #0
   267ca:	601a      	str	r2, [r3, #0]
   267cc:	605a      	str	r2, [r3, #4]
   267ce:	7dbb      	ldrb	r3, [r7, #22]
   267d0:	b29b      	uxth	r3, r3
   267d2:	813b      	strh	r3, [r7, #8]
   267d4:	7dbb      	ldrb	r3, [r7, #22]
   267d6:	b29b      	uxth	r3, r3
   267d8:	817b      	strh	r3, [r7, #10]
    };

    NRF_LOG_DEBUG("Updating data length to %u bytes on connection 0x%x.",
                  data_length, p_gap_evt->conn_handle);

    err_code = sd_ble_gap_data_length_update(p_gap_evt->conn_handle, &dlp, NULL);
   267da:	69fb      	ldr	r3, [r7, #28]
   267dc:	881b      	ldrh	r3, [r3, #0]
   267de:	f107 0108 	add.w	r1, r7, #8
   267e2:	2200      	movs	r2, #0
   267e4:	4618      	mov	r0, r3
   267e6:	f7ff fe63 	bl	264b0 <sd_ble_gap_data_length_update>
   267ea:	6138      	str	r0, [r7, #16]
    {
        NRF_LOG_ERROR("sd_ble_gap_data_length_update() (reply)"
                      " returned unexpected value 0x%x.",
                      err_code);
    }
}
   267ec:	bf00      	nop
   267ee:	3720      	adds	r7, #32
   267f0:	46bd      	mov	sp, r7
   267f2:	bd80      	pop	{r7, pc}

000267f4 <nrf_ble_gatt_init>:


ret_code_t nrf_ble_gatt_init(nrf_ble_gatt_t * p_gatt, nrf_ble_gatt_evt_handler_t evt_handler)
{
   267f4:	b580      	push	{r7, lr}
   267f6:	b084      	sub	sp, #16
   267f8:	af00      	add	r7, sp, #0
   267fa:	6078      	str	r0, [r7, #4]
   267fc:	6039      	str	r1, [r7, #0]
    VERIFY_PARAM_NOT_NULL(p_gatt);
   267fe:	687b      	ldr	r3, [r7, #4]
   26800:	2b00      	cmp	r3, #0
   26802:	d101      	bne.n	26808 <nrf_ble_gatt_init+0x14>
   26804:	230e      	movs	r3, #14
   26806:	e01d      	b.n	26844 <nrf_ble_gatt_init+0x50>

    p_gatt->evt_handler             = evt_handler;
   26808:	687b      	ldr	r3, [r7, #4]
   2680a:	683a      	ldr	r2, [r7, #0]
   2680c:	619a      	str	r2, [r3, #24]
    p_gatt->att_mtu_desired_periph  = NRF_SDH_BLE_GATT_MAX_MTU_SIZE;
   2680e:	687b      	ldr	r3, [r7, #4]
   26810:	2217      	movs	r2, #23
   26812:	801a      	strh	r2, [r3, #0]
    p_gatt->att_mtu_desired_central = NRF_SDH_BLE_GATT_MAX_MTU_SIZE;
   26814:	687b      	ldr	r3, [r7, #4]
   26816:	2217      	movs	r2, #23
   26818:	805a      	strh	r2, [r3, #2]
    p_gatt->data_length             = NRF_SDH_BLE_GATT_MAX_MTU_SIZE + L2CAP_HDR_LEN;
   2681a:	687b      	ldr	r3, [r7, #4]
   2681c:	221b      	movs	r2, #27
   2681e:	711a      	strb	r2, [r3, #4]

    for (uint32_t i = 0; i < NRF_BLE_GATT_LINK_COUNT; i++)
   26820:	2300      	movs	r3, #0
   26822:	60fb      	str	r3, [r7, #12]
   26824:	e00a      	b.n	2683c <nrf_ble_gatt_init+0x48>
    {
        link_init(&p_gatt->links[i]);
   26826:	68fb      	ldr	r3, [r7, #12]
   26828:	00db      	lsls	r3, r3, #3
   2682a:	687a      	ldr	r2, [r7, #4]
   2682c:	4413      	add	r3, r2
   2682e:	3306      	adds	r3, #6
   26830:	4618      	mov	r0, r3
   26832:	f7ff fe49 	bl	264c8 <link_init>
    for (uint32_t i = 0; i < NRF_BLE_GATT_LINK_COUNT; i++)
   26836:	68fb      	ldr	r3, [r7, #12]
   26838:	3301      	adds	r3, #1
   2683a:	60fb      	str	r3, [r7, #12]
   2683c:	68fb      	ldr	r3, [r7, #12]
   2683e:	2b01      	cmp	r3, #1
   26840:	d9f1      	bls.n	26826 <nrf_ble_gatt_init+0x32>
    }

    return NRF_SUCCESS;
   26842:	2300      	movs	r3, #0
}
   26844:	4618      	mov	r0, r3
   26846:	3710      	adds	r7, #16
   26848:	46bd      	mov	sp, r7
   2684a:	bd80      	pop	{r7, pc}

0002684c <nrf_ble_gatt_on_ble_evt>:
    return NRF_SUCCESS;
}


void nrf_ble_gatt_on_ble_evt(ble_evt_t const * p_ble_evt, void * p_context)
{
   2684c:	b580      	push	{r7, lr}
   2684e:	b086      	sub	sp, #24
   26850:	af00      	add	r7, sp, #0
   26852:	6078      	str	r0, [r7, #4]
   26854:	6039      	str	r1, [r7, #0]
    nrf_ble_gatt_t * p_gatt      = (nrf_ble_gatt_t *)p_context;
   26856:	683b      	ldr	r3, [r7, #0]
   26858:	617b      	str	r3, [r7, #20]
    uint16_t         conn_handle = p_ble_evt->evt.common_evt.conn_handle;
   2685a:	687b      	ldr	r3, [r7, #4]
   2685c:	889b      	ldrh	r3, [r3, #4]
   2685e:	827b      	strh	r3, [r7, #18]

    if (conn_handle >= NRF_BLE_GATT_LINK_COUNT)
   26860:	8a7b      	ldrh	r3, [r7, #18]
   26862:	2b01      	cmp	r3, #1
   26864:	d854      	bhi.n	26910 <nrf_ble_gatt_on_ble_evt+0xc4>
    {
        return;
    }

    switch (p_ble_evt->header.evt_id)
   26866:	687b      	ldr	r3, [r7, #4]
   26868:	881b      	ldrh	r3, [r3, #0]
   2686a:	2b23      	cmp	r3, #35	; 0x23
   2686c:	d026      	beq.n	268bc <nrf_ble_gatt_on_ble_evt+0x70>
   2686e:	2b23      	cmp	r3, #35	; 0x23
   26870:	dc04      	bgt.n	2687c <nrf_ble_gatt_on_ble_evt+0x30>
   26872:	2b10      	cmp	r3, #16
   26874:	d009      	beq.n	2688a <nrf_ble_gatt_on_ble_evt+0x3e>
   26876:	2b11      	cmp	r3, #17
   26878:	d00c      	beq.n	26894 <nrf_ble_gatt_on_ble_evt+0x48>
        case BLE_GAP_EVT_DATA_LENGTH_UPDATE_REQUEST:
            on_data_length_update_request_evt(p_gatt, p_ble_evt);
            break;

        default:
            break;
   2687a:	e024      	b.n	268c6 <nrf_ble_gatt_on_ble_evt+0x7a>
    switch (p_ble_evt->header.evt_id)
   2687c:	2b3a      	cmp	r3, #58	; 0x3a
   2687e:	d00e      	beq.n	2689e <nrf_ble_gatt_on_ble_evt+0x52>
   26880:	2b55      	cmp	r3, #85	; 0x55
   26882:	d011      	beq.n	268a8 <nrf_ble_gatt_on_ble_evt+0x5c>
   26884:	2b24      	cmp	r3, #36	; 0x24
   26886:	d014      	beq.n	268b2 <nrf_ble_gatt_on_ble_evt+0x66>
            break;
   26888:	e01d      	b.n	268c6 <nrf_ble_gatt_on_ble_evt+0x7a>
            on_connected_evt(p_gatt, p_ble_evt);
   2688a:	6879      	ldr	r1, [r7, #4]
   2688c:	6978      	ldr	r0, [r7, #20]
   2688e:	f7ff fe5a 	bl	26546 <on_connected_evt>
            break;
   26892:	e018      	b.n	268c6 <nrf_ble_gatt_on_ble_evt+0x7a>
            on_disconnected_evt(p_gatt, p_ble_evt);
   26894:	6879      	ldr	r1, [r7, #4]
   26896:	6978      	ldr	r0, [r7, #20]
   26898:	f7ff fea2 	bl	265e0 <on_disconnected_evt>
            break;
   2689c:	e013      	b.n	268c6 <nrf_ble_gatt_on_ble_evt+0x7a>
            on_exchange_mtu_rsp_evt(p_gatt, p_ble_evt);
   2689e:	6879      	ldr	r1, [r7, #4]
   268a0:	6978      	ldr	r0, [r7, #20]
   268a2:	f7ff feaf 	bl	26604 <on_exchange_mtu_rsp_evt>
            break;
   268a6:	e00e      	b.n	268c6 <nrf_ble_gatt_on_ble_evt+0x7a>
            on_exchange_mtu_request_evt(p_gatt, p_ble_evt);
   268a8:	6879      	ldr	r1, [r7, #4]
   268aa:	6978      	ldr	r0, [r7, #20]
   268ac:	f7ff feed 	bl	2668a <on_exchange_mtu_request_evt>
            break;
   268b0:	e009      	b.n	268c6 <nrf_ble_gatt_on_ble_evt+0x7a>
            on_data_length_update_evt(p_gatt, p_ble_evt);
   268b2:	6879      	ldr	r1, [r7, #4]
   268b4:	6978      	ldr	r0, [r7, #20]
   268b6:	f7ff ff2e 	bl	26716 <on_data_length_update_evt>
            break;
   268ba:	e004      	b.n	268c6 <nrf_ble_gatt_on_ble_evt+0x7a>
            on_data_length_update_request_evt(p_gatt, p_ble_evt);
   268bc:	6879      	ldr	r1, [r7, #4]
   268be:	6978      	ldr	r0, [r7, #20]
   268c0:	f7ff ff67 	bl	26792 <on_data_length_update_request_evt>
            break;
   268c4:	bf00      	nop
    }

    if (p_gatt->links[conn_handle].att_mtu_exchange_pending)
   268c6:	8a7b      	ldrh	r3, [r7, #18]
   268c8:	697a      	ldr	r2, [r7, #20]
   268ca:	00db      	lsls	r3, r3, #3
   268cc:	4413      	add	r3, r2
   268ce:	7a9b      	ldrb	r3, [r3, #10]
   268d0:	2b00      	cmp	r3, #0
   268d2:	d01e      	beq.n	26912 <nrf_ble_gatt_on_ble_evt+0xc6>
    {
        ret_code_t err_code;

        err_code = sd_ble_gattc_exchange_mtu_request(conn_handle,
   268d4:	8a7b      	ldrh	r3, [r7, #18]
   268d6:	697a      	ldr	r2, [r7, #20]
   268d8:	00db      	lsls	r3, r3, #3
   268da:	4413      	add	r3, r2
   268dc:	88da      	ldrh	r2, [r3, #6]
   268de:	8a7b      	ldrh	r3, [r7, #18]
   268e0:	4611      	mov	r1, r2
   268e2:	4618      	mov	r0, r3
   268e4:	f7ff fde8 	bl	264b8 <sd_ble_gattc_exchange_mtu_request>
   268e8:	60f8      	str	r0, [r7, #12]
                                                     p_gatt->links[conn_handle].att_mtu_desired);

        if (err_code == NRF_SUCCESS)
   268ea:	68fb      	ldr	r3, [r7, #12]
   268ec:	2b00      	cmp	r3, #0
   268ee:	d10c      	bne.n	2690a <nrf_ble_gatt_on_ble_evt+0xbe>
        {
            p_gatt->links[conn_handle].att_mtu_exchange_pending   = false;
   268f0:	8a7b      	ldrh	r3, [r7, #18]
   268f2:	697a      	ldr	r2, [r7, #20]
   268f4:	00db      	lsls	r3, r3, #3
   268f6:	4413      	add	r3, r2
   268f8:	2200      	movs	r2, #0
   268fa:	729a      	strb	r2, [r3, #10]
            p_gatt->links[conn_handle].att_mtu_exchange_requested = true;
   268fc:	8a7b      	ldrh	r3, [r7, #18]
   268fe:	697a      	ldr	r2, [r7, #20]
   26900:	00db      	lsls	r3, r3, #3
   26902:	4413      	add	r3, r2
   26904:	2201      	movs	r2, #1
   26906:	72da      	strb	r2, [r3, #11]
   26908:	e003      	b.n	26912 <nrf_ble_gatt_on_ble_evt+0xc6>

            NRF_LOG_DEBUG("Requesting to update ATT MTU to %u bytes on connection 0x%x (retry).",
                          p_gatt->links[conn_handle].att_mtu_desired, conn_handle);
        }
        else if (err_code != NRF_ERROR_BUSY)
   2690a:	68fb      	ldr	r3, [r7, #12]
   2690c:	2b11      	cmp	r3, #17
   2690e:	e000      	b.n	26912 <nrf_ble_gatt_on_ble_evt+0xc6>
        return;
   26910:	bf00      	nop
        {
            NRF_LOG_ERROR("sd_ble_gattc_exchange_mtu_request() returned unexpected value 0x%x.",
                          err_code);
        }
    }
}
   26912:	3718      	adds	r7, #24
   26914:	46bd      	mov	sp, r7
   26916:	bd80      	pop	{r7, pc}

00026918 <record_activate>:
 * @param role         The role of the connection.
 *
 * @return whether the record was activated successfully.
 */
static bool record_activate(uint16_t conn_handle)
{
   26918:	b580      	push	{r7, lr}
   2691a:	b084      	sub	sp, #16
   2691c:	af00      	add	r7, sp, #0
   2691e:	4603      	mov	r3, r0
   26920:	80fb      	strh	r3, [r7, #6]
    uint16_t available_index = sdk_mapped_flags_first_key_index_get(~m_bcs.flags.valid_flags);
   26922:	4b13      	ldr	r3, [pc, #76]	; (26970 <record_activate+0x58>)
   26924:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   26926:	43db      	mvns	r3, r3
   26928:	4618      	mov	r0, r3
   2692a:	f000 fda0 	bl	2746e <sdk_mapped_flags_first_key_index_get>
   2692e:	4603      	mov	r3, r0
   26930:	81fb      	strh	r3, [r7, #14]

    if (available_index != SDK_MAPPED_FLAGS_INVALID_INDEX)
   26932:	89fb      	ldrh	r3, [r7, #14]
   26934:	f64f 72ff 	movw	r2, #65535	; 0xffff
   26938:	4293      	cmp	r3, r2
   2693a:	d013      	beq.n	26964 <record_activate+0x4c>
    {
        m_bcs.valid_conn_handles[available_index] = conn_handle;
   2693c:	89fb      	ldrh	r3, [r7, #14]
   2693e:	4a0c      	ldr	r2, [pc, #48]	; (26970 <record_activate+0x58>)
   26940:	005b      	lsls	r3, r3, #1
   26942:	4413      	add	r3, r2
   26944:	88fa      	ldrh	r2, [r7, #6]
   26946:	809a      	strh	r2, [r3, #4]
        sdk_mapped_flags_update_by_key(m_bcs.valid_conn_handles,
   26948:	88fa      	ldrh	r2, [r7, #6]
   2694a:	2301      	movs	r3, #1
   2694c:	4909      	ldr	r1, [pc, #36]	; (26974 <record_activate+0x5c>)
   2694e:	480a      	ldr	r0, [pc, #40]	; (26978 <record_activate+0x60>)
   26950:	f000 fdaa 	bl	274a8 <sdk_mapped_flags_update_by_key>
                                      &m_bcs.flags.connected_flags,
                                       conn_handle,
                                       1);
        sdk_mapped_flags_update_by_key(m_bcs.valid_conn_handles,
   26954:	88fa      	ldrh	r2, [r7, #6]
   26956:	2301      	movs	r3, #1
   26958:	4908      	ldr	r1, [pc, #32]	; (2697c <record_activate+0x64>)
   2695a:	4807      	ldr	r0, [pc, #28]	; (26978 <record_activate+0x60>)
   2695c:	f000 fda4 	bl	274a8 <sdk_mapped_flags_update_by_key>
                                      &m_bcs.flags.valid_flags,
                                       conn_handle,
                                       1);

        return true;
   26960:	2301      	movs	r3, #1
   26962:	e000      	b.n	26966 <record_activate+0x4e>
    }

    return false;
   26964:	2300      	movs	r3, #0
}
   26966:	4618      	mov	r0, r3
   26968:	3710      	adds	r7, #16
   2696a:	46bd      	mov	sp, r7
   2696c:	bd80      	pop	{r7, pc}
   2696e:	bf00      	nop
   26970:	200052c0 	.word	0x200052c0
   26974:	20005308 	.word	0x20005308
   26978:	200052c4 	.word	0x200052c4
   2697c:	20005304 	.word	0x20005304

00026980 <record_invalidate>:
/**@brief Function for marking a connection record as invalid and resetting the values.
 *
 * @param p_record  The record to invalidate.
 */
static void record_invalidate(uint16_t conn_handle)
{
   26980:	b580      	push	{r7, lr}
   26982:	b084      	sub	sp, #16
   26984:	af02      	add	r7, sp, #8
   26986:	4603      	mov	r3, r0
   26988:	80fb      	strh	r3, [r7, #6]
    sdk_mapped_flags_bulk_update_by_key(m_bcs.valid_conn_handles,
   2698a:	88fa      	ldrh	r2, [r7, #6]
   2698c:	2300      	movs	r3, #0
   2698e:	9300      	str	r3, [sp, #0]
   26990:	4613      	mov	r3, r2
   26992:	221d      	movs	r2, #29
   26994:	4903      	ldr	r1, [pc, #12]	; (269a4 <record_invalidate+0x24>)
   26996:	4804      	ldr	r0, [pc, #16]	; (269a8 <record_invalidate+0x28>)
   26998:	f000 fd9e 	bl	274d8 <sdk_mapped_flags_bulk_update_by_key>
                                        m_bcs.flag_array,
                                        BLE_CONN_STATE_N_FLAGS,
                                        conn_handle,
                                        0);
}
   2699c:	bf00      	nop
   2699e:	3708      	adds	r7, #8
   269a0:	46bd      	mov	sp, r7
   269a2:	bd80      	pop	{r7, pc}
   269a4:	20005304 	.word	0x20005304
   269a8:	200052c4 	.word	0x200052c4

000269ac <record_set_disconnected>:
/**@brief Function for marking a connection as disconnected. See @ref BLE_CONN_STATUS_DISCONNECTED.
 *
 * @param p_record   The record of the connection to set as disconnected.
 */
static void record_set_disconnected(uint16_t conn_handle)
{
   269ac:	b580      	push	{r7, lr}
   269ae:	b082      	sub	sp, #8
   269b0:	af00      	add	r7, sp, #0
   269b2:	4603      	mov	r3, r0
   269b4:	80fb      	strh	r3, [r7, #6]
    sdk_mapped_flags_update_by_key(m_bcs.valid_conn_handles,
   269b6:	88fa      	ldrh	r2, [r7, #6]
   269b8:	2300      	movs	r3, #0
   269ba:	4904      	ldr	r1, [pc, #16]	; (269cc <record_set_disconnected+0x20>)
   269bc:	4804      	ldr	r0, [pc, #16]	; (269d0 <record_set_disconnected+0x24>)
   269be:	f000 fd73 	bl	274a8 <sdk_mapped_flags_update_by_key>
                                  &m_bcs.flags.connected_flags,
                                   conn_handle,
                                   0);
}
   269c2:	bf00      	nop
   269c4:	3708      	adds	r7, #8
   269c6:	46bd      	mov	sp, r7
   269c8:	bd80      	pop	{r7, pc}
   269ca:	bf00      	nop
   269cc:	20005308 	.word	0x20005308
   269d0:	200052c4 	.word	0x200052c4

000269d4 <record_purge_disconnected>:

/**@brief Function for invalidating records with a @ref BLE_CONN_STATUS_DISCONNECTED
 *        connection status
 */
static void record_purge_disconnected()
{
   269d4:	b580      	push	{r7, lr}
   269d6:	b0a4      	sub	sp, #144	; 0x90
   269d8:	af00      	add	r7, sp, #0
    sdk_mapped_flags_key_list_t disconnected_list;

    disconnected_list = sdk_mapped_flags_key_list_get(
                                   m_bcs.valid_conn_handles,
                                 (~m_bcs.flags.connected_flags) & (m_bcs.flags.valid_flags));
   269da:	4b17      	ldr	r3, [pc, #92]	; (26a38 <record_purge_disconnected+0x64>)
   269dc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   269de:	43da      	mvns	r2, r3
   269e0:	4b15      	ldr	r3, [pc, #84]	; (26a38 <record_purge_disconnected+0x64>)
   269e2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    disconnected_list = sdk_mapped_flags_key_list_get(
   269e4:	401a      	ands	r2, r3
   269e6:	463b      	mov	r3, r7
   269e8:	4914      	ldr	r1, [pc, #80]	; (26a3c <record_purge_disconnected+0x68>)
   269ea:	4618      	mov	r0, r3
   269ec:	f000 fde4 	bl	275b8 <sdk_mapped_flags_key_list_get>
   269f0:	f107 0348 	add.w	r3, r7, #72	; 0x48
   269f4:	4639      	mov	r1, r7
   269f6:	2244      	movs	r2, #68	; 0x44
   269f8:	4618      	mov	r0, r3
   269fa:	f000 ff05 	bl	27808 <memcpy>

    for (uint32_t i = 0; i < disconnected_list.len; i++)
   269fe:	2300      	movs	r3, #0
   26a00:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
   26a04:	e00f      	b.n	26a26 <record_purge_disconnected+0x52>
    {
        record_invalidate(disconnected_list.flag_keys[i]);
   26a06:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
   26a0a:	005b      	lsls	r3, r3, #1
   26a0c:	f107 0290 	add.w	r2, r7, #144	; 0x90
   26a10:	4413      	add	r3, r2
   26a12:	f833 3c44 	ldrh.w	r3, [r3, #-68]
   26a16:	4618      	mov	r0, r3
   26a18:	f7ff ffb2 	bl	26980 <record_invalidate>
    for (uint32_t i = 0; i < disconnected_list.len; i++)
   26a1c:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
   26a20:	3301      	adds	r3, #1
   26a22:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
   26a26:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   26a28:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
   26a2c:	429a      	cmp	r2, r3
   26a2e:	d3ea      	bcc.n	26a06 <record_purge_disconnected+0x32>
    }
}
   26a30:	bf00      	nop
   26a32:	3790      	adds	r7, #144	; 0x90
   26a34:	46bd      	mov	sp, r7
   26a36:	bd80      	pop	{r7, pc}
   26a38:	200052c0 	.word	0x200052c0
   26a3c:	200052c4 	.word	0x200052c4

00026a40 <ble_evt_handler>:
 *
 * @param[in]   p_ble_evt       Event received from the BLE stack.
 * @param[in]   p_context       Context.
 */
static void ble_evt_handler(ble_evt_t const * p_ble_evt, void * p_context)
{
   26a40:	b580      	push	{r7, lr}
   26a42:	b084      	sub	sp, #16
   26a44:	af00      	add	r7, sp, #0
   26a46:	6078      	str	r0, [r7, #4]
   26a48:	6039      	str	r1, [r7, #0]
    switch (p_ble_evt->header.evt_id)
   26a4a:	687b      	ldr	r3, [r7, #4]
   26a4c:	881b      	ldrh	r3, [r3, #0]
   26a4e:	2b11      	cmp	r3, #17
   26a50:	d026      	beq.n	26aa0 <ble_evt_handler+0x60>
   26a52:	2b1a      	cmp	r3, #26
   26a54:	d02a      	beq.n	26aac <ble_evt_handler+0x6c>
   26a56:	2b10      	cmp	r3, #16
   26a58:	d000      	beq.n	26a5c <ble_evt_handler+0x1c>
                         &m_bcs.flags.mitm_protected_flags,
                          p_ble_evt->evt.gap_evt.conn_handle,
                         (p_ble_evt->evt.gap_evt.params.conn_sec_update.conn_sec.sec_mode.lv > 2));
            break;
    }
}
   26a5a:	e048      	b.n	26aee <ble_evt_handler+0xae>
            record_purge_disconnected();
   26a5c:	f7ff ffba 	bl	269d4 <record_purge_disconnected>
            if ( !record_activate(p_ble_evt->evt.gap_evt.conn_handle) )
   26a60:	687b      	ldr	r3, [r7, #4]
   26a62:	889b      	ldrh	r3, [r3, #4]
   26a64:	4618      	mov	r0, r3
   26a66:	f7ff ff57 	bl	26918 <record_activate>
   26a6a:	4603      	mov	r3, r0
   26a6c:	f083 0301 	eor.w	r3, r3, #1
   26a70:	b2db      	uxtb	r3, r3
   26a72:	2b00      	cmp	r3, #0
   26a74:	d005      	beq.n	26a82 <ble_evt_handler+0x42>
                APP_ERROR_HANDLER(NRF_ERROR_NO_MEM);
   26a76:	4a20      	ldr	r2, [pc, #128]	; (26af8 <ble_evt_handler+0xb8>)
   26a78:	21e5      	movs	r1, #229	; 0xe5
   26a7a:	2004      	movs	r0, #4
   26a7c:	f7ff fa0e 	bl	25e9c <app_error_handler>
            break;
   26a80:	e035      	b.n	26aee <ble_evt_handler+0xae>
                        (p_ble_evt->evt.gap_evt.params.connected.role == BLE_GAP_ROLE_CENTRAL);
   26a82:	687b      	ldr	r3, [r7, #4]
   26a84:	7bdb      	ldrb	r3, [r3, #15]
                bool is_central =
   26a86:	2b02      	cmp	r3, #2
   26a88:	bf0c      	ite	eq
   26a8a:	2301      	moveq	r3, #1
   26a8c:	2300      	movne	r3, #0
   26a8e:	73fb      	strb	r3, [r7, #15]
                sdk_mapped_flags_update_by_key(m_bcs.valid_conn_handles,
   26a90:	687b      	ldr	r3, [r7, #4]
   26a92:	889a      	ldrh	r2, [r3, #4]
   26a94:	7bfb      	ldrb	r3, [r7, #15]
   26a96:	4919      	ldr	r1, [pc, #100]	; (26afc <ble_evt_handler+0xbc>)
   26a98:	4819      	ldr	r0, [pc, #100]	; (26b00 <ble_evt_handler+0xc0>)
   26a9a:	f000 fd05 	bl	274a8 <sdk_mapped_flags_update_by_key>
            break;
   26a9e:	e026      	b.n	26aee <ble_evt_handler+0xae>
            record_set_disconnected(p_ble_evt->evt.gap_evt.conn_handle);
   26aa0:	687b      	ldr	r3, [r7, #4]
   26aa2:	889b      	ldrh	r3, [r3, #4]
   26aa4:	4618      	mov	r0, r3
   26aa6:	f7ff ff81 	bl	269ac <record_set_disconnected>
            break;
   26aaa:	e020      	b.n	26aee <ble_evt_handler+0xae>
            sdk_mapped_flags_update_by_key(
   26aac:	687b      	ldr	r3, [r7, #4]
   26aae:	889a      	ldrh	r2, [r3, #4]
                         (p_ble_evt->evt.gap_evt.params.conn_sec_update.conn_sec.sec_mode.lv > 1));
   26ab0:	687b      	ldr	r3, [r7, #4]
   26ab2:	7a1b      	ldrb	r3, [r3, #8]
   26ab4:	f3c3 1303 	ubfx	r3, r3, #4, #4
   26ab8:	b2db      	uxtb	r3, r3
            sdk_mapped_flags_update_by_key(
   26aba:	2b01      	cmp	r3, #1
   26abc:	bf8c      	ite	hi
   26abe:	2301      	movhi	r3, #1
   26ac0:	2300      	movls	r3, #0
   26ac2:	b2db      	uxtb	r3, r3
   26ac4:	490f      	ldr	r1, [pc, #60]	; (26b04 <ble_evt_handler+0xc4>)
   26ac6:	480e      	ldr	r0, [pc, #56]	; (26b00 <ble_evt_handler+0xc0>)
   26ac8:	f000 fcee 	bl	274a8 <sdk_mapped_flags_update_by_key>
            sdk_mapped_flags_update_by_key(
   26acc:	687b      	ldr	r3, [r7, #4]
   26ace:	889a      	ldrh	r2, [r3, #4]
                         (p_ble_evt->evt.gap_evt.params.conn_sec_update.conn_sec.sec_mode.lv > 2));
   26ad0:	687b      	ldr	r3, [r7, #4]
   26ad2:	7a1b      	ldrb	r3, [r3, #8]
   26ad4:	f3c3 1303 	ubfx	r3, r3, #4, #4
   26ad8:	b2db      	uxtb	r3, r3
            sdk_mapped_flags_update_by_key(
   26ada:	2b02      	cmp	r3, #2
   26adc:	bf8c      	ite	hi
   26ade:	2301      	movhi	r3, #1
   26ae0:	2300      	movls	r3, #0
   26ae2:	b2db      	uxtb	r3, r3
   26ae4:	4908      	ldr	r1, [pc, #32]	; (26b08 <ble_evt_handler+0xc8>)
   26ae6:	4806      	ldr	r0, [pc, #24]	; (26b00 <ble_evt_handler+0xc0>)
   26ae8:	f000 fcde 	bl	274a8 <sdk_mapped_flags_update_by_key>
            break;
   26aec:	bf00      	nop
}
   26aee:	bf00      	nop
   26af0:	3710      	adds	r7, #16
   26af2:	46bd      	mov	sp, r7
   26af4:	bd80      	pop	{r7, pc}
   26af6:	bf00      	nop
   26af8:	00027b34 	.word	0x00027b34
   26afc:	2000530c 	.word	0x2000530c
   26b00:	200052c4 	.word	0x200052c4
   26b04:	20005310 	.word	0x20005310
   26b08:	20005314 	.word	0x20005314

00026b0c <ble_conn_state_role>:
                                       conn_handle);
}


uint8_t ble_conn_state_role(uint16_t conn_handle)
{
   26b0c:	b580      	push	{r7, lr}
   26b0e:	b084      	sub	sp, #16
   26b10:	af00      	add	r7, sp, #0
   26b12:	4603      	mov	r3, r0
   26b14:	80fb      	strh	r3, [r7, #6]
    uint8_t role = BLE_GAP_ROLE_INVALID;
   26b16:	2300      	movs	r3, #0
   26b18:	73fb      	strb	r3, [r7, #15]

    if ( sdk_mapped_flags_get_by_key(m_bcs.valid_conn_handles, m_bcs.flags.valid_flags, conn_handle) )
   26b1a:	4b0f      	ldr	r3, [pc, #60]	; (26b58 <ble_conn_state_role+0x4c>)
   26b1c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   26b1e:	88fa      	ldrh	r2, [r7, #6]
   26b20:	4619      	mov	r1, r3
   26b22:	480e      	ldr	r0, [pc, #56]	; (26b5c <ble_conn_state_role+0x50>)
   26b24:	f000 fd20 	bl	27568 <sdk_mapped_flags_get_by_key>
   26b28:	4603      	mov	r3, r0
   26b2a:	2b00      	cmp	r3, #0
   26b2c:	d00f      	beq.n	26b4e <ble_conn_state_role+0x42>
    {
        bool central = sdk_mapped_flags_get_by_key(m_bcs.valid_conn_handles,
   26b2e:	4b0a      	ldr	r3, [pc, #40]	; (26b58 <ble_conn_state_role+0x4c>)
   26b30:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   26b32:	88fa      	ldrh	r2, [r7, #6]
   26b34:	4619      	mov	r1, r3
   26b36:	4809      	ldr	r0, [pc, #36]	; (26b5c <ble_conn_state_role+0x50>)
   26b38:	f000 fd16 	bl	27568 <sdk_mapped_flags_get_by_key>
   26b3c:	4603      	mov	r3, r0
   26b3e:	73bb      	strb	r3, [r7, #14]
                                                   m_bcs.flags.central_flags,
                                                   conn_handle);

        role = central ? BLE_GAP_ROLE_CENTRAL : BLE_GAP_ROLE_PERIPH;
   26b40:	7bbb      	ldrb	r3, [r7, #14]
   26b42:	2b00      	cmp	r3, #0
   26b44:	d001      	beq.n	26b4a <ble_conn_state_role+0x3e>
   26b46:	2302      	movs	r3, #2
   26b48:	e000      	b.n	26b4c <ble_conn_state_role+0x40>
   26b4a:	2301      	movs	r3, #1
   26b4c:	73fb      	strb	r3, [r7, #15]
    }

    return role;
   26b4e:	7bfb      	ldrb	r3, [r7, #15]
}
   26b50:	4618      	mov	r0, r3
   26b52:	3710      	adds	r7, #16
   26b54:	46bd      	mov	sp, r7
   26b56:	bd80      	pop	{r7, pc}
   26b58:	200052c0 	.word	0x200052c0
   26b5c:	200052c4 	.word	0x200052c4

00026b60 <uint16_decode>:
 * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
 *
 * @return      Decoded value.
 */
static __INLINE uint16_t uint16_decode(const uint8_t * p_encoded_data)
{
   26b60:	b480      	push	{r7}
   26b62:	b083      	sub	sp, #12
   26b64:	af00      	add	r7, sp, #0
   26b66:	6078      	str	r0, [r7, #4]
        return ( (((uint16_t)((uint8_t *)p_encoded_data)[0])) |
   26b68:	687b      	ldr	r3, [r7, #4]
   26b6a:	781b      	ldrb	r3, [r3, #0]
   26b6c:	b21a      	sxth	r2, r3
                 (((uint16_t)((uint8_t *)p_encoded_data)[1]) << 8 ));
   26b6e:	687b      	ldr	r3, [r7, #4]
   26b70:	3301      	adds	r3, #1
   26b72:	781b      	ldrb	r3, [r3, #0]
   26b74:	021b      	lsls	r3, r3, #8
        return ( (((uint16_t)((uint8_t *)p_encoded_data)[0])) |
   26b76:	b21b      	sxth	r3, r3
   26b78:	4313      	orrs	r3, r2
   26b7a:	b21b      	sxth	r3, r3
   26b7c:	b29b      	uxth	r3, r3
}
   26b7e:	4618      	mov	r0, r3
   26b80:	370c      	adds	r7, #12
   26b82:	46bd      	mov	sp, r7
   26b84:	bc80      	pop	{r7}
   26b86:	4770      	bx	lr

00026b88 <ble_srv_is_notification_enabled>:
#include "nordic_common.h"
#include "app_error.h"
#include "ble.h"

bool ble_srv_is_notification_enabled(uint8_t const * p_encoded_data)
{
   26b88:	b580      	push	{r7, lr}
   26b8a:	b084      	sub	sp, #16
   26b8c:	af00      	add	r7, sp, #0
   26b8e:	6078      	str	r0, [r7, #4]
    uint16_t cccd_value = uint16_decode(p_encoded_data);
   26b90:	6878      	ldr	r0, [r7, #4]
   26b92:	f7ff ffe5 	bl	26b60 <uint16_decode>
   26b96:	4603      	mov	r3, r0
   26b98:	81fb      	strh	r3, [r7, #14]
    return ((cccd_value & BLE_GATT_HVX_NOTIFICATION) != 0);
   26b9a:	89fb      	ldrh	r3, [r7, #14]
   26b9c:	f003 0301 	and.w	r3, r3, #1
   26ba0:	2b00      	cmp	r3, #0
   26ba2:	bf14      	ite	ne
   26ba4:	2301      	movne	r3, #1
   26ba6:	2300      	moveq	r3, #0
   26ba8:	b2db      	uxtb	r3, r3
}
   26baa:	4618      	mov	r0, r3
   26bac:	3710      	adds	r7, #16
   26bae:	46bd      	mov	sp, r7
   26bb0:	bd80      	pop	{r7, pc}

00026bb2 <ble_srv_is_indication_enabled>:

bool ble_srv_is_indication_enabled(uint8_t const * p_encoded_data)
{
   26bb2:	b580      	push	{r7, lr}
   26bb4:	b084      	sub	sp, #16
   26bb6:	af00      	add	r7, sp, #0
   26bb8:	6078      	str	r0, [r7, #4]
    uint16_t cccd_value = uint16_decode(p_encoded_data);
   26bba:	6878      	ldr	r0, [r7, #4]
   26bbc:	f7ff ffd0 	bl	26b60 <uint16_decode>
   26bc0:	4603      	mov	r3, r0
   26bc2:	81fb      	strh	r3, [r7, #14]
    return ((cccd_value & BLE_GATT_HVX_INDICATION) != 0);
   26bc4:	89fb      	ldrh	r3, [r7, #14]
   26bc6:	f003 0302 	and.w	r3, r3, #2
   26bca:	2b00      	cmp	r3, #0
   26bcc:	bf14      	ite	ne
   26bce:	2301      	movne	r3, #1
   26bd0:	2300      	moveq	r3, #0
   26bd2:	b2db      	uxtb	r3, r3
}
   26bd4:	4618      	mov	r0, r3
   26bd6:	3710      	adds	r7, #16
   26bd8:	46bd      	mov	sp, r7
   26bda:	bd80      	pop	{r7, pc}

00026bdc <sd_ble_gap_adv_start>:
SVCALL(SD_BLE_GAP_ADV_START, uint32_t, sd_ble_gap_adv_start(ble_gap_adv_params_t const *p_adv_params, uint8_t conn_cfg_tag));
   26bdc:	df73      	svc	115	; 0x73
   26bde:	4770      	bx	lr
   26be0:	bf00      	nop
   26be2:	4618      	mov	r0, r3

00026be4 <whitelist_has_entries>:
    }

#else

    static bool whitelist_has_entries(ble_advertising_t * const p_advertising)
    {
   26be4:	b480      	push	{r7}
   26be6:	b083      	sub	sp, #12
   26be8:	af00      	add	r7, sp, #0
   26bea:	6078      	str	r0, [r7, #4]
        return p_advertising->whitelist_in_use;
   26bec:	687b      	ldr	r3, [r7, #4]
   26bee:	f893 30d6 	ldrb.w	r3, [r3, #214]	; 0xd6
    }
   26bf2:	4618      	mov	r0, r3
   26bf4:	370c      	adds	r7, #12
   26bf6:	46bd      	mov	sp, r7
   26bf8:	bc80      	pop	{r7}
   26bfa:	4770      	bx	lr

00026bfc <addr_is_valid>:


/**@brief Function for checking if an address is valid.
 */
static bool addr_is_valid(uint8_t const * const addr)
{
   26bfc:	b480      	push	{r7}
   26bfe:	b085      	sub	sp, #20
   26c00:	af00      	add	r7, sp, #0
   26c02:	6078      	str	r0, [r7, #4]
    for (uint32_t i = 0; i < BLE_GAP_ADDR_LEN; i++)
   26c04:	2300      	movs	r3, #0
   26c06:	60fb      	str	r3, [r7, #12]
   26c08:	e00a      	b.n	26c20 <addr_is_valid+0x24>
    {
        if (addr[i] != 0)
   26c0a:	687a      	ldr	r2, [r7, #4]
   26c0c:	68fb      	ldr	r3, [r7, #12]
   26c0e:	4413      	add	r3, r2
   26c10:	781b      	ldrb	r3, [r3, #0]
   26c12:	2b00      	cmp	r3, #0
   26c14:	d001      	beq.n	26c1a <addr_is_valid+0x1e>
        {
            return true;
   26c16:	2301      	movs	r3, #1
   26c18:	e006      	b.n	26c28 <addr_is_valid+0x2c>
    for (uint32_t i = 0; i < BLE_GAP_ADDR_LEN; i++)
   26c1a:	68fb      	ldr	r3, [r7, #12]
   26c1c:	3301      	adds	r3, #1
   26c1e:	60fb      	str	r3, [r7, #12]
   26c20:	68fb      	ldr	r3, [r7, #12]
   26c22:	2b05      	cmp	r3, #5
   26c24:	d9f1      	bls.n	26c0a <addr_is_valid+0xe>
        }
    }
    return false;
   26c26:	2300      	movs	r3, #0
}
   26c28:	4618      	mov	r0, r3
   26c2a:	3714      	adds	r7, #20
   26c2c:	46bd      	mov	sp, r7
   26c2e:	bc80      	pop	{r7}
   26c30:	4770      	bx	lr
	...

00026c34 <adv_mode_next_get>:


static ble_adv_mode_t adv_mode_next_get(ble_adv_mode_t adv_mode)
{
   26c34:	b480      	push	{r7}
   26c36:	b083      	sub	sp, #12
   26c38:	af00      	add	r7, sp, #0
   26c3a:	4603      	mov	r3, r0
   26c3c:	71fb      	strb	r3, [r7, #7]
    return (ble_adv_mode_t)((adv_mode + 1) % BLE_ADV_MODES);
   26c3e:	79fb      	ldrb	r3, [r7, #7]
   26c40:	1c5a      	adds	r2, r3, #1
   26c42:	4b08      	ldr	r3, [pc, #32]	; (26c64 <adv_mode_next_get+0x30>)
   26c44:	fb83 1302 	smull	r1, r3, r3, r2
   26c48:	1059      	asrs	r1, r3, #1
   26c4a:	17d3      	asrs	r3, r2, #31
   26c4c:	1ac9      	subs	r1, r1, r3
   26c4e:	460b      	mov	r3, r1
   26c50:	009b      	lsls	r3, r3, #2
   26c52:	440b      	add	r3, r1
   26c54:	1ad1      	subs	r1, r2, r3
   26c56:	b2cb      	uxtb	r3, r1
}
   26c58:	4618      	mov	r0, r3
   26c5a:	370c      	adds	r7, #12
   26c5c:	46bd      	mov	sp, r7
   26c5e:	bc80      	pop	{r7}
   26c60:	4770      	bx	lr
   26c62:	bf00      	nop
   26c64:	66666667 	.word	0x66666667

00026c68 <on_connected>:
/**@brief Function for handling the Connected event.
 *
 * @param[in] p_ble_evt Event received from the BLE stack.
 */
static void on_connected(ble_advertising_t * const p_advertising, ble_evt_t const * p_ble_evt)
{
   26c68:	b480      	push	{r7}
   26c6a:	b083      	sub	sp, #12
   26c6c:	af00      	add	r7, sp, #0
   26c6e:	6078      	str	r0, [r7, #4]
   26c70:	6039      	str	r1, [r7, #0]
    if (p_ble_evt->evt.gap_evt.params.connected.role == BLE_GAP_ROLE_PERIPH)
   26c72:	683b      	ldr	r3, [r7, #0]
   26c74:	7bdb      	ldrb	r3, [r3, #15]
   26c76:	2b01      	cmp	r3, #1
   26c78:	d104      	bne.n	26c84 <on_connected+0x1c>
    {
        p_advertising->current_slave_link_conn_handle = p_ble_evt->evt.gap_evt.conn_handle;
   26c7a:	683b      	ldr	r3, [r7, #0]
   26c7c:	889a      	ldrh	r2, [r3, #4]
   26c7e:	687b      	ldr	r3, [r7, #4]
   26c80:	f8a3 20c8 	strh.w	r2, [r3, #200]	; 0xc8
    }
}
   26c84:	bf00      	nop
   26c86:	370c      	adds	r7, #12
   26c88:	46bd      	mov	sp, r7
   26c8a:	bc80      	pop	{r7}
   26c8c:	4770      	bx	lr

00026c8e <on_disconnected>:
 *
 * @param[in] p_advertising Advertising module instance.
 * @param[in] p_ble_evt Event received from the BLE stack.
 */
static void on_disconnected(ble_advertising_t * const p_advertising, ble_evt_t const * p_ble_evt)
{
   26c8e:	b580      	push	{r7, lr}
   26c90:	b084      	sub	sp, #16
   26c92:	af00      	add	r7, sp, #0
   26c94:	6078      	str	r0, [r7, #4]
   26c96:	6039      	str	r1, [r7, #0]
    uint32_t ret;

    p_advertising->whitelist_temporarily_disabled = false;
   26c98:	687b      	ldr	r3, [r7, #4]
   26c9a:	2200      	movs	r2, #0
   26c9c:	f883 20d4 	strb.w	r2, [r3, #212]	; 0xd4

    if (p_ble_evt->evt.gap_evt.conn_handle == p_advertising->current_slave_link_conn_handle &&
   26ca0:	683b      	ldr	r3, [r7, #0]
   26ca2:	889a      	ldrh	r2, [r3, #4]
   26ca4:	687b      	ldr	r3, [r7, #4]
   26ca6:	f8b3 30c8 	ldrh.w	r3, [r3, #200]	; 0xc8
   26caa:	429a      	cmp	r2, r3
   26cac:	d118      	bne.n	26ce0 <on_disconnected+0x52>
        p_advertising->adv_modes_config.ble_adv_on_disconnect_disabled == false)
   26cae:	687b      	ldr	r3, [r7, #4]
   26cb0:	791b      	ldrb	r3, [r3, #4]
   26cb2:	f083 0301 	eor.w	r3, r3, #1
   26cb6:	b2db      	uxtb	r3, r3
    if (p_ble_evt->evt.gap_evt.conn_handle == p_advertising->current_slave_link_conn_handle &&
   26cb8:	2b00      	cmp	r3, #0
   26cba:	d011      	beq.n	26ce0 <on_disconnected+0x52>
    {
       ret = ble_advertising_start(p_advertising, BLE_ADV_MODE_DIRECTED);
   26cbc:	2101      	movs	r1, #1
   26cbe:	6878      	ldr	r0, [r7, #4]
   26cc0:	f000 fa5c 	bl	2717c <ble_advertising_start>
   26cc4:	60f8      	str	r0, [r7, #12]
       if ((ret != NRF_SUCCESS) && (p_advertising->error_handler != NULL))
   26cc6:	68fb      	ldr	r3, [r7, #12]
   26cc8:	2b00      	cmp	r3, #0
   26cca:	d009      	beq.n	26ce0 <on_disconnected+0x52>
   26ccc:	687b      	ldr	r3, [r7, #4]
   26cce:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
   26cd2:	2b00      	cmp	r3, #0
   26cd4:	d004      	beq.n	26ce0 <on_disconnected+0x52>
       {
           p_advertising->error_handler(ret);
   26cd6:	687b      	ldr	r3, [r7, #4]
   26cd8:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
   26cdc:	68f8      	ldr	r0, [r7, #12]
   26cde:	4798      	blx	r3
       }
    }
}
   26ce0:	bf00      	nop
   26ce2:	3710      	adds	r7, #16
   26ce4:	46bd      	mov	sp, r7
   26ce6:	bd80      	pop	{r7, pc}

00026ce8 <on_timeout>:
 *
 * @param[in] p_advertising Advertising module instance.
 * @param[in] p_ble_evt Event received from the BLE stack.
 */
static void on_timeout(ble_advertising_t * const p_advertising, ble_evt_t const * p_ble_evt)
{
   26ce8:	b580      	push	{r7, lr}
   26cea:	b084      	sub	sp, #16
   26cec:	af00      	add	r7, sp, #0
   26cee:	6078      	str	r0, [r7, #4]
   26cf0:	6039      	str	r1, [r7, #0]
    ret_code_t ret;

    if (p_ble_evt->evt.gap_evt.params.timeout.src != BLE_GAP_TIMEOUT_SRC_ADVERTISING)
   26cf2:	683b      	ldr	r3, [r7, #0]
   26cf4:	7a1b      	ldrb	r3, [r3, #8]
   26cf6:	2b00      	cmp	r3, #0
   26cf8:	d118      	bne.n	26d2c <on_timeout+0x44>
        // Nothing to do.
        return;
    }

    // Start advertising in the next mode.
    ret = ble_advertising_start(p_advertising, adv_mode_next_get(p_advertising->adv_mode_current));
   26cfa:	687b      	ldr	r3, [r7, #4]
   26cfc:	78db      	ldrb	r3, [r3, #3]
   26cfe:	4618      	mov	r0, r3
   26d00:	f7ff ff98 	bl	26c34 <adv_mode_next_get>
   26d04:	4603      	mov	r3, r0
   26d06:	4619      	mov	r1, r3
   26d08:	6878      	ldr	r0, [r7, #4]
   26d0a:	f000 fa37 	bl	2717c <ble_advertising_start>
   26d0e:	60f8      	str	r0, [r7, #12]

    if ((ret != NRF_SUCCESS) && (p_advertising->error_handler != NULL))
   26d10:	68fb      	ldr	r3, [r7, #12]
   26d12:	2b00      	cmp	r3, #0
   26d14:	d00b      	beq.n	26d2e <on_timeout+0x46>
   26d16:	687b      	ldr	r3, [r7, #4]
   26d18:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
   26d1c:	2b00      	cmp	r3, #0
   26d1e:	d006      	beq.n	26d2e <on_timeout+0x46>
    {
        p_advertising->error_handler(ret);
   26d20:	687b      	ldr	r3, [r7, #4]
   26d22:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
   26d26:	68f8      	ldr	r0, [r7, #12]
   26d28:	4798      	blx	r3
   26d2a:	e000      	b.n	26d2e <on_timeout+0x46>
        return;
   26d2c:	bf00      	nop
    }
}
   26d2e:	3710      	adds	r7, #16
   26d30:	46bd      	mov	sp, r7
   26d32:	bd80      	pop	{r7, pc}

00026d34 <flash_access_in_progress>:
/** @brief Function to determine if a flash write operation in in progress.
 *
 * @return true if a flash operation is in progress, false if not.
 */
static bool flash_access_in_progress()
{
   26d34:	b580      	push	{r7, lr}
   26d36:	af00      	add	r7, sp, #0
    return nrf_fstorage_is_busy(NULL);
   26d38:	2000      	movs	r0, #0
   26d3a:	f000 fce3 	bl	27704 <nrf_fstorage_is_busy>
   26d3e:	4603      	mov	r3, r0
}
   26d40:	4618      	mov	r0, r3
   26d42:	bd80      	pop	{r7, pc}

00026d44 <adv_mode_next_avail_get>:
 *
 * @returns adv_mode if possible, or the best available mode if not.
 */
static ble_adv_mode_t adv_mode_next_avail_get(ble_advertising_t * const p_advertising,
                                              ble_adv_mode_t            adv_mode)
{
   26d44:	b580      	push	{r7, lr}
   26d46:	b084      	sub	sp, #16
   26d48:	af00      	add	r7, sp, #0
   26d4a:	6078      	str	r0, [r7, #4]
   26d4c:	460b      	mov	r3, r1
   26d4e:	70fb      	strb	r3, [r7, #3]
    bool peer_addr_is_valid = addr_is_valid(p_advertising->peer_address.addr);
   26d50:	687b      	ldr	r3, [r7, #4]
   26d52:	3326      	adds	r3, #38	; 0x26
   26d54:	4618      	mov	r0, r3
   26d56:	f7ff ff51 	bl	26bfc <addr_is_valid>
   26d5a:	4603      	mov	r3, r0
   26d5c:	73fb      	strb	r3, [r7, #15]

    // If a mode is disabled, continue to the next mode.

    switch (adv_mode)
   26d5e:	78fb      	ldrb	r3, [r7, #3]
   26d60:	3b01      	subs	r3, #1
   26d62:	2b03      	cmp	r3, #3
   26d64:	d828      	bhi.n	26db8 <adv_mode_next_avail_get+0x74>
   26d66:	a201      	add	r2, pc, #4	; (adr r2, 26d6c <adv_mode_next_avail_get+0x28>)
   26d68:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   26d6c:	00026d7d 	.word	0x00026d7d
   26d70:	00026d8f 	.word	0x00026d8f
   26d74:	00026da1 	.word	0x00026da1
   26d78:	00026dad 	.word	0x00026dad
    {
        case BLE_ADV_MODE_DIRECTED:
            if ((p_advertising->adv_modes_config.ble_adv_directed_enabled) && peer_addr_is_valid)
   26d7c:	687b      	ldr	r3, [r7, #4]
   26d7e:	799b      	ldrb	r3, [r3, #6]
   26d80:	2b00      	cmp	r3, #0
   26d82:	d004      	beq.n	26d8e <adv_mode_next_avail_get+0x4a>
   26d84:	7bfb      	ldrb	r3, [r7, #15]
   26d86:	2b00      	cmp	r3, #0
   26d88:	d001      	beq.n	26d8e <adv_mode_next_avail_get+0x4a>
            {
                return BLE_ADV_MODE_DIRECTED;
   26d8a:	2301      	movs	r3, #1
   26d8c:	e015      	b.n	26dba <adv_mode_next_avail_get+0x76>
            }
            // Fallthrough.

        case BLE_ADV_MODE_DIRECTED_SLOW:
            if ((p_advertising->adv_modes_config.ble_adv_directed_slow_enabled) && peer_addr_is_valid)
   26d8e:	687b      	ldr	r3, [r7, #4]
   26d90:	79db      	ldrb	r3, [r3, #7]
   26d92:	2b00      	cmp	r3, #0
   26d94:	d004      	beq.n	26da0 <adv_mode_next_avail_get+0x5c>
   26d96:	7bfb      	ldrb	r3, [r7, #15]
   26d98:	2b00      	cmp	r3, #0
   26d9a:	d001      	beq.n	26da0 <adv_mode_next_avail_get+0x5c>
            {
                return BLE_ADV_MODE_DIRECTED_SLOW;
   26d9c:	2302      	movs	r3, #2
   26d9e:	e00c      	b.n	26dba <adv_mode_next_avail_get+0x76>
            }
            // Fallthrough.

        case BLE_ADV_MODE_FAST:
            if (p_advertising->adv_modes_config.ble_adv_fast_enabled)
   26da0:	687b      	ldr	r3, [r7, #4]
   26da2:	7a1b      	ldrb	r3, [r3, #8]
   26da4:	2b00      	cmp	r3, #0
   26da6:	d001      	beq.n	26dac <adv_mode_next_avail_get+0x68>
            {
                return BLE_ADV_MODE_FAST;
   26da8:	2303      	movs	r3, #3
   26daa:	e006      	b.n	26dba <adv_mode_next_avail_get+0x76>
            }
            // Fallthrough.

        case BLE_ADV_MODE_SLOW:
            if (p_advertising->adv_modes_config.ble_adv_slow_enabled)
   26dac:	687b      	ldr	r3, [r7, #4]
   26dae:	7a5b      	ldrb	r3, [r3, #9]
   26db0:	2b00      	cmp	r3, #0
   26db2:	d001      	beq.n	26db8 <adv_mode_next_avail_get+0x74>
            {
                return BLE_ADV_MODE_SLOW;
   26db4:	2304      	movs	r3, #4
   26db6:	e000      	b.n	26dba <adv_mode_next_avail_get+0x76>
            }
            // Fallthrough.

        default:
            return BLE_ADV_MODE_IDLE;
   26db8:	2300      	movs	r3, #0
    }
}
   26dba:	4618      	mov	r0, r3
   26dbc:	3710      	adds	r7, #16
   26dbe:	46bd      	mov	sp, r7
   26dc0:	bd80      	pop	{r7, pc}
   26dc2:	bf00      	nop

00026dc4 <set_adv_mode_directed>:
 *
 * @return NRF_SUCCESS
 */
static ret_code_t set_adv_mode_directed(ble_advertising_t * const p_advertising,
                                        ble_gap_adv_params_t    * p_adv_params)
{
   26dc4:	b480      	push	{r7}
   26dc6:	b083      	sub	sp, #12
   26dc8:	af00      	add	r7, sp, #0
   26dca:	6078      	str	r0, [r7, #4]
   26dcc:	6039      	str	r1, [r7, #0]
    p_advertising->adv_evt  = BLE_ADV_EVT_DIRECTED;
   26dce:	687b      	ldr	r3, [r7, #4]
   26dd0:	2201      	movs	r2, #1
   26dd2:	709a      	strb	r2, [r3, #2]

    p_adv_params->p_peer_addr = &(p_advertising->peer_address);
   26dd4:	687b      	ldr	r3, [r7, #4]
   26dd6:	f103 0225 	add.w	r2, r3, #37	; 0x25
   26dda:	683b      	ldr	r3, [r7, #0]
   26ddc:	605a      	str	r2, [r3, #4]
    p_adv_params->type        = BLE_GAP_ADV_TYPE_ADV_DIRECT_IND;
   26dde:	683b      	ldr	r3, [r7, #0]
   26de0:	2201      	movs	r2, #1
   26de2:	701a      	strb	r2, [r3, #0]
    p_adv_params->timeout     = 0;
   26de4:	683b      	ldr	r3, [r7, #0]
   26de6:	2200      	movs	r2, #0
   26de8:	819a      	strh	r2, [r3, #12]
    p_adv_params->interval    = 0;
   26dea:	683b      	ldr	r3, [r7, #0]
   26dec:	2200      	movs	r2, #0
   26dee:	815a      	strh	r2, [r3, #10]

    return NRF_SUCCESS;
   26df0:	2300      	movs	r3, #0
}
   26df2:	4618      	mov	r0, r3
   26df4:	370c      	adds	r7, #12
   26df6:	46bd      	mov	sp, r7
   26df8:	bc80      	pop	{r7}
   26dfa:	4770      	bx	lr

00026dfc <set_adv_mode_directed_slow>:
 *
 * @return NRF_SUCCESS
 */
static ret_code_t set_adv_mode_directed_slow(ble_advertising_t * const p_advertising,
                                             ble_gap_adv_params_t    * p_adv_params)
{
   26dfc:	b480      	push	{r7}
   26dfe:	b083      	sub	sp, #12
   26e00:	af00      	add	r7, sp, #0
   26e02:	6078      	str	r0, [r7, #4]
   26e04:	6039      	str	r1, [r7, #0]
    p_advertising->adv_evt = BLE_ADV_EVT_DIRECTED_SLOW;
   26e06:	687b      	ldr	r3, [r7, #4]
   26e08:	2202      	movs	r2, #2
   26e0a:	709a      	strb	r2, [r3, #2]

    p_adv_params->p_peer_addr = &p_advertising->peer_address;
   26e0c:	687b      	ldr	r3, [r7, #4]
   26e0e:	f103 0225 	add.w	r2, r3, #37	; 0x25
   26e12:	683b      	ldr	r3, [r7, #0]
   26e14:	605a      	str	r2, [r3, #4]
    p_adv_params->type        = BLE_GAP_ADV_TYPE_ADV_DIRECT_IND;
   26e16:	683b      	ldr	r3, [r7, #0]
   26e18:	2201      	movs	r2, #1
   26e1a:	701a      	strb	r2, [r3, #0]
    p_adv_params->timeout     = p_advertising->adv_modes_config.ble_adv_directed_slow_timeout;
   26e1c:	687b      	ldr	r3, [r7, #4]
   26e1e:	691b      	ldr	r3, [r3, #16]
   26e20:	b29a      	uxth	r2, r3
   26e22:	683b      	ldr	r3, [r7, #0]
   26e24:	819a      	strh	r2, [r3, #12]
    p_adv_params->interval    = p_advertising->adv_modes_config.ble_adv_directed_slow_interval;
   26e26:	687b      	ldr	r3, [r7, #4]
   26e28:	68db      	ldr	r3, [r3, #12]
   26e2a:	b29a      	uxth	r2, r3
   26e2c:	683b      	ldr	r3, [r7, #0]
   26e2e:	815a      	strh	r2, [r3, #10]

    return NRF_SUCCESS;
   26e30:	2300      	movs	r3, #0
}
   26e32:	4618      	mov	r0, r3
   26e34:	370c      	adds	r7, #12
   26e36:	46bd      	mov	sp, r7
   26e38:	bc80      	pop	{r7}
   26e3a:	4770      	bx	lr

00026e3c <set_adv_mode_fast>:
 *
 * @return NRF_SUCCESS or an error from @ref ble_advdata_set().
 */
static ret_code_t set_adv_mode_fast(ble_advertising_t * const p_advertising,
                                    ble_gap_adv_params_t    * p_adv_params)
{
   26e3c:	b580      	push	{r7, lr}
   26e3e:	b084      	sub	sp, #16
   26e40:	af00      	add	r7, sp, #0
   26e42:	6078      	str	r0, [r7, #4]
   26e44:	6039      	str	r1, [r7, #0]
    ret_code_t ret;

    p_adv_params->interval = p_advertising->adv_modes_config.ble_adv_fast_interval;
   26e46:	687b      	ldr	r3, [r7, #4]
   26e48:	695b      	ldr	r3, [r3, #20]
   26e4a:	b29a      	uxth	r2, r3
   26e4c:	683b      	ldr	r3, [r7, #0]
   26e4e:	815a      	strh	r2, [r3, #10]
    p_adv_params->timeout  = p_advertising->adv_modes_config.ble_adv_fast_timeout;
   26e50:	687b      	ldr	r3, [r7, #4]
   26e52:	699b      	ldr	r3, [r3, #24]
   26e54:	b29a      	uxth	r2, r3
   26e56:	683b      	ldr	r3, [r7, #0]
   26e58:	819a      	strh	r2, [r3, #12]

    if ((p_advertising->adv_modes_config.ble_adv_whitelist_enabled) &&
   26e5a:	687b      	ldr	r3, [r7, #4]
   26e5c:	795b      	ldrb	r3, [r3, #5]
   26e5e:	2b00      	cmp	r3, #0
   26e60:	d024      	beq.n	26eac <set_adv_mode_fast+0x70>
        (!p_advertising->whitelist_temporarily_disabled) &&
   26e62:	687b      	ldr	r3, [r7, #4]
   26e64:	f893 30d4 	ldrb.w	r3, [r3, #212]	; 0xd4
   26e68:	f083 0301 	eor.w	r3, r3, #1
   26e6c:	b2db      	uxtb	r3, r3
    if ((p_advertising->adv_modes_config.ble_adv_whitelist_enabled) &&
   26e6e:	2b00      	cmp	r3, #0
   26e70:	d01c      	beq.n	26eac <set_adv_mode_fast+0x70>
        (whitelist_has_entries(p_advertising)))
   26e72:	6878      	ldr	r0, [r7, #4]
   26e74:	f7ff feb6 	bl	26be4 <whitelist_has_entries>
   26e78:	4603      	mov	r3, r0
        (!p_advertising->whitelist_temporarily_disabled) &&
   26e7a:	2b00      	cmp	r3, #0
   26e7c:	d016      	beq.n	26eac <set_adv_mode_fast+0x70>
    {
        #if (NRF_SD_BLE_API_VERSION <= 2)
            p_adv_params->p_whitelist = &m_whitelist;
        #endif

        p_adv_params->fp = BLE_GAP_ADV_FP_FILTER_CONNREQ;
   26e7e:	683b      	ldr	r3, [r7, #0]
   26e80:	2202      	movs	r2, #2
   26e82:	721a      	strb	r2, [r3, #8]
        p_advertising->advdata.flags  = BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED;
   26e84:	687b      	ldr	r3, [r7, #4]
   26e86:	2204      	movs	r2, #4
   26e88:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33

        ret = ble_advdata_set(&(p_advertising->advdata), NULL);
   26e8c:	687b      	ldr	r3, [r7, #4]
   26e8e:	3330      	adds	r3, #48	; 0x30
   26e90:	2100      	movs	r1, #0
   26e92:	4618      	mov	r0, r3
   26e94:	f7fe ffa2 	bl	25ddc <ble_advdata_set>
   26e98:	60f8      	str	r0, [r7, #12]
        if (ret != NRF_SUCCESS)
   26e9a:	68fb      	ldr	r3, [r7, #12]
   26e9c:	2b00      	cmp	r3, #0
   26e9e:	d001      	beq.n	26ea4 <set_adv_mode_fast+0x68>
        {
            return ret;
   26ea0:	68fb      	ldr	r3, [r7, #12]
   26ea2:	e007      	b.n	26eb4 <set_adv_mode_fast+0x78>
        }

        p_advertising->adv_evt = BLE_ADV_EVT_FAST_WHITELIST;
   26ea4:	687b      	ldr	r3, [r7, #4]
   26ea6:	2205      	movs	r2, #5
   26ea8:	709a      	strb	r2, [r3, #2]
   26eaa:	e002      	b.n	26eb2 <set_adv_mode_fast+0x76>
    }
    else
    {
        p_advertising->adv_evt = BLE_ADV_EVT_FAST;
   26eac:	687b      	ldr	r3, [r7, #4]
   26eae:	2203      	movs	r2, #3
   26eb0:	709a      	strb	r2, [r3, #2]
    }

    return NRF_SUCCESS;
   26eb2:	2300      	movs	r3, #0
}
   26eb4:	4618      	mov	r0, r3
   26eb6:	3710      	adds	r7, #16
   26eb8:	46bd      	mov	sp, r7
   26eba:	bd80      	pop	{r7, pc}

00026ebc <set_adv_mode_slow>:
 *
 * @return NRF_SUCCESS or an error from @ref ble_advdata_set().
 */
static ret_code_t set_adv_mode_slow(ble_advertising_t * const p_advertising,
                                    ble_gap_adv_params_t    * p_adv_params)
{
   26ebc:	b580      	push	{r7, lr}
   26ebe:	b084      	sub	sp, #16
   26ec0:	af00      	add	r7, sp, #0
   26ec2:	6078      	str	r0, [r7, #4]
   26ec4:	6039      	str	r1, [r7, #0]
    ret_code_t ret;

    p_adv_params->interval = p_advertising->adv_modes_config.ble_adv_slow_interval;
   26ec6:	687b      	ldr	r3, [r7, #4]
   26ec8:	69db      	ldr	r3, [r3, #28]
   26eca:	b29a      	uxth	r2, r3
   26ecc:	683b      	ldr	r3, [r7, #0]
   26ece:	815a      	strh	r2, [r3, #10]
    p_adv_params->timeout  = p_advertising->adv_modes_config.ble_adv_slow_timeout;
   26ed0:	687b      	ldr	r3, [r7, #4]
   26ed2:	6a1b      	ldr	r3, [r3, #32]
   26ed4:	b29a      	uxth	r2, r3
   26ed6:	683b      	ldr	r3, [r7, #0]
   26ed8:	819a      	strh	r2, [r3, #12]

    if ((p_advertising->adv_modes_config.ble_adv_whitelist_enabled) &&
   26eda:	687b      	ldr	r3, [r7, #4]
   26edc:	795b      	ldrb	r3, [r3, #5]
   26ede:	2b00      	cmp	r3, #0
   26ee0:	d024      	beq.n	26f2c <set_adv_mode_slow+0x70>
        (!p_advertising->whitelist_temporarily_disabled) &&
   26ee2:	687b      	ldr	r3, [r7, #4]
   26ee4:	f893 30d4 	ldrb.w	r3, [r3, #212]	; 0xd4
   26ee8:	f083 0301 	eor.w	r3, r3, #1
   26eec:	b2db      	uxtb	r3, r3
    if ((p_advertising->adv_modes_config.ble_adv_whitelist_enabled) &&
   26eee:	2b00      	cmp	r3, #0
   26ef0:	d01c      	beq.n	26f2c <set_adv_mode_slow+0x70>
        (whitelist_has_entries(p_advertising)))
   26ef2:	6878      	ldr	r0, [r7, #4]
   26ef4:	f7ff fe76 	bl	26be4 <whitelist_has_entries>
   26ef8:	4603      	mov	r3, r0
        (!p_advertising->whitelist_temporarily_disabled) &&
   26efa:	2b00      	cmp	r3, #0
   26efc:	d016      	beq.n	26f2c <set_adv_mode_slow+0x70>
        {
            p_adv_params->p_whitelist = &p_advertising->whitelist;
        }
        #endif

        p_adv_params->fp = BLE_GAP_ADV_FP_FILTER_CONNREQ;
   26efe:	683b      	ldr	r3, [r7, #0]
   26f00:	2202      	movs	r2, #2
   26f02:	721a      	strb	r2, [r3, #8]
        p_advertising->advdata.flags  = BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED;
   26f04:	687b      	ldr	r3, [r7, #4]
   26f06:	2204      	movs	r2, #4
   26f08:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33

        ret = ble_advdata_set(&(p_advertising->advdata), NULL);
   26f0c:	687b      	ldr	r3, [r7, #4]
   26f0e:	3330      	adds	r3, #48	; 0x30
   26f10:	2100      	movs	r1, #0
   26f12:	4618      	mov	r0, r3
   26f14:	f7fe ff62 	bl	25ddc <ble_advdata_set>
   26f18:	60f8      	str	r0, [r7, #12]
        if (ret != NRF_SUCCESS)
   26f1a:	68fb      	ldr	r3, [r7, #12]
   26f1c:	2b00      	cmp	r3, #0
   26f1e:	d001      	beq.n	26f24 <set_adv_mode_slow+0x68>
        {
            return ret;
   26f20:	68fb      	ldr	r3, [r7, #12]
   26f22:	e007      	b.n	26f34 <set_adv_mode_slow+0x78>
        }

        p_advertising->adv_evt = BLE_ADV_EVT_SLOW_WHITELIST;
   26f24:	687b      	ldr	r3, [r7, #4]
   26f26:	2206      	movs	r2, #6
   26f28:	709a      	strb	r2, [r3, #2]
   26f2a:	e002      	b.n	26f32 <set_adv_mode_slow+0x76>
    }
    else
    {
        p_advertising->adv_evt = BLE_ADV_EVT_SLOW;
   26f2c:	687b      	ldr	r3, [r7, #4]
   26f2e:	2204      	movs	r2, #4
   26f30:	709a      	strb	r2, [r3, #2]
    }

    return NRF_SUCCESS;
   26f32:	2300      	movs	r3, #0
}
   26f34:	4618      	mov	r0, r3
   26f36:	3710      	adds	r7, #16
   26f38:	46bd      	mov	sp, r7
   26f3a:	bd80      	pop	{r7, pc}

00026f3c <ble_advertising_conn_cfg_tag_set>:


void ble_advertising_conn_cfg_tag_set(ble_advertising_t * const p_advertising,
                                      uint8_t                   ble_cfg_tag)
{
   26f3c:	b480      	push	{r7}
   26f3e:	b083      	sub	sp, #12
   26f40:	af00      	add	r7, sp, #0
   26f42:	6078      	str	r0, [r7, #4]
   26f44:	460b      	mov	r3, r1
   26f46:	70fb      	strb	r3, [r7, #3]
    p_advertising->conn_cfg_tag = ble_cfg_tag;
   26f48:	687b      	ldr	r3, [r7, #4]
   26f4a:	78fa      	ldrb	r2, [r7, #3]
   26f4c:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
}
   26f50:	bf00      	nop
   26f52:	370c      	adds	r7, #12
   26f54:	46bd      	mov	sp, r7
   26f56:	bc80      	pop	{r7}
   26f58:	4770      	bx	lr

00026f5a <ble_advertising_init>:


uint32_t ble_advertising_init(ble_advertising_t            * const p_advertising,
                              ble_advertising_init_t const * const p_init)
{
   26f5a:	b5b0      	push	{r4, r5, r7, lr}
   26f5c:	b086      	sub	sp, #24
   26f5e:	af00      	add	r7, sp, #0
   26f60:	6078      	str	r0, [r7, #4]
   26f62:	6039      	str	r1, [r7, #0]
    uint32_t ret;
    if ((p_init == NULL) || (p_advertising == NULL))
   26f64:	683b      	ldr	r3, [r7, #0]
   26f66:	2b00      	cmp	r3, #0
   26f68:	d002      	beq.n	26f70 <ble_advertising_init+0x16>
   26f6a:	687b      	ldr	r3, [r7, #4]
   26f6c:	2b00      	cmp	r3, #0
   26f6e:	d101      	bne.n	26f74 <ble_advertising_init+0x1a>
    {
        return NRF_ERROR_NULL;
   26f70:	230e      	movs	r3, #14
   26f72:	e0ff      	b.n	27174 <ble_advertising_init+0x21a>
    }

    p_advertising->initialized                    = true;
   26f74:	687b      	ldr	r3, [r7, #4]
   26f76:	2201      	movs	r2, #1
   26f78:	701a      	strb	r2, [r3, #0]
    p_advertising->adv_mode_current               = BLE_ADV_MODE_IDLE;
   26f7a:	687b      	ldr	r3, [r7, #4]
   26f7c:	2200      	movs	r2, #0
   26f7e:	70da      	strb	r2, [r3, #3]
    p_advertising->adv_modes_config               = p_init->config;
   26f80:	687a      	ldr	r2, [r7, #4]
   26f82:	683b      	ldr	r3, [r7, #0]
   26f84:	1d14      	adds	r4, r2, #4
   26f86:	f103 0578 	add.w	r5, r3, #120	; 0x78
   26f8a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   26f8c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   26f8e:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   26f92:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    p_advertising->conn_cfg_tag                   = BLE_CONN_CFG_TAG_DEFAULT;
   26f96:	687b      	ldr	r3, [r7, #4]
   26f98:	2200      	movs	r2, #0
   26f9a:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
    p_advertising->evt_handler                    = p_init->evt_handler;
   26f9e:	683b      	ldr	r3, [r7, #0]
   26fa0:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
   26fa4:	687b      	ldr	r3, [r7, #4]
   26fa6:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
    p_advertising->error_handler                  = p_init->error_handler;
   26faa:	683b      	ldr	r3, [r7, #0]
   26fac:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
   26fb0:	687b      	ldr	r3, [r7, #4]
   26fb2:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
    p_advertising->current_slave_link_conn_handle = BLE_CONN_HANDLE_INVALID;
   26fb6:	687b      	ldr	r3, [r7, #4]
   26fb8:	f64f 72ff 	movw	r2, #65535	; 0xffff
   26fbc:	f8a3 20c8 	strh.w	r2, [r3, #200]	; 0xc8

    memset(&p_advertising->peer_address, 0, sizeof(p_advertising->peer_address));
   26fc0:	687b      	ldr	r3, [r7, #4]
   26fc2:	3325      	adds	r3, #37	; 0x25
   26fc4:	2207      	movs	r2, #7
   26fc6:	2100      	movs	r1, #0
   26fc8:	4618      	mov	r0, r3
   26fca:	f7fc fb27 	bl	2361c <memset>
    memset(&p_advertising->advdata,      0, sizeof(p_advertising->advdata));
   26fce:	687b      	ldr	r3, [r7, #4]
   26fd0:	3330      	adds	r3, #48	; 0x30
   26fd2:	223c      	movs	r2, #60	; 0x3c
   26fd4:	2100      	movs	r1, #0
   26fd6:	4618      	mov	r0, r3
   26fd8:	f7fc fb20 	bl	2361c <memset>

    // Copy advertising data.
    p_advertising->advdata.name_type          = p_init->advdata.name_type;
   26fdc:	683b      	ldr	r3, [r7, #0]
   26fde:	781a      	ldrb	r2, [r3, #0]
   26fe0:	687b      	ldr	r3, [r7, #4]
   26fe2:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
    p_advertising->advdata.include_appearance = p_init->advdata.include_appearance;
   26fe6:	683b      	ldr	r3, [r7, #0]
   26fe8:	789a      	ldrb	r2, [r3, #2]
   26fea:	687b      	ldr	r3, [r7, #4]
   26fec:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
    p_advertising->advdata.flags              = p_init->advdata.flags;
   26ff0:	683b      	ldr	r3, [r7, #0]
   26ff2:	78da      	ldrb	r2, [r3, #3]
   26ff4:	687b      	ldr	r3, [r7, #4]
   26ff6:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
    p_advertising->advdata.short_name_len     = p_init->advdata.short_name_len;
   26ffa:	683b      	ldr	r3, [r7, #0]
   26ffc:	785a      	ldrb	r2, [r3, #1]
   26ffe:	687b      	ldr	r3, [r7, #4]
   27000:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31

    p_advertising->advdata.uuids_complete          = p_init->advdata.uuids_complete;
   27004:	687b      	ldr	r3, [r7, #4]
   27006:	683a      	ldr	r2, [r7, #0]
   27008:	3340      	adds	r3, #64	; 0x40
   2700a:	3210      	adds	r2, #16
   2700c:	e892 0003 	ldmia.w	r2, {r0, r1}
   27010:	e883 0003 	stmia.w	r3, {r0, r1}
    p_advertising->advdata.uuids_more_available    = p_init->advdata.uuids_more_available;
   27014:	687b      	ldr	r3, [r7, #4]
   27016:	683a      	ldr	r2, [r7, #0]
   27018:	3338      	adds	r3, #56	; 0x38
   2701a:	3208      	adds	r2, #8
   2701c:	e892 0003 	ldmia.w	r2, {r0, r1}
   27020:	e883 0003 	stmia.w	r3, {r0, r1}
    p_advertising->advdata.uuids_solicited         = p_init->advdata.uuids_solicited;
   27024:	687b      	ldr	r3, [r7, #4]
   27026:	683a      	ldr	r2, [r7, #0]
   27028:	3348      	adds	r3, #72	; 0x48
   2702a:	3218      	adds	r2, #24
   2702c:	e892 0003 	ldmia.w	r2, {r0, r1}
   27030:	e883 0003 	stmia.w	r3, {r0, r1}
    p_advertising->advdata.include_ble_device_addr = p_init->advdata.include_ble_device_addr;
   27034:	683b      	ldr	r3, [r7, #0]
   27036:	f893 202d 	ldrb.w	r2, [r3, #45]	; 0x2d
   2703a:	687b      	ldr	r3, [r7, #4]
   2703c:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d

    if (p_init->advdata.p_manuf_specific_data != NULL)
   27040:	683b      	ldr	r3, [r7, #0]
   27042:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   27044:	2b00      	cmp	r3, #0
   27046:	d02e      	beq.n	270a6 <ble_advertising_init+0x14c>
    {
        p_advertising->advdata.p_manuf_specific_data   = &(p_advertising->manuf_specific_data);
   27048:	687b      	ldr	r3, [r7, #4]
   2704a:	f103 026c 	add.w	r2, r3, #108	; 0x6c
   2704e:	687b      	ldr	r3, [r7, #4]
   27050:	655a      	str	r2, [r3, #84]	; 0x54
        p_advertising->manuf_specific_data.data.p_data = p_advertising->manuf_data_array;
   27052:	687b      	ldr	r3, [r7, #4]
   27054:	f103 0278 	add.w	r2, r3, #120	; 0x78
   27058:	687b      	ldr	r3, [r7, #4]
   2705a:	675a      	str	r2, [r3, #116]	; 0x74
        p_advertising->advdata.p_manuf_specific_data->company_identifier =
            p_init->advdata.p_manuf_specific_data->company_identifier;
   2705c:	683b      	ldr	r3, [r7, #0]
   2705e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
        p_advertising->advdata.p_manuf_specific_data->company_identifier =
   27060:	687b      	ldr	r3, [r7, #4]
   27062:	6d5b      	ldr	r3, [r3, #84]	; 0x54
            p_init->advdata.p_manuf_specific_data->company_identifier;
   27064:	8812      	ldrh	r2, [r2, #0]
        p_advertising->advdata.p_manuf_specific_data->company_identifier =
   27066:	801a      	strh	r2, [r3, #0]
        p_advertising->advdata.p_manuf_specific_data->data.size = p_init->advdata.p_manuf_specific_data->data.size;
   27068:	683b      	ldr	r3, [r7, #0]
   2706a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   2706c:	687b      	ldr	r3, [r7, #4]
   2706e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   27070:	8892      	ldrh	r2, [r2, #4]
   27072:	809a      	strh	r2, [r3, #4]

        for (uint32_t i = 0; i < p_advertising->advdata.p_manuf_specific_data->data.size; i++)
   27074:	2300      	movs	r3, #0
   27076:	617b      	str	r3, [r7, #20]
   27078:	e00e      	b.n	27098 <ble_advertising_init+0x13e>
        {
            p_advertising->manuf_data_array[i] = p_init->advdata.p_manuf_specific_data->data.p_data[i];
   2707a:	683b      	ldr	r3, [r7, #0]
   2707c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   2707e:	689a      	ldr	r2, [r3, #8]
   27080:	697b      	ldr	r3, [r7, #20]
   27082:	4413      	add	r3, r2
   27084:	7819      	ldrb	r1, [r3, #0]
   27086:	687a      	ldr	r2, [r7, #4]
   27088:	697b      	ldr	r3, [r7, #20]
   2708a:	4413      	add	r3, r2
   2708c:	3378      	adds	r3, #120	; 0x78
   2708e:	460a      	mov	r2, r1
   27090:	701a      	strb	r2, [r3, #0]
        for (uint32_t i = 0; i < p_advertising->advdata.p_manuf_specific_data->data.size; i++)
   27092:	697b      	ldr	r3, [r7, #20]
   27094:	3301      	adds	r3, #1
   27096:	617b      	str	r3, [r7, #20]
   27098:	687b      	ldr	r3, [r7, #4]
   2709a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   2709c:	889b      	ldrh	r3, [r3, #4]
   2709e:	461a      	mov	r2, r3
   270a0:	697b      	ldr	r3, [r7, #20]
   270a2:	4293      	cmp	r3, r2
   270a4:	d3e9      	bcc.n	2707a <ble_advertising_init+0x120>
        }
    }

    if (p_init->advdata.p_service_data_array != NULL)
   270a6:	683b      	ldr	r3, [r7, #0]
   270a8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   270aa:	2b00      	cmp	r3, #0
   270ac:	d03a      	beq.n	27124 <ble_advertising_init+0x1ca>
    {
        p_advertising->service_data.data.p_data                   = p_advertising->service_data_array;
   270ae:	687b      	ldr	r3, [r7, #4]
   270b0:	f103 02a4 	add.w	r2, r3, #164	; 0xa4
   270b4:	687b      	ldr	r3, [r7, #4]
   270b6:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
        p_advertising->advdata.p_service_data_array               = &(p_advertising->service_data);
   270ba:	687b      	ldr	r3, [r7, #4]
   270bc:	f103 0298 	add.w	r2, r3, #152	; 0x98
   270c0:	687b      	ldr	r3, [r7, #4]
   270c2:	659a      	str	r2, [r3, #88]	; 0x58
        p_advertising->advdata.p_service_data_array->data.p_data  = p_advertising->service_data_array;
   270c4:	687b      	ldr	r3, [r7, #4]
   270c6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
   270c8:	687a      	ldr	r2, [r7, #4]
   270ca:	32a4      	adds	r2, #164	; 0xa4
   270cc:	609a      	str	r2, [r3, #8]
        p_advertising->advdata.p_service_data_array->data.size    = p_init->advdata.p_service_data_array->data.size;
   270ce:	683b      	ldr	r3, [r7, #0]
   270d0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   270d2:	687b      	ldr	r3, [r7, #4]
   270d4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
   270d6:	8892      	ldrh	r2, [r2, #4]
   270d8:	809a      	strh	r2, [r3, #4]
        p_advertising->advdata.p_service_data_array->service_uuid = p_init->advdata.p_service_data_array->service_uuid;
   270da:	683b      	ldr	r3, [r7, #0]
   270dc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   270de:	687b      	ldr	r3, [r7, #4]
   270e0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
   270e2:	8812      	ldrh	r2, [r2, #0]
   270e4:	801a      	strh	r2, [r3, #0]

        for (uint32_t i = 0; i < p_advertising->advdata.p_service_data_array->data.size; i++)
   270e6:	2300      	movs	r3, #0
   270e8:	613b      	str	r3, [r7, #16]
   270ea:	e00e      	b.n	2710a <ble_advertising_init+0x1b0>
        {
            p_advertising->service_data_array[i] = p_init->advdata.p_service_data_array->data.p_data[i];
   270ec:	683b      	ldr	r3, [r7, #0]
   270ee:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   270f0:	689a      	ldr	r2, [r3, #8]
   270f2:	693b      	ldr	r3, [r7, #16]
   270f4:	4413      	add	r3, r2
   270f6:	7819      	ldrb	r1, [r3, #0]
   270f8:	687a      	ldr	r2, [r7, #4]
   270fa:	693b      	ldr	r3, [r7, #16]
   270fc:	4413      	add	r3, r2
   270fe:	33a4      	adds	r3, #164	; 0xa4
   27100:	460a      	mov	r2, r1
   27102:	701a      	strb	r2, [r3, #0]
        for (uint32_t i = 0; i < p_advertising->advdata.p_service_data_array->data.size; i++)
   27104:	693b      	ldr	r3, [r7, #16]
   27106:	3301      	adds	r3, #1
   27108:	613b      	str	r3, [r7, #16]
   2710a:	687b      	ldr	r3, [r7, #4]
   2710c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
   2710e:	889b      	ldrh	r3, [r3, #4]
   27110:	461a      	mov	r2, r3
   27112:	693b      	ldr	r3, [r7, #16]
   27114:	4293      	cmp	r3, r2
   27116:	d3e9      	bcc.n	270ec <ble_advertising_init+0x192>
        }

        p_advertising->advdata.service_data_count = p_init->advdata.service_data_count;
   27118:	683b      	ldr	r3, [r7, #0]
   2711a:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c
   2711e:	687b      	ldr	r3, [r7, #4]
   27120:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
    }

    if (p_init->advdata.p_slave_conn_int != NULL)
   27124:	683b      	ldr	r3, [r7, #0]
   27126:	6a1b      	ldr	r3, [r3, #32]
   27128:	2b00      	cmp	r3, #0
   2712a:	d010      	beq.n	2714e <ble_advertising_init+0x1f4>
    {
        p_advertising->advdata.p_slave_conn_int                    = &(p_advertising->slave_conn_int);
   2712c:	687b      	ldr	r3, [r7, #4]
   2712e:	f103 02c4 	add.w	r2, r3, #196	; 0xc4
   27132:	687b      	ldr	r3, [r7, #4]
   27134:	651a      	str	r2, [r3, #80]	; 0x50
        p_advertising->advdata.p_slave_conn_int->max_conn_interval = p_init->advdata.p_slave_conn_int->max_conn_interval;
   27136:	683b      	ldr	r3, [r7, #0]
   27138:	6a1a      	ldr	r2, [r3, #32]
   2713a:	687b      	ldr	r3, [r7, #4]
   2713c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
   2713e:	8852      	ldrh	r2, [r2, #2]
   27140:	805a      	strh	r2, [r3, #2]
        p_advertising->advdata.p_slave_conn_int->min_conn_interval = p_init->advdata.p_slave_conn_int->min_conn_interval;
   27142:	683b      	ldr	r3, [r7, #0]
   27144:	6a1a      	ldr	r2, [r3, #32]
   27146:	687b      	ldr	r3, [r7, #4]
   27148:	6d1b      	ldr	r3, [r3, #80]	; 0x50
   2714a:	8812      	ldrh	r2, [r2, #0]
   2714c:	801a      	strh	r2, [r3, #0]
    }

    if (p_init->advdata.p_tx_power_level != NULL)
   2714e:	683b      	ldr	r3, [r7, #0]
   27150:	685b      	ldr	r3, [r3, #4]
   27152:	2b00      	cmp	r3, #0
   27154:	d003      	beq.n	2715e <ble_advertising_init+0x204>
    {
        p_advertising->advdata.p_tx_power_level = p_init->advdata.p_tx_power_level;
   27156:	683b      	ldr	r3, [r7, #0]
   27158:	685a      	ldr	r2, [r3, #4]
   2715a:	687b      	ldr	r3, [r7, #4]
   2715c:	635a      	str	r2, [r3, #52]	; 0x34
        for (int i = 0; i <BLE_GAP_WHITELIST_IRK_MAX_COUNT ; i++)
        {
            p_advertising->whitelist.pp_irks[i] = &p_advertising->whitelist_irks[i];
        }
#endif
    ret = ble_advdata_set(&(p_advertising->advdata), &(p_init->srdata));
   2715e:	687b      	ldr	r3, [r7, #4]
   27160:	f103 0230 	add.w	r2, r3, #48	; 0x30
   27164:	683b      	ldr	r3, [r7, #0]
   27166:	333c      	adds	r3, #60	; 0x3c
   27168:	4619      	mov	r1, r3
   2716a:	4610      	mov	r0, r2
   2716c:	f7fe fe36 	bl	25ddc <ble_advdata_set>
   27170:	60f8      	str	r0, [r7, #12]
    return ret;
   27172:	68fb      	ldr	r3, [r7, #12]
}
   27174:	4618      	mov	r0, r3
   27176:	3718      	adds	r7, #24
   27178:	46bd      	mov	sp, r7
   2717a:	bdb0      	pop	{r4, r5, r7, pc}

0002717c <ble_advertising_start>:


uint32_t ble_advertising_start(ble_advertising_t * const p_advertising,
                               ble_adv_mode_t            advertising_mode)
{
   2717c:	b580      	push	{r7, lr}
   2717e:	b088      	sub	sp, #32
   27180:	af00      	add	r7, sp, #0
   27182:	6078      	str	r0, [r7, #4]
   27184:	460b      	mov	r3, r1
   27186:	70fb      	strb	r3, [r7, #3]
    uint32_t             ret;
    ble_gap_adv_params_t adv_params;

    if (p_advertising->initialized == false)
   27188:	687b      	ldr	r3, [r7, #4]
   2718a:	781b      	ldrb	r3, [r3, #0]
   2718c:	f083 0301 	eor.w	r3, r3, #1
   27190:	b2db      	uxtb	r3, r3
   27192:	2b00      	cmp	r3, #0
   27194:	d001      	beq.n	2719a <ble_advertising_start+0x1e>
    {
        return NRF_ERROR_INVALID_STATE;
   27196:	2308      	movs	r3, #8
   27198:	e0d3      	b.n	27342 <ble_advertising_start+0x1c6>
    }

    p_advertising->adv_mode_current = advertising_mode;
   2719a:	687b      	ldr	r3, [r7, #4]
   2719c:	78fa      	ldrb	r2, [r7, #3]
   2719e:	70da      	strb	r2, [r3, #3]

    // Delay starting advertising until the flash operations are complete.
    if (flash_access_in_progress())
   271a0:	f7ff fdc8 	bl	26d34 <flash_access_in_progress>
   271a4:	4603      	mov	r3, r0
   271a6:	2b00      	cmp	r3, #0
   271a8:	d004      	beq.n	271b4 <ble_advertising_start+0x38>
    {
        p_advertising->advertising_start_pending = true;
   271aa:	687b      	ldr	r3, [r7, #4]
   271ac:	2201      	movs	r2, #1
   271ae:	705a      	strb	r2, [r3, #1]
        return NRF_SUCCESS;
   271b0:	2300      	movs	r3, #0
   271b2:	e0c6      	b.n	27342 <ble_advertising_start+0x1c6>
    }

   memset(&p_advertising->peer_address, 0, sizeof(p_advertising->peer_address));
   271b4:	687b      	ldr	r3, [r7, #4]
   271b6:	3325      	adds	r3, #37	; 0x25
   271b8:	2207      	movs	r2, #7
   271ba:	2100      	movs	r1, #0
   271bc:	4618      	mov	r0, r3
   271be:	f7fc fa2d 	bl	2361c <memset>

    if (  ((p_advertising->adv_modes_config.ble_adv_directed_enabled)      && (p_advertising->adv_mode_current == BLE_ADV_MODE_DIRECTED))
   271c2:	687b      	ldr	r3, [r7, #4]
   271c4:	799b      	ldrb	r3, [r3, #6]
   271c6:	2b00      	cmp	r3, #0
   271c8:	d003      	beq.n	271d2 <ble_advertising_start+0x56>
   271ca:	687b      	ldr	r3, [r7, #4]
   271cc:	78db      	ldrb	r3, [r3, #3]
   271ce:	2b01      	cmp	r3, #1
   271d0:	d00f      	beq.n	271f2 <ble_advertising_start+0x76>
        ||((p_advertising->adv_modes_config.ble_adv_directed_slow_enabled) && (p_advertising->adv_mode_current == BLE_ADV_MODE_DIRECTED))
   271d2:	687b      	ldr	r3, [r7, #4]
   271d4:	79db      	ldrb	r3, [r3, #7]
   271d6:	2b00      	cmp	r3, #0
   271d8:	d003      	beq.n	271e2 <ble_advertising_start+0x66>
   271da:	687b      	ldr	r3, [r7, #4]
   271dc:	78db      	ldrb	r3, [r3, #3]
   271de:	2b01      	cmp	r3, #1
   271e0:	d007      	beq.n	271f2 <ble_advertising_start+0x76>
        ||((p_advertising->adv_modes_config.ble_adv_directed_slow_enabled) && (p_advertising->adv_mode_current == BLE_ADV_MODE_DIRECTED_SLOW))
   271e2:	687b      	ldr	r3, [r7, #4]
   271e4:	79db      	ldrb	r3, [r3, #7]
   271e6:	2b00      	cmp	r3, #0
   271e8:	d016      	beq.n	27218 <ble_advertising_start+0x9c>
   271ea:	687b      	ldr	r3, [r7, #4]
   271ec:	78db      	ldrb	r3, [r3, #3]
   271ee:	2b02      	cmp	r3, #2
   271f0:	d112      	bne.n	27218 <ble_advertising_start+0x9c>
       )
    {
        if (p_advertising->evt_handler != NULL)
   271f2:	687b      	ldr	r3, [r7, #4]
   271f4:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
   271f8:	2b00      	cmp	r3, #0
   271fa:	d009      	beq.n	27210 <ble_advertising_start+0x94>
        {
            p_advertising->peer_addr_reply_expected = true;
   271fc:	687b      	ldr	r3, [r7, #4]
   271fe:	2201      	movs	r2, #1
   27200:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
            p_advertising->evt_handler(BLE_ADV_EVT_PEER_ADDR_REQUEST);
   27204:	687b      	ldr	r3, [r7, #4]
   27206:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
   2720a:	2008      	movs	r0, #8
   2720c:	4798      	blx	r3
   2720e:	e003      	b.n	27218 <ble_advertising_start+0x9c>
        }
        else
        {
            p_advertising->peer_addr_reply_expected = false;
   27210:	687b      	ldr	r3, [r7, #4]
   27212:	2200      	movs	r2, #0
   27214:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
        }
    }

    p_advertising->adv_mode_current = adv_mode_next_avail_get(p_advertising, advertising_mode);
   27218:	78fb      	ldrb	r3, [r7, #3]
   2721a:	4619      	mov	r1, r3
   2721c:	6878      	ldr	r0, [r7, #4]
   2721e:	f7ff fd91 	bl	26d44 <adv_mode_next_avail_get>
   27222:	4603      	mov	r3, r0
   27224:	461a      	mov	r2, r3
   27226:	687b      	ldr	r3, [r7, #4]
   27228:	70da      	strb	r2, [r3, #3]

    // Fetch the whitelist.
    if ((p_advertising->evt_handler != NULL) &&
   2722a:	687b      	ldr	r3, [r7, #4]
   2722c:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
   27230:	2b00      	cmp	r3, #0
   27232:	d021      	beq.n	27278 <ble_advertising_start+0xfc>
        (p_advertising->adv_mode_current == BLE_ADV_MODE_FAST || p_advertising->adv_mode_current == BLE_ADV_MODE_SLOW) &&
   27234:	687b      	ldr	r3, [r7, #4]
   27236:	78db      	ldrb	r3, [r3, #3]
    if ((p_advertising->evt_handler != NULL) &&
   27238:	2b03      	cmp	r3, #3
   2723a:	d003      	beq.n	27244 <ble_advertising_start+0xc8>
        (p_advertising->adv_mode_current == BLE_ADV_MODE_FAST || p_advertising->adv_mode_current == BLE_ADV_MODE_SLOW) &&
   2723c:	687b      	ldr	r3, [r7, #4]
   2723e:	78db      	ldrb	r3, [r3, #3]
   27240:	2b04      	cmp	r3, #4
   27242:	d119      	bne.n	27278 <ble_advertising_start+0xfc>
        (p_advertising->adv_modes_config.ble_adv_whitelist_enabled) &&
   27244:	687b      	ldr	r3, [r7, #4]
   27246:	795b      	ldrb	r3, [r3, #5]
        (p_advertising->adv_mode_current == BLE_ADV_MODE_FAST || p_advertising->adv_mode_current == BLE_ADV_MODE_SLOW) &&
   27248:	2b00      	cmp	r3, #0
   2724a:	d015      	beq.n	27278 <ble_advertising_start+0xfc>
        (!p_advertising->whitelist_temporarily_disabled))
   2724c:	687b      	ldr	r3, [r7, #4]
   2724e:	f893 30d4 	ldrb.w	r3, [r3, #212]	; 0xd4
   27252:	f083 0301 	eor.w	r3, r3, #1
   27256:	b2db      	uxtb	r3, r3
        (p_advertising->adv_modes_config.ble_adv_whitelist_enabled) &&
   27258:	2b00      	cmp	r3, #0
   2725a:	d00d      	beq.n	27278 <ble_advertising_start+0xfc>
    {
        #if (NRF_SD_BLE_API_VERSION >= 3)
            p_advertising->whitelist_in_use = false;
   2725c:	687b      	ldr	r3, [r7, #4]
   2725e:	2200      	movs	r2, #0
   27260:	f883 20d6 	strb.w	r2, [r3, #214]	; 0xd6
        #endif
        p_advertising->whitelist_reply_expected = true;
   27264:	687b      	ldr	r3, [r7, #4]
   27266:	2201      	movs	r2, #1
   27268:	f883 20d5 	strb.w	r2, [r3, #213]	; 0xd5
        p_advertising->evt_handler(BLE_ADV_EVT_WHITELIST_REQUEST);
   2726c:	687b      	ldr	r3, [r7, #4]
   2726e:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
   27272:	2007      	movs	r0, #7
   27274:	4798      	blx	r3
   27276:	e003      	b.n	27280 <ble_advertising_start+0x104>
    }
    else
    {
        p_advertising->whitelist_reply_expected = false;
   27278:	687b      	ldr	r3, [r7, #4]
   2727a:	2200      	movs	r2, #0
   2727c:	f883 20d5 	strb.w	r2, [r3, #213]	; 0xd5
    }

    // Initialize advertising parameters with default values.
    memset(&adv_params, 0, sizeof(adv_params));
   27280:	f107 030c 	add.w	r3, r7, #12
   27284:	2210      	movs	r2, #16
   27286:	2100      	movs	r1, #0
   27288:	4618      	mov	r0, r3
   2728a:	f7fc f9c7 	bl	2361c <memset>

    adv_params.type = BLE_GAP_ADV_TYPE_ADV_IND;
   2728e:	2300      	movs	r3, #0
   27290:	733b      	strb	r3, [r7, #12]
    adv_params.fp   = BLE_GAP_ADV_FP_ANY;
   27292:	2300      	movs	r3, #0
   27294:	753b      	strb	r3, [r7, #20]

    // Set advertising parameters and events according to selected advertising mode.
    switch (p_advertising->adv_mode_current)
   27296:	687b      	ldr	r3, [r7, #4]
   27298:	78db      	ldrb	r3, [r3, #3]
   2729a:	2b04      	cmp	r3, #4
   2729c:	d830      	bhi.n	27300 <ble_advertising_start+0x184>
   2729e:	a201      	add	r2, pc, #4	; (adr r2, 272a4 <ble_advertising_start+0x128>)
   272a0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   272a4:	000272f9 	.word	0x000272f9
   272a8:	000272b9 	.word	0x000272b9
   272ac:	000272c9 	.word	0x000272c9
   272b0:	000272d9 	.word	0x000272d9
   272b4:	000272e9 	.word	0x000272e9
    {
        case BLE_ADV_MODE_DIRECTED:
            ret = set_adv_mode_directed(p_advertising, &adv_params);
   272b8:	f107 030c 	add.w	r3, r7, #12
   272bc:	4619      	mov	r1, r3
   272be:	6878      	ldr	r0, [r7, #4]
   272c0:	f7ff fd80 	bl	26dc4 <set_adv_mode_directed>
   272c4:	61f8      	str	r0, [r7, #28]
            break;
   272c6:	e01c      	b.n	27302 <ble_advertising_start+0x186>

        case BLE_ADV_MODE_DIRECTED_SLOW:
            ret = set_adv_mode_directed_slow(p_advertising, &adv_params);
   272c8:	f107 030c 	add.w	r3, r7, #12
   272cc:	4619      	mov	r1, r3
   272ce:	6878      	ldr	r0, [r7, #4]
   272d0:	f7ff fd94 	bl	26dfc <set_adv_mode_directed_slow>
   272d4:	61f8      	str	r0, [r7, #28]
            break;
   272d6:	e014      	b.n	27302 <ble_advertising_start+0x186>

        case BLE_ADV_MODE_FAST:
            ret = set_adv_mode_fast(p_advertising, &adv_params);
   272d8:	f107 030c 	add.w	r3, r7, #12
   272dc:	4619      	mov	r1, r3
   272de:	6878      	ldr	r0, [r7, #4]
   272e0:	f7ff fdac 	bl	26e3c <set_adv_mode_fast>
   272e4:	61f8      	str	r0, [r7, #28]
            break;
   272e6:	e00c      	b.n	27302 <ble_advertising_start+0x186>

        case BLE_ADV_MODE_SLOW:
            ret = set_adv_mode_slow(p_advertising, &adv_params);
   272e8:	f107 030c 	add.w	r3, r7, #12
   272ec:	4619      	mov	r1, r3
   272ee:	6878      	ldr	r0, [r7, #4]
   272f0:	f7ff fde4 	bl	26ebc <set_adv_mode_slow>
   272f4:	61f8      	str	r0, [r7, #28]
            break;
   272f6:	e004      	b.n	27302 <ble_advertising_start+0x186>

        case BLE_ADV_MODE_IDLE:
            p_advertising->adv_evt = BLE_ADV_EVT_IDLE;
   272f8:	687b      	ldr	r3, [r7, #4]
   272fa:	2200      	movs	r2, #0
   272fc:	709a      	strb	r2, [r3, #2]
            break;
   272fe:	e000      	b.n	27302 <ble_advertising_start+0x186>

        default:
            break;
   27300:	bf00      	nop
    }

    if (p_advertising->adv_mode_current != BLE_ADV_MODE_IDLE)
   27302:	687b      	ldr	r3, [r7, #4]
   27304:	78db      	ldrb	r3, [r3, #3]
   27306:	2b00      	cmp	r3, #0
   27308:	d00e      	beq.n	27328 <ble_advertising_start+0x1ac>
    {
        ret = sd_ble_gap_adv_start(&adv_params, p_advertising->conn_cfg_tag);
   2730a:	687b      	ldr	r3, [r7, #4]
   2730c:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
   27310:	f107 030c 	add.w	r3, r7, #12
   27314:	4611      	mov	r1, r2
   27316:	4618      	mov	r0, r3
   27318:	f7ff fc60 	bl	26bdc <sd_ble_gap_adv_start>
   2731c:	61f8      	str	r0, [r7, #28]
        if (ret != NRF_SUCCESS)
   2731e:	69fb      	ldr	r3, [r7, #28]
   27320:	2b00      	cmp	r3, #0
   27322:	d001      	beq.n	27328 <ble_advertising_start+0x1ac>
        {
            return ret;
   27324:	69fb      	ldr	r3, [r7, #28]
   27326:	e00c      	b.n	27342 <ble_advertising_start+0x1c6>
        }
    }

    if (p_advertising->evt_handler != NULL)
   27328:	687b      	ldr	r3, [r7, #4]
   2732a:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
   2732e:	2b00      	cmp	r3, #0
   27330:	d006      	beq.n	27340 <ble_advertising_start+0x1c4>
    {
        p_advertising->evt_handler(p_advertising->adv_evt);
   27332:	687b      	ldr	r3, [r7, #4]
   27334:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
   27338:	687a      	ldr	r2, [r7, #4]
   2733a:	7892      	ldrb	r2, [r2, #2]
   2733c:	4610      	mov	r0, r2
   2733e:	4798      	blx	r3
    }

    return NRF_SUCCESS;
   27340:	2300      	movs	r3, #0
}
   27342:	4618      	mov	r0, r3
   27344:	3720      	adds	r7, #32
   27346:	46bd      	mov	sp, r7
   27348:	bd80      	pop	{r7, pc}
   2734a:	bf00      	nop

0002734c <ble_advertising_on_ble_evt>:


void ble_advertising_on_ble_evt(ble_evt_t const * p_ble_evt, void * p_context)
{
   2734c:	b580      	push	{r7, lr}
   2734e:	b084      	sub	sp, #16
   27350:	af00      	add	r7, sp, #0
   27352:	6078      	str	r0, [r7, #4]
   27354:	6039      	str	r1, [r7, #0]
    ble_advertising_t * p_advertising = (ble_advertising_t *)p_context;
   27356:	683b      	ldr	r3, [r7, #0]
   27358:	60fb      	str	r3, [r7, #12]

    switch (p_ble_evt->header.evt_id)
   2735a:	687b      	ldr	r3, [r7, #4]
   2735c:	881b      	ldrh	r3, [r3, #0]
   2735e:	2b11      	cmp	r3, #17
   27360:	d009      	beq.n	27376 <ble_advertising_on_ble_evt+0x2a>
   27362:	2b1b      	cmp	r3, #27
   27364:	d00c      	beq.n	27380 <ble_advertising_on_ble_evt+0x34>
   27366:	2b10      	cmp	r3, #16
   27368:	d000      	beq.n	2736c <ble_advertising_on_ble_evt+0x20>
        case BLE_GAP_EVT_TIMEOUT:
            on_timeout(p_advertising, p_ble_evt);
            break;

        default:
            break;
   2736a:	e00e      	b.n	2738a <ble_advertising_on_ble_evt+0x3e>
            on_connected(p_advertising, p_ble_evt);
   2736c:	6879      	ldr	r1, [r7, #4]
   2736e:	68f8      	ldr	r0, [r7, #12]
   27370:	f7ff fc7a 	bl	26c68 <on_connected>
            break;
   27374:	e009      	b.n	2738a <ble_advertising_on_ble_evt+0x3e>
            on_disconnected(p_advertising, p_ble_evt);
   27376:	6879      	ldr	r1, [r7, #4]
   27378:	68f8      	ldr	r0, [r7, #12]
   2737a:	f7ff fc88 	bl	26c8e <on_disconnected>
            break;
   2737e:	e004      	b.n	2738a <ble_advertising_on_ble_evt+0x3e>
            on_timeout(p_advertising, p_ble_evt);
   27380:	6879      	ldr	r1, [r7, #4]
   27382:	68f8      	ldr	r0, [r7, #12]
   27384:	f7ff fcb0 	bl	26ce8 <on_timeout>
            break;
   27388:	bf00      	nop
    }
}
   2738a:	bf00      	nop
   2738c:	3710      	adds	r7, #16
   2738e:	46bd      	mov	sp, r7
   27390:	bd80      	pop	{r7, pc}

00027392 <ble_advertising_on_sys_evt>:


void ble_advertising_on_sys_evt(uint32_t evt_id, void * p_context)
{
   27392:	b580      	push	{r7, lr}
   27394:	b084      	sub	sp, #16
   27396:	af00      	add	r7, sp, #0
   27398:	6078      	str	r0, [r7, #4]
   2739a:	6039      	str	r1, [r7, #0]
    ble_advertising_t * p_advertising = (ble_advertising_t *)p_context;
   2739c:	683b      	ldr	r3, [r7, #0]
   2739e:	60fb      	str	r3, [r7, #12]

    switch (evt_id)
   273a0:	687b      	ldr	r3, [r7, #4]
   273a2:	3b02      	subs	r3, #2
   273a4:	2b01      	cmp	r3, #1
   273a6:	d81b      	bhi.n	273e0 <ble_advertising_on_sys_evt+0x4e>
    {
        //When a flash operation finishes, re-attempt to start advertising operations.
        case NRF_EVT_FLASH_OPERATION_SUCCESS:
        case NRF_EVT_FLASH_OPERATION_ERROR:
        {
            if (p_advertising->advertising_start_pending)
   273a8:	68fb      	ldr	r3, [r7, #12]
   273aa:	785b      	ldrb	r3, [r3, #1]
   273ac:	2b00      	cmp	r3, #0
   273ae:	d019      	beq.n	273e4 <ble_advertising_on_sys_evt+0x52>
            {
                p_advertising->advertising_start_pending = false;
   273b0:	68fb      	ldr	r3, [r7, #12]
   273b2:	2200      	movs	r2, #0
   273b4:	705a      	strb	r2, [r3, #1]
                ret_code_t ret = ble_advertising_start(p_advertising,
   273b6:	68fb      	ldr	r3, [r7, #12]
   273b8:	78db      	ldrb	r3, [r3, #3]
   273ba:	4619      	mov	r1, r3
   273bc:	68f8      	ldr	r0, [r7, #12]
   273be:	f7ff fedd 	bl	2717c <ble_advertising_start>
   273c2:	60b8      	str	r0, [r7, #8]
                                                       p_advertising->adv_mode_current);

                if ((ret != NRF_SUCCESS) && (p_advertising->error_handler != NULL))
   273c4:	68bb      	ldr	r3, [r7, #8]
   273c6:	2b00      	cmp	r3, #0
   273c8:	d00c      	beq.n	273e4 <ble_advertising_on_sys_evt+0x52>
   273ca:	68fb      	ldr	r3, [r7, #12]
   273cc:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
   273d0:	2b00      	cmp	r3, #0
   273d2:	d007      	beq.n	273e4 <ble_advertising_on_sys_evt+0x52>
                {
                    p_advertising->error_handler(ret);
   273d4:	68fb      	ldr	r3, [r7, #12]
   273d6:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
   273da:	68b8      	ldr	r0, [r7, #8]
   273dc:	4798      	blx	r3
                }
            }
        } break;
   273de:	e001      	b.n	273e4 <ble_advertising_on_sys_evt+0x52>

        default:
            // No implementation needed.
            break;
   273e0:	bf00      	nop
   273e2:	e000      	b.n	273e6 <ble_advertising_on_sys_evt+0x54>
        } break;
   273e4:	bf00      	nop
    }
}
   273e6:	bf00      	nop
   273e8:	3710      	adds	r7, #16
   273ea:	46bd      	mov	sp, r7
   273ec:	bd80      	pop	{r7, pc}

000273ee <sdk_mapped_flags_set_by_index>:
 *
 * @param[in]  p_flags  The collection of flags to modify.
 * @param[in]  index    The index of the flag to modify.
 */
static __INLINE void sdk_mapped_flags_set_by_index(sdk_mapped_flags_t * p_flags, uint16_t index)
{
   273ee:	b480      	push	{r7}
   273f0:	b083      	sub	sp, #12
   273f2:	af00      	add	r7, sp, #0
   273f4:	6078      	str	r0, [r7, #4]
   273f6:	460b      	mov	r3, r1
   273f8:	807b      	strh	r3, [r7, #2]
    *p_flags |= (1U << index);
   273fa:	687b      	ldr	r3, [r7, #4]
   273fc:	681a      	ldr	r2, [r3, #0]
   273fe:	887b      	ldrh	r3, [r7, #2]
   27400:	2101      	movs	r1, #1
   27402:	fa01 f303 	lsl.w	r3, r1, r3
   27406:	431a      	orrs	r2, r3
   27408:	687b      	ldr	r3, [r7, #4]
   2740a:	601a      	str	r2, [r3, #0]
}
   2740c:	bf00      	nop
   2740e:	370c      	adds	r7, #12
   27410:	46bd      	mov	sp, r7
   27412:	bc80      	pop	{r7}
   27414:	4770      	bx	lr

00027416 <sdk_mapped_flags_clear_by_index>:
 *
 * @param[in]  p_flags  The collection of flags to modify.
 * @param[in]  index    The index of the flag to modify.
 */
static __INLINE void sdk_mapped_flags_clear_by_index(sdk_mapped_flags_t * p_flags, uint16_t index)
{
   27416:	b480      	push	{r7}
   27418:	b083      	sub	sp, #12
   2741a:	af00      	add	r7, sp, #0
   2741c:	6078      	str	r0, [r7, #4]
   2741e:	460b      	mov	r3, r1
   27420:	807b      	strh	r3, [r7, #2]
    *p_flags &= ~(1U << index);
   27422:	687b      	ldr	r3, [r7, #4]
   27424:	681a      	ldr	r2, [r3, #0]
   27426:	887b      	ldrh	r3, [r7, #2]
   27428:	2101      	movs	r1, #1
   2742a:	fa01 f303 	lsl.w	r3, r1, r3
   2742e:	43db      	mvns	r3, r3
   27430:	401a      	ands	r2, r3
   27432:	687b      	ldr	r3, [r7, #4]
   27434:	601a      	str	r2, [r3, #0]
}
   27436:	bf00      	nop
   27438:	370c      	adds	r7, #12
   2743a:	46bd      	mov	sp, r7
   2743c:	bc80      	pop	{r7}
   2743e:	4770      	bx	lr

00027440 <sdk_mapped_flags_get_by_index>:
 *
 * @param[in]  p_flags  The collection of flags to read.
 * @param[in]  index    The index of the flag to get.
 */
static __INLINE bool sdk_mapped_flags_get_by_index(sdk_mapped_flags_t flags, uint16_t index)
{
   27440:	b480      	push	{r7}
   27442:	b083      	sub	sp, #12
   27444:	af00      	add	r7, sp, #0
   27446:	6078      	str	r0, [r7, #4]
   27448:	460b      	mov	r3, r1
   2744a:	807b      	strh	r3, [r7, #2]
    return ((flags & (1 << index)) != 0);
   2744c:	887b      	ldrh	r3, [r7, #2]
   2744e:	2201      	movs	r2, #1
   27450:	fa02 f303 	lsl.w	r3, r2, r3
   27454:	461a      	mov	r2, r3
   27456:	687b      	ldr	r3, [r7, #4]
   27458:	4013      	ands	r3, r2
   2745a:	2b00      	cmp	r3, #0
   2745c:	bf14      	ite	ne
   2745e:	2301      	movne	r3, #1
   27460:	2300      	moveq	r3, #0
   27462:	b2db      	uxtb	r3, r3
}
   27464:	4618      	mov	r0, r3
   27466:	370c      	adds	r7, #12
   27468:	46bd      	mov	sp, r7
   2746a:	bc80      	pop	{r7}
   2746c:	4770      	bx	lr

0002746e <sdk_mapped_flags_first_key_index_get>:



uint16_t sdk_mapped_flags_first_key_index_get(sdk_mapped_flags_t flags)
{
   2746e:	b580      	push	{r7, lr}
   27470:	b084      	sub	sp, #16
   27472:	af00      	add	r7, sp, #0
   27474:	6078      	str	r0, [r7, #4]
    for (uint16_t i = 0; i < SDK_MAPPED_FLAGS_N_KEYS; i++)
   27476:	2300      	movs	r3, #0
   27478:	81fb      	strh	r3, [r7, #14]
   2747a:	e00c      	b.n	27496 <sdk_mapped_flags_first_key_index_get+0x28>
    {
        if (sdk_mapped_flags_get_by_index(flags, i))
   2747c:	89fb      	ldrh	r3, [r7, #14]
   2747e:	4619      	mov	r1, r3
   27480:	6878      	ldr	r0, [r7, #4]
   27482:	f7ff ffdd 	bl	27440 <sdk_mapped_flags_get_by_index>
   27486:	4603      	mov	r3, r0
   27488:	2b00      	cmp	r3, #0
   2748a:	d001      	beq.n	27490 <sdk_mapped_flags_first_key_index_get+0x22>
        {
            return i;
   2748c:	89fb      	ldrh	r3, [r7, #14]
   2748e:	e007      	b.n	274a0 <sdk_mapped_flags_first_key_index_get+0x32>
    for (uint16_t i = 0; i < SDK_MAPPED_FLAGS_N_KEYS; i++)
   27490:	89fb      	ldrh	r3, [r7, #14]
   27492:	3301      	adds	r3, #1
   27494:	81fb      	strh	r3, [r7, #14]
   27496:	89fb      	ldrh	r3, [r7, #14]
   27498:	2b1f      	cmp	r3, #31
   2749a:	d9ef      	bls.n	2747c <sdk_mapped_flags_first_key_index_get+0xe>
        }
    }
    return SDK_MAPPED_FLAGS_INVALID_INDEX;
   2749c:	f64f 73ff 	movw	r3, #65535	; 0xffff
}
   274a0:	4618      	mov	r0, r3
   274a2:	3710      	adds	r7, #16
   274a4:	46bd      	mov	sp, r7
   274a6:	bd80      	pop	{r7, pc}

000274a8 <sdk_mapped_flags_update_by_key>:

void sdk_mapped_flags_update_by_key(uint16_t           * p_keys,
                                    sdk_mapped_flags_t * p_flags,
                                    uint16_t             key,
                                    bool                 value)
{
   274a8:	b580      	push	{r7, lr}
   274aa:	b086      	sub	sp, #24
   274ac:	af02      	add	r7, sp, #8
   274ae:	60f8      	str	r0, [r7, #12]
   274b0:	60b9      	str	r1, [r7, #8]
   274b2:	4611      	mov	r1, r2
   274b4:	461a      	mov	r2, r3
   274b6:	460b      	mov	r3, r1
   274b8:	80fb      	strh	r3, [r7, #6]
   274ba:	4613      	mov	r3, r2
   274bc:	717b      	strb	r3, [r7, #5]
    sdk_mapped_flags_bulk_update_by_key(p_keys, p_flags, 1, key, value);
   274be:	88fa      	ldrh	r2, [r7, #6]
   274c0:	797b      	ldrb	r3, [r7, #5]
   274c2:	9300      	str	r3, [sp, #0]
   274c4:	4613      	mov	r3, r2
   274c6:	2201      	movs	r2, #1
   274c8:	68b9      	ldr	r1, [r7, #8]
   274ca:	68f8      	ldr	r0, [r7, #12]
   274cc:	f000 f804 	bl	274d8 <sdk_mapped_flags_bulk_update_by_key>
}
   274d0:	bf00      	nop
   274d2:	3710      	adds	r7, #16
   274d4:	46bd      	mov	sp, r7
   274d6:	bd80      	pop	{r7, pc}

000274d8 <sdk_mapped_flags_bulk_update_by_key>:
void sdk_mapped_flags_bulk_update_by_key(uint16_t           * p_keys,
                                         sdk_mapped_flags_t * p_flags,
                                         uint32_t             n_flag_collections,
                                         uint16_t             key,
                                         bool                 value)
{
   274d8:	b580      	push	{r7, lr}
   274da:	b086      	sub	sp, #24
   274dc:	af00      	add	r7, sp, #0
   274de:	60f8      	str	r0, [r7, #12]
   274e0:	60b9      	str	r1, [r7, #8]
   274e2:	607a      	str	r2, [r7, #4]
   274e4:	807b      	strh	r3, [r7, #2]
    if ((p_keys != NULL) && (p_flags != NULL) && (n_flag_collections > 0))
   274e6:	68fb      	ldr	r3, [r7, #12]
   274e8:	2b00      	cmp	r3, #0
   274ea:	d03a      	beq.n	27562 <sdk_mapped_flags_bulk_update_by_key+0x8a>
   274ec:	68bb      	ldr	r3, [r7, #8]
   274ee:	2b00      	cmp	r3, #0
   274f0:	d037      	beq.n	27562 <sdk_mapped_flags_bulk_update_by_key+0x8a>
   274f2:	687b      	ldr	r3, [r7, #4]
   274f4:	2b00      	cmp	r3, #0
   274f6:	d034      	beq.n	27562 <sdk_mapped_flags_bulk_update_by_key+0x8a>
    {
        for (uint32_t i = 0; i < SDK_MAPPED_FLAGS_N_KEYS; i++)
   274f8:	2300      	movs	r3, #0
   274fa:	617b      	str	r3, [r7, #20]
   274fc:	e02e      	b.n	2755c <sdk_mapped_flags_bulk_update_by_key+0x84>
        {
            if (p_keys[i] == key)
   274fe:	697b      	ldr	r3, [r7, #20]
   27500:	005b      	lsls	r3, r3, #1
   27502:	68fa      	ldr	r2, [r7, #12]
   27504:	4413      	add	r3, r2
   27506:	881b      	ldrh	r3, [r3, #0]
   27508:	887a      	ldrh	r2, [r7, #2]
   2750a:	429a      	cmp	r2, r3
   2750c:	d123      	bne.n	27556 <sdk_mapped_flags_bulk_update_by_key+0x7e>
            {
                for (uint32_t j = 0; j < n_flag_collections; j++)
   2750e:	2300      	movs	r3, #0
   27510:	613b      	str	r3, [r7, #16]
   27512:	e01b      	b.n	2754c <sdk_mapped_flags_bulk_update_by_key+0x74>
                {
                    if (value)
   27514:	f897 3020 	ldrb.w	r3, [r7, #32]
   27518:	2b00      	cmp	r3, #0
   2751a:	d00a      	beq.n	27532 <sdk_mapped_flags_bulk_update_by_key+0x5a>
                    {
                        sdk_mapped_flags_set_by_index(&p_flags[j], i);
   2751c:	693b      	ldr	r3, [r7, #16]
   2751e:	009b      	lsls	r3, r3, #2
   27520:	68ba      	ldr	r2, [r7, #8]
   27522:	4413      	add	r3, r2
   27524:	697a      	ldr	r2, [r7, #20]
   27526:	b292      	uxth	r2, r2
   27528:	4611      	mov	r1, r2
   2752a:	4618      	mov	r0, r3
   2752c:	f7ff ff5f 	bl	273ee <sdk_mapped_flags_set_by_index>
   27530:	e009      	b.n	27546 <sdk_mapped_flags_bulk_update_by_key+0x6e>
                    }
                    else
                    {
                        sdk_mapped_flags_clear_by_index(&p_flags[j], i);
   27532:	693b      	ldr	r3, [r7, #16]
   27534:	009b      	lsls	r3, r3, #2
   27536:	68ba      	ldr	r2, [r7, #8]
   27538:	4413      	add	r3, r2
   2753a:	697a      	ldr	r2, [r7, #20]
   2753c:	b292      	uxth	r2, r2
   2753e:	4611      	mov	r1, r2
   27540:	4618      	mov	r0, r3
   27542:	f7ff ff68 	bl	27416 <sdk_mapped_flags_clear_by_index>
                for (uint32_t j = 0; j < n_flag_collections; j++)
   27546:	693b      	ldr	r3, [r7, #16]
   27548:	3301      	adds	r3, #1
   2754a:	613b      	str	r3, [r7, #16]
   2754c:	693a      	ldr	r2, [r7, #16]
   2754e:	687b      	ldr	r3, [r7, #4]
   27550:	429a      	cmp	r2, r3
   27552:	d3df      	bcc.n	27514 <sdk_mapped_flags_bulk_update_by_key+0x3c>
                    }
                }
                return;
   27554:	e005      	b.n	27562 <sdk_mapped_flags_bulk_update_by_key+0x8a>
        for (uint32_t i = 0; i < SDK_MAPPED_FLAGS_N_KEYS; i++)
   27556:	697b      	ldr	r3, [r7, #20]
   27558:	3301      	adds	r3, #1
   2755a:	617b      	str	r3, [r7, #20]
   2755c:	697b      	ldr	r3, [r7, #20]
   2755e:	2b1f      	cmp	r3, #31
   27560:	d9cd      	bls.n	274fe <sdk_mapped_flags_bulk_update_by_key+0x26>
            }
        }
    }
}
   27562:	3718      	adds	r7, #24
   27564:	46bd      	mov	sp, r7
   27566:	bd80      	pop	{r7, pc}

00027568 <sdk_mapped_flags_get_by_key>:
    return false;
}


bool sdk_mapped_flags_get_by_key(uint16_t * p_keys, sdk_mapped_flags_t flags, uint16_t key)
{
   27568:	b580      	push	{r7, lr}
   2756a:	b086      	sub	sp, #24
   2756c:	af00      	add	r7, sp, #0
   2756e:	60f8      	str	r0, [r7, #12]
   27570:	60b9      	str	r1, [r7, #8]
   27572:	4613      	mov	r3, r2
   27574:	80fb      	strh	r3, [r7, #6]
    if (p_keys != NULL)
   27576:	68fb      	ldr	r3, [r7, #12]
   27578:	2b00      	cmp	r3, #0
   2757a:	d018      	beq.n	275ae <sdk_mapped_flags_get_by_key+0x46>
    {
        for (uint32_t i = 0; i < SDK_MAPPED_FLAGS_N_KEYS; i++)
   2757c:	2300      	movs	r3, #0
   2757e:	617b      	str	r3, [r7, #20]
   27580:	e012      	b.n	275a8 <sdk_mapped_flags_get_by_key+0x40>
        {
            if (p_keys[i] == key)
   27582:	697b      	ldr	r3, [r7, #20]
   27584:	005b      	lsls	r3, r3, #1
   27586:	68fa      	ldr	r2, [r7, #12]
   27588:	4413      	add	r3, r2
   2758a:	881b      	ldrh	r3, [r3, #0]
   2758c:	88fa      	ldrh	r2, [r7, #6]
   2758e:	429a      	cmp	r2, r3
   27590:	d107      	bne.n	275a2 <sdk_mapped_flags_get_by_key+0x3a>
            {
                return sdk_mapped_flags_get_by_index(flags, i);
   27592:	697b      	ldr	r3, [r7, #20]
   27594:	b29b      	uxth	r3, r3
   27596:	4619      	mov	r1, r3
   27598:	68b8      	ldr	r0, [r7, #8]
   2759a:	f7ff ff51 	bl	27440 <sdk_mapped_flags_get_by_index>
   2759e:	4603      	mov	r3, r0
   275a0:	e006      	b.n	275b0 <sdk_mapped_flags_get_by_key+0x48>
        for (uint32_t i = 0; i < SDK_MAPPED_FLAGS_N_KEYS; i++)
   275a2:	697b      	ldr	r3, [r7, #20]
   275a4:	3301      	adds	r3, #1
   275a6:	617b      	str	r3, [r7, #20]
   275a8:	697b      	ldr	r3, [r7, #20]
   275aa:	2b1f      	cmp	r3, #31
   275ac:	d9e9      	bls.n	27582 <sdk_mapped_flags_get_by_key+0x1a>
            }
        }
    }
    return false;
   275ae:	2300      	movs	r3, #0
}
   275b0:	4618      	mov	r0, r3
   275b2:	3718      	adds	r7, #24
   275b4:	46bd      	mov	sp, r7
   275b6:	bd80      	pop	{r7, pc}

000275b8 <sdk_mapped_flags_key_list_get>:


sdk_mapped_flags_key_list_t sdk_mapped_flags_key_list_get(uint16_t           * p_keys,
                                                          sdk_mapped_flags_t   flags)
{
   275b8:	b580      	push	{r7, lr}
   275ba:	b096      	sub	sp, #88	; 0x58
   275bc:	af00      	add	r7, sp, #0
   275be:	60f8      	str	r0, [r7, #12]
   275c0:	60b9      	str	r1, [r7, #8]
   275c2:	607a      	str	r2, [r7, #4]
    sdk_mapped_flags_key_list_t key_list;
    key_list.len = 0;
   275c4:	2300      	movs	r3, #0
   275c6:	613b      	str	r3, [r7, #16]

    if (p_keys != NULL)
   275c8:	68bb      	ldr	r3, [r7, #8]
   275ca:	2b00      	cmp	r3, #0
   275cc:	d01f      	beq.n	2760e <sdk_mapped_flags_key_list_get+0x56>
    {
        for (uint32_t i = 0; i < SDK_MAPPED_FLAGS_N_KEYS; i++)
   275ce:	2300      	movs	r3, #0
   275d0:	657b      	str	r3, [r7, #84]	; 0x54
   275d2:	e019      	b.n	27608 <sdk_mapped_flags_key_list_get+0x50>
        {
            if (sdk_mapped_flags_get_by_index(flags, i))
   275d4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   275d6:	b29b      	uxth	r3, r3
   275d8:	4619      	mov	r1, r3
   275da:	6878      	ldr	r0, [r7, #4]
   275dc:	f7ff ff30 	bl	27440 <sdk_mapped_flags_get_by_index>
   275e0:	4603      	mov	r3, r0
   275e2:	2b00      	cmp	r3, #0
   275e4:	d00d      	beq.n	27602 <sdk_mapped_flags_key_list_get+0x4a>
            {
                key_list.flag_keys[key_list.len++] = p_keys[i];
   275e6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   275e8:	005b      	lsls	r3, r3, #1
   275ea:	68ba      	ldr	r2, [r7, #8]
   275ec:	441a      	add	r2, r3
   275ee:	693b      	ldr	r3, [r7, #16]
   275f0:	1c59      	adds	r1, r3, #1
   275f2:	6139      	str	r1, [r7, #16]
   275f4:	8812      	ldrh	r2, [r2, #0]
   275f6:	005b      	lsls	r3, r3, #1
   275f8:	f107 0158 	add.w	r1, r7, #88	; 0x58
   275fc:	440b      	add	r3, r1
   275fe:	f823 2c44 	strh.w	r2, [r3, #-68]
        for (uint32_t i = 0; i < SDK_MAPPED_FLAGS_N_KEYS; i++)
   27602:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   27604:	3301      	adds	r3, #1
   27606:	657b      	str	r3, [r7, #84]	; 0x54
   27608:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   2760a:	2b1f      	cmp	r3, #31
   2760c:	d9e2      	bls.n	275d4 <sdk_mapped_flags_key_list_get+0x1c>
            }
        }
    }

    return key_list;
   2760e:	68fb      	ldr	r3, [r7, #12]
   27610:	4618      	mov	r0, r3
   27612:	f107 0310 	add.w	r3, r7, #16
   27616:	2244      	movs	r2, #68	; 0x44
   27618:	4619      	mov	r1, r3
   2761a:	f000 f8f5 	bl	27808 <memcpy>
}
   2761e:	68f8      	ldr	r0, [r7, #12]
   27620:	3758      	adds	r7, #88	; 0x58
   27622:	46bd      	mov	sp, r7
   27624:	bd80      	pop	{r7, pc}

00027626 <fifo_length>:
#include "sdk_common.h"
#if NRF_MODULE_ENABLED(APP_FIFO)
#include "app_fifo.h"

static __INLINE uint32_t fifo_length(app_fifo_t * p_fifo)
{
   27626:	b480      	push	{r7}
   27628:	b085      	sub	sp, #20
   2762a:	af00      	add	r7, sp, #0
   2762c:	6078      	str	r0, [r7, #4]
    uint32_t tmp = p_fifo->read_pos;
   2762e:	687b      	ldr	r3, [r7, #4]
   27630:	689b      	ldr	r3, [r3, #8]
   27632:	60fb      	str	r3, [r7, #12]
    return p_fifo->write_pos - tmp;
   27634:	687b      	ldr	r3, [r7, #4]
   27636:	68da      	ldr	r2, [r3, #12]
   27638:	68fb      	ldr	r3, [r7, #12]
   2763a:	1ad3      	subs	r3, r2, r3
}
   2763c:	4618      	mov	r0, r3
   2763e:	3714      	adds	r7, #20
   27640:	46bd      	mov	sp, r7
   27642:	bc80      	pop	{r7}
   27644:	4770      	bx	lr

00027646 <fifo_put>:
#define FIFO_LENGTH() fifo_length(p_fifo)  /**< Macro for calculating the FIFO length. */


/**@brief Put one byte to the FIFO. */
static __INLINE void fifo_put(app_fifo_t * p_fifo, uint8_t byte)
{
   27646:	b480      	push	{r7}
   27648:	b083      	sub	sp, #12
   2764a:	af00      	add	r7, sp, #0
   2764c:	6078      	str	r0, [r7, #4]
   2764e:	460b      	mov	r3, r1
   27650:	70fb      	strb	r3, [r7, #3]
    p_fifo->p_buf[p_fifo->write_pos & p_fifo->buf_size_mask] = byte;
   27652:	687b      	ldr	r3, [r7, #4]
   27654:	681a      	ldr	r2, [r3, #0]
   27656:	687b      	ldr	r3, [r7, #4]
   27658:	68db      	ldr	r3, [r3, #12]
   2765a:	6879      	ldr	r1, [r7, #4]
   2765c:	8889      	ldrh	r1, [r1, #4]
   2765e:	400b      	ands	r3, r1
   27660:	4413      	add	r3, r2
   27662:	78fa      	ldrb	r2, [r7, #3]
   27664:	701a      	strb	r2, [r3, #0]
    p_fifo->write_pos++;
   27666:	687b      	ldr	r3, [r7, #4]
   27668:	68db      	ldr	r3, [r3, #12]
   2766a:	1c5a      	adds	r2, r3, #1
   2766c:	687b      	ldr	r3, [r7, #4]
   2766e:	60da      	str	r2, [r3, #12]
}
   27670:	bf00      	nop
   27672:	370c      	adds	r7, #12
   27674:	46bd      	mov	sp, r7
   27676:	bc80      	pop	{r7}
   27678:	4770      	bx	lr

0002767a <app_fifo_init>:
    p_fifo->read_pos++;
}


uint32_t app_fifo_init(app_fifo_t * p_fifo, uint8_t * p_buf, uint16_t buf_size)
{
   2767a:	b480      	push	{r7}
   2767c:	b085      	sub	sp, #20
   2767e:	af00      	add	r7, sp, #0
   27680:	60f8      	str	r0, [r7, #12]
   27682:	60b9      	str	r1, [r7, #8]
   27684:	4613      	mov	r3, r2
   27686:	80fb      	strh	r3, [r7, #6]
    // Check buffer for null pointer.
    if (p_buf == NULL)
   27688:	68bb      	ldr	r3, [r7, #8]
   2768a:	2b00      	cmp	r3, #0
   2768c:	d101      	bne.n	27692 <app_fifo_init+0x18>
    {
        return NRF_ERROR_NULL;
   2768e:	230e      	movs	r3, #14
   27690:	e019      	b.n	276c6 <app_fifo_init+0x4c>
    }

    // Check that the buffer size is a power of two.
    if (!IS_POWER_OF_TWO(buf_size))
   27692:	88fb      	ldrh	r3, [r7, #6]
   27694:	2b00      	cmp	r3, #0
   27696:	d005      	beq.n	276a4 <app_fifo_init+0x2a>
   27698:	88fb      	ldrh	r3, [r7, #6]
   2769a:	1e5a      	subs	r2, r3, #1
   2769c:	88fb      	ldrh	r3, [r7, #6]
   2769e:	4013      	ands	r3, r2
   276a0:	2b00      	cmp	r3, #0
   276a2:	d001      	beq.n	276a8 <app_fifo_init+0x2e>
    {
        return NRF_ERROR_INVALID_LENGTH;
   276a4:	2309      	movs	r3, #9
   276a6:	e00e      	b.n	276c6 <app_fifo_init+0x4c>
    }

    p_fifo->p_buf         = p_buf;
   276a8:	68fb      	ldr	r3, [r7, #12]
   276aa:	68ba      	ldr	r2, [r7, #8]
   276ac:	601a      	str	r2, [r3, #0]
    p_fifo->buf_size_mask = buf_size - 1;
   276ae:	88fb      	ldrh	r3, [r7, #6]
   276b0:	3b01      	subs	r3, #1
   276b2:	b29a      	uxth	r2, r3
   276b4:	68fb      	ldr	r3, [r7, #12]
   276b6:	809a      	strh	r2, [r3, #4]
    p_fifo->read_pos      = 0;
   276b8:	68fb      	ldr	r3, [r7, #12]
   276ba:	2200      	movs	r2, #0
   276bc:	609a      	str	r2, [r3, #8]
    p_fifo->write_pos     = 0;
   276be:	68fb      	ldr	r3, [r7, #12]
   276c0:	2200      	movs	r2, #0
   276c2:	60da      	str	r2, [r3, #12]

    return NRF_SUCCESS;
   276c4:	2300      	movs	r3, #0
}
   276c6:	4618      	mov	r0, r3
   276c8:	3714      	adds	r7, #20
   276ca:	46bd      	mov	sp, r7
   276cc:	bc80      	pop	{r7}
   276ce:	4770      	bx	lr

000276d0 <app_fifo_put>:


uint32_t app_fifo_put(app_fifo_t * p_fifo, uint8_t byte)
{
   276d0:	b580      	push	{r7, lr}
   276d2:	b082      	sub	sp, #8
   276d4:	af00      	add	r7, sp, #0
   276d6:	6078      	str	r0, [r7, #4]
   276d8:	460b      	mov	r3, r1
   276da:	70fb      	strb	r3, [r7, #3]
    if (FIFO_LENGTH() <= p_fifo->buf_size_mask)
   276dc:	6878      	ldr	r0, [r7, #4]
   276de:	f7ff ffa2 	bl	27626 <fifo_length>
   276e2:	4602      	mov	r2, r0
   276e4:	687b      	ldr	r3, [r7, #4]
   276e6:	889b      	ldrh	r3, [r3, #4]
   276e8:	429a      	cmp	r2, r3
   276ea:	d806      	bhi.n	276fa <app_fifo_put+0x2a>
    {
        fifo_put(p_fifo, byte);
   276ec:	78fb      	ldrb	r3, [r7, #3]
   276ee:	4619      	mov	r1, r3
   276f0:	6878      	ldr	r0, [r7, #4]
   276f2:	f7ff ffa8 	bl	27646 <fifo_put>
        return NRF_SUCCESS;
   276f6:	2300      	movs	r3, #0
   276f8:	e000      	b.n	276fc <app_fifo_put+0x2c>
    }

    return NRF_ERROR_NO_MEM;
   276fa:	2304      	movs	r3, #4
}
   276fc:	4618      	mov	r0, r3
   276fe:	3708      	adds	r7, #8
   27700:	46bd      	mov	sp, r7
   27702:	bd80      	pop	{r7, pc}

00027704 <nrf_fstorage_is_busy>:
    return ((nrf_fstorage_api_t *)p_fs->p_api)->erase(p_fs, page_addr, len, p_context);
}


bool nrf_fstorage_is_busy(nrf_fstorage_t const * p_fs)
{
   27704:	b580      	push	{r7, lr}
   27706:	b084      	sub	sp, #16
   27708:	af00      	add	r7, sp, #0
   2770a:	6078      	str	r0, [r7, #4]
    nrf_fstorage_api_t const * p_api;

    /* If a NULL instance is provided, return true if any instance is busy.
     * Uninitialized instances are considered not busy. */
    if ((p_fs == NULL) || (p_fs->p_api == NULL))
   2770c:	687b      	ldr	r3, [r7, #4]
   2770e:	2b00      	cmp	r3, #0
   27710:	d003      	beq.n	2771a <nrf_fstorage_is_busy+0x16>
   27712:	687b      	ldr	r3, [r7, #4]
   27714:	681b      	ldr	r3, [r3, #0]
   27716:	2b00      	cmp	r3, #0
   27718:	d129      	bne.n	2776e <nrf_fstorage_is_busy+0x6a>
    {
        for (uint32_t i = 0; i < NRF_FSTORAGE_INSTANCE_CNT; i++)
   2771a:	2300      	movs	r3, #0
   2771c:	60fb      	str	r3, [r7, #12]
   2771e:	e01a      	b.n	27756 <nrf_fstorage_is_busy+0x52>
        {
            p_fs  = NRF_FSTORAGE_INSTANCE_GET(i);   /* cannot be NULL. */
   27720:	68fa      	ldr	r2, [r7, #12]
   27722:	4613      	mov	r3, r2
   27724:	009b      	lsls	r3, r3, #2
   27726:	4413      	add	r3, r2
   27728:	009b      	lsls	r3, r3, #2
   2772a:	461a      	mov	r2, r3
   2772c:	4b16      	ldr	r3, [pc, #88]	; (27788 <nrf_fstorage_is_busy+0x84>)
   2772e:	4413      	add	r3, r2
   27730:	607b      	str	r3, [r7, #4]
            p_api = (nrf_fstorage_api_t*)p_fs->p_api;
   27732:	687b      	ldr	r3, [r7, #4]
   27734:	681b      	ldr	r3, [r3, #0]
   27736:	60bb      	str	r3, [r7, #8]

            if (p_api != NULL)
   27738:	68bb      	ldr	r3, [r7, #8]
   2773a:	2b00      	cmp	r3, #0
   2773c:	d008      	beq.n	27750 <nrf_fstorage_is_busy+0x4c>
            {
                /* p_api->is_busy() cannot be NULL. */
                if (p_api->is_busy(p_fs))
   2773e:	68bb      	ldr	r3, [r7, #8]
   27740:	695b      	ldr	r3, [r3, #20]
   27742:	6878      	ldr	r0, [r7, #4]
   27744:	4798      	blx	r3
   27746:	4603      	mov	r3, r0
   27748:	2b00      	cmp	r3, #0
   2774a:	d001      	beq.n	27750 <nrf_fstorage_is_busy+0x4c>
                {
                    return true;
   2774c:	2301      	movs	r3, #1
   2774e:	e016      	b.n	2777e <nrf_fstorage_is_busy+0x7a>
        for (uint32_t i = 0; i < NRF_FSTORAGE_INSTANCE_CNT; i++)
   27750:	68fb      	ldr	r3, [r7, #12]
   27752:	3301      	adds	r3, #1
   27754:	60fb      	str	r3, [r7, #12]
   27756:	4a0d      	ldr	r2, [pc, #52]	; (2778c <nrf_fstorage_is_busy+0x88>)
   27758:	4b0b      	ldr	r3, [pc, #44]	; (27788 <nrf_fstorage_is_busy+0x84>)
   2775a:	1ad3      	subs	r3, r2, r3
   2775c:	4a0c      	ldr	r2, [pc, #48]	; (27790 <nrf_fstorage_is_busy+0x8c>)
   2775e:	fba2 2303 	umull	r2, r3, r2, r3
   27762:	091b      	lsrs	r3, r3, #4
   27764:	68fa      	ldr	r2, [r7, #12]
   27766:	429a      	cmp	r2, r3
   27768:	d3da      	bcc.n	27720 <nrf_fstorage_is_busy+0x1c>
                }
            }
        }

        return false;
   2776a:	2300      	movs	r3, #0
   2776c:	e007      	b.n	2777e <nrf_fstorage_is_busy+0x7a>
    }

    p_api = (nrf_fstorage_api_t*)p_fs->p_api;
   2776e:	687b      	ldr	r3, [r7, #4]
   27770:	681b      	ldr	r3, [r3, #0]
   27772:	60bb      	str	r3, [r7, #8]

    return p_api->is_busy(p_fs);
   27774:	68bb      	ldr	r3, [r7, #8]
   27776:	695b      	ldr	r3, [r3, #20]
   27778:	6878      	ldr	r0, [r7, #4]
   2777a:	4798      	blx	r3
   2777c:	4603      	mov	r3, r0
}
   2777e:	4618      	mov	r0, r3
   27780:	3710      	adds	r7, #16
   27782:	46bd      	mov	sp, r7
   27784:	bd80      	pop	{r7, pc}
   27786:	bf00      	nop
   27788:	20005080 	.word	0x20005080
   2778c:	20005080 	.word	0x20005080
   27790:	cccccccd 	.word	0xcccccccd

00027794 <Reset_Handler>:
   27794:	490b      	ldr	r1, [pc, #44]	; (277c4 <Reset_Handler+0x30>)
   27796:	4a0c      	ldr	r2, [pc, #48]	; (277c8 <Reset_Handler+0x34>)
   27798:	4b0c      	ldr	r3, [pc, #48]	; (277cc <Reset_Handler+0x38>)
   2779a:	1a9b      	subs	r3, r3, r2
   2779c:	dd03      	ble.n	277a6 <Reset_Handler+0x12>
   2779e:	3b04      	subs	r3, #4
   277a0:	58c8      	ldr	r0, [r1, r3]
   277a2:	50d0      	str	r0, [r2, r3]
   277a4:	dcfb      	bgt.n	2779e <Reset_Handler+0xa>
   277a6:	4909      	ldr	r1, [pc, #36]	; (277cc <Reset_Handler+0x38>)
   277a8:	4a09      	ldr	r2, [pc, #36]	; (277d0 <Reset_Handler+0x3c>)
   277aa:	2000      	movs	r0, #0
   277ac:	1a52      	subs	r2, r2, r1
   277ae:	dd02      	ble.n	277b6 <Reset_Handler+0x22>
   277b0:	3a04      	subs	r2, #4
   277b2:	5088      	str	r0, [r1, r2]
   277b4:	dcfc      	bgt.n	277b0 <Reset_Handler+0x1c>
   277b6:	f7fc f8ef 	bl	23998 <SystemInit>
   277ba:	f7fc f8b7 	bl	2392c <main>
   277be:	f7fb fe59 	bl	23474 <_mainCRTStartup>
   277c2:	0000      	.short	0x0000
   277c4:	00027bb8 	.word	0x00027bb8
   277c8:	20005000 	.word	0x20005000
   277cc:	20005080 	.word	0x20005080
   277d0:	200053b4 	.word	0x200053b4

000277d4 <NMI_Handler>:
   277d4:	e7fe      	b.n	277d4 <NMI_Handler>

000277d6 <HardFault_Handler>:
   277d6:	e7fe      	b.n	277d6 <HardFault_Handler>

000277d8 <MemoryManagement_Handler>:
   277d8:	e7fe      	b.n	277d8 <MemoryManagement_Handler>

000277da <BusFault_Handler>:
   277da:	e7fe      	b.n	277da <BusFault_Handler>

000277dc <UsageFault_Handler>:
   277dc:	e7fe      	b.n	277dc <UsageFault_Handler>

000277de <SVC_Handler>:
   277de:	e7fe      	b.n	277de <SVC_Handler>

000277e0 <DebugMon_Handler>:
   277e0:	e7fe      	b.n	277e0 <DebugMon_Handler>

000277e2 <PendSV_Handler>:
   277e2:	e7fe      	b.n	277e2 <PendSV_Handler>
   277e4:	e7fe      	b.n	277e4 <PendSV_Handler+0x2>

000277e6 <Default_Handler>:
   277e6:	e7fe      	b.n	277e6 <Default_Handler>

000277e8 <malloc>:
   277e8:	4b02      	ldr	r3, [pc, #8]	; (277f4 <malloc+0xc>)
   277ea:	4601      	mov	r1, r0
   277ec:	6818      	ldr	r0, [r3, #0]
   277ee:	f000 b865 	b.w	278bc <_malloc_r>
   277f2:	bf00      	nop
   277f4:	20005000 	.word	0x20005000

000277f8 <free>:
   277f8:	4b02      	ldr	r3, [pc, #8]	; (27804 <free+0xc>)
   277fa:	4601      	mov	r1, r0
   277fc:	6818      	ldr	r0, [r3, #0]
   277fe:	f000 b80f 	b.w	27820 <_free_r>
   27802:	bf00      	nop
   27804:	20005000 	.word	0x20005000

00027808 <memcpy>:
   27808:	b510      	push	{r4, lr}
   2780a:	1e43      	subs	r3, r0, #1
   2780c:	440a      	add	r2, r1
   2780e:	4291      	cmp	r1, r2
   27810:	d100      	bne.n	27814 <memcpy+0xc>
   27812:	bd10      	pop	{r4, pc}
   27814:	f811 4b01 	ldrb.w	r4, [r1], #1
   27818:	f803 4f01 	strb.w	r4, [r3, #1]!
   2781c:	e7f7      	b.n	2780e <memcpy+0x6>
	...

00027820 <_free_r>:
   27820:	b538      	push	{r3, r4, r5, lr}
   27822:	4605      	mov	r5, r0
   27824:	2900      	cmp	r1, #0
   27826:	d045      	beq.n	278b4 <_free_r+0x94>
   27828:	f851 3c04 	ldr.w	r3, [r1, #-4]
   2782c:	1f0c      	subs	r4, r1, #4
   2782e:	2b00      	cmp	r3, #0
   27830:	bfb8      	it	lt
   27832:	18e4      	addlt	r4, r4, r3
   27834:	f000 f8b8 	bl	279a8 <__malloc_lock>
   27838:	4a1f      	ldr	r2, [pc, #124]	; (278b8 <_free_r+0x98>)
   2783a:	6813      	ldr	r3, [r2, #0]
   2783c:	4610      	mov	r0, r2
   2783e:	b933      	cbnz	r3, 2784e <_free_r+0x2e>
   27840:	6063      	str	r3, [r4, #4]
   27842:	6014      	str	r4, [r2, #0]
   27844:	4628      	mov	r0, r5
   27846:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   2784a:	f000 b8ae 	b.w	279aa <__malloc_unlock>
   2784e:	42a3      	cmp	r3, r4
   27850:	d90c      	bls.n	2786c <_free_r+0x4c>
   27852:	6821      	ldr	r1, [r4, #0]
   27854:	1862      	adds	r2, r4, r1
   27856:	4293      	cmp	r3, r2
   27858:	bf04      	itt	eq
   2785a:	681a      	ldreq	r2, [r3, #0]
   2785c:	685b      	ldreq	r3, [r3, #4]
   2785e:	6063      	str	r3, [r4, #4]
   27860:	bf04      	itt	eq
   27862:	1852      	addeq	r2, r2, r1
   27864:	6022      	streq	r2, [r4, #0]
   27866:	6004      	str	r4, [r0, #0]
   27868:	e7ec      	b.n	27844 <_free_r+0x24>
   2786a:	4613      	mov	r3, r2
   2786c:	685a      	ldr	r2, [r3, #4]
   2786e:	b10a      	cbz	r2, 27874 <_free_r+0x54>
   27870:	42a2      	cmp	r2, r4
   27872:	d9fa      	bls.n	2786a <_free_r+0x4a>
   27874:	6819      	ldr	r1, [r3, #0]
   27876:	1858      	adds	r0, r3, r1
   27878:	42a0      	cmp	r0, r4
   2787a:	d10b      	bne.n	27894 <_free_r+0x74>
   2787c:	6820      	ldr	r0, [r4, #0]
   2787e:	4401      	add	r1, r0
   27880:	1858      	adds	r0, r3, r1
   27882:	4282      	cmp	r2, r0
   27884:	6019      	str	r1, [r3, #0]
   27886:	d1dd      	bne.n	27844 <_free_r+0x24>
   27888:	6810      	ldr	r0, [r2, #0]
   2788a:	6852      	ldr	r2, [r2, #4]
   2788c:	605a      	str	r2, [r3, #4]
   2788e:	4401      	add	r1, r0
   27890:	6019      	str	r1, [r3, #0]
   27892:	e7d7      	b.n	27844 <_free_r+0x24>
   27894:	d902      	bls.n	2789c <_free_r+0x7c>
   27896:	230c      	movs	r3, #12
   27898:	602b      	str	r3, [r5, #0]
   2789a:	e7d3      	b.n	27844 <_free_r+0x24>
   2789c:	6820      	ldr	r0, [r4, #0]
   2789e:	1821      	adds	r1, r4, r0
   278a0:	428a      	cmp	r2, r1
   278a2:	bf04      	itt	eq
   278a4:	6811      	ldreq	r1, [r2, #0]
   278a6:	6852      	ldreq	r2, [r2, #4]
   278a8:	6062      	str	r2, [r4, #4]
   278aa:	bf04      	itt	eq
   278ac:	1809      	addeq	r1, r1, r0
   278ae:	6021      	streq	r1, [r4, #0]
   278b0:	605c      	str	r4, [r3, #4]
   278b2:	e7c7      	b.n	27844 <_free_r+0x24>
   278b4:	bd38      	pop	{r3, r4, r5, pc}
   278b6:	bf00      	nop
   278b8:	20005378 	.word	0x20005378

000278bc <_malloc_r>:
   278bc:	b570      	push	{r4, r5, r6, lr}
   278be:	1ccd      	adds	r5, r1, #3
   278c0:	f025 0503 	bic.w	r5, r5, #3
   278c4:	3508      	adds	r5, #8
   278c6:	2d0c      	cmp	r5, #12
   278c8:	bf38      	it	cc
   278ca:	250c      	movcc	r5, #12
   278cc:	2d00      	cmp	r5, #0
   278ce:	4606      	mov	r6, r0
   278d0:	db01      	blt.n	278d6 <_malloc_r+0x1a>
   278d2:	42a9      	cmp	r1, r5
   278d4:	d903      	bls.n	278de <_malloc_r+0x22>
   278d6:	230c      	movs	r3, #12
   278d8:	6033      	str	r3, [r6, #0]
   278da:	2000      	movs	r0, #0
   278dc:	bd70      	pop	{r4, r5, r6, pc}
   278de:	f000 f863 	bl	279a8 <__malloc_lock>
   278e2:	4a23      	ldr	r2, [pc, #140]	; (27970 <_malloc_r+0xb4>)
   278e4:	6814      	ldr	r4, [r2, #0]
   278e6:	4621      	mov	r1, r4
   278e8:	b991      	cbnz	r1, 27910 <_malloc_r+0x54>
   278ea:	4c22      	ldr	r4, [pc, #136]	; (27974 <_malloc_r+0xb8>)
   278ec:	6823      	ldr	r3, [r4, #0]
   278ee:	b91b      	cbnz	r3, 278f8 <_malloc_r+0x3c>
   278f0:	4630      	mov	r0, r6
   278f2:	f000 f841 	bl	27978 <_sbrk_r>
   278f6:	6020      	str	r0, [r4, #0]
   278f8:	4629      	mov	r1, r5
   278fa:	4630      	mov	r0, r6
   278fc:	f000 f83c 	bl	27978 <_sbrk_r>
   27900:	1c43      	adds	r3, r0, #1
   27902:	d126      	bne.n	27952 <_malloc_r+0x96>
   27904:	230c      	movs	r3, #12
   27906:	6033      	str	r3, [r6, #0]
   27908:	4630      	mov	r0, r6
   2790a:	f000 f84e 	bl	279aa <__malloc_unlock>
   2790e:	e7e4      	b.n	278da <_malloc_r+0x1e>
   27910:	680b      	ldr	r3, [r1, #0]
   27912:	1b5b      	subs	r3, r3, r5
   27914:	d41a      	bmi.n	2794c <_malloc_r+0x90>
   27916:	2b0b      	cmp	r3, #11
   27918:	d90f      	bls.n	2793a <_malloc_r+0x7e>
   2791a:	600b      	str	r3, [r1, #0]
   2791c:	50cd      	str	r5, [r1, r3]
   2791e:	18cc      	adds	r4, r1, r3
   27920:	4630      	mov	r0, r6
   27922:	f000 f842 	bl	279aa <__malloc_unlock>
   27926:	f104 000b 	add.w	r0, r4, #11
   2792a:	1d23      	adds	r3, r4, #4
   2792c:	f020 0007 	bic.w	r0, r0, #7
   27930:	1ac3      	subs	r3, r0, r3
   27932:	d01b      	beq.n	2796c <_malloc_r+0xb0>
   27934:	425a      	negs	r2, r3
   27936:	50e2      	str	r2, [r4, r3]
   27938:	bd70      	pop	{r4, r5, r6, pc}
   2793a:	428c      	cmp	r4, r1
   2793c:	bf0d      	iteet	eq
   2793e:	6863      	ldreq	r3, [r4, #4]
   27940:	684b      	ldrne	r3, [r1, #4]
   27942:	6063      	strne	r3, [r4, #4]
   27944:	6013      	streq	r3, [r2, #0]
   27946:	bf18      	it	ne
   27948:	460c      	movne	r4, r1
   2794a:	e7e9      	b.n	27920 <_malloc_r+0x64>
   2794c:	460c      	mov	r4, r1
   2794e:	6849      	ldr	r1, [r1, #4]
   27950:	e7ca      	b.n	278e8 <_malloc_r+0x2c>
   27952:	1cc4      	adds	r4, r0, #3
   27954:	f024 0403 	bic.w	r4, r4, #3
   27958:	42a0      	cmp	r0, r4
   2795a:	d005      	beq.n	27968 <_malloc_r+0xac>
   2795c:	1a21      	subs	r1, r4, r0
   2795e:	4630      	mov	r0, r6
   27960:	f000 f80a 	bl	27978 <_sbrk_r>
   27964:	3001      	adds	r0, #1
   27966:	d0cd      	beq.n	27904 <_malloc_r+0x48>
   27968:	6025      	str	r5, [r4, #0]
   2796a:	e7d9      	b.n	27920 <_malloc_r+0x64>
   2796c:	bd70      	pop	{r4, r5, r6, pc}
   2796e:	bf00      	nop
   27970:	20005378 	.word	0x20005378
   27974:	2000537c 	.word	0x2000537c

00027978 <_sbrk_r>:
   27978:	b538      	push	{r3, r4, r5, lr}
   2797a:	4c06      	ldr	r4, [pc, #24]	; (27994 <_sbrk_r+0x1c>)
   2797c:	2300      	movs	r3, #0
   2797e:	4605      	mov	r5, r0
   27980:	4608      	mov	r0, r1
   27982:	6023      	str	r3, [r4, #0]
   27984:	f000 f812 	bl	279ac <_sbrk>
   27988:	1c43      	adds	r3, r0, #1
   2798a:	d102      	bne.n	27992 <_sbrk_r+0x1a>
   2798c:	6823      	ldr	r3, [r4, #0]
   2798e:	b103      	cbz	r3, 27992 <_sbrk_r+0x1a>
   27990:	602b      	str	r3, [r5, #0]
   27992:	bd38      	pop	{r3, r4, r5, pc}
   27994:	200053b0 	.word	0x200053b0

00027998 <strlen>:
   27998:	4603      	mov	r3, r0
   2799a:	f813 2b01 	ldrb.w	r2, [r3], #1
   2799e:	2a00      	cmp	r2, #0
   279a0:	d1fb      	bne.n	2799a <strlen+0x2>
   279a2:	1a18      	subs	r0, r3, r0
   279a4:	3801      	subs	r0, #1
   279a6:	4770      	bx	lr

000279a8 <__malloc_lock>:
   279a8:	4770      	bx	lr

000279aa <__malloc_unlock>:
   279aa:	4770      	bx	lr

000279ac <_sbrk>:
   279ac:	4a04      	ldr	r2, [pc, #16]	; (279c0 <_sbrk+0x14>)
   279ae:	4905      	ldr	r1, [pc, #20]	; (279c4 <_sbrk+0x18>)
   279b0:	6813      	ldr	r3, [r2, #0]
   279b2:	2b00      	cmp	r3, #0
   279b4:	bf08      	it	eq
   279b6:	460b      	moveq	r3, r1
   279b8:	4418      	add	r0, r3
   279ba:	6010      	str	r0, [r2, #0]
   279bc:	4618      	mov	r0, r3
   279be:	4770      	bx	lr
   279c0:	20005380 	.word	0x20005380
   279c4:	200053b8 	.word	0x200053b8

000279c8 <_init>:
   279c8:	e1a0c00d 	mov	ip, sp
   279cc:	e92ddff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
   279d0:	e24cb004 	sub	fp, ip, #4
   279d4:	e24bd028 	sub	sp, fp, #40	; 0x28
   279d8:	e89d6ff0 	ldm	sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, lr}
   279dc:	e12fff1e 	bx	lr

000279e0 <_fini>:
   279e0:	e1a0c00d 	mov	ip, sp
   279e4:	e92ddff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
   279e8:	e24cb004 	sub	fp, ip, #4
   279ec:	e24bd028 	sub	sp, fp, #40	; 0x28
   279f0:	e89d6ff0 	ldm	sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, lr}
   279f4:	e12fff1e 	bx	lr

000279f8 <_global_impure_ptr>:
   279f8:	20005004 65756c62 746f6f74 6c622f68     .P. bluetooth/bl
   27a08:	6f635f65 6e6f6d6d 0000632e 5479654b     e_common.c..KeyT
   27a18:	00006761 65756c62 746f6f74 64612f68     ag..bluetooth/ad
   27a28:	74726576 6e697369 00632e67 7774694c     vertising.c.Litw
   27a38:	4f202c6f 797a636a 206f6e7a 616a6f6d     o, Ojczyzno moja
   27a48:	6c492021 69432065 72742065 6162657a     ! Ile Cie trzeba
   27a58:	6e656320 00006369 00007854 6e657645      cenic..Tx..Even
   27a68:	00007374 ac2007b0 3c2016ca 7214e7b9     ts.... ... <...r
   27a78:	ac040000                                ....

00027a7c <sdh_req_observers>:
   27a7c:	00027b80 00027b80 00000008              .{...{......

00027a88 <sdh_state_observers>:
   27a88:	00027b80 00027b80 00000008              .{...{......

00027a94 <sdh_stack_observers>:
   27a94:	00027b70 00027b80 00000008 07021000     p{...{..........

00027aa4 <sdh_ble_observers>:
   27aa4:	00027b80 00027ba0 00000008 3566726e     .{...{......nrf5
   27ab4:	6b647332 2e34315f 2f302e30 706d6f63     2sdk_14.0.0/comp
   27ac4:	6e656e6f 732f7374 6474666f 63697665     onents/softdevic
   27ad4:	6f632f65 6e6f6d6d 66726e2f 6864735f     e/common/nrf_sdh
   27ae4:	656c625f 0000632e                       _ble.c..

00027aec <sdh_soc_observers>:
   27aec:	00027ba0 00027bb0 00000008 3566726e     .{...{......nrf5
   27afc:	6b647332 2e34315f 2f302e30 706d6f63     2sdk_14.0.0/comp
   27b0c:	6e656e6f 732f7374 6474666f 63697665     onents/softdevic
   27b1c:	6f632f65 6e6f6d6d 66726e2f 6864735f     e/common/nrf_sdh
   27b2c:	636f735f 0000632e 3566726e 6b647332     _soc.c..nrf52sdk
   27b3c:	2e34315f 2f302e30 706d6f63 6e656e6f     _14.0.0/componen
   27b4c:	622f7374 632f656c 6f6d6d6f 6c622f6e     ts/ble/common/bl
   27b5c:	6f635f65 735f6e6e 65746174 0000632e     e_conn_state.c..

00027b6c <__EH_FRAME_BEGIN__>:
   27b6c:	00000000                                ....


Build_Output/KeyTag.elf:     file format elf32-littlearm


Disassembly of section .text:

00023000 <__isr_vector>:
   23000:	20010000 	.word	0x20010000
   23004:	0002853d 	.word	0x0002853d
   23008:	0002857d 	.word	0x0002857d
   2300c:	0002857f 	.word	0x0002857f
   23010:	00028581 	.word	0x00028581
   23014:	00028583 	.word	0x00028583
   23018:	00028585 	.word	0x00028585
	...
   2302c:	00028587 	.word	0x00028587
   23030:	00028589 	.word	0x00028589
   23034:	00000000 	.word	0x00000000
   23038:	0002858b 	.word	0x0002858b
   2303c:	0002858d 	.word	0x0002858d
   23040:	000238ef 	.word	0x000238ef
   23044:	0002858f 	.word	0x0002858f
   23048:	0002858f 	.word	0x0002858f
   2304c:	0002858f 	.word	0x0002858f
   23050:	0002858f 	.word	0x0002858f
   23054:	000248c9 	.word	0x000248c9
   23058:	0002858f 	.word	0x0002858f
   2305c:	0002858f 	.word	0x0002858f
   23060:	0002858f 	.word	0x0002858f
   23064:	0002858f 	.word	0x0002858f
   23068:	0002858f 	.word	0x0002858f
   2306c:	0002858f 	.word	0x0002858f
   23070:	0002858f 	.word	0x0002858f
   23074:	0002858f 	.word	0x0002858f
   23078:	0002858f 	.word	0x0002858f
   2307c:	0002858f 	.word	0x0002858f
   23080:	0002858f 	.word	0x0002858f
   23084:	00024c69 	.word	0x00024c69
   23088:	0002858f 	.word	0x0002858f
   2308c:	0002858f 	.word	0x0002858f
   23090:	0002858f 	.word	0x0002858f
   23094:	0002858f 	.word	0x0002858f
   23098:	00026ff9 	.word	0x00026ff9
   2309c:	0002858f 	.word	0x0002858f
   230a0:	0002858f 	.word	0x0002858f
   230a4:	0002858f 	.word	0x0002858f
   230a8:	0002858f 	.word	0x0002858f
   230ac:	0002858f 	.word	0x0002858f
   230b0:	0002858f 	.word	0x0002858f
   230b4:	0002858f 	.word	0x0002858f
	...
   230c0:	0002858f 	.word	0x0002858f
   230c4:	0002858f 	.word	0x0002858f
   230c8:	0002858f 	.word	0x0002858f
   230cc:	0002858f 	.word	0x0002858f
   230d0:	00024d29 	.word	0x00024d29
   230d4:	0002858f 	.word	0x0002858f
   230d8:	0002858f 	.word	0x0002858f
	...

00023400 <__do_global_dtors_aux>:
   23400:	e59f3030 	ldr	r3, [pc, #48]	; 23438 <__do_global_dtors_aux+0x38>
   23404:	e5d32000 	ldrb	r2, [r3]
   23408:	e3520000 	cmp	r2, #0
   2340c:	112fff1e 	bxne	lr
   23410:	e92d4010 	push	{r4, lr}
   23414:	e1a04003 	mov	r4, r3
   23418:	e59f301c 	ldr	r3, [pc, #28]	; 2343c <__do_global_dtors_aux+0x3c>
   2341c:	e3530000 	cmp	r3, #0
   23420:	159f0018 	ldrne	r0, [pc, #24]	; 23440 <__do_global_dtors_aux+0x40>
   23424:	11a00000 	movne	r0, r0
   23428:	e3a03001 	mov	r3, #1
   2342c:	e5c43000 	strb	r3, [r4]
   23430:	e8bd4010 	pop	{r4, lr}
   23434:	e12fff1e 	bx	lr
   23438:	20005088 	.word	0x20005088
   2343c:	00000000 	.word	0x00000000
   23440:	0002b6b4 	.word	0x0002b6b4

00023444 <frame_dummy>:
   23444:	e59f301c 	ldr	r3, [pc, #28]	; 23468 <frame_dummy+0x24>
   23448:	e3530000 	cmp	r3, #0
   2344c:	012fff1e 	bxeq	lr
   23450:	e92d4010 	push	{r4, lr}
   23454:	e59f1010 	ldr	r1, [pc, #16]	; 2346c <frame_dummy+0x28>
   23458:	e59f0010 	ldr	r0, [pc, #16]	; 23470 <frame_dummy+0x2c>
   2345c:	e1a00000 	nop			; (mov r0, r0)
   23460:	e8bd4010 	pop	{r4, lr}
   23464:	e12fff1e 	bx	lr
   23468:	00000000 	.word	0x00000000
   2346c:	2000508c 	.word	0x2000508c
   23470:	0002b6b4 	.word	0x0002b6b4

00023474 <_mainCRTStartup>:
   23474:	e59f30e4 	ldr	r3, [pc, #228]	; 23560 <_mainCRTStartup+0xec>
   23478:	e3530000 	cmp	r3, #0
   2347c:	059f30d8 	ldreq	r3, [pc, #216]	; 2355c <_mainCRTStartup+0xe8>
   23480:	e1a0d003 	mov	sp, r3
   23484:	e10f2000 	mrs	r2, CPSR
   23488:	e312000f 	tst	r2, #15
   2348c:	0a000015 	beq	234e8 <_mainCRTStartup+0x74>
   23490:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
   23494:	e1a0d003 	mov	sp, r3
   23498:	e24daa01 	sub	sl, sp, #4096	; 0x1000
   2349c:	e1a0300a 	mov	r3, sl
   234a0:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
   234a4:	e1a0d003 	mov	sp, r3
   234a8:	e2433a01 	sub	r3, r3, #4096	; 0x1000
   234ac:	e321f0db 	msr	CPSR_c, #219	; 0xdb
   234b0:	e1a0d003 	mov	sp, r3
   234b4:	e2433a01 	sub	r3, r3, #4096	; 0x1000
   234b8:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
   234bc:	e1a0d003 	mov	sp, r3
   234c0:	e2433a02 	sub	r3, r3, #8192	; 0x2000
   234c4:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
   234c8:	e1a0d003 	mov	sp, r3
   234cc:	e2433902 	sub	r3, r3, #32768	; 0x8000
   234d0:	e3c330ff 	bic	r3, r3, #255	; 0xff
   234d4:	e3c33cff 	bic	r3, r3, #65280	; 0xff00
   234d8:	e5033004 	str	r3, [r3, #-4]
   234dc:	e9532000 	ldmdb	r3, {sp}^
   234e0:	e38220c0 	orr	r2, r2, #192	; 0xc0
   234e4:	e121f002 	msr	CPSR_c, r2
   234e8:	e243a801 	sub	sl, r3, #65536	; 0x10000
   234ec:	e3b01000 	movs	r1, #0
   234f0:	e1a0b001 	mov	fp, r1
   234f4:	e1a07001 	mov	r7, r1
   234f8:	e59f006c 	ldr	r0, [pc, #108]	; 2356c <_mainCRTStartup+0xf8>
   234fc:	e59f206c 	ldr	r2, [pc, #108]	; 23570 <_mainCRTStartup+0xfc>
   23500:	e0522000 	subs	r2, r2, r0
   23504:	fa000044 	blx	2361c <memset>
   23508:	e59f3054 	ldr	r3, [pc, #84]	; 23564 <_mainCRTStartup+0xf0>
   2350c:	e3530000 	cmp	r3, #0
   23510:	0a000001 	beq	2351c <_mainCRTStartup+0xa8>
   23514:	e1a0e00f 	mov	lr, pc
   23518:	e1a0f003 	mov	pc, r3
   2351c:	e59f3044 	ldr	r3, [pc, #68]	; 23568 <_mainCRTStartup+0xf4>
   23520:	e3530000 	cmp	r3, #0
   23524:	0a000001 	beq	23530 <_mainCRTStartup+0xbc>
   23528:	e1a0e00f 	mov	lr, pc
   2352c:	e1a0f003 	mov	pc, r3
   23530:	e3b00000 	movs	r0, #0
   23534:	e3b01000 	movs	r1, #0
   23538:	e1b04000 	movs	r4, r0
   2353c:	e1b05001 	movs	r5, r1
   23540:	e59f002c 	ldr	r0, [pc, #44]	; 23574 <_mainCRTStartup+0x100>
   23544:	fa00000b 	blx	23578 <atexit>
   23548:	fa000021 	blx	235d4 <__libc_init_array>
   2354c:	e1b00004 	movs	r0, r4
   23550:	e1b01005 	movs	r1, r5
   23554:	fa0000f2 	blx	23924 <main>
   23558:	fa000009 	blx	23584 <exit>
   2355c:	00080000 	.word	0x00080000
   23560:	20010000 	.word	0x20010000
	...
   2356c:	20005088 	.word	0x20005088
   23570:	20005494 	.word	0x20005494
   23574:	000235ad 	.word	0x000235ad

00023578 <atexit>:
   23578:	2300      	movs	r3, #0
   2357a:	4601      	mov	r1, r0
   2357c:	461a      	mov	r2, r3
   2357e:	4618      	mov	r0, r3
   23580:	f000 b854 	b.w	2362c <__register_exitproc>

00023584 <exit>:
   23584:	b508      	push	{r3, lr}
   23586:	4b07      	ldr	r3, [pc, #28]	; (235a4 <exit+0x20>)
   23588:	4604      	mov	r4, r0
   2358a:	b113      	cbz	r3, 23592 <exit+0xe>
   2358c:	2100      	movs	r1, #0
   2358e:	f000 f8b1 	bl	236f4 <__call_exitprocs>
   23592:	4b05      	ldr	r3, [pc, #20]	; (235a8 <exit+0x24>)
   23594:	6818      	ldr	r0, [r3, #0]
   23596:	6a83      	ldr	r3, [r0, #40]	; 0x28
   23598:	b103      	cbz	r3, 2359c <exit+0x18>
   2359a:	4798      	blx	r3
   2359c:	4620      	mov	r0, r4
   2359e:	f000 f917 	bl	237d0 <_exit>
   235a2:	bf00      	nop
   235a4:	000236f5 	.word	0x000236f5
   235a8:	0002b4e0 	.word	0x0002b4e0

000235ac <__libc_fini_array>:
   235ac:	b538      	push	{r3, r4, r5, lr}
   235ae:	4d07      	ldr	r5, [pc, #28]	; (235cc <__libc_fini_array+0x20>)
   235b0:	4c07      	ldr	r4, [pc, #28]	; (235d0 <__libc_fini_array+0x24>)
   235b2:	1b64      	subs	r4, r4, r5
   235b4:	10a4      	asrs	r4, r4, #2
   235b6:	b91c      	cbnz	r4, 235c0 <__libc_fini_array+0x14>
   235b8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   235bc:	f007 bf84 	b.w	2b4c8 <_fini>
   235c0:	3c01      	subs	r4, #1
   235c2:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   235c6:	4798      	blx	r3
   235c8:	e7f5      	b.n	235b6 <__libc_fini_array+0xa>
   235ca:	bf00      	nop
   235cc:	20005084 	.word	0x20005084
   235d0:	20005088 	.word	0x20005088

000235d4 <__libc_init_array>:
   235d4:	b570      	push	{r4, r5, r6, lr}
   235d6:	4e0d      	ldr	r6, [pc, #52]	; (2360c <__libc_init_array+0x38>)
   235d8:	4c0d      	ldr	r4, [pc, #52]	; (23610 <__libc_init_array+0x3c>)
   235da:	1ba4      	subs	r4, r4, r6
   235dc:	10a4      	asrs	r4, r4, #2
   235de:	2500      	movs	r5, #0
   235e0:	42a5      	cmp	r5, r4
   235e2:	d109      	bne.n	235f8 <__libc_init_array+0x24>
   235e4:	4e0b      	ldr	r6, [pc, #44]	; (23614 <__libc_init_array+0x40>)
   235e6:	4c0c      	ldr	r4, [pc, #48]	; (23618 <__libc_init_array+0x44>)
   235e8:	f007 ff62 	bl	2b4b0 <_init>
   235ec:	1ba4      	subs	r4, r4, r6
   235ee:	10a4      	asrs	r4, r4, #2
   235f0:	2500      	movs	r5, #0
   235f2:	42a5      	cmp	r5, r4
   235f4:	d105      	bne.n	23602 <__libc_init_array+0x2e>
   235f6:	bd70      	pop	{r4, r5, r6, pc}
   235f8:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
   235fc:	4798      	blx	r3
   235fe:	3501      	adds	r5, #1
   23600:	e7ee      	b.n	235e0 <__libc_init_array+0xc>
   23602:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
   23606:	4798      	blx	r3
   23608:	3501      	adds	r5, #1
   2360a:	e7f2      	b.n	235f2 <__libc_init_array+0x1e>
   2360c:	20005080 	.word	0x20005080
   23610:	20005080 	.word	0x20005080
   23614:	20005080 	.word	0x20005080
   23618:	20005084 	.word	0x20005084

0002361c <memset>:
   2361c:	4402      	add	r2, r0
   2361e:	4603      	mov	r3, r0
   23620:	4293      	cmp	r3, r2
   23622:	d100      	bne.n	23626 <memset+0xa>
   23624:	4770      	bx	lr
   23626:	f803 1b01 	strb.w	r1, [r3], #1
   2362a:	e7f9      	b.n	23620 <memset+0x4>

0002362c <__register_exitproc>:
   2362c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   23630:	4d2c      	ldr	r5, [pc, #176]	; (236e4 <__register_exitproc+0xb8>)
   23632:	682c      	ldr	r4, [r5, #0]
   23634:	4607      	mov	r7, r0
   23636:	460e      	mov	r6, r1
   23638:	4691      	mov	r9, r2
   2363a:	4698      	mov	r8, r3
   2363c:	b934      	cbnz	r4, 2364c <__register_exitproc+0x20>
   2363e:	4b2a      	ldr	r3, [pc, #168]	; (236e8 <__register_exitproc+0xbc>)
   23640:	4c2a      	ldr	r4, [pc, #168]	; (236ec <__register_exitproc+0xc0>)
   23642:	602c      	str	r4, [r5, #0]
   23644:	b113      	cbz	r3, 2364c <__register_exitproc+0x20>
   23646:	681b      	ldr	r3, [r3, #0]
   23648:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
   2364c:	6863      	ldr	r3, [r4, #4]
   2364e:	2b1f      	cmp	r3, #31
   23650:	dd3e      	ble.n	236d0 <__register_exitproc+0xa4>
   23652:	4b27      	ldr	r3, [pc, #156]	; (236f0 <__register_exitproc+0xc4>)
   23654:	b91b      	cbnz	r3, 2365e <__register_exitproc+0x32>
   23656:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2365a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   2365e:	208c      	movs	r0, #140	; 0x8c
   23660:	f007 fe36 	bl	2b2d0 <malloc>
   23664:	4604      	mov	r4, r0
   23666:	2800      	cmp	r0, #0
   23668:	d0f5      	beq.n	23656 <__register_exitproc+0x2a>
   2366a:	2300      	movs	r3, #0
   2366c:	682a      	ldr	r2, [r5, #0]
   2366e:	6002      	str	r2, [r0, #0]
   23670:	6043      	str	r3, [r0, #4]
   23672:	6028      	str	r0, [r5, #0]
   23674:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
   23678:	b30f      	cbz	r7, 236be <__register_exitproc+0x92>
   2367a:	f44f 7084 	mov.w	r0, #264	; 0x108
   2367e:	f007 fe27 	bl	2b2d0 <malloc>
   23682:	2800      	cmp	r0, #0
   23684:	d0e7      	beq.n	23656 <__register_exitproc+0x2a>
   23686:	2300      	movs	r3, #0
   23688:	f8c0 3100 	str.w	r3, [r0, #256]	; 0x100
   2368c:	f8c0 3104 	str.w	r3, [r0, #260]	; 0x104
   23690:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
   23694:	6862      	ldr	r2, [r4, #4]
   23696:	f840 9022 	str.w	r9, [r0, r2, lsl #2]
   2369a:	2301      	movs	r3, #1
   2369c:	4093      	lsls	r3, r2
   2369e:	eb00 0182 	add.w	r1, r0, r2, lsl #2
   236a2:	f8d0 2100 	ldr.w	r2, [r0, #256]	; 0x100
   236a6:	431a      	orrs	r2, r3
   236a8:	2f02      	cmp	r7, #2
   236aa:	f8c0 2100 	str.w	r2, [r0, #256]	; 0x100
   236ae:	f8c1 8080 	str.w	r8, [r1, #128]	; 0x80
   236b2:	bf02      	ittt	eq
   236b4:	f8d0 2104 	ldreq.w	r2, [r0, #260]	; 0x104
   236b8:	4313      	orreq	r3, r2
   236ba:	f8c0 3104 	streq.w	r3, [r0, #260]	; 0x104
   236be:	6863      	ldr	r3, [r4, #4]
   236c0:	1c5a      	adds	r2, r3, #1
   236c2:	3302      	adds	r3, #2
   236c4:	6062      	str	r2, [r4, #4]
   236c6:	2000      	movs	r0, #0
   236c8:	f844 6023 	str.w	r6, [r4, r3, lsl #2]
   236cc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   236d0:	2f00      	cmp	r7, #0
   236d2:	d0f4      	beq.n	236be <__register_exitproc+0x92>
   236d4:	f8d4 0088 	ldr.w	r0, [r4, #136]	; 0x88
   236d8:	2800      	cmp	r0, #0
   236da:	d1db      	bne.n	23694 <__register_exitproc+0x68>
   236dc:	4b04      	ldr	r3, [pc, #16]	; (236f0 <__register_exitproc+0xc4>)
   236de:	2b00      	cmp	r3, #0
   236e0:	d0b9      	beq.n	23656 <__register_exitproc+0x2a>
   236e2:	e7ca      	b.n	2367a <__register_exitproc+0x4e>
   236e4:	20005130 	.word	0x20005130
   236e8:	00000000 	.word	0x00000000
   236ec:	200050a4 	.word	0x200050a4
   236f0:	0002b2d1 	.word	0x0002b2d1

000236f4 <__call_exitprocs>:
   236f4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   236f8:	f8df a0d0 	ldr.w	sl, [pc, #208]	; 237cc <__call_exitprocs+0xd8>
   236fc:	9001      	str	r0, [sp, #4]
   236fe:	4689      	mov	r9, r1
   23700:	f8da 4000 	ldr.w	r4, [sl]
   23704:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 237cc <__call_exitprocs+0xd8>
   23708:	b914      	cbnz	r4, 23710 <__call_exitprocs+0x1c>
   2370a:	b003      	add	sp, #12
   2370c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   23710:	6865      	ldr	r5, [r4, #4]
   23712:	f8d4 6088 	ldr.w	r6, [r4, #136]	; 0x88
   23716:	1e6f      	subs	r7, r5, #1
   23718:	00ad      	lsls	r5, r5, #2
   2371a:	eb06 0b05 	add.w	fp, r6, r5
   2371e:	3504      	adds	r5, #4
   23720:	4425      	add	r5, r4
   23722:	2f00      	cmp	r7, #0
   23724:	da14      	bge.n	23750 <__call_exitprocs+0x5c>
   23726:	4b28      	ldr	r3, [pc, #160]	; (237c8 <__call_exitprocs+0xd4>)
   23728:	2b00      	cmp	r3, #0
   2372a:	d0ee      	beq.n	2370a <__call_exitprocs+0x16>
   2372c:	6862      	ldr	r2, [r4, #4]
   2372e:	6823      	ldr	r3, [r4, #0]
   23730:	2a00      	cmp	r2, #0
   23732:	d145      	bne.n	237c0 <__call_exitprocs+0xcc>
   23734:	2b00      	cmp	r3, #0
   23736:	d043      	beq.n	237c0 <__call_exitprocs+0xcc>
   23738:	f8c8 3000 	str.w	r3, [r8]
   2373c:	b116      	cbz	r6, 23744 <__call_exitprocs+0x50>
   2373e:	4630      	mov	r0, r6
   23740:	f007 fdce 	bl	2b2e0 <free>
   23744:	4620      	mov	r0, r4
   23746:	f007 fdcb 	bl	2b2e0 <free>
   2374a:	f8d8 4000 	ldr.w	r4, [r8]
   2374e:	e7db      	b.n	23708 <__call_exitprocs+0x14>
   23750:	f1b9 0f00 	cmp.w	r9, #0
   23754:	d009      	beq.n	2376a <__call_exitprocs+0x76>
   23756:	b926      	cbnz	r6, 23762 <__call_exitprocs+0x6e>
   23758:	3f01      	subs	r7, #1
   2375a:	f1ab 0b04 	sub.w	fp, fp, #4
   2375e:	3d04      	subs	r5, #4
   23760:	e7df      	b.n	23722 <__call_exitprocs+0x2e>
   23762:	f8db 207c 	ldr.w	r2, [fp, #124]	; 0x7c
   23766:	4591      	cmp	r9, r2
   23768:	d1f6      	bne.n	23758 <__call_exitprocs+0x64>
   2376a:	6861      	ldr	r1, [r4, #4]
   2376c:	682a      	ldr	r2, [r5, #0]
   2376e:	3901      	subs	r1, #1
   23770:	428f      	cmp	r7, r1
   23772:	bf16      	itet	ne
   23774:	2300      	movne	r3, #0
   23776:	6067      	streq	r7, [r4, #4]
   23778:	602b      	strne	r3, [r5, #0]
   2377a:	2a00      	cmp	r2, #0
   2377c:	d0ec      	beq.n	23758 <__call_exitprocs+0x64>
   2377e:	6863      	ldr	r3, [r4, #4]
   23780:	9300      	str	r3, [sp, #0]
   23782:	b136      	cbz	r6, 23792 <__call_exitprocs+0x9e>
   23784:	2301      	movs	r3, #1
   23786:	f8d6 0100 	ldr.w	r0, [r6, #256]	; 0x100
   2378a:	fa03 f107 	lsl.w	r1, r3, r7
   2378e:	4201      	tst	r1, r0
   23790:	d109      	bne.n	237a6 <__call_exitprocs+0xb2>
   23792:	4790      	blx	r2
   23794:	6862      	ldr	r2, [r4, #4]
   23796:	9b00      	ldr	r3, [sp, #0]
   23798:	4293      	cmp	r3, r2
   2379a:	d1b1      	bne.n	23700 <__call_exitprocs+0xc>
   2379c:	f8d8 2000 	ldr.w	r2, [r8]
   237a0:	4294      	cmp	r4, r2
   237a2:	d0d9      	beq.n	23758 <__call_exitprocs+0x64>
   237a4:	e7ac      	b.n	23700 <__call_exitprocs+0xc>
   237a6:	f8d6 0104 	ldr.w	r0, [r6, #260]	; 0x104
   237aa:	4201      	tst	r1, r0
   237ac:	d104      	bne.n	237b8 <__call_exitprocs+0xc4>
   237ae:	f85b 1c04 	ldr.w	r1, [fp, #-4]
   237b2:	9801      	ldr	r0, [sp, #4]
   237b4:	4790      	blx	r2
   237b6:	e7ed      	b.n	23794 <__call_exitprocs+0xa0>
   237b8:	f85b 0c04 	ldr.w	r0, [fp, #-4]
   237bc:	4790      	blx	r2
   237be:	e7e9      	b.n	23794 <__call_exitprocs+0xa0>
   237c0:	46a0      	mov	r8, r4
   237c2:	461c      	mov	r4, r3
   237c4:	e7a0      	b.n	23708 <__call_exitprocs+0x14>
   237c6:	bf00      	nop
   237c8:	0002b2e1 	.word	0x0002b2e1
   237cc:	20005130 	.word	0x20005130

000237d0 <_exit>:
   237d0:	e7fe      	b.n	237d0 <_exit>
   237d2:	bf00      	nop

000237d4 <nrf_gpio_pin_port_decode>:
 *
 * @return Pointer to port register set.
 *
 */
__STATIC_INLINE NRF_GPIO_Type * nrf_gpio_pin_port_decode(uint32_t * p_pin)
{
   237d4:	b480      	push	{r7}
   237d6:	b083      	sub	sp, #12
   237d8:	af00      	add	r7, sp, #0
   237da:	6078      	str	r0, [r7, #4]
    ASSERT(*p_pin < NUMBER_OF_PINS);
#if (GPIO_COUNT == 1)
    // The oldest definition case
    return NRF_GPIO;
   237dc:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
    {
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
        return NRF_P1;
    }
#endif
}
   237e0:	4618      	mov	r0, r3
   237e2:	370c      	adds	r7, #12
   237e4:	46bd      	mov	sp, r7
   237e6:	bc80      	pop	{r7}
   237e8:	4770      	bx	lr

000237ea <nrf_gpio_cfg>:
    nrf_gpio_pin_dir_t   dir,
    nrf_gpio_pin_input_t input,
    nrf_gpio_pin_pull_t  pull,
    nrf_gpio_pin_drive_t drive,
    nrf_gpio_pin_sense_t sense)
{
   237ea:	b580      	push	{r7, lr}
   237ec:	b084      	sub	sp, #16
   237ee:	af00      	add	r7, sp, #0
   237f0:	6078      	str	r0, [r7, #4]
   237f2:	4608      	mov	r0, r1
   237f4:	4611      	mov	r1, r2
   237f6:	461a      	mov	r2, r3
   237f8:	4603      	mov	r3, r0
   237fa:	70fb      	strb	r3, [r7, #3]
   237fc:	460b      	mov	r3, r1
   237fe:	70bb      	strb	r3, [r7, #2]
   23800:	4613      	mov	r3, r2
   23802:	707b      	strb	r3, [r7, #1]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   23804:	1d3b      	adds	r3, r7, #4
   23806:	4618      	mov	r0, r3
   23808:	f7ff ffe4 	bl	237d4 <nrf_gpio_pin_port_decode>
   2380c:	60f8      	str	r0, [r7, #12]

    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   2380e:	78fa      	ldrb	r2, [r7, #3]
                               | ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos)
   23810:	78bb      	ldrb	r3, [r7, #2]
   23812:	005b      	lsls	r3, r3, #1
   23814:	431a      	orrs	r2, r3
                               | ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)
   23816:	787b      	ldrb	r3, [r7, #1]
   23818:	009b      	lsls	r3, r3, #2
   2381a:	431a      	orrs	r2, r3
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
   2381c:	7e3b      	ldrb	r3, [r7, #24]
   2381e:	021b      	lsls	r3, r3, #8
   23820:	ea42 0103 	orr.w	r1, r2, r3
                               | ((uint32_t)sense << GPIO_PIN_CNF_SENSE_Pos);
   23824:	7f3b      	ldrb	r3, [r7, #28]
   23826:	041b      	lsls	r3, r3, #16
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   23828:	687a      	ldr	r2, [r7, #4]
                               | ((uint32_t)sense << GPIO_PIN_CNF_SENSE_Pos);
   2382a:	4319      	orrs	r1, r3
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   2382c:	68fb      	ldr	r3, [r7, #12]
   2382e:	f502 72e0 	add.w	r2, r2, #448	; 0x1c0
   23832:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
   23836:	bf00      	nop
   23838:	3710      	adds	r7, #16
   2383a:	46bd      	mov	sp, r7
   2383c:	bd80      	pop	{r7, pc}

0002383e <nrf_gpio_cfg_output>:


__STATIC_INLINE void nrf_gpio_cfg_output(uint32_t pin_number)
{
   2383e:	b580      	push	{r7, lr}
   23840:	b084      	sub	sp, #16
   23842:	af02      	add	r7, sp, #8
   23844:	6078      	str	r0, [r7, #4]
    nrf_gpio_cfg(
   23846:	2300      	movs	r3, #0
   23848:	9301      	str	r3, [sp, #4]
   2384a:	2300      	movs	r3, #0
   2384c:	9300      	str	r3, [sp, #0]
   2384e:	2300      	movs	r3, #0
   23850:	2201      	movs	r2, #1
   23852:	2101      	movs	r1, #1
   23854:	6878      	ldr	r0, [r7, #4]
   23856:	f7ff ffc8 	bl	237ea <nrf_gpio_cfg>
        NRF_GPIO_PIN_DIR_OUTPUT,
        NRF_GPIO_PIN_INPUT_DISCONNECT,
        NRF_GPIO_PIN_NOPULL,
        NRF_GPIO_PIN_S0S1,
        NRF_GPIO_PIN_NOSENSE);
}
   2385a:	bf00      	nop
   2385c:	3708      	adds	r7, #8
   2385e:	46bd      	mov	sp, r7
   23860:	bd80      	pop	{r7, pc}

00023862 <nrf_gpio_pin_set>:
    }
}


__STATIC_INLINE void nrf_gpio_pin_set(uint32_t pin_number)
{
   23862:	b580      	push	{r7, lr}
   23864:	b084      	sub	sp, #16
   23866:	af00      	add	r7, sp, #0
   23868:	6078      	str	r0, [r7, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   2386a:	1d3b      	adds	r3, r7, #4
   2386c:	4618      	mov	r0, r3
   2386e:	f7ff ffb1 	bl	237d4 <nrf_gpio_pin_port_decode>
   23872:	60f8      	str	r0, [r7, #12]

    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   23874:	687b      	ldr	r3, [r7, #4]
   23876:	2201      	movs	r2, #1
   23878:	fa02 f303 	lsl.w	r3, r2, r3
   2387c:	4619      	mov	r1, r3
   2387e:	68f8      	ldr	r0, [r7, #12]
   23880:	f000 f819 	bl	238b6 <nrf_gpio_port_out_set>
}
   23884:	bf00      	nop
   23886:	3710      	adds	r7, #16
   23888:	46bd      	mov	sp, r7
   2388a:	bd80      	pop	{r7, pc}

0002388c <nrf_gpio_pin_clear>:


__STATIC_INLINE void nrf_gpio_pin_clear(uint32_t pin_number)
{
   2388c:	b580      	push	{r7, lr}
   2388e:	b084      	sub	sp, #16
   23890:	af00      	add	r7, sp, #0
   23892:	6078      	str	r0, [r7, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   23894:	1d3b      	adds	r3, r7, #4
   23896:	4618      	mov	r0, r3
   23898:	f7ff ff9c 	bl	237d4 <nrf_gpio_pin_port_decode>
   2389c:	60f8      	str	r0, [r7, #12]

    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   2389e:	687b      	ldr	r3, [r7, #4]
   238a0:	2201      	movs	r2, #1
   238a2:	fa02 f303 	lsl.w	r3, r2, r3
   238a6:	4619      	mov	r1, r3
   238a8:	68f8      	ldr	r0, [r7, #12]
   238aa:	f000 f812 	bl	238d2 <nrf_gpio_port_out_clear>
}
   238ae:	bf00      	nop
   238b0:	3710      	adds	r7, #16
   238b2:	46bd      	mov	sp, r7
   238b4:	bd80      	pop	{r7, pc}

000238b6 <nrf_gpio_port_out_set>:
    p_reg->OUT = value;
}


__STATIC_INLINE void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask)
{
   238b6:	b480      	push	{r7}
   238b8:	b083      	sub	sp, #12
   238ba:	af00      	add	r7, sp, #0
   238bc:	6078      	str	r0, [r7, #4]
   238be:	6039      	str	r1, [r7, #0]
    p_reg->OUTSET = set_mask;
   238c0:	687b      	ldr	r3, [r7, #4]
   238c2:	683a      	ldr	r2, [r7, #0]
   238c4:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
}
   238c8:	bf00      	nop
   238ca:	370c      	adds	r7, #12
   238cc:	46bd      	mov	sp, r7
   238ce:	bc80      	pop	{r7}
   238d0:	4770      	bx	lr

000238d2 <nrf_gpio_port_out_clear>:


__STATIC_INLINE void nrf_gpio_port_out_clear(NRF_GPIO_Type * p_reg, uint32_t clr_mask)
{
   238d2:	b480      	push	{r7}
   238d4:	b083      	sub	sp, #12
   238d6:	af00      	add	r7, sp, #0
   238d8:	6078      	str	r0, [r7, #4]
   238da:	6039      	str	r1, [r7, #0]
    p_reg->OUTCLR = clr_mask;
   238dc:	687b      	ldr	r3, [r7, #4]
   238de:	683a      	ldr	r2, [r7, #0]
   238e0:	f8c3 250c 	str.w	r2, [r3, #1292]	; 0x50c
}
   238e4:	bf00      	nop
   238e6:	370c      	adds	r7, #12
   238e8:	46bd      	mov	sp, r7
   238ea:	bc80      	pop	{r7}
   238ec:	4770      	bx	lr

000238ee <POWER_CLOCK_IRQHandler>:

nrf_nvic_state_t nrf_nvic_state = {0};


void POWER_CLOCK_IRQHandler()
{
   238ee:	b580      	push	{r7, lr}
   238f0:	af00      	add	r7, sp, #0
	NRF_CLOCK->EVENTS_HFCLKSTARTED = 0;
   238f2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   238f6:	2200      	movs	r2, #0
   238f8:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
	nrf_gpio_cfg_output(20);
   238fc:	2014      	movs	r0, #20
   238fe:	f7ff ff9e 	bl	2383e <nrf_gpio_cfg_output>
	nrf_gpio_pin_clear(20);
   23902:	2014      	movs	r0, #20
   23904:	f7ff ffc2 	bl	2388c <nrf_gpio_pin_clear>
}
   23908:	bf00      	nop
   2390a:	bd80      	pop	{r7, pc}

0002390c <soc_evt_handler>:
 *
 * @param[in]   evt_id      SOC stack event id.
 * @param[in]   p_context   Unused.
 */
static void soc_evt_handler(uint32_t evt_id, void * p_context)
{
   2390c:	b580      	push	{r7, lr}
   2390e:	b082      	sub	sp, #8
   23910:	af00      	add	r7, sp, #0
   23912:	6078      	str	r0, [r7, #4]
   23914:	6039      	str	r1, [r7, #0]
    SD_flash_operation_callback(evt_id);
   23916:	6878      	ldr	r0, [r7, #4]
   23918:	f000 ff06 	bl	24728 <SD_flash_operation_callback>
}
   2391c:	bf00      	nop
   2391e:	3708      	adds	r7, #8
   23920:	46bd      	mov	sp, r7
   23922:	bd80      	pop	{r7, pc}

00023924 <main>:
	NVIC_SetPriorityGrouping(0);
}

__attribute__((optimize("O0")))
int main(void)
{
   23924:	b580      	push	{r7, lr}
   23926:	b082      	sub	sp, #8
   23928:	af00      	add	r7, sp, #0
#if SOFTDEVICE_ENABLED
    BleStackInit();
   2392a:	f001 fc7f 	bl	2522c <BleStackInit>
    RTCInit(NRF_RTC1);
   2392e:	4834      	ldr	r0, [pc, #208]	; (23a00 <main+0xdc>)
   23930:	f001 fa96 	bl	24e60 <RTCInit>

	GapParamsInit();
   23934:	f001 fc18 	bl	25168 <GapParamsInit>
	GattInit();
   23938:	f001 fc5e 	bl	251f8 <GattInit>
//	ConnParamsInit();
	ServicesInit();
   2393c:	f001 fcb0 	bl	252a0 <ServicesInit>
	AdvertisingInit();
   23940:	f001 fdea 	bl	25518 <AdvertisingInit>
//	SystickInit();


	nrf_gpio_cfg_output(17);
   23944:	2011      	movs	r0, #17
   23946:	f7ff ff7a 	bl	2383e <nrf_gpio_cfg_output>
	nrf_gpio_pin_set(17);
   2394a:	2011      	movs	r0, #17
   2394c:	f7ff ff89 	bl	23862 <nrf_gpio_pin_set>

	nrf_gpio_cfg_output(BLUE_LED);
   23950:	2010      	movs	r0, #16
   23952:	f7ff ff74 	bl	2383e <nrf_gpio_cfg_output>
	nrf_gpio_cfg_output(GREEN_LED);
   23956:	200f      	movs	r0, #15
   23958:	f7ff ff71 	bl	2383e <nrf_gpio_cfg_output>
    nrf_gpio_cfg_output(RED_LED);
   2395c:	200e      	movs	r0, #14
   2395e:	f7ff ff6e 	bl	2383e <nrf_gpio_cfg_output>

    nrf_gpio_pin_set(BLUE_LED);
   23962:	2010      	movs	r0, #16
   23964:	f7ff ff7d 	bl	23862 <nrf_gpio_pin_set>
    nrf_gpio_pin_set(GREEN_LED);
   23968:	200f      	movs	r0, #15
   2396a:	f7ff ff7a 	bl	23862 <nrf_gpio_pin_set>
    nrf_gpio_pin_clear(RED_LED);
   2396e:	200e      	movs	r0, #14
   23970:	f7ff ff8c 	bl	2388c <nrf_gpio_pin_clear>

    // Check if the Main Key exists
    if (!CryptoCheckMainKey())
   23974:	f000 fb81 	bl	2407a <CryptoCheckMainKey>
   23978:	4603      	mov	r3, r0
   2397a:	2b00      	cmp	r3, #0
   2397c:	d12b      	bne.n	239d6 <main+0xb2>
    {
        CryptoGenerateAndStoreDeactivationCommandKey();
   2397e:	f000 fb9f 	bl	240c0 <CryptoGenerateAndStoreDeactivationCommandKey>
        uint32_t keyPart = 0xDEADBEEF;
   23982:	4b20      	ldr	r3, [pc, #128]	; (23a04 <main+0xe0>)
   23984:	607b      	str	r3, [r7, #4]
        memcpy(mainEncryptionKey, &keyPart, sizeof(keyPart));
   23986:	1d3b      	adds	r3, r7, #4
   23988:	2204      	movs	r2, #4
   2398a:	4619      	mov	r1, r3
   2398c:	481e      	ldr	r0, [pc, #120]	; (23a08 <main+0xe4>)
   2398e:	f007 fcaf 	bl	2b2f0 <memcpy>
        keyPart = 0xABBAABBA;
   23992:	4b1e      	ldr	r3, [pc, #120]	; (23a0c <main+0xe8>)
   23994:	607b      	str	r3, [r7, #4]
        memcpy(mainEncryptionKey + 4, &keyPart, sizeof(keyPart));
   23996:	481e      	ldr	r0, [pc, #120]	; (23a10 <main+0xec>)
   23998:	1d3b      	adds	r3, r7, #4
   2399a:	2204      	movs	r2, #4
   2399c:	4619      	mov	r1, r3
   2399e:	f007 fca7 	bl	2b2f0 <memcpy>
        keyPart = 0xBAABBAAB;
   239a2:	4b1c      	ldr	r3, [pc, #112]	; (23a14 <main+0xf0>)
   239a4:	607b      	str	r3, [r7, #4]
        memcpy(mainEncryptionKey + 8, &keyPart, sizeof(keyPart));
   239a6:	481c      	ldr	r0, [pc, #112]	; (23a18 <main+0xf4>)
   239a8:	1d3b      	adds	r3, r7, #4
   239aa:	2204      	movs	r2, #4
   239ac:	4619      	mov	r1, r3
   239ae:	f007 fc9f 	bl	2b2f0 <memcpy>
        keyPart = 0xDEADFEED;
   239b2:	4b1a      	ldr	r3, [pc, #104]	; (23a1c <main+0xf8>)
   239b4:	607b      	str	r3, [r7, #4]
        memcpy(mainEncryptionKey + 12, &keyPart, sizeof(keyPart));
   239b6:	481a      	ldr	r0, [pc, #104]	; (23a20 <main+0xfc>)
   239b8:	1d3b      	adds	r3, r7, #4
   239ba:	2204      	movs	r2, #4
   239bc:	4619      	mov	r1, r3
   239be:	f007 fc97 	bl	2b2f0 <memcpy>

        IntFlashUpdatePage(mainEncryptionKey, CRYPTO_KEY_SIZE, CRYPTO_MAIN_KEY_ADDRESS);
   239c2:	f44f 22f0 	mov.w	r2, #491520	; 0x78000
   239c6:	2110      	movs	r1, #16
   239c8:	480f      	ldr	r0, [pc, #60]	; (23a08 <main+0xe4>)
   239ca:	f000 fc79 	bl	242c0 <IntFlashUpdatePage>
//        }

//        IntFlashUpdatePage(mainEncryptionKey, receivedDataSize, CRYPTO_MAIN_KEY_ADDRESS);

//        NfcDisable();
        nfcInitState = E_INITIALIZED;
   239ce:	4b15      	ldr	r3, [pc, #84]	; (23a24 <main+0x100>)
   239d0:	2206      	movs	r2, #6
   239d2:	701a      	strb	r2, [r3, #0]
   239d4:	e00d      	b.n	239f2 <main+0xce>
    }
    else
    {
        memcpy(mainEncryptionKey, CRYPTO_MAIN_KEY_ADDRESS, sizeof(mainEncryptionKey));
   239d6:	2210      	movs	r2, #16
   239d8:	f44f 21f0 	mov.w	r1, #491520	; 0x78000
   239dc:	480a      	ldr	r0, [pc, #40]	; (23a08 <main+0xe4>)
   239de:	f007 fc87 	bl	2b2f0 <memcpy>
        memcpy(alarmDeactivationCmd, KEY_TAG_ALARM_DISARMING_COMMAND_ADDRESS, sizeof(alarmDeactivationCmd));
   239e2:	2210      	movs	r2, #16
   239e4:	4910      	ldr	r1, [pc, #64]	; (23a28 <main+0x104>)
   239e6:	4811      	ldr	r0, [pc, #68]	; (23a2c <main+0x108>)
   239e8:	f007 fc82 	bl	2b2f0 <memcpy>
        nfcInitState = E_INITIALIZED;
   239ec:	4b0d      	ldr	r3, [pc, #52]	; (23a24 <main+0x100>)
   239ee:	2206      	movs	r2, #6
   239f0:	701a      	strb	r2, [r3, #0]
    }
#endif

    AdvertisingStart();
   239f2:	f001 fdd5 	bl	255a0 <AdvertisingStart>
  \details Wait For Event is a hint instruction that permits the processor to enter
    a low-power state until one of a number of events occurs.
 */
__attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
{
  __ASM volatile ("wfe");
   239f6:	bf20      	wfe

    while(1)
    {
//        sd_app_evt_wait();
        __WFE();
        BleExecutePendingRequests();
   239f8:	f001 ffe6 	bl	259c8 <BleExecutePendingRequests>
        __WFE();
   239fc:	e7fb      	b.n	239f6 <main+0xd2>
   239fe:	bf00      	nop
   23a00:	40011000 	.word	0x40011000
   23a04:	deadbeef 	.word	0xdeadbeef
   23a08:	20005410 	.word	0x20005410
   23a0c:	abbaabba 	.word	0xabbaabba
   23a10:	20005414 	.word	0x20005414
   23a14:	baabbaab 	.word	0xbaabbaab
   23a18:	20005418 	.word	0x20005418
   23a1c:	deadfeed 	.word	0xdeadfeed
   23a20:	2000541c 	.word	0x2000541c
   23a24:	200051d0 	.word	0x200051d0
   23a28:	00078010 	.word	0x00078010
   23a2c:	20005420 	.word	0x20005420

00023a30 <SystemCoreClockUpdate>:
#elif defined ( __GNUC__ )
    uint32_t SystemCoreClock __attribute__((used)) = __SYSTEM_CLOCK_64M;
#endif

void SystemCoreClockUpdate(void)
{
   23a30:	b480      	push	{r7}
   23a32:	af00      	add	r7, sp, #0
    SystemCoreClock = __SYSTEM_CLOCK_64M;
   23a34:	4b03      	ldr	r3, [pc, #12]	; (23a44 <SystemCoreClockUpdate+0x14>)
   23a36:	4a04      	ldr	r2, [pc, #16]	; (23a48 <SystemCoreClockUpdate+0x18>)
   23a38:	601a      	str	r2, [r3, #0]
}
   23a3a:	bf00      	nop
   23a3c:	46bd      	mov	sp, r7
   23a3e:	bc80      	pop	{r7}
   23a40:	4770      	bx	lr
   23a42:	bf00      	nop
   23a44:	20005064 	.word	0x20005064
   23a48:	03d09000 	.word	0x03d09000

00023a4c <SystemInit>:

void SystemInit(void)
{
   23a4c:	b580      	push	{r7, lr}
   23a4e:	af00      	add	r7, sp, #0
    /* Workaround for Errata 16 "System: RAM may be corrupt on wakeup from CPU IDLE" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/ */
    if (errata_16()){
   23a50:	f000 f8f0 	bl	23c34 <errata_16>
   23a54:	4603      	mov	r3, r0
   23a56:	2b00      	cmp	r3, #0
   23a58:	d002      	beq.n	23a60 <SystemInit+0x14>
        *(volatile uint32_t *)0x4007C074 = 3131961357ul;
   23a5a:	4b69      	ldr	r3, [pc, #420]	; (23c00 <SystemInit+0x1b4>)
   23a5c:	4a69      	ldr	r2, [pc, #420]	; (23c04 <SystemInit+0x1b8>)
   23a5e:	601a      	str	r2, [r3, #0]
    }

    /* Workaround for Errata 31 "CLOCK: Calibration values are not correctly loaded from FICR at reset" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/ */
    if (errata_31()){
   23a60:	f000 f908 	bl	23c74 <errata_31>
   23a64:	4603      	mov	r3, r0
   23a66:	2b00      	cmp	r3, #0
   23a68:	d006      	beq.n	23a78 <SystemInit+0x2c>
        *(volatile uint32_t *)0x4000053C = ((*(volatile uint32_t *)0x10000244) & 0x0000E000) >> 13;
   23a6a:	4b67      	ldr	r3, [pc, #412]	; (23c08 <SystemInit+0x1bc>)
   23a6c:	681b      	ldr	r3, [r3, #0]
   23a6e:	0b5b      	lsrs	r3, r3, #13
   23a70:	4a66      	ldr	r2, [pc, #408]	; (23c0c <SystemInit+0x1c0>)
   23a72:	f003 0307 	and.w	r3, r3, #7
   23a76:	6013      	str	r3, [r2, #0]
    }

    /* Workaround for Errata 32 "DIF: Debug session automatically enables TracePort pins" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/ */
    if (errata_32()){
   23a78:	f000 f92c 	bl	23cd4 <errata_32>
   23a7c:	4603      	mov	r3, r0
   23a7e:	2b00      	cmp	r3, #0
   23a80:	d005      	beq.n	23a8e <SystemInit+0x42>
        CoreDebug->DEMCR &= ~CoreDebug_DEMCR_TRCENA_Msk;
   23a82:	4b63      	ldr	r3, [pc, #396]	; (23c10 <SystemInit+0x1c4>)
   23a84:	68db      	ldr	r3, [r3, #12]
   23a86:	4a62      	ldr	r2, [pc, #392]	; (23c10 <SystemInit+0x1c4>)
   23a88:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
   23a8c:	60d3      	str	r3, [r2, #12]
    }

    /* Workaround for Errata 36 "CLOCK: Some registers are not reset when expected" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/  */
    if (errata_36()){
   23a8e:	f000 f941 	bl	23d14 <errata_36>
   23a92:	4603      	mov	r3, r0
   23a94:	2b00      	cmp	r3, #0
   23a96:	d00e      	beq.n	23ab6 <SystemInit+0x6a>
        NRF_CLOCK->EVENTS_DONE = 0;
   23a98:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   23a9c:	2200      	movs	r2, #0
   23a9e:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
        NRF_CLOCK->EVENTS_CTTO = 0;
   23aa2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   23aa6:	2200      	movs	r2, #0
   23aa8:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
        NRF_CLOCK->CTIV = 0;
   23aac:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   23ab0:	2200      	movs	r2, #0
   23ab2:	f8c3 2538 	str.w	r2, [r3, #1336]	; 0x538
    }

    /* Workaround for Errata 37 "RADIO: Encryption engine is slow by default" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/  */
    if (errata_37()){
   23ab6:	f000 f95d 	bl	23d74 <errata_37>
   23aba:	4603      	mov	r3, r0
   23abc:	2b00      	cmp	r3, #0
   23abe:	d002      	beq.n	23ac6 <SystemInit+0x7a>
        *(volatile uint32_t *)0x400005A0 = 0x3;
   23ac0:	4b54      	ldr	r3, [pc, #336]	; (23c14 <SystemInit+0x1c8>)
   23ac2:	2203      	movs	r2, #3
   23ac4:	601a      	str	r2, [r3, #0]
    }

    /* Workaround for Errata 57 "NFCT: NFC Modulation amplitude" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/  */
    if (errata_57()){
   23ac6:	f000 f975 	bl	23db4 <errata_57>
   23aca:	4603      	mov	r3, r0
   23acc:	2b00      	cmp	r3, #0
   23ace:	d00b      	beq.n	23ae8 <SystemInit+0x9c>
        *(volatile uint32_t *)0x40005610 = 0x00000005;
   23ad0:	4b51      	ldr	r3, [pc, #324]	; (23c18 <SystemInit+0x1cc>)
   23ad2:	2205      	movs	r2, #5
   23ad4:	601a      	str	r2, [r3, #0]
        *(volatile uint32_t *)0x40005688 = 0x00000001;
   23ad6:	4b51      	ldr	r3, [pc, #324]	; (23c1c <SystemInit+0x1d0>)
   23ad8:	2201      	movs	r2, #1
   23ada:	601a      	str	r2, [r3, #0]
        *(volatile uint32_t *)0x40005618 = 0x00000000;
   23adc:	4b50      	ldr	r3, [pc, #320]	; (23c20 <SystemInit+0x1d4>)
   23ade:	2200      	movs	r2, #0
   23ae0:	601a      	str	r2, [r3, #0]
        *(volatile uint32_t *)0x40005614 = 0x0000003F;
   23ae2:	4b50      	ldr	r3, [pc, #320]	; (23c24 <SystemInit+0x1d8>)
   23ae4:	223f      	movs	r2, #63	; 0x3f
   23ae6:	601a      	str	r2, [r3, #0]
    }

    /* Workaround for Errata 66 "TEMP: Linearity specification not met with default settings" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/  */
    if (errata_66()){
   23ae8:	f000 f984 	bl	23df4 <errata_66>
   23aec:	4603      	mov	r3, r0
   23aee:	2b00      	cmp	r3, #0
   23af0:	d076      	beq.n	23be0 <SystemInit+0x194>
        NRF_TEMP->A0 = NRF_FICR->TEMP.A0;
   23af2:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23af6:	4a4c      	ldr	r2, [pc, #304]	; (23c28 <SystemInit+0x1dc>)
   23af8:	f8d3 3404 	ldr.w	r3, [r3, #1028]	; 0x404
   23afc:	f8c2 3520 	str.w	r3, [r2, #1312]	; 0x520
        NRF_TEMP->A1 = NRF_FICR->TEMP.A1;
   23b00:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23b04:	4a48      	ldr	r2, [pc, #288]	; (23c28 <SystemInit+0x1dc>)
   23b06:	f8d3 3408 	ldr.w	r3, [r3, #1032]	; 0x408
   23b0a:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
        NRF_TEMP->A2 = NRF_FICR->TEMP.A2;
   23b0e:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23b12:	4a45      	ldr	r2, [pc, #276]	; (23c28 <SystemInit+0x1dc>)
   23b14:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
   23b18:	f8c2 3528 	str.w	r3, [r2, #1320]	; 0x528
        NRF_TEMP->A3 = NRF_FICR->TEMP.A3;
   23b1c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23b20:	4a41      	ldr	r2, [pc, #260]	; (23c28 <SystemInit+0x1dc>)
   23b22:	f8d3 3410 	ldr.w	r3, [r3, #1040]	; 0x410
   23b26:	f8c2 352c 	str.w	r3, [r2, #1324]	; 0x52c
        NRF_TEMP->A4 = NRF_FICR->TEMP.A4;
   23b2a:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23b2e:	4a3e      	ldr	r2, [pc, #248]	; (23c28 <SystemInit+0x1dc>)
   23b30:	f8d3 3414 	ldr.w	r3, [r3, #1044]	; 0x414
   23b34:	f8c2 3530 	str.w	r3, [r2, #1328]	; 0x530
        NRF_TEMP->A5 = NRF_FICR->TEMP.A5;
   23b38:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23b3c:	4a3a      	ldr	r2, [pc, #232]	; (23c28 <SystemInit+0x1dc>)
   23b3e:	f8d3 3418 	ldr.w	r3, [r3, #1048]	; 0x418
   23b42:	f8c2 3534 	str.w	r3, [r2, #1332]	; 0x534
        NRF_TEMP->B0 = NRF_FICR->TEMP.B0;
   23b46:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23b4a:	4a37      	ldr	r2, [pc, #220]	; (23c28 <SystemInit+0x1dc>)
   23b4c:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
   23b50:	f8c2 3540 	str.w	r3, [r2, #1344]	; 0x540
        NRF_TEMP->B1 = NRF_FICR->TEMP.B1;
   23b54:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23b58:	4a33      	ldr	r2, [pc, #204]	; (23c28 <SystemInit+0x1dc>)
   23b5a:	f8d3 3420 	ldr.w	r3, [r3, #1056]	; 0x420
   23b5e:	f8c2 3544 	str.w	r3, [r2, #1348]	; 0x544
        NRF_TEMP->B2 = NRF_FICR->TEMP.B2;
   23b62:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23b66:	4a30      	ldr	r2, [pc, #192]	; (23c28 <SystemInit+0x1dc>)
   23b68:	f8d3 3424 	ldr.w	r3, [r3, #1060]	; 0x424
   23b6c:	f8c2 3548 	str.w	r3, [r2, #1352]	; 0x548
        NRF_TEMP->B3 = NRF_FICR->TEMP.B3;
   23b70:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23b74:	4a2c      	ldr	r2, [pc, #176]	; (23c28 <SystemInit+0x1dc>)
   23b76:	f8d3 3428 	ldr.w	r3, [r3, #1064]	; 0x428
   23b7a:	f8c2 354c 	str.w	r3, [r2, #1356]	; 0x54c
        NRF_TEMP->B4 = NRF_FICR->TEMP.B4;
   23b7e:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23b82:	4a29      	ldr	r2, [pc, #164]	; (23c28 <SystemInit+0x1dc>)
   23b84:	f8d3 342c 	ldr.w	r3, [r3, #1068]	; 0x42c
   23b88:	f8c2 3550 	str.w	r3, [r2, #1360]	; 0x550
        NRF_TEMP->B5 = NRF_FICR->TEMP.B5;
   23b8c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23b90:	4a25      	ldr	r2, [pc, #148]	; (23c28 <SystemInit+0x1dc>)
   23b92:	f8d3 3430 	ldr.w	r3, [r3, #1072]	; 0x430
   23b96:	f8c2 3554 	str.w	r3, [r2, #1364]	; 0x554
        NRF_TEMP->T0 = NRF_FICR->TEMP.T0;
   23b9a:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23b9e:	4a22      	ldr	r2, [pc, #136]	; (23c28 <SystemInit+0x1dc>)
   23ba0:	f8d3 3434 	ldr.w	r3, [r3, #1076]	; 0x434
   23ba4:	f8c2 3560 	str.w	r3, [r2, #1376]	; 0x560
        NRF_TEMP->T1 = NRF_FICR->TEMP.T1;
   23ba8:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23bac:	4a1e      	ldr	r2, [pc, #120]	; (23c28 <SystemInit+0x1dc>)
   23bae:	f8d3 3438 	ldr.w	r3, [r3, #1080]	; 0x438
   23bb2:	f8c2 3564 	str.w	r3, [r2, #1380]	; 0x564
        NRF_TEMP->T2 = NRF_FICR->TEMP.T2;
   23bb6:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23bba:	4a1b      	ldr	r2, [pc, #108]	; (23c28 <SystemInit+0x1dc>)
   23bbc:	f8d3 343c 	ldr.w	r3, [r3, #1084]	; 0x43c
   23bc0:	f8c2 3568 	str.w	r3, [r2, #1384]	; 0x568
        NRF_TEMP->T3 = NRF_FICR->TEMP.T3;
   23bc4:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23bc8:	4a17      	ldr	r2, [pc, #92]	; (23c28 <SystemInit+0x1dc>)
   23bca:	f8d3 3440 	ldr.w	r3, [r3, #1088]	; 0x440
   23bce:	f8c2 356c 	str.w	r3, [r2, #1388]	; 0x56c
        NRF_TEMP->T4 = NRF_FICR->TEMP.T4;
   23bd2:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   23bd6:	4a14      	ldr	r2, [pc, #80]	; (23c28 <SystemInit+0x1dc>)
   23bd8:	f8d3 3444 	ldr.w	r3, [r3, #1092]	; 0x444
   23bdc:	f8c2 3570 	str.w	r3, [r2, #1392]	; 0x570
    }

    /* Workaround for Errata 108 "RAM: RAM content cannot be trusted upon waking up from System ON Idle or System OFF mode" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/  */
    if (errata_108()){
   23be0:	f000 f928 	bl	23e34 <errata_108>
   23be4:	4603      	mov	r3, r0
   23be6:	2b00      	cmp	r3, #0
   23be8:	d005      	beq.n	23bf6 <SystemInit+0x1aa>
        *(volatile uint32_t *)0x40000EE4 = *(volatile uint32_t *)0x10000258 & 0x0000004F;
   23bea:	4b10      	ldr	r3, [pc, #64]	; (23c2c <SystemInit+0x1e0>)
   23bec:	681b      	ldr	r3, [r3, #0]
   23bee:	4a10      	ldr	r2, [pc, #64]	; (23c30 <SystemInit+0x1e4>)
   23bf0:	f003 034f 	and.w	r3, r3, #79	; 0x4f
   23bf4:	6013      	str	r3, [r2, #0]
        NRF_P0->PIN_CNF[16] = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
        NRF_P0->PIN_CNF[18] = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
        NRF_P0->PIN_CNF[20] = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
    #endif

    SystemCoreClockUpdate();
   23bf6:	f7ff ff1b 	bl	23a30 <SystemCoreClockUpdate>
}
   23bfa:	bf00      	nop
   23bfc:	bd80      	pop	{r7, pc}
   23bfe:	bf00      	nop
   23c00:	4007c074 	.word	0x4007c074
   23c04:	baadf00d 	.word	0xbaadf00d
   23c08:	10000244 	.word	0x10000244
   23c0c:	4000053c 	.word	0x4000053c
   23c10:	e000edf0 	.word	0xe000edf0
   23c14:	400005a0 	.word	0x400005a0
   23c18:	40005610 	.word	0x40005610
   23c1c:	40005688 	.word	0x40005688
   23c20:	40005618 	.word	0x40005618
   23c24:	40005614 	.word	0x40005614
   23c28:	4000c000 	.word	0x4000c000
   23c2c:	10000258 	.word	0x10000258
   23c30:	40000ee4 	.word	0x40000ee4

00023c34 <errata_16>:


static bool errata_16(void)
{
   23c34:	b480      	push	{r7}
   23c36:	af00      	add	r7, sp, #0
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
   23c38:	4b0b      	ldr	r3, [pc, #44]	; (23c68 <errata_16+0x34>)
   23c3a:	681b      	ldr	r3, [r3, #0]
   23c3c:	b2db      	uxtb	r3, r3
   23c3e:	2b06      	cmp	r3, #6
   23c40:	d10d      	bne.n	23c5e <errata_16+0x2a>
   23c42:	4b0a      	ldr	r3, [pc, #40]	; (23c6c <errata_16+0x38>)
   23c44:	681b      	ldr	r3, [r3, #0]
   23c46:	f003 030f 	and.w	r3, r3, #15
   23c4a:	2b00      	cmp	r3, #0
   23c4c:	d107      	bne.n	23c5e <errata_16+0x2a>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
   23c4e:	4b08      	ldr	r3, [pc, #32]	; (23c70 <errata_16+0x3c>)
   23c50:	681b      	ldr	r3, [r3, #0]
   23c52:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   23c56:	2b30      	cmp	r3, #48	; 0x30
   23c58:	d101      	bne.n	23c5e <errata_16+0x2a>
            return true;
   23c5a:	2301      	movs	r3, #1
   23c5c:	e000      	b.n	23c60 <errata_16+0x2c>
        }
    }

    return false;
   23c5e:	2300      	movs	r3, #0
}
   23c60:	4618      	mov	r0, r3
   23c62:	46bd      	mov	sp, r7
   23c64:	bc80      	pop	{r7}
   23c66:	4770      	bx	lr
   23c68:	f0000fe0 	.word	0xf0000fe0
   23c6c:	f0000fe4 	.word	0xf0000fe4
   23c70:	f0000fe8 	.word	0xf0000fe8

00023c74 <errata_31>:

static bool errata_31(void)
{
   23c74:	b480      	push	{r7}
   23c76:	af00      	add	r7, sp, #0
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
   23c78:	4b13      	ldr	r3, [pc, #76]	; (23cc8 <errata_31+0x54>)
   23c7a:	681b      	ldr	r3, [r3, #0]
   23c7c:	b2db      	uxtb	r3, r3
   23c7e:	2b06      	cmp	r3, #6
   23c80:	d11d      	bne.n	23cbe <errata_31+0x4a>
   23c82:	4b12      	ldr	r3, [pc, #72]	; (23ccc <errata_31+0x58>)
   23c84:	681b      	ldr	r3, [r3, #0]
   23c86:	f003 030f 	and.w	r3, r3, #15
   23c8a:	2b00      	cmp	r3, #0
   23c8c:	d117      	bne.n	23cbe <errata_31+0x4a>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
   23c8e:	4b10      	ldr	r3, [pc, #64]	; (23cd0 <errata_31+0x5c>)
   23c90:	681b      	ldr	r3, [r3, #0]
   23c92:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   23c96:	2b30      	cmp	r3, #48	; 0x30
   23c98:	d101      	bne.n	23c9e <errata_31+0x2a>
            return true;
   23c9a:	2301      	movs	r3, #1
   23c9c:	e010      	b.n	23cc0 <errata_31+0x4c>
        }
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x40){
   23c9e:	4b0c      	ldr	r3, [pc, #48]	; (23cd0 <errata_31+0x5c>)
   23ca0:	681b      	ldr	r3, [r3, #0]
   23ca2:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   23ca6:	2b40      	cmp	r3, #64	; 0x40
   23ca8:	d101      	bne.n	23cae <errata_31+0x3a>
            return true;
   23caa:	2301      	movs	r3, #1
   23cac:	e008      	b.n	23cc0 <errata_31+0x4c>
        }
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x50){
   23cae:	4b08      	ldr	r3, [pc, #32]	; (23cd0 <errata_31+0x5c>)
   23cb0:	681b      	ldr	r3, [r3, #0]
   23cb2:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   23cb6:	2b50      	cmp	r3, #80	; 0x50
   23cb8:	d101      	bne.n	23cbe <errata_31+0x4a>
            return true;
   23cba:	2301      	movs	r3, #1
   23cbc:	e000      	b.n	23cc0 <errata_31+0x4c>
        }
    }

    return false;
   23cbe:	2300      	movs	r3, #0
}
   23cc0:	4618      	mov	r0, r3
   23cc2:	46bd      	mov	sp, r7
   23cc4:	bc80      	pop	{r7}
   23cc6:	4770      	bx	lr
   23cc8:	f0000fe0 	.word	0xf0000fe0
   23ccc:	f0000fe4 	.word	0xf0000fe4
   23cd0:	f0000fe8 	.word	0xf0000fe8

00023cd4 <errata_32>:

static bool errata_32(void)
{
   23cd4:	b480      	push	{r7}
   23cd6:	af00      	add	r7, sp, #0
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
   23cd8:	4b0b      	ldr	r3, [pc, #44]	; (23d08 <errata_32+0x34>)
   23cda:	681b      	ldr	r3, [r3, #0]
   23cdc:	b2db      	uxtb	r3, r3
   23cde:	2b06      	cmp	r3, #6
   23ce0:	d10d      	bne.n	23cfe <errata_32+0x2a>
   23ce2:	4b0a      	ldr	r3, [pc, #40]	; (23d0c <errata_32+0x38>)
   23ce4:	681b      	ldr	r3, [r3, #0]
   23ce6:	f003 030f 	and.w	r3, r3, #15
   23cea:	2b00      	cmp	r3, #0
   23cec:	d107      	bne.n	23cfe <errata_32+0x2a>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
   23cee:	4b08      	ldr	r3, [pc, #32]	; (23d10 <errata_32+0x3c>)
   23cf0:	681b      	ldr	r3, [r3, #0]
   23cf2:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   23cf6:	2b30      	cmp	r3, #48	; 0x30
   23cf8:	d101      	bne.n	23cfe <errata_32+0x2a>
            return true;
   23cfa:	2301      	movs	r3, #1
   23cfc:	e000      	b.n	23d00 <errata_32+0x2c>
        }
    }

    return false;
   23cfe:	2300      	movs	r3, #0
}
   23d00:	4618      	mov	r0, r3
   23d02:	46bd      	mov	sp, r7
   23d04:	bc80      	pop	{r7}
   23d06:	4770      	bx	lr
   23d08:	f0000fe0 	.word	0xf0000fe0
   23d0c:	f0000fe4 	.word	0xf0000fe4
   23d10:	f0000fe8 	.word	0xf0000fe8

00023d14 <errata_36>:

static bool errata_36(void)
{
   23d14:	b480      	push	{r7}
   23d16:	af00      	add	r7, sp, #0
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
   23d18:	4b13      	ldr	r3, [pc, #76]	; (23d68 <errata_36+0x54>)
   23d1a:	681b      	ldr	r3, [r3, #0]
   23d1c:	b2db      	uxtb	r3, r3
   23d1e:	2b06      	cmp	r3, #6
   23d20:	d11d      	bne.n	23d5e <errata_36+0x4a>
   23d22:	4b12      	ldr	r3, [pc, #72]	; (23d6c <errata_36+0x58>)
   23d24:	681b      	ldr	r3, [r3, #0]
   23d26:	f003 030f 	and.w	r3, r3, #15
   23d2a:	2b00      	cmp	r3, #0
   23d2c:	d117      	bne.n	23d5e <errata_36+0x4a>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
   23d2e:	4b10      	ldr	r3, [pc, #64]	; (23d70 <errata_36+0x5c>)
   23d30:	681b      	ldr	r3, [r3, #0]
   23d32:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   23d36:	2b30      	cmp	r3, #48	; 0x30
   23d38:	d101      	bne.n	23d3e <errata_36+0x2a>
            return true;
   23d3a:	2301      	movs	r3, #1
   23d3c:	e010      	b.n	23d60 <errata_36+0x4c>
        }
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x40){
   23d3e:	4b0c      	ldr	r3, [pc, #48]	; (23d70 <errata_36+0x5c>)
   23d40:	681b      	ldr	r3, [r3, #0]
   23d42:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   23d46:	2b40      	cmp	r3, #64	; 0x40
   23d48:	d101      	bne.n	23d4e <errata_36+0x3a>
            return true;
   23d4a:	2301      	movs	r3, #1
   23d4c:	e008      	b.n	23d60 <errata_36+0x4c>
        }
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x50){
   23d4e:	4b08      	ldr	r3, [pc, #32]	; (23d70 <errata_36+0x5c>)
   23d50:	681b      	ldr	r3, [r3, #0]
   23d52:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   23d56:	2b50      	cmp	r3, #80	; 0x50
   23d58:	d101      	bne.n	23d5e <errata_36+0x4a>
            return true;
   23d5a:	2301      	movs	r3, #1
   23d5c:	e000      	b.n	23d60 <errata_36+0x4c>
        }
    }

    return false;
   23d5e:	2300      	movs	r3, #0
}
   23d60:	4618      	mov	r0, r3
   23d62:	46bd      	mov	sp, r7
   23d64:	bc80      	pop	{r7}
   23d66:	4770      	bx	lr
   23d68:	f0000fe0 	.word	0xf0000fe0
   23d6c:	f0000fe4 	.word	0xf0000fe4
   23d70:	f0000fe8 	.word	0xf0000fe8

00023d74 <errata_37>:

static bool errata_37(void)
{
   23d74:	b480      	push	{r7}
   23d76:	af00      	add	r7, sp, #0
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
   23d78:	4b0b      	ldr	r3, [pc, #44]	; (23da8 <errata_37+0x34>)
   23d7a:	681b      	ldr	r3, [r3, #0]
   23d7c:	b2db      	uxtb	r3, r3
   23d7e:	2b06      	cmp	r3, #6
   23d80:	d10d      	bne.n	23d9e <errata_37+0x2a>
   23d82:	4b0a      	ldr	r3, [pc, #40]	; (23dac <errata_37+0x38>)
   23d84:	681b      	ldr	r3, [r3, #0]
   23d86:	f003 030f 	and.w	r3, r3, #15
   23d8a:	2b00      	cmp	r3, #0
   23d8c:	d107      	bne.n	23d9e <errata_37+0x2a>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
   23d8e:	4b08      	ldr	r3, [pc, #32]	; (23db0 <errata_37+0x3c>)
   23d90:	681b      	ldr	r3, [r3, #0]
   23d92:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   23d96:	2b30      	cmp	r3, #48	; 0x30
   23d98:	d101      	bne.n	23d9e <errata_37+0x2a>
            return true;
   23d9a:	2301      	movs	r3, #1
   23d9c:	e000      	b.n	23da0 <errata_37+0x2c>
        }
    }

    return false;
   23d9e:	2300      	movs	r3, #0
}
   23da0:	4618      	mov	r0, r3
   23da2:	46bd      	mov	sp, r7
   23da4:	bc80      	pop	{r7}
   23da6:	4770      	bx	lr
   23da8:	f0000fe0 	.word	0xf0000fe0
   23dac:	f0000fe4 	.word	0xf0000fe4
   23db0:	f0000fe8 	.word	0xf0000fe8

00023db4 <errata_57>:

static bool errata_57(void)
{
   23db4:	b480      	push	{r7}
   23db6:	af00      	add	r7, sp, #0
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
   23db8:	4b0b      	ldr	r3, [pc, #44]	; (23de8 <errata_57+0x34>)
   23dba:	681b      	ldr	r3, [r3, #0]
   23dbc:	b2db      	uxtb	r3, r3
   23dbe:	2b06      	cmp	r3, #6
   23dc0:	d10d      	bne.n	23dde <errata_57+0x2a>
   23dc2:	4b0a      	ldr	r3, [pc, #40]	; (23dec <errata_57+0x38>)
   23dc4:	681b      	ldr	r3, [r3, #0]
   23dc6:	f003 030f 	and.w	r3, r3, #15
   23dca:	2b00      	cmp	r3, #0
   23dcc:	d107      	bne.n	23dde <errata_57+0x2a>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
   23dce:	4b08      	ldr	r3, [pc, #32]	; (23df0 <errata_57+0x3c>)
   23dd0:	681b      	ldr	r3, [r3, #0]
   23dd2:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   23dd6:	2b30      	cmp	r3, #48	; 0x30
   23dd8:	d101      	bne.n	23dde <errata_57+0x2a>
            return true;
   23dda:	2301      	movs	r3, #1
   23ddc:	e000      	b.n	23de0 <errata_57+0x2c>
        }
    }

    return false;
   23dde:	2300      	movs	r3, #0
}
   23de0:	4618      	mov	r0, r3
   23de2:	46bd      	mov	sp, r7
   23de4:	bc80      	pop	{r7}
   23de6:	4770      	bx	lr
   23de8:	f0000fe0 	.word	0xf0000fe0
   23dec:	f0000fe4 	.word	0xf0000fe4
   23df0:	f0000fe8 	.word	0xf0000fe8

00023df4 <errata_66>:

static bool errata_66(void)
{
   23df4:	b480      	push	{r7}
   23df6:	af00      	add	r7, sp, #0
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
   23df8:	4b0b      	ldr	r3, [pc, #44]	; (23e28 <errata_66+0x34>)
   23dfa:	681b      	ldr	r3, [r3, #0]
   23dfc:	b2db      	uxtb	r3, r3
   23dfe:	2b06      	cmp	r3, #6
   23e00:	d10d      	bne.n	23e1e <errata_66+0x2a>
   23e02:	4b0a      	ldr	r3, [pc, #40]	; (23e2c <errata_66+0x38>)
   23e04:	681b      	ldr	r3, [r3, #0]
   23e06:	f003 030f 	and.w	r3, r3, #15
   23e0a:	2b00      	cmp	r3, #0
   23e0c:	d107      	bne.n	23e1e <errata_66+0x2a>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x50){
   23e0e:	4b08      	ldr	r3, [pc, #32]	; (23e30 <errata_66+0x3c>)
   23e10:	681b      	ldr	r3, [r3, #0]
   23e12:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   23e16:	2b50      	cmp	r3, #80	; 0x50
   23e18:	d101      	bne.n	23e1e <errata_66+0x2a>
            return true;
   23e1a:	2301      	movs	r3, #1
   23e1c:	e000      	b.n	23e20 <errata_66+0x2c>
        }
    }

    return false;
   23e1e:	2300      	movs	r3, #0
}
   23e20:	4618      	mov	r0, r3
   23e22:	46bd      	mov	sp, r7
   23e24:	bc80      	pop	{r7}
   23e26:	4770      	bx	lr
   23e28:	f0000fe0 	.word	0xf0000fe0
   23e2c:	f0000fe4 	.word	0xf0000fe4
   23e30:	f0000fe8 	.word	0xf0000fe8

00023e34 <errata_108>:


static bool errata_108(void)
{
   23e34:	b480      	push	{r7}
   23e36:	af00      	add	r7, sp, #0
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
   23e38:	4b13      	ldr	r3, [pc, #76]	; (23e88 <errata_108+0x54>)
   23e3a:	681b      	ldr	r3, [r3, #0]
   23e3c:	b2db      	uxtb	r3, r3
   23e3e:	2b06      	cmp	r3, #6
   23e40:	d11d      	bne.n	23e7e <errata_108+0x4a>
   23e42:	4b12      	ldr	r3, [pc, #72]	; (23e8c <errata_108+0x58>)
   23e44:	681b      	ldr	r3, [r3, #0]
   23e46:	f003 030f 	and.w	r3, r3, #15
   23e4a:	2b00      	cmp	r3, #0
   23e4c:	d117      	bne.n	23e7e <errata_108+0x4a>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
   23e4e:	4b10      	ldr	r3, [pc, #64]	; (23e90 <errata_108+0x5c>)
   23e50:	681b      	ldr	r3, [r3, #0]
   23e52:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   23e56:	2b30      	cmp	r3, #48	; 0x30
   23e58:	d101      	bne.n	23e5e <errata_108+0x2a>
            return true;
   23e5a:	2301      	movs	r3, #1
   23e5c:	e010      	b.n	23e80 <errata_108+0x4c>
        }
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x40){
   23e5e:	4b0c      	ldr	r3, [pc, #48]	; (23e90 <errata_108+0x5c>)
   23e60:	681b      	ldr	r3, [r3, #0]
   23e62:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   23e66:	2b40      	cmp	r3, #64	; 0x40
   23e68:	d101      	bne.n	23e6e <errata_108+0x3a>
            return true;
   23e6a:	2301      	movs	r3, #1
   23e6c:	e008      	b.n	23e80 <errata_108+0x4c>
        }
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x50){
   23e6e:	4b08      	ldr	r3, [pc, #32]	; (23e90 <errata_108+0x5c>)
   23e70:	681b      	ldr	r3, [r3, #0]
   23e72:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   23e76:	2b50      	cmp	r3, #80	; 0x50
   23e78:	d101      	bne.n	23e7e <errata_108+0x4a>
            return true;
   23e7a:	2301      	movs	r3, #1
   23e7c:	e000      	b.n	23e80 <errata_108+0x4c>
        }
    }

    return false;
   23e7e:	2300      	movs	r3, #0
}
   23e80:	4618      	mov	r0, r3
   23e82:	46bd      	mov	sp, r7
   23e84:	bc80      	pop	{r7}
   23e86:	4770      	bx	lr
   23e88:	f0000fe0 	.word	0xf0000fe0
   23e8c:	f0000fe4 	.word	0xf0000fe4
   23e90:	f0000fe8 	.word	0xf0000fe8

00023e94 <FifoInit>:
 * \param fifo      - the fifo to be configured
 * \param buf       - the buffer which will be attached to the fifo
 * \param buf_size  - the size of the buffer which will be attached to the fifo
 */
void FifoInit(fifo_t* fifo, void* buf, uint16_t buf_size, uint8_t word_size)
{
   23e94:	b480      	push	{r7}
   23e96:	b085      	sub	sp, #20
   23e98:	af00      	add	r7, sp, #0
   23e9a:	60f8      	str	r0, [r7, #12]
   23e9c:	60b9      	str	r1, [r7, #8]
   23e9e:	4611      	mov	r1, r2
   23ea0:	461a      	mov	r2, r3
   23ea2:	460b      	mov	r3, r1
   23ea4:	80fb      	strh	r3, [r7, #6]
   23ea6:	4613      	mov	r3, r2
   23ea8:	717b      	strb	r3, [r7, #5]
//    app_fifo_init(fifo, buf, buf_size);
    fifo->p_buf = buf;
   23eaa:	68fb      	ldr	r3, [r7, #12]
   23eac:	68ba      	ldr	r2, [r7, #8]
   23eae:	601a      	str	r2, [r3, #0]
    fifo->buf_size_mask = buf_size;
   23eb0:	68fb      	ldr	r3, [r7, #12]
   23eb2:	88fa      	ldrh	r2, [r7, #6]
   23eb4:	809a      	strh	r2, [r3, #4]
    fifo->word_size = word_size;
   23eb6:	68fb      	ldr	r3, [r7, #12]
   23eb8:	797a      	ldrb	r2, [r7, #5]
   23eba:	719a      	strb	r2, [r3, #6]
    fifo->read_pos = 0;
   23ebc:	68fb      	ldr	r3, [r7, #12]
   23ebe:	2200      	movs	r2, #0
   23ec0:	811a      	strh	r2, [r3, #8]
    fifo->write_pos = 0;
   23ec2:	68fb      	ldr	r3, [r7, #12]
   23ec4:	2200      	movs	r2, #0
   23ec6:	815a      	strh	r2, [r3, #10]
}
   23ec8:	bf00      	nop
   23eca:	3714      	adds	r7, #20
   23ecc:	46bd      	mov	sp, r7
   23ece:	bc80      	pop	{r7}
   23ed0:	4770      	bx	lr

00023ed2 <FifoGet>:
 *
 * \param fifo - the fifo from which the byte is to be extracted
 * \param byte - pointer to the single byte buffer
 */
inline int FifoGet(fifo_t* fifo, void* data)
{
   23ed2:	b580      	push	{r7, lr}
   23ed4:	b082      	sub	sp, #8
   23ed6:	af00      	add	r7, sp, #0
   23ed8:	6078      	str	r0, [r7, #4]
   23eda:	6039      	str	r1, [r7, #0]
    // If fifo empty
    if (fifo->read_pos == fifo->write_pos)
   23edc:	687b      	ldr	r3, [r7, #4]
   23ede:	891b      	ldrh	r3, [r3, #8]
   23ee0:	b29a      	uxth	r2, r3
   23ee2:	687b      	ldr	r3, [r7, #4]
   23ee4:	895b      	ldrh	r3, [r3, #10]
   23ee6:	b29b      	uxth	r3, r3
   23ee8:	429a      	cmp	r2, r3
   23eea:	d105      	bne.n	23ef8 <FifoGet+0x26>
    {
        *(uint8_t*)data = 0;
   23eec:	683b      	ldr	r3, [r7, #0]
   23eee:	2200      	movs	r2, #0
   23ef0:	701a      	strb	r2, [r3, #0]
        return -1;
   23ef2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   23ef6:	e022      	b.n	23f3e <FifoGet+0x6c>
    }
    else
    {
        memcpy((uint8_t*)data, &((uint8_t*)fifo->p_buf)[fifo->read_pos*fifo->word_size], fifo->word_size);
   23ef8:	687b      	ldr	r3, [r7, #4]
   23efa:	681b      	ldr	r3, [r3, #0]
   23efc:	687a      	ldr	r2, [r7, #4]
   23efe:	8912      	ldrh	r2, [r2, #8]
   23f00:	b292      	uxth	r2, r2
   23f02:	4611      	mov	r1, r2
   23f04:	687a      	ldr	r2, [r7, #4]
   23f06:	7992      	ldrb	r2, [r2, #6]
   23f08:	fb02 f201 	mul.w	r2, r2, r1
   23f0c:	1899      	adds	r1, r3, r2
   23f0e:	687b      	ldr	r3, [r7, #4]
   23f10:	799b      	ldrb	r3, [r3, #6]
   23f12:	461a      	mov	r2, r3
   23f14:	6838      	ldr	r0, [r7, #0]
   23f16:	f007 f9eb 	bl	2b2f0 <memcpy>
    }

    fifo->read_pos++;
   23f1a:	687b      	ldr	r3, [r7, #4]
   23f1c:	891b      	ldrh	r3, [r3, #8]
   23f1e:	b29b      	uxth	r3, r3
   23f20:	3301      	adds	r3, #1
   23f22:	b29a      	uxth	r2, r3
   23f24:	687b      	ldr	r3, [r7, #4]
   23f26:	811a      	strh	r2, [r3, #8]
    if (fifo->read_pos == fifo->buf_size_mask)
   23f28:	687b      	ldr	r3, [r7, #4]
   23f2a:	891b      	ldrh	r3, [r3, #8]
   23f2c:	b29a      	uxth	r2, r3
   23f2e:	687b      	ldr	r3, [r7, #4]
   23f30:	889b      	ldrh	r3, [r3, #4]
   23f32:	429a      	cmp	r2, r3
   23f34:	d102      	bne.n	23f3c <FifoGet+0x6a>
    {
        fifo->read_pos = 0;
   23f36:	687b      	ldr	r3, [r7, #4]
   23f38:	2200      	movs	r2, #0
   23f3a:	811a      	strh	r2, [r3, #8]
    }

    return 0;
   23f3c:	2300      	movs	r3, #0
}
   23f3e:	4618      	mov	r0, r3
   23f40:	3708      	adds	r7, #8
   23f42:	46bd      	mov	sp, r7
   23f44:	bd80      	pop	{r7, pc}

00023f46 <FifoPut>:
 *
 * \param fifo - the FIFO where the byte is to be put
 * \param data - the data to be put
 */
inline void FifoPut(fifo_t* fifo, uint32_t data)
{
   23f46:	b580      	push	{r7, lr}
   23f48:	b082      	sub	sp, #8
   23f4a:	af00      	add	r7, sp, #0
   23f4c:	6078      	str	r0, [r7, #4]
   23f4e:	6039      	str	r1, [r7, #0]
    memcpy(&(((uint8_t*)fifo->p_buf)[fifo->write_pos*fifo->word_size]), &data, fifo->word_size);
   23f50:	687b      	ldr	r3, [r7, #4]
   23f52:	681b      	ldr	r3, [r3, #0]
   23f54:	687a      	ldr	r2, [r7, #4]
   23f56:	8952      	ldrh	r2, [r2, #10]
   23f58:	b292      	uxth	r2, r2
   23f5a:	4611      	mov	r1, r2
   23f5c:	687a      	ldr	r2, [r7, #4]
   23f5e:	7992      	ldrb	r2, [r2, #6]
   23f60:	fb02 f201 	mul.w	r2, r2, r1
   23f64:	1898      	adds	r0, r3, r2
   23f66:	687b      	ldr	r3, [r7, #4]
   23f68:	799b      	ldrb	r3, [r3, #6]
   23f6a:	461a      	mov	r2, r3
   23f6c:	463b      	mov	r3, r7
   23f6e:	4619      	mov	r1, r3
   23f70:	f007 f9be 	bl	2b2f0 <memcpy>
    fifo->write_pos++;
   23f74:	687b      	ldr	r3, [r7, #4]
   23f76:	895b      	ldrh	r3, [r3, #10]
   23f78:	b29b      	uxth	r3, r3
   23f7a:	3301      	adds	r3, #1
   23f7c:	b29a      	uxth	r2, r3
   23f7e:	687b      	ldr	r3, [r7, #4]
   23f80:	815a      	strh	r2, [r3, #10]
    if (fifo->write_pos > fifo->buf_size_mask)
   23f82:	687b      	ldr	r3, [r7, #4]
   23f84:	895b      	ldrh	r3, [r3, #10]
   23f86:	b29a      	uxth	r2, r3
   23f88:	687b      	ldr	r3, [r7, #4]
   23f8a:	889b      	ldrh	r3, [r3, #4]
   23f8c:	429a      	cmp	r2, r3
   23f8e:	d902      	bls.n	23f96 <FifoPut+0x50>
        fifo->write_pos = 0;
   23f90:	687b      	ldr	r3, [r7, #4]
   23f92:	2200      	movs	r2, #0
   23f94:	815a      	strh	r2, [r3, #10]

    ((uint8_t*)fifo->p_buf)[fifo->write_pos] = 0;
   23f96:	687b      	ldr	r3, [r7, #4]
   23f98:	681b      	ldr	r3, [r3, #0]
   23f9a:	687a      	ldr	r2, [r7, #4]
   23f9c:	8952      	ldrh	r2, [r2, #10]
   23f9e:	b292      	uxth	r2, r2
   23fa0:	4413      	add	r3, r2
   23fa2:	2200      	movs	r2, #0
   23fa4:	701a      	strb	r2, [r3, #0]
}
   23fa6:	bf00      	nop
   23fa8:	3708      	adds	r7, #8
   23faa:	46bd      	mov	sp, r7
   23fac:	bd80      	pop	{r7, pc}

00023fae <FifoIsEmpty>:
 *
 * \return      true - if fifo empty
 *              false - if fifo contains some data
 */
inline uint32_t FifoIsEmpty(fifo_t* fifo)
{
   23fae:	b480      	push	{r7}
   23fb0:	b083      	sub	sp, #12
   23fb2:	af00      	add	r7, sp, #0
   23fb4:	6078      	str	r0, [r7, #4]
    if(fifo->read_pos == fifo->write_pos)
   23fb6:	687b      	ldr	r3, [r7, #4]
   23fb8:	891b      	ldrh	r3, [r3, #8]
   23fba:	b29a      	uxth	r2, r3
   23fbc:	687b      	ldr	r3, [r7, #4]
   23fbe:	895b      	ldrh	r3, [r3, #10]
   23fc0:	b29b      	uxth	r3, r3
   23fc2:	429a      	cmp	r2, r3
   23fc4:	d101      	bne.n	23fca <FifoIsEmpty+0x1c>
        return true;
   23fc6:	2301      	movs	r3, #1
   23fc8:	e000      	b.n	23fcc <FifoIsEmpty+0x1e>

    return false;
   23fca:	2300      	movs	r3, #0
}
   23fcc:	4618      	mov	r0, r3
   23fce:	370c      	adds	r7, #12
   23fd0:	46bd      	mov	sp, r7
   23fd2:	bc80      	pop	{r7}
   23fd4:	4770      	bx	lr

00023fd6 <sd_rand_application_bytes_available_get>:
 *
 * @param[out] p_bytes_available The number of bytes currently available in the pool.
 *
 * @retval ::NRF_SUCCESS
 */
SVCALL(SD_RAND_APPLICATION_BYTES_AVAILABLE_GET, uint32_t, sd_rand_application_bytes_available_get(uint8_t * p_bytes_available));
   23fd6:	df2f      	svc	47	; 0x2f
   23fd8:	4770      	bx	lr
   23fda:	bf00      	nop
   23fdc:	4618      	mov	r0, r3

00023fde <sd_rand_application_vector_get>:
 * @param[in]   length  Number of bytes to take from pool and place in p_buff.
 *
 * @retval ::NRF_SUCCESS The requested bytes were written to p_buff.
 * @retval ::NRF_ERROR_SOC_RAND_NOT_ENOUGH_VALUES No bytes were written to the buffer, because there were not enough bytes available.
*/
SVCALL(SD_RAND_APPLICATION_VECTOR_GET, uint32_t, sd_rand_application_vector_get(uint8_t * p_buff, uint8_t length));
   23fde:	df30      	svc	48	; 0x30
   23fe0:	4770      	bx	lr
   23fe2:	bf00      	nop
   23fe4:	4618      	mov	r0, r3

00023fe6 <_XorData>:
extern void AES_128_keyschedule_dec(const uint8_t *, uint8_t *);
extern void AES_128_encrypt(const uint8_t *, const uint8_t *, uint8_t *);
extern void AES_128_decrypt(const uint8_t *, const uint8_t *, uint8_t *);

static uint32_t* _XorData(uint32_t* leftSide, uint32_t* rightSide, uint16_t wordCount)
{
   23fe6:	b480      	push	{r7}
   23fe8:	b087      	sub	sp, #28
   23fea:	af00      	add	r7, sp, #0
   23fec:	60f8      	str	r0, [r7, #12]
   23fee:	60b9      	str	r1, [r7, #8]
   23ff0:	4613      	mov	r3, r2
   23ff2:	80fb      	strh	r3, [r7, #6]
    uint32_t* output = leftSide;
   23ff4:	68fb      	ldr	r3, [r7, #12]
   23ff6:	617b      	str	r3, [r7, #20]
    while (wordCount != 0)
   23ff8:	e00f      	b.n	2401a <_XorData+0x34>
    {
        *leftSide ^= *rightSide;
   23ffa:	68fb      	ldr	r3, [r7, #12]
   23ffc:	681a      	ldr	r2, [r3, #0]
   23ffe:	68bb      	ldr	r3, [r7, #8]
   24000:	681b      	ldr	r3, [r3, #0]
   24002:	405a      	eors	r2, r3
   24004:	68fb      	ldr	r3, [r7, #12]
   24006:	601a      	str	r2, [r3, #0]
        leftSide++;
   24008:	68fb      	ldr	r3, [r7, #12]
   2400a:	3304      	adds	r3, #4
   2400c:	60fb      	str	r3, [r7, #12]
        rightSide++;
   2400e:	68bb      	ldr	r3, [r7, #8]
   24010:	3304      	adds	r3, #4
   24012:	60bb      	str	r3, [r7, #8]
        wordCount--;
   24014:	88fb      	ldrh	r3, [r7, #6]
   24016:	3b01      	subs	r3, #1
   24018:	80fb      	strh	r3, [r7, #6]
    while (wordCount != 0)
   2401a:	88fb      	ldrh	r3, [r7, #6]
   2401c:	2b00      	cmp	r3, #0
   2401e:	d1ec      	bne.n	23ffa <_XorData+0x14>
    }

    return output;
   24020:	697b      	ldr	r3, [r7, #20]
}
   24022:	4618      	mov	r0, r3
   24024:	371c      	adds	r7, #28
   24026:	46bd      	mov	sp, r7
   24028:	bc80      	pop	{r7}
   2402a:	4770      	bx	lr

0002402c <CryptoGenerateKey>:

uint32_t CryptoGenerateKey(uint8_t* generatedKey, uint8_t* generatedKeySize)
{
   2402c:	b580      	push	{r7, lr}
   2402e:	b084      	sub	sp, #16
   24030:	af00      	add	r7, sp, #0
   24032:	6078      	str	r0, [r7, #4]
   24034:	6039      	str	r1, [r7, #0]
    uint8_t availableBytes = 0;
   24036:	2300      	movs	r3, #0
   24038:	72fb      	strb	r3, [r7, #11]
    while (availableBytes < CRYPTO_KEY_SIZE)
   2403a:	e007      	b.n	2404c <CryptoGenerateKey+0x20>
    {
        sd_rand_application_bytes_available_get(&availableBytes);
   2403c:	f107 030b 	add.w	r3, r7, #11
   24040:	4618      	mov	r0, r3
   24042:	f7ff ffc8 	bl	23fd6 <sd_rand_application_bytes_available_get>
        Rtc1DelayMs(1);
   24046:	2001      	movs	r0, #1
   24048:	f000 fef2 	bl	24e30 <Rtc1DelayMs>
    while (availableBytes < CRYPTO_KEY_SIZE)
   2404c:	7afb      	ldrb	r3, [r7, #11]
   2404e:	2b0f      	cmp	r3, #15
   24050:	d9f4      	bls.n	2403c <CryptoGenerateKey+0x10>
    }

    *generatedKeySize = CRYPTO_KEY_SIZE;
   24052:	683b      	ldr	r3, [r7, #0]
   24054:	2210      	movs	r2, #16
   24056:	701a      	strb	r2, [r3, #0]
    uint32_t retval = sd_rand_application_vector_get(generatedKey, CRYPTO_KEY_SIZE);
   24058:	2110      	movs	r1, #16
   2405a:	6878      	ldr	r0, [r7, #4]
   2405c:	f7ff ffbf 	bl	23fde <sd_rand_application_vector_get>
   24060:	60f8      	str	r0, [r7, #12]

    if (retval == NRF_ERROR_SOC_RAND_NOT_ENOUGH_VALUES)
   24062:	68fb      	ldr	r3, [r7, #12]
   24064:	f242 0207 	movw	r2, #8199	; 0x2007
   24068:	4293      	cmp	r3, r2
   2406a:	d101      	bne.n	24070 <CryptoGenerateKey+0x44>
        return retval;
   2406c:	68fb      	ldr	r3, [r7, #12]
   2406e:	e000      	b.n	24072 <CryptoGenerateKey+0x46>

    return NRF_SUCCESS;
   24070:	2300      	movs	r3, #0
}
   24072:	4618      	mov	r0, r3
   24074:	3710      	adds	r7, #16
   24076:	46bd      	mov	sp, r7
   24078:	bd80      	pop	{r7, pc}

0002407a <CryptoCheckMainKey>:

uint32_t CryptoCheckMainKey()
{
   2407a:	b580      	push	{r7, lr}
   2407c:	b086      	sub	sp, #24
   2407e:	af00      	add	r7, sp, #0
    uint8_t generatedKey[CRYPTO_KEY_SIZE];

    memcpy(generatedKey, (uint8_t*)CRYPTO_MAIN_KEY_ADDRESS, CRYPTO_KEY_SIZE);
   24080:	1d3b      	adds	r3, r7, #4
   24082:	2210      	movs	r2, #16
   24084:	f44f 21f0 	mov.w	r1, #491520	; 0x78000
   24088:	4618      	mov	r0, r3
   2408a:	f007 f931 	bl	2b2f0 <memcpy>

    for (uint8_t i=0; i<CRYPTO_KEY_SIZE; ++i)
   2408e:	2300      	movs	r3, #0
   24090:	75fb      	strb	r3, [r7, #23]
   24092:	e00c      	b.n	240ae <CryptoCheckMainKey+0x34>
    {
        if (generatedKey[i] != CHAR_MAX)
   24094:	7dfb      	ldrb	r3, [r7, #23]
   24096:	f107 0218 	add.w	r2, r7, #24
   2409a:	4413      	add	r3, r2
   2409c:	f813 3c14 	ldrb.w	r3, [r3, #-20]
   240a0:	2bff      	cmp	r3, #255	; 0xff
   240a2:	d001      	beq.n	240a8 <CryptoCheckMainKey+0x2e>
            return true;
   240a4:	2301      	movs	r3, #1
   240a6:	e006      	b.n	240b6 <CryptoCheckMainKey+0x3c>
    for (uint8_t i=0; i<CRYPTO_KEY_SIZE; ++i)
   240a8:	7dfb      	ldrb	r3, [r7, #23]
   240aa:	3301      	adds	r3, #1
   240ac:	75fb      	strb	r3, [r7, #23]
   240ae:	7dfb      	ldrb	r3, [r7, #23]
   240b0:	2b0f      	cmp	r3, #15
   240b2:	d9ef      	bls.n	24094 <CryptoCheckMainKey+0x1a>
    }

    return false;
   240b4:	2300      	movs	r3, #0
}
   240b6:	4618      	mov	r0, r3
   240b8:	3718      	adds	r7, #24
   240ba:	46bd      	mov	sp, r7
   240bc:	bd80      	pop	{r7, pc}
	...

000240c0 <CryptoGenerateAndStoreDeactivationCommandKey>:

    return NRF_SUCCESS;
}

uint32_t CryptoGenerateAndStoreDeactivationCommandKey()
{
   240c0:	b580      	push	{r7, lr}
   240c2:	b082      	sub	sp, #8
   240c4:	af00      	add	r7, sp, #0
    uint32_t retval = NRF_SUCCESS;
   240c6:	2300      	movs	r3, #0
   240c8:	607b      	str	r3, [r7, #4]
    uint8_t generatedKeySize = 0;
   240ca:	2300      	movs	r3, #0
   240cc:	70fb      	strb	r3, [r7, #3]

    retval = CryptoGenerateKey(alarmDeactivationCmd, &generatedKeySize);
   240ce:	1cfb      	adds	r3, r7, #3
   240d0:	4619      	mov	r1, r3
   240d2:	480d      	ldr	r0, [pc, #52]	; (24108 <CryptoGenerateAndStoreDeactivationCommandKey+0x48>)
   240d4:	f7ff ffaa 	bl	2402c <CryptoGenerateKey>
   240d8:	6078      	str	r0, [r7, #4]

    if (retval == NRF_ERROR_SOC_RAND_NOT_ENOUGH_VALUES)
   240da:	687b      	ldr	r3, [r7, #4]
   240dc:	f242 0207 	movw	r2, #8199	; 0x2007
   240e0:	4293      	cmp	r3, r2
   240e2:	d101      	bne.n	240e8 <CryptoGenerateAndStoreDeactivationCommandKey+0x28>
        return retval;
   240e4:	687b      	ldr	r3, [r7, #4]
   240e6:	e00b      	b.n	24100 <CryptoGenerateAndStoreDeactivationCommandKey+0x40>

    retval = IntFlashUpdatePage(alarmDeactivationCmd, CRYPTO_KEY_SIZE, (uint32_t*)KEY_TAG_ALARM_DISARMING_COMMAND_ADDRESS);
   240e8:	4a08      	ldr	r2, [pc, #32]	; (2410c <CryptoGenerateAndStoreDeactivationCommandKey+0x4c>)
   240ea:	2110      	movs	r1, #16
   240ec:	4806      	ldr	r0, [pc, #24]	; (24108 <CryptoGenerateAndStoreDeactivationCommandKey+0x48>)
   240ee:	f000 f8e7 	bl	242c0 <IntFlashUpdatePage>
   240f2:	6078      	str	r0, [r7, #4]

    if (retval != FLASH_OP_SUCCESS)
   240f4:	687b      	ldr	r3, [r7, #4]
   240f6:	2bff      	cmp	r3, #255	; 0xff
   240f8:	d001      	beq.n	240fe <CryptoGenerateAndStoreDeactivationCommandKey+0x3e>
        return retval;
   240fa:	687b      	ldr	r3, [r7, #4]
   240fc:	e000      	b.n	24100 <CryptoGenerateAndStoreDeactivationCommandKey+0x40>

    return NRF_SUCCESS;
   240fe:	2300      	movs	r3, #0
}
   24100:	4618      	mov	r0, r3
   24102:	3708      	adds	r7, #8
   24104:	46bd      	mov	sp, r7
   24106:	bd80      	pop	{r7, pc}
   24108:	20005420 	.word	0x20005420
   2410c:	00078010 	.word	0x00078010

00024110 <CryptoUpdateIv>:
{
    return currentInitialisingVector;
}

uint32_t CryptoUpdateIv(uint8_t* newIv)
{
   24110:	b580      	push	{r7, lr}
   24112:	b082      	sub	sp, #8
   24114:	af00      	add	r7, sp, #0
   24116:	6078      	str	r0, [r7, #4]
    memcpy(currentInitialisingVector, newIv, CRYPTO_KEY_SIZE);
   24118:	2210      	movs	r2, #16
   2411a:	6879      	ldr	r1, [r7, #4]
   2411c:	4803      	ldr	r0, [pc, #12]	; (2412c <CryptoUpdateIv+0x1c>)
   2411e:	f007 f8e7 	bl	2b2f0 <memcpy>
    return 0;
   24122:	2300      	movs	r3, #0
}
   24124:	4618      	mov	r0, r3
   24126:	3708      	adds	r7, #8
   24128:	46bd      	mov	sp, r7
   2412a:	bd80      	pop	{r7, pc}
   2412c:	20005440 	.word	0x20005440

00024130 <CryptoECBEncryptData>:
uint32_t CryptoECBEncryptData(uint8_t* dataToEncrypt,
                           uint16_t dataSize,
                           uint8_t* key,
                           uint8_t keySize,
                           uint8_t* encryptedData)
{
   24130:	b580      	push	{r7, lr}
   24132:	b0b0      	sub	sp, #192	; 0xc0
   24134:	af00      	add	r7, sp, #0
   24136:	60f8      	str	r0, [r7, #12]
   24138:	607a      	str	r2, [r7, #4]
   2413a:	461a      	mov	r2, r3
   2413c:	460b      	mov	r3, r1
   2413e:	817b      	strh	r3, [r7, #10]
   24140:	4613      	mov	r3, r2
   24142:	727b      	strb	r3, [r7, #9]
    // Assert the data size.
    if (dataSize != CRYPTO_KEY_SIZE)
   24144:	897b      	ldrh	r3, [r7, #10]
   24146:	2b10      	cmp	r3, #16
   24148:	d001      	beq.n	2414e <CryptoECBEncryptData+0x1e>
    {
        return NRF_ERROR_DATA_SIZE;
   2414a:	230c      	movs	r3, #12
   2414c:	e016      	b.n	2417c <CryptoECBEncryptData+0x4c>
    }

    uint8_t rk[11*16];
    memcpy(rk, key, 16);
   2414e:	f107 0310 	add.w	r3, r7, #16
   24152:	2210      	movs	r2, #16
   24154:	6879      	ldr	r1, [r7, #4]
   24156:	4618      	mov	r0, r3
   24158:	f007 f8ca 	bl	2b2f0 <memcpy>
    AES_128_keyschedule(key, rk+16);
   2415c:	f107 0310 	add.w	r3, r7, #16
   24160:	3310      	adds	r3, #16
   24162:	4619      	mov	r1, r3
   24164:	6878      	ldr	r0, [r7, #4]
   24166:	f004 fc13 	bl	28990 <AES_128_keyschedule>
    AES_128_encrypt(rk, dataToEncrypt, encryptedData);
   2416a:	f107 0310 	add.w	r3, r7, #16
   2416e:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
   24172:	68f9      	ldr	r1, [r7, #12]
   24174:	4618      	mov	r0, r3
   24176:	f004 fdbb 	bl	28cf0 <AES_128_encrypt>

    return NRF_SUCCESS;
   2417a:	2300      	movs	r3, #0
}
   2417c:	4618      	mov	r0, r3
   2417e:	37c0      	adds	r7, #192	; 0xc0
   24180:	46bd      	mov	sp, r7
   24182:	bd80      	pop	{r7, pc}

00024184 <CryptoECBDecryptData>:
uint32_t CryptoECBDecryptData(uint8_t* dataToDecrypt,
                           uint16_t dataSize,
                           uint8_t* key,
                           uint8_t keySize,
                           uint8_t* decryptedData)
{
   24184:	b580      	push	{r7, lr}
   24186:	b0b0      	sub	sp, #192	; 0xc0
   24188:	af00      	add	r7, sp, #0
   2418a:	60f8      	str	r0, [r7, #12]
   2418c:	607a      	str	r2, [r7, #4]
   2418e:	461a      	mov	r2, r3
   24190:	460b      	mov	r3, r1
   24192:	817b      	strh	r3, [r7, #10]
   24194:	4613      	mov	r3, r2
   24196:	727b      	strb	r3, [r7, #9]
    // Assert the data size.
    if (dataSize != CRYPTO_KEY_SIZE)
   24198:	897b      	ldrh	r3, [r7, #10]
   2419a:	2b10      	cmp	r3, #16
   2419c:	d001      	beq.n	241a2 <CryptoECBDecryptData+0x1e>
    {
        return NRF_ERROR_DATA_SIZE;
   2419e:	230c      	movs	r3, #12
   241a0:	e016      	b.n	241d0 <CryptoECBDecryptData+0x4c>
    }

    uint8_t rk[11*16];
    memcpy(rk+160, key, 16);
   241a2:	f107 0310 	add.w	r3, r7, #16
   241a6:	33a0      	adds	r3, #160	; 0xa0
   241a8:	2210      	movs	r2, #16
   241aa:	6879      	ldr	r1, [r7, #4]
   241ac:	4618      	mov	r0, r3
   241ae:	f007 f89f 	bl	2b2f0 <memcpy>

    AES_128_keyschedule_dec(key, rk);
   241b2:	f107 0310 	add.w	r3, r7, #16
   241b6:	4619      	mov	r1, r3
   241b8:	6878      	ldr	r0, [r7, #4]
   241ba:	f005 fd79 	bl	29cb0 <AES_128_keyschedule_dec>
    AES_128_decrypt(rk, dataToDecrypt, decryptedData);
   241be:	f107 0310 	add.w	r3, r7, #16
   241c2:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
   241c6:	68f9      	ldr	r1, [r7, #12]
   241c8:	4618      	mov	r0, r3
   241ca:	f006 fca1 	bl	2ab10 <AES_128_decrypt>


    return NRF_SUCCESS;
   241ce:	2300      	movs	r3, #0
}
   241d0:	4618      	mov	r0, r3
   241d2:	37c0      	adds	r7, #192	; 0xc0
   241d4:	46bd      	mov	sp, r7
   241d6:	bd80      	pop	{r7, pc}

000241d8 <CryptoCFBEncryptData>:
                              uint8_t* initialisingVector,
                              uint8_t* key,
                              uint8_t  keySize,
                              uint8_t* encryptedData,
                              uint32_t dataSize)
{
   241d8:	b580      	push	{r7, lr}
   241da:	b08a      	sub	sp, #40	; 0x28
   241dc:	af02      	add	r7, sp, #8
   241de:	60f8      	str	r0, [r7, #12]
   241e0:	60b9      	str	r1, [r7, #8]
   241e2:	607a      	str	r2, [r7, #4]
   241e4:	70fb      	strb	r3, [r7, #3]
    uint8_t* initCipher = encryptedData;
   241e6:	6abb      	ldr	r3, [r7, #40]	; 0x28
   241e8:	61bb      	str	r3, [r7, #24]

    // Assert the data size. It should be a multiple of keySize
    if (dataSize % keySize != 0)
   241ea:	78fa      	ldrb	r2, [r7, #3]
   241ec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   241ee:	fbb3 f1f2 	udiv	r1, r3, r2
   241f2:	fb02 f201 	mul.w	r2, r2, r1
   241f6:	1a9b      	subs	r3, r3, r2
   241f8:	2b00      	cmp	r3, #0
   241fa:	d001      	beq.n	24200 <CryptoCFBEncryptData+0x28>
    {
        return NRF_ERROR_DATA_SIZE;
   241fc:	230c      	movs	r3, #12
   241fe:	e042      	b.n	24286 <CryptoCFBEncryptData+0xae>
    }

    uint16_t blocksCount = dataSize/keySize;
   24200:	78fb      	ldrb	r3, [r7, #3]
   24202:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   24204:	fbb2 f3f3 	udiv	r3, r2, r3
   24208:	82fb      	strh	r3, [r7, #22]
    uint8_t* tmpInitVector = malloc(keySize);
   2420a:	78fb      	ldrb	r3, [r7, #3]
   2420c:	4618      	mov	r0, r3
   2420e:	f007 f85f 	bl	2b2d0 <malloc>
   24212:	6138      	str	r0, [r7, #16]

    memcpy(tmpInitVector, initialisingVector, keySize);
   24214:	78fb      	ldrb	r3, [r7, #3]
   24216:	461a      	mov	r2, r3
   24218:	68b9      	ldr	r1, [r7, #8]
   2421a:	6938      	ldr	r0, [r7, #16]
   2421c:	f007 f868 	bl	2b2f0 <memcpy>


    for (uint16_t i=0; i<blocksCount; ++i)
   24220:	2300      	movs	r3, #0
   24222:	83fb      	strh	r3, [r7, #30]
   24224:	e024      	b.n	24270 <CryptoCFBEncryptData+0x98>
    {
        // Encrypt the initialising vector and store the output in encryptedDatabuffer
        CryptoECBEncryptData(tmpInitVector,
   24226:	78fb      	ldrb	r3, [r7, #3]
   24228:	b299      	uxth	r1, r3
   2422a:	78fa      	ldrb	r2, [r7, #3]
   2422c:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2422e:	9300      	str	r3, [sp, #0]
   24230:	4613      	mov	r3, r2
   24232:	687a      	ldr	r2, [r7, #4]
   24234:	6938      	ldr	r0, [r7, #16]
   24236:	f7ff ff7b 	bl	24130 <CryptoECBEncryptData>
                             key,
                             keySize,
                             encryptedData);

        // Xor the encrypting output with part of data to be encrypted
        encryptedData = (uint8_t*)_XorData((uint32_t*)encryptedData, (uint32_t*)dataToEncrypt, keySize/sizeof(uint32_t));
   2423a:	78fb      	ldrb	r3, [r7, #3]
   2423c:	089b      	lsrs	r3, r3, #2
   2423e:	b2db      	uxtb	r3, r3
   24240:	b29b      	uxth	r3, r3
   24242:	461a      	mov	r2, r3
   24244:	68f9      	ldr	r1, [r7, #12]
   24246:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   24248:	f7ff fecd 	bl	23fe6 <_XorData>
   2424c:	62b8      	str	r0, [r7, #40]	; 0x28
        // The encrypted data is an initialising vector for the next data packet
        memcpy(tmpInitVector, encryptedData, keySize);
   2424e:	78fb      	ldrb	r3, [r7, #3]
   24250:	461a      	mov	r2, r3
   24252:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   24254:	6938      	ldr	r0, [r7, #16]
   24256:	f007 f84b 	bl	2b2f0 <memcpy>
        // Increase the pointers to point to the next packet
        dataToEncrypt += keySize;
   2425a:	78fb      	ldrb	r3, [r7, #3]
   2425c:	68fa      	ldr	r2, [r7, #12]
   2425e:	4413      	add	r3, r2
   24260:	60fb      	str	r3, [r7, #12]
        encryptedData += keySize;
   24262:	78fb      	ldrb	r3, [r7, #3]
   24264:	6aba      	ldr	r2, [r7, #40]	; 0x28
   24266:	4413      	add	r3, r2
   24268:	62bb      	str	r3, [r7, #40]	; 0x28
    for (uint16_t i=0; i<blocksCount; ++i)
   2426a:	8bfb      	ldrh	r3, [r7, #30]
   2426c:	3301      	adds	r3, #1
   2426e:	83fb      	strh	r3, [r7, #30]
   24270:	8bfa      	ldrh	r2, [r7, #30]
   24272:	8afb      	ldrh	r3, [r7, #22]
   24274:	429a      	cmp	r2, r3
   24276:	d3d6      	bcc.n	24226 <CryptoCFBEncryptData+0x4e>
    }

    free(tmpInitVector);
   24278:	6938      	ldr	r0, [r7, #16]
   2427a:	f007 f831 	bl	2b2e0 <free>

    CryptoUpdateIv(initCipher);
   2427e:	69b8      	ldr	r0, [r7, #24]
   24280:	f7ff ff46 	bl	24110 <CryptoUpdateIv>
    return NRF_SUCCESS;
   24284:	2300      	movs	r3, #0
}
   24286:	4618      	mov	r0, r3
   24288:	3720      	adds	r7, #32
   2428a:	46bd      	mov	sp, r7
   2428c:	bd80      	pop	{r7, pc}

0002428e <sd_flash_write>:
* @retval ::NRF_ERROR_BUSY           The previous command has not yet completed.
* @retval ::NRF_ERROR_INVALID_LENGTH Size was 0, or higher than the maximum allowed size.
* @retval ::NRF_ERROR_FORBIDDEN      Tried to write to or read from protected location.
* @retval ::NRF_SUCCESS              The command was accepted.
*/
SVCALL(SD_FLASH_WRITE, uint32_t, sd_flash_write(uint32_t * p_dst, uint32_t const * p_src, uint32_t size));
   2428e:	df29      	svc	41	; 0x29
   24290:	4770      	bx	lr
   24292:	bf00      	nop
   24294:	4618      	mov	r0, r3

00024296 <sd_flash_page_erase>:
* @retval ::NRF_ERROR_INVALID_ADDR  Tried to erase to a non existing flash page.
* @retval ::NRF_ERROR_BUSY          The previous command has not yet completed.
* @retval ::NRF_ERROR_FORBIDDEN     Tried to erase a protected page.
* @retval ::NRF_SUCCESS             The command was accepted.
*/
SVCALL(SD_FLASH_PAGE_ERASE, uint32_t, sd_flash_page_erase(uint32_t page_number));
   24296:	df28      	svc	40	; 0x28
   24298:	4770      	bx	lr
   2429a:	bf00      	nop
   2429c:	4618      	mov	r0, r3
	...

000242a0 <_FlashWaitTillOpDone>:
static volatile uint8_t                     flash_operation_completed_flag      = TRUE;
static uint32_t                             last_flashed_data;
static uint32_t*                            last_flashed_data_pointer;

static void _FlashWaitTillOpDone()
{
   242a0:	b480      	push	{r7}
   242a2:	af00      	add	r7, sp, #0
    while(flash_operation_completed_flag == FALSE)
   242a4:	e000      	b.n	242a8 <_FlashWaitTillOpDone+0x8>
  __ASM volatile ("wfi");
   242a6:	bf30      	wfi
   242a8:	4b04      	ldr	r3, [pc, #16]	; (242bc <_FlashWaitTillOpDone+0x1c>)
   242aa:	781b      	ldrb	r3, [r3, #0]
   242ac:	b2db      	uxtb	r3, r3
   242ae:	2b00      	cmp	r3, #0
   242b0:	d0f9      	beq.n	242a6 <_FlashWaitTillOpDone+0x6>
    {
        __WFI();
    }
}
   242b2:	bf00      	nop
   242b4:	46bd      	mov	sp, r7
   242b6:	bc80      	pop	{r7}
   242b8:	4770      	bx	lr
   242ba:	bf00      	nop
   242bc:	20005068 	.word	0x20005068

000242c0 <IntFlashUpdatePage>:
*               NRF_ERROR_DATA_SIZE     -   The end address of the updated data doesn't lie on the same page as the start
*               FLASH_OP_WRITE_ERROR    -   If the data couldn't been correctly flashed
*
*/
uint32_t IntFlashUpdatePage(uint8_t* p_data, uint32_t data_len, uint32_t* address)
{
   242c0:	b580      	push	{r7, lr}
   242c2:	b08c      	sub	sp, #48	; 0x30
   242c4:	af00      	add	r7, sp, #0
   242c6:	60f8      	str	r0, [r7, #12]
   242c8:	60b9      	str	r1, [r7, #8]
   242ca:	607a      	str	r2, [r7, #4]
    uint32_t*           temp_pointer = address;     /*< Temp pointer needed to check if there is enough blank space for copy the data and to update the data */
   242cc:	687b      	ldr	r3, [r7, #4]
   242ce:	62fb      	str	r3, [r7, #44]	; 0x2c
    dword_to_byte_u     data;                       /*< Internal buffer for data. The size is equal to uint32_t */
    uint32_t            empty_bytes_counter = 0;    /**< This variable calculates the number of the free (0xFFFFFFFF) flash cells in the area starting with \var address and size of \var data_len */
   242d0:	2300      	movs	r3, #0
   242d2:	62bb      	str	r3, [r7, #40]	; 0x28
    uint32_t            err_code;                   /*< Error code to check if Int_Flash_Erase_Page and Int_Flash_Store_Dword went successfully */
    int16_t             temp_swap_index;            /*< This variable gets an index of the current processed byte in uint32_t unit */
    /// Get flash page start address
    uint32_t*           page_start_address = (uint32_t*)((uint32_t)address - ((uint32_t)address % INTERNAL_FLASH_PAGE_SIZE));   /*< Pointer to the start of the page we want to update data on */
   242d4:	687b      	ldr	r3, [r7, #4]
   242d6:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
   242da:	f023 030f 	bic.w	r3, r3, #15
   242de:	617b      	str	r3, [r7, #20]
    uint8_t             flash_operation_counter = 0;    /*< Counter which prevents infinite flashing of data */
   242e0:	2300      	movs	r3, #0
   242e2:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21

    /// Check if an end address of the data lies on the same page as the start
    if(address + data_len/4 > page_start_address + INTERNAL_FLASH_PAGE_SIZE_UINT32)
   242e6:	68bb      	ldr	r3, [r7, #8]
   242e8:	f023 0303 	bic.w	r3, r3, #3
   242ec:	687a      	ldr	r2, [r7, #4]
   242ee:	441a      	add	r2, r3
   242f0:	697b      	ldr	r3, [r7, #20]
   242f2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
   242f6:	429a      	cmp	r2, r3
   242f8:	d901      	bls.n	242fe <IntFlashUpdatePage+0x3e>
        return NRF_ERROR_DATA_SIZE;
   242fa:	230c      	movs	r3, #12
   242fc:	e186      	b.n	2460c <IntFlashUpdatePage+0x34c>

    /** CHECK IF BY CHANCE THE ENTIRE PLACE WHERE WE WANT TO STORE THE DATA ISN'T EMPTY */
    for(uint32_t i=0; i<data_len; i+=4)
   242fe:	2300      	movs	r3, #0
   24300:	61fb      	str	r3, [r7, #28]
   24302:	e013      	b.n	2432c <IntFlashUpdatePage+0x6c>
    {
        /// Check if the cell we are trying to save the data in is empty
        memcpy(&data.doubleword, temp_pointer, sizeof(uint32_t));
   24304:	f107 0310 	add.w	r3, r7, #16
   24308:	2204      	movs	r2, #4
   2430a:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   2430c:	4618      	mov	r0, r3
   2430e:	f006 ffef 	bl	2b2f0 <memcpy>
        /// If the flash cell is empty
        if(data.doubleword == 0xFFFFFFFF)
   24312:	693b      	ldr	r3, [r7, #16]
   24314:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   24318:	d102      	bne.n	24320 <IntFlashUpdatePage+0x60>
            empty_bytes_counter += 4;
   2431a:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2431c:	3304      	adds	r3, #4
   2431e:	62bb      	str	r3, [r7, #40]	; 0x28
        /// Increase the pointer to the next uint32_t
        temp_pointer++;
   24320:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   24322:	3304      	adds	r3, #4
   24324:	62fb      	str	r3, [r7, #44]	; 0x2c
    for(uint32_t i=0; i<data_len; i+=4)
   24326:	69fb      	ldr	r3, [r7, #28]
   24328:	3304      	adds	r3, #4
   2432a:	61fb      	str	r3, [r7, #28]
   2432c:	69fa      	ldr	r2, [r7, #28]
   2432e:	68bb      	ldr	r3, [r7, #8]
   24330:	429a      	cmp	r2, r3
   24332:	d3e7      	bcc.n	24304 <IntFlashUpdatePage+0x44>
    }

    /** COPY THE DATA TO THE SWAP PAGE IF NEEDED */
    /// If there is some data in the place where we want to store the data
    if(empty_bytes_counter <= data_len)
   24334:	6aba      	ldr	r2, [r7, #40]	; 0x28
   24336:	68bb      	ldr	r3, [r7, #8]
   24338:	429a      	cmp	r2, r3
   2433a:	f200 8128 	bhi.w	2458e <IntFlashUpdatePage+0x2ce>
    {
        do
        {
            flash_operation_counter++;
   2433e:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
   24342:	3301      	adds	r3, #1
   24344:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
            temp_swap_index = 0;
   24348:	2300      	movs	r3, #0
   2434a:	847b      	strh	r3, [r7, #34]	; 0x22
            /// Erase swap page
            err_code = IntFlashErasePage(INTERNAL_FLASH_SWAP_PAGE_ADDRESS);
   2434c:	f44f 20f2 	mov.w	r0, #495616	; 0x79000
   24350:	f000 f9a8 	bl	246a4 <IntFlashErasePage>
   24354:	6278      	str	r0, [r7, #36]	; 0x24
            /// Copy the flash page to the swap page from the beginning to the address we want to update
            while((page_start_address + temp_swap_index) != address)
   24356:	e029      	b.n	243ac <IntFlashUpdatePage+0xec>
            {
                /// Get the byte from the page...
                memcpy(&data.doubleword, page_start_address+temp_swap_index, sizeof(uint32_t));
   24358:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
   2435c:	009b      	lsls	r3, r3, #2
   2435e:	697a      	ldr	r2, [r7, #20]
   24360:	18d1      	adds	r1, r2, r3
   24362:	f107 0310 	add.w	r3, r7, #16
   24366:	2204      	movs	r2, #4
   24368:	4618      	mov	r0, r3
   2436a:	f006 ffc1 	bl	2b2f0 <memcpy>
                if(data.doubleword == 0xFFFFFFFF)
   2436e:	693b      	ldr	r3, [r7, #16]
   24370:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   24374:	d106      	bne.n	24384 <IntFlashUpdatePage+0xc4>
                {
                    /// Increase the swap byte index to indicate the next uint32_t address we want to store
                    temp_swap_index++;
   24376:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
   2437a:	b29b      	uxth	r3, r3
   2437c:	3301      	adds	r3, #1
   2437e:	b29b      	uxth	r3, r3
   24380:	847b      	strh	r3, [r7, #34]	; 0x22
                    /// Skip flashing the 0xFFFFFFFF because it has no sense
                    continue;
   24382:	e013      	b.n	243ac <IntFlashUpdatePage+0xec>
                }
                /// ...and flash it in the swap page
                err_code = IntFlashStoreWord(data.doubleword, INTERNAL_FLASH_SWAP_PAGE_ADDRESS + temp_swap_index);
   24384:	693a      	ldr	r2, [r7, #16]
   24386:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
   2438a:	009b      	lsls	r3, r3, #2
   2438c:	f503 23f2 	add.w	r3, r3, #495616	; 0x79000
   24390:	4619      	mov	r1, r3
   24392:	4610      	mov	r0, r2
   24394:	f000 f93e 	bl	24614 <IntFlashStoreWord>
   24398:	6278      	str	r0, [r7, #36]	; 0x24
                if(err_code != FLASH_OP_SUCCESS)
   2439a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   2439c:	2bff      	cmp	r3, #255	; 0xff
   2439e:	d10e      	bne.n	243be <IntFlashUpdatePage+0xfe>
                {
                    break;
                }
                /// Increase the swap byte index to indicate the next uint32_t address we want to store
                temp_swap_index++;
   243a0:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
   243a4:	b29b      	uxth	r3, r3
   243a6:	3301      	adds	r3, #1
   243a8:	b29b      	uxth	r3, r3
   243aa:	847b      	strh	r3, [r7, #34]	; 0x22
            while((page_start_address + temp_swap_index) != address)
   243ac:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
   243b0:	009b      	lsls	r3, r3, #2
   243b2:	697a      	ldr	r2, [r7, #20]
   243b4:	4413      	add	r3, r2
   243b6:	687a      	ldr	r2, [r7, #4]
   243b8:	429a      	cmp	r2, r3
   243ba:	d1cd      	bne.n	24358 <IntFlashUpdatePage+0x98>
   243bc:	e000      	b.n	243c0 <IntFlashUpdatePage+0x100>
                    break;
   243be:	bf00      	nop
            }
            if(err_code != FLASH_OP_SUCCESS)
   243c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   243c2:	2bff      	cmp	r3, #255	; 0xff
   243c4:	d13b      	bne.n	2443e <IntFlashUpdatePage+0x17e>
            {
                continue;
            }
            /// Get the index of the first uint32_t behind the place we want to store
            temp_swap_index = ((uint32_t)temp_pointer % INTERNAL_FLASH_PAGE_SIZE)>>2;
   243c6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   243c8:	089b      	lsrs	r3, r3, #2
   243ca:	b21b      	sxth	r3, r3
   243cc:	f3c3 0309 	ubfx	r3, r3, #0, #10
   243d0:	847b      	strh	r3, [r7, #34]	; 0x22
            /// Copy the data which lies behind the block we want to update
            while((page_start_address + temp_swap_index) != page_start_address + INTERNAL_FLASH_PAGE_SIZE_UINT32)
   243d2:	e029      	b.n	24428 <IntFlashUpdatePage+0x168>
            {
                /// Get the byte from the page...
                memcpy(&data.doubleword, page_start_address+temp_swap_index, sizeof(uint32_t));
   243d4:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
   243d8:	009b      	lsls	r3, r3, #2
   243da:	697a      	ldr	r2, [r7, #20]
   243dc:	18d1      	adds	r1, r2, r3
   243de:	f107 0310 	add.w	r3, r7, #16
   243e2:	2204      	movs	r2, #4
   243e4:	4618      	mov	r0, r3
   243e6:	f006 ff83 	bl	2b2f0 <memcpy>
                /// ...and flash it in the swap page
                err_code = IntFlashStoreWord(data.doubleword, INTERNAL_FLASH_SWAP_PAGE_ADDRESS + temp_swap_index);
   243ea:	693a      	ldr	r2, [r7, #16]
   243ec:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
   243f0:	009b      	lsls	r3, r3, #2
   243f2:	f503 23f2 	add.w	r3, r3, #495616	; 0x79000
   243f6:	4619      	mov	r1, r3
   243f8:	4610      	mov	r0, r2
   243fa:	f000 f90b 	bl	24614 <IntFlashStoreWord>
   243fe:	6278      	str	r0, [r7, #36]	; 0x24
                if(err_code != FLASH_OP_SUCCESS)
   24400:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   24402:	2bff      	cmp	r3, #255	; 0xff
   24404:	d11d      	bne.n	24442 <IntFlashUpdatePage+0x182>
                {
                    break;
                }
                if(data.doubleword == 0xFFFFFFFF)
   24406:	693b      	ldr	r3, [r7, #16]
   24408:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   2440c:	d106      	bne.n	2441c <IntFlashUpdatePage+0x15c>
                {
                    /// Increase the swap byte index to indicate the next uint32_t address we want to store
                    temp_swap_index++;
   2440e:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
   24412:	b29b      	uxth	r3, r3
   24414:	3301      	adds	r3, #1
   24416:	b29b      	uxth	r3, r3
   24418:	847b      	strh	r3, [r7, #34]	; 0x22
                    /// Skip flashing the 0xFFFFFFFF because it has no sense
                    continue;
   2441a:	e005      	b.n	24428 <IntFlashUpdatePage+0x168>
                }
                /// Increase the swap byte index to indicate the next uint32_t address we want to store
                temp_swap_index++;
   2441c:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
   24420:	b29b      	uxth	r3, r3
   24422:	3301      	adds	r3, #1
   24424:	b29b      	uxth	r3, r3
   24426:	847b      	strh	r3, [r7, #34]	; 0x22
            while((page_start_address + temp_swap_index) != page_start_address + INTERNAL_FLASH_PAGE_SIZE_UINT32)
   24428:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
   2442c:	009b      	lsls	r3, r3, #2
   2442e:	697a      	ldr	r2, [r7, #20]
   24430:	441a      	add	r2, r3
   24432:	697b      	ldr	r3, [r7, #20]
   24434:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
   24438:	429a      	cmp	r2, r3
   2443a:	d1cb      	bne.n	243d4 <IntFlashUpdatePage+0x114>
   2443c:	e002      	b.n	24444 <IntFlashUpdatePage+0x184>
                continue;
   2443e:	bf00      	nop
   24440:	e000      	b.n	24444 <IntFlashUpdatePage+0x184>
                    break;
   24442:	bf00      	nop
            }
        }while(err_code != FLASH_OP_SUCCESS && flash_operation_counter <= MAX_FLASH_OPERATION_ERROR_COUNTER);
   24444:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   24446:	2bff      	cmp	r3, #255	; 0xff
   24448:	d004      	beq.n	24454 <IntFlashUpdatePage+0x194>
   2444a:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
   2444e:	2b03      	cmp	r3, #3
   24450:	f67f af75 	bls.w	2433e <IntFlashUpdatePage+0x7e>
        /// Check if there was an error after three times reflashing

        if(flash_operation_counter > MAX_FLASH_OPERATION_ERROR_COUNTER)
   24454:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
   24458:	2b03      	cmp	r3, #3
   2445a:	d901      	bls.n	24460 <IntFlashUpdatePage+0x1a0>
        {
            return FLASH_OP_WRITE_ERROR;
   2445c:	230f      	movs	r3, #15
   2445e:	e0d5      	b.n	2460c <IntFlashUpdatePage+0x34c>
        }
        flash_operation_counter = 0;
   24460:	2300      	movs	r3, #0
   24462:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
        do
        {
            flash_operation_counter++;
   24466:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
   2446a:	3301      	adds	r3, #1
   2446c:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
            /*< ERASE THE PAGE */
            /// Erase the page where we want to store the data
            IntFlashErasePage(page_start_address);
   24470:	6978      	ldr	r0, [r7, #20]
   24472:	f000 f917 	bl	246a4 <IntFlashErasePage>

            /*< COPY THE NOT AFFECTED DATA BACK TO THE PAGE */

            /// Set the swap index to the last uint32_t of the working page
            if(temp_swap_index == 256)
   24476:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
   2447a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
   2447e:	d12f      	bne.n	244e0 <IntFlashUpdatePage+0x220>
                temp_swap_index--;
   24480:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
   24484:	b29b      	uxth	r3, r3
   24486:	3b01      	subs	r3, #1
   24488:	b29b      	uxth	r3, r3
   2448a:	847b      	strh	r3, [r7, #34]	; 0x22
            /// While we don't get to the end of the message
            while((page_start_address + temp_swap_index) >= (address + (data_len >> 2)))
   2448c:	e028      	b.n	244e0 <IntFlashUpdatePage+0x220>
            {
                /// Get the byte from the swap page...
                memcpy(&data.doubleword, INTERNAL_FLASH_SWAP_PAGE_ADDRESS+temp_swap_index, sizeof(uint32_t));
   2448e:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
   24492:	009b      	lsls	r3, r3, #2
   24494:	f503 21f2 	add.w	r1, r3, #495616	; 0x79000
   24498:	f107 0310 	add.w	r3, r7, #16
   2449c:	2204      	movs	r2, #4
   2449e:	4618      	mov	r0, r3
   244a0:	f006 ff26 	bl	2b2f0 <memcpy>
                if(data.doubleword == 0xFFFFFFFF)
   244a4:	693b      	ldr	r3, [r7, #16]
   244a6:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   244aa:	d106      	bne.n	244ba <IntFlashUpdatePage+0x1fa>
                {
                    /// Increase the swap byte index to indicate the next uint32_t address we want to store
                    temp_swap_index--;
   244ac:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
   244b0:	b29b      	uxth	r3, r3
   244b2:	3b01      	subs	r3, #1
   244b4:	b29b      	uxth	r3, r3
   244b6:	847b      	strh	r3, [r7, #34]	; 0x22
                    /// Skip flashing the 0xFFFFFFFF because it has no sense
                    continue;
   244b8:	e012      	b.n	244e0 <IntFlashUpdatePage+0x220>
                }
                /// ...and flash it in the page
                err_code = IntFlashStoreWord(data.doubleword, page_start_address + temp_swap_index); // bug - dodawanie liczby do adresu?
   244ba:	6938      	ldr	r0, [r7, #16]
   244bc:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
   244c0:	009b      	lsls	r3, r3, #2
   244c2:	697a      	ldr	r2, [r7, #20]
   244c4:	4413      	add	r3, r2
   244c6:	4619      	mov	r1, r3
   244c8:	f000 f8a4 	bl	24614 <IntFlashStoreWord>
   244cc:	6278      	str	r0, [r7, #36]	; 0x24
                if(err_code != FLASH_OP_SUCCESS)
   244ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   244d0:	2bff      	cmp	r3, #255	; 0xff
   244d2:	d112      	bne.n	244fa <IntFlashUpdatePage+0x23a>
                {
                    break;
                }
                /// Increase the swap byte index to indicate the next uint32_t address we want to store
                temp_swap_index--;
   244d4:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
   244d8:	b29b      	uxth	r3, r3
   244da:	3b01      	subs	r3, #1
   244dc:	b29b      	uxth	r3, r3
   244de:	847b      	strh	r3, [r7, #34]	; 0x22
            while((page_start_address + temp_swap_index) >= (address + (data_len >> 2)))
   244e0:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
   244e4:	009b      	lsls	r3, r3, #2
   244e6:	697a      	ldr	r2, [r7, #20]
   244e8:	441a      	add	r2, r3
   244ea:	68bb      	ldr	r3, [r7, #8]
   244ec:	089b      	lsrs	r3, r3, #2
   244ee:	009b      	lsls	r3, r3, #2
   244f0:	6879      	ldr	r1, [r7, #4]
   244f2:	440b      	add	r3, r1
   244f4:	429a      	cmp	r2, r3
   244f6:	d2ca      	bcs.n	2448e <IntFlashUpdatePage+0x1ce>
   244f8:	e000      	b.n	244fc <IntFlashUpdatePage+0x23c>
                    break;
   244fa:	bf00      	nop
            }
            if(err_code != FLASH_OP_SUCCESS)
   244fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   244fe:	2bff      	cmp	r3, #255	; 0xff
   24500:	d13a      	bne.n	24578 <IntFlashUpdatePage+0x2b8>
            {
                continue;
            }
            /// Set the temp_swap index to the first uint32_t before the update area
            temp_swap_index = (((uint32_t)address - (uint32_t)page_start_address)>>2) - 1;
   24502:	687a      	ldr	r2, [r7, #4]
   24504:	697b      	ldr	r3, [r7, #20]
   24506:	1ad3      	subs	r3, r2, r3
   24508:	089b      	lsrs	r3, r3, #2
   2450a:	b29b      	uxth	r3, r3
   2450c:	3b01      	subs	r3, #1
   2450e:	b29b      	uxth	r3, r3
   24510:	847b      	strh	r3, [r7, #34]	; 0x22

            /// While we don't get to the beginning of the page
            while((page_start_address + temp_swap_index) >= page_start_address)
   24512:	e028      	b.n	24566 <IntFlashUpdatePage+0x2a6>
            {
                /// Get the byte from the swap page...
                memcpy(&data.doubleword, INTERNAL_FLASH_SWAP_PAGE_ADDRESS+temp_swap_index, sizeof(uint32_t));
   24514:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
   24518:	009b      	lsls	r3, r3, #2
   2451a:	f503 21f2 	add.w	r1, r3, #495616	; 0x79000
   2451e:	f107 0310 	add.w	r3, r7, #16
   24522:	2204      	movs	r2, #4
   24524:	4618      	mov	r0, r3
   24526:	f006 fee3 	bl	2b2f0 <memcpy>
                if(data.doubleword == 0xFFFFFFFF)
   2452a:	693b      	ldr	r3, [r7, #16]
   2452c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   24530:	d106      	bne.n	24540 <IntFlashUpdatePage+0x280>
                {
                    /// Increase the swap byte index to indicate the next uint32_t address we want to store
                    temp_swap_index--;
   24532:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
   24536:	b29b      	uxth	r3, r3
   24538:	3b01      	subs	r3, #1
   2453a:	b29b      	uxth	r3, r3
   2453c:	847b      	strh	r3, [r7, #34]	; 0x22
                    /// Skip flashing the 0xFFFFFFFF because it has no sense
                    continue;
   2453e:	e012      	b.n	24566 <IntFlashUpdatePage+0x2a6>
                }
                /// ...and flash it in the page
                err_code = IntFlashStoreWord(data.doubleword, page_start_address + temp_swap_index);
   24540:	6938      	ldr	r0, [r7, #16]
   24542:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
   24546:	009b      	lsls	r3, r3, #2
   24548:	697a      	ldr	r2, [r7, #20]
   2454a:	4413      	add	r3, r2
   2454c:	4619      	mov	r1, r3
   2454e:	f000 f861 	bl	24614 <IntFlashStoreWord>
   24552:	6278      	str	r0, [r7, #36]	; 0x24
                if(err_code != FLASH_OP_SUCCESS)
   24554:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   24556:	2bff      	cmp	r3, #255	; 0xff
   24558:	d110      	bne.n	2457c <IntFlashUpdatePage+0x2bc>
                {
                    break;
                }
                /// Increase the swap byte index to indicate the next uint32_t address we want to store
                temp_swap_index--;
   2455a:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
   2455e:	b29b      	uxth	r3, r3
   24560:	3b01      	subs	r3, #1
   24562:	b29b      	uxth	r3, r3
   24564:	847b      	strh	r3, [r7, #34]	; 0x22
            while((page_start_address + temp_swap_index) >= page_start_address)
   24566:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
   2456a:	009b      	lsls	r3, r3, #2
   2456c:	697a      	ldr	r2, [r7, #20]
   2456e:	4413      	add	r3, r2
   24570:	697a      	ldr	r2, [r7, #20]
   24572:	429a      	cmp	r2, r3
   24574:	d9ce      	bls.n	24514 <IntFlashUpdatePage+0x254>
   24576:	e002      	b.n	2457e <IntFlashUpdatePage+0x2be>
                continue;
   24578:	bf00      	nop
   2457a:	e000      	b.n	2457e <IntFlashUpdatePage+0x2be>
                    break;
   2457c:	bf00      	nop
            }
        }while(err_code != FLASH_OP_SUCCESS && flash_operation_counter <= MAX_FLASH_OPERATION_ERROR_COUNTER);
   2457e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   24580:	2bff      	cmp	r3, #255	; 0xff
   24582:	d004      	beq.n	2458e <IntFlashUpdatePage+0x2ce>
   24584:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
   24588:	2b03      	cmp	r3, #3
   2458a:	f67f af6c 	bls.w	24466 <IntFlashUpdatePage+0x1a6>

    }
    /// Check if there was an error after three times reflashing
    if(flash_operation_counter > MAX_FLASH_OPERATION_ERROR_COUNTER)
   2458e:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
   24592:	2b03      	cmp	r3, #3
   24594:	d901      	bls.n	2459a <IntFlashUpdatePage+0x2da>
    {
        return FLASH_OP_WRITE_ERROR;
   24596:	230f      	movs	r3, #15
   24598:	e038      	b.n	2460c <IntFlashUpdatePage+0x34c>
    }
    flash_operation_counter = 0;
   2459a:	2300      	movs	r3, #0
   2459c:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21

    do
    {
        flash_operation_counter++;
   245a0:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
   245a4:	3301      	adds	r3, #1
   245a6:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
        /*< UPDATE THE DATA */
        /// Go back with the temp_pointer to the given address
        temp_pointer = address;
   245aa:	687b      	ldr	r3, [r7, #4]
   245ac:	62fb      	str	r3, [r7, #44]	; 0x2c
        /// Store the data we wanted to update
        for(uint16_t i=0; i< data_len; i += 4)
   245ae:	2300      	movs	r3, #0
   245b0:	837b      	strh	r3, [r7, #26]
   245b2:	e017      	b.n	245e4 <IntFlashUpdatePage+0x324>
        {
            /// Copy the data in the internal buffer
            memcpy(data.byte, &p_data[i], sizeof(uint32_t));
   245b4:	8b7b      	ldrh	r3, [r7, #26]
   245b6:	68fa      	ldr	r2, [r7, #12]
   245b8:	18d1      	adds	r1, r2, r3
   245ba:	f107 0310 	add.w	r3, r7, #16
   245be:	2204      	movs	r2, #4
   245c0:	4618      	mov	r0, r3
   245c2:	f006 fe95 	bl	2b2f0 <memcpy>
            /// Flash the internal buffer
            err_code = IntFlashStoreWord(data.doubleword, temp_pointer);
   245c6:	693b      	ldr	r3, [r7, #16]
   245c8:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   245ca:	4618      	mov	r0, r3
   245cc:	f000 f822 	bl	24614 <IntFlashStoreWord>
   245d0:	6278      	str	r0, [r7, #36]	; 0x24
            if(err_code != FLASH_OP_SUCCESS)
   245d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   245d4:	2bff      	cmp	r3, #255	; 0xff
   245d6:	d10a      	bne.n	245ee <IntFlashUpdatePage+0x32e>
            {
                break;
            }
            temp_pointer++;
   245d8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   245da:	3304      	adds	r3, #4
   245dc:	62fb      	str	r3, [r7, #44]	; 0x2c
        for(uint16_t i=0; i< data_len; i += 4)
   245de:	8b7b      	ldrh	r3, [r7, #26]
   245e0:	3304      	adds	r3, #4
   245e2:	837b      	strh	r3, [r7, #26]
   245e4:	8b7b      	ldrh	r3, [r7, #26]
   245e6:	68ba      	ldr	r2, [r7, #8]
   245e8:	429a      	cmp	r2, r3
   245ea:	d8e3      	bhi.n	245b4 <IntFlashUpdatePage+0x2f4>
   245ec:	e000      	b.n	245f0 <IntFlashUpdatePage+0x330>
                break;
   245ee:	bf00      	nop
        }
    }while(err_code != FLASH_OP_SUCCESS && flash_operation_counter <= MAX_FLASH_OPERATION_ERROR_COUNTER);
   245f0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   245f2:	2bff      	cmp	r3, #255	; 0xff
   245f4:	d003      	beq.n	245fe <IntFlashUpdatePage+0x33e>
   245f6:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
   245fa:	2b03      	cmp	r3, #3
   245fc:	d9d0      	bls.n	245a0 <IntFlashUpdatePage+0x2e0>
    /// Check if there was an error after three times reflashing
    if(flash_operation_counter > MAX_FLASH_OPERATION_ERROR_COUNTER)
   245fe:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
   24602:	2b03      	cmp	r3, #3
   24604:	d901      	bls.n	2460a <IntFlashUpdatePage+0x34a>
    {
        return FLASH_OP_WRITE_ERROR;
   24606:	230f      	movs	r3, #15
   24608:	e000      	b.n	2460c <IntFlashUpdatePage+0x34c>
    }

    return FLASH_OP_SUCCESS;
   2460a:	23ff      	movs	r3, #255	; 0xff
}
   2460c:	4618      	mov	r0, r3
   2460e:	3730      	adds	r7, #48	; 0x30
   24610:	46bd      	mov	sp, r7
   24612:	bd80      	pop	{r7, pc}

00024614 <IntFlashStoreWord>:
*           COMPLETED_WRITE_ERROR   -   data was stored but corrupted
*           FLASH_OP_SUCCESS        -   storage OK
*
**/
uint32_t  IntFlashStoreWord(uint32_t data_to_flash, uint32_t* pointer)
{
   24614:	b580      	push	{r7, lr}
   24616:	b084      	sub	sp, #16
   24618:	af00      	add	r7, sp, #0
   2461a:	6078      	str	r0, [r7, #4]
   2461c:	6039      	str	r1, [r7, #0]
    flash_write_or_erase_flag = FLASH_WRITE_OPERATION;
   2461e:	4b1c      	ldr	r3, [pc, #112]	; (24690 <IntFlashStoreWord+0x7c>)
   24620:	220f      	movs	r2, #15
   24622:	701a      	strb	r2, [r3, #0]
    static uint8_t flash_counter = 0;
    do
    {
        //  Clear the flag which informs whether the flash write was completed and was corrupted
        flash_operation_completed_flag = FALSE;
   24624:	4b1b      	ldr	r3, [pc, #108]	; (24694 <IntFlashStoreWord+0x80>)
   24626:	2200      	movs	r2, #0
   24628:	701a      	strb	r2, [r3, #0]
        //  Fill the global variable with the data we want to store
        last_flashed_data = data_to_flash;
   2462a:	687b      	ldr	r3, [r7, #4]
   2462c:	4a1a      	ldr	r2, [pc, #104]	; (24698 <IntFlashStoreWord+0x84>)
   2462e:	6013      	str	r3, [r2, #0]
        //  Set the global pointer where we try to store the given uint32_t
        last_flashed_data_pointer = pointer;
   24630:	4a1a      	ldr	r2, [pc, #104]	; (2469c <IntFlashStoreWord+0x88>)
   24632:	683b      	ldr	r3, [r7, #0]
   24634:	6013      	str	r3, [r2, #0]
        //  Try to write the data at the given address
        uint32_t retval = sd_flash_write(pointer, &data_to_flash, 1);
   24636:	1d3b      	adds	r3, r7, #4
   24638:	2201      	movs	r2, #1
   2463a:	4619      	mov	r1, r3
   2463c:	6838      	ldr	r0, [r7, #0]
   2463e:	f7ff fe26 	bl	2428e <sd_flash_write>
   24642:	60f8      	str	r0, [r7, #12]
        //  Wait till the flag is set indicating whethet the flash store was completed and has ended with an error
        _FlashWaitTillOpDone();
   24644:	f7ff fe2c 	bl	242a0 <_FlashWaitTillOpDone>
        flash_counter++;
   24648:	4b15      	ldr	r3, [pc, #84]	; (246a0 <IntFlashStoreWord+0x8c>)
   2464a:	781b      	ldrb	r3, [r3, #0]
   2464c:	3301      	adds	r3, #1
   2464e:	b2da      	uxtb	r2, r3
   24650:	4b13      	ldr	r3, [pc, #76]	; (246a0 <IntFlashStoreWord+0x8c>)
   24652:	701a      	strb	r2, [r3, #0]

        //  If it was FLASH_OPERATION_ERROR and the memory was not programmed, try to flash it again. If it was FLASH_OP_SUCCESS or FLASH_OP_WRITE_ERROR then return from this function with a proper value
    }while(flash_operation_completed_flag == FLASH_OPERATION_ERROR && flash_counter < MAX_FLASH_OPERATION_ERROR_COUNTER);
   24654:	4b0f      	ldr	r3, [pc, #60]	; (24694 <IntFlashStoreWord+0x80>)
   24656:	781b      	ldrb	r3, [r3, #0]
   24658:	b2db      	uxtb	r3, r3
   2465a:	2ba0      	cmp	r3, #160	; 0xa0
   2465c:	d103      	bne.n	24666 <IntFlashStoreWord+0x52>
   2465e:	4b10      	ldr	r3, [pc, #64]	; (246a0 <IntFlashStoreWord+0x8c>)
   24660:	781b      	ldrb	r3, [r3, #0]
   24662:	2b02      	cmp	r3, #2
   24664:	d9de      	bls.n	24624 <IntFlashStoreWord+0x10>

    /// If after MAX_FLASH_OPERATION_ERROR_COUNTER tries it still isn't programmed, then return FLASH_OP_WRITE_ERROR
    if(flash_operation_completed_flag == FLASH_OPERATION_ERROR)
   24666:	4b0b      	ldr	r3, [pc, #44]	; (24694 <IntFlashStoreWord+0x80>)
   24668:	781b      	ldrb	r3, [r3, #0]
   2466a:	b2db      	uxtb	r3, r3
   2466c:	2ba0      	cmp	r3, #160	; 0xa0
   2466e:	d102      	bne.n	24676 <IntFlashStoreWord+0x62>
        flash_operation_completed_flag = FLASH_OP_WRITE_ERROR;
   24670:	4b08      	ldr	r3, [pc, #32]	; (24694 <IntFlashStoreWord+0x80>)
   24672:	220f      	movs	r2, #15
   24674:	701a      	strb	r2, [r3, #0]
    flash_counter = 0;
   24676:	4b0a      	ldr	r3, [pc, #40]	; (246a0 <IntFlashStoreWord+0x8c>)
   24678:	2200      	movs	r2, #0
   2467a:	701a      	strb	r2, [r3, #0]

    //  If there was an flash write error, log it
    if(flash_operation_completed_flag != FLASH_OP_SUCCESS)
   2467c:	4b05      	ldr	r3, [pc, #20]	; (24694 <IntFlashStoreWord+0x80>)
   2467e:	781b      	ldrb	r3, [r3, #0]
    {

    }
    //  return callback flag
    return flash_operation_completed_flag;
   24680:	4b04      	ldr	r3, [pc, #16]	; (24694 <IntFlashStoreWord+0x80>)
   24682:	781b      	ldrb	r3, [r3, #0]
   24684:	b2db      	uxtb	r3, r3
}
   24686:	4618      	mov	r0, r3
   24688:	3710      	adds	r7, #16
   2468a:	46bd      	mov	sp, r7
   2468c:	bd80      	pop	{r7, pc}
   2468e:	bf00      	nop
   24690:	20005140 	.word	0x20005140
   24694:	20005068 	.word	0x20005068
   24698:	20005144 	.word	0x20005144
   2469c:	20005148 	.word	0x20005148
   246a0:	2000514c 	.word	0x2000514c

000246a4 <IntFlashErasePage>:
*   @param  The actually erased flash page beginning address
*               FLASH_OP_ERASE_ERROR    -   page wasn't erased
*               FLASH_OP_SUCCESS        -   page erased
**/
uint32_t IntFlashErasePage(uint32_t* flash_page_beginning_address)
{
   246a4:	b580      	push	{r7, lr}
   246a6:	b086      	sub	sp, #24
   246a8:	af00      	add	r7, sp, #0
   246aa:	6078      	str	r0, [r7, #4]
    uint8_t erase_counter = 0;
   246ac:	2300      	movs	r3, #0
   246ae:	75fb      	strb	r3, [r7, #23]
    flash_write_or_erase_flag = FLASH_ERASE_OPERATION;
   246b0:	4b1b      	ldr	r3, [pc, #108]	; (24720 <IntFlashErasePage+0x7c>)
   246b2:	22f0      	movs	r2, #240	; 0xf0
   246b4:	701a      	strb	r2, [r3, #0]
    flash_operation_completed_flag = FALSE;
   246b6:	4b1b      	ldr	r3, [pc, #108]	; (24724 <IntFlashErasePage+0x80>)
   246b8:	2200      	movs	r2, #0
   246ba:	701a      	strb	r2, [r3, #0]
    uint32_t temp;
    uint32_t ret_val = 0;
   246bc:	2300      	movs	r3, #0
   246be:	613b      	str	r3, [r7, #16]
    do
    {
        ret_val = sd_flash_page_erase((uint32_t)flash_page_beginning_address/INTERNAL_FLASH_PAGE_SIZE);
   246c0:	687b      	ldr	r3, [r7, #4]
   246c2:	0b1b      	lsrs	r3, r3, #12
   246c4:	4618      	mov	r0, r3
   246c6:	f7ff fde6 	bl	24296 <sd_flash_page_erase>
   246ca:	6138      	str	r0, [r7, #16]

        _FlashWaitTillOpDone();
   246cc:	f7ff fde8 	bl	242a0 <_FlashWaitTillOpDone>

        //  If the first cell on the page is cleared
        memcpy(&temp, flash_page_beginning_address, 4);
   246d0:	f107 030c 	add.w	r3, r7, #12
   246d4:	2204      	movs	r2, #4
   246d6:	6879      	ldr	r1, [r7, #4]
   246d8:	4618      	mov	r0, r3
   246da:	f006 fe09 	bl	2b2f0 <memcpy>
        if(temp == 0xFFFFFFFF)
   246de:	68fb      	ldr	r3, [r7, #12]
   246e0:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   246e4:	d111      	bne.n	2470a <IntFlashErasePage+0x66>
        {
            //  And the second cell on the page also  is cleared
            memcpy(&temp, flash_page_beginning_address+1, 4);
   246e6:	687b      	ldr	r3, [r7, #4]
   246e8:	1d19      	adds	r1, r3, #4
   246ea:	f107 030c 	add.w	r3, r7, #12
   246ee:	2204      	movs	r2, #4
   246f0:	4618      	mov	r0, r3
   246f2:	f006 fdfd 	bl	2b2f0 <memcpy>
            if(temp == 0xFFFFFFFF)
   246f6:	68fb      	ldr	r3, [r7, #12]
   246f8:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   246fc:	d101      	bne.n	24702 <IntFlashErasePage+0x5e>
            {
                return FLASH_OP_SUCCESS;
   246fe:	23ff      	movs	r3, #255	; 0xff
   24700:	e00a      	b.n	24718 <IntFlashErasePage+0x74>
            }
            else

                erase_counter++;
   24702:	7dfb      	ldrb	r3, [r7, #23]
   24704:	3301      	adds	r3, #1
   24706:	75fb      	strb	r3, [r7, #23]
   24708:	e002      	b.n	24710 <IntFlashErasePage+0x6c>
        }
        else
            erase_counter++;
   2470a:	7dfb      	ldrb	r3, [r7, #23]
   2470c:	3301      	adds	r3, #1
   2470e:	75fb      	strb	r3, [r7, #23]

    }while(erase_counter<MAX_FLASH_OPERATION_ERROR_COUNTER);
   24710:	7dfb      	ldrb	r3, [r7, #23]
   24712:	2b02      	cmp	r3, #2
   24714:	d9d4      	bls.n	246c0 <IntFlashErasePage+0x1c>


    return FLASH_OP_ERASE_ERROR;
   24716:	23f0      	movs	r3, #240	; 0xf0
}
   24718:	4618      	mov	r0, r3
   2471a:	3718      	adds	r7, #24
   2471c:	46bd      	mov	sp, r7
   2471e:	bd80      	pop	{r7, pc}
   24720:	20005140 	.word	0x20005140
   24724:	20005068 	.word	0x20005068

00024728 <SD_flash_operation_callback>:
/**
*   @brief This function is a callback which is called in sys_evt_dispatch() function, after some data is stored or the page erased using sd_flash_xxx() function. It gives us a feedback when the operation is completed and if the data was stored successfully
*   @param uint32_t sys_evt - the number of event which is given by SWIO from softdevice
**/
void SD_flash_operation_callback(uint32_t sys_evt)
{
   24728:	b580      	push	{r7, lr}
   2472a:	b084      	sub	sp, #16
   2472c:	af00      	add	r7, sp, #0
   2472e:	6078      	str	r0, [r7, #4]
    switch(sys_evt)
   24730:	687b      	ldr	r3, [r7, #4]
   24732:	2b02      	cmp	r3, #2
   24734:	d002      	beq.n	2473c <SD_flash_operation_callback+0x14>
   24736:	2b03      	cmp	r3, #3
   24738:	d026      	beq.n	24788 <SD_flash_operation_callback+0x60>
   2473a:	e048      	b.n	247ce <SD_flash_operation_callback+0xa6>
    {
        case NRF_EVT_FLASH_OPERATION_SUCCESS:
        {
            switch(flash_write_or_erase_flag)
   2473c:	4b27      	ldr	r3, [pc, #156]	; (247dc <SD_flash_operation_callback+0xb4>)
   2473e:	781b      	ldrb	r3, [r3, #0]
   24740:	2b0f      	cmp	r3, #15
   24742:	d002      	beq.n	2474a <SD_flash_operation_callback+0x22>
   24744:	2bf0      	cmp	r3, #240	; 0xf0
   24746:	d016      	beq.n	24776 <SD_flash_operation_callback+0x4e>
   24748:	e019      	b.n	2477e <SD_flash_operation_callback+0x56>
            {
                case FLASH_WRITE_OPERATION:
                {
                    uint32_t temp;
                    //  read what was just flashed
                    memcpy(&temp, last_flashed_data_pointer, sizeof(uint32_t));
   2474a:	4b25      	ldr	r3, [pc, #148]	; (247e0 <SD_flash_operation_callback+0xb8>)
   2474c:	6819      	ldr	r1, [r3, #0]
   2474e:	f107 030c 	add.w	r3, r7, #12
   24752:	2204      	movs	r2, #4
   24754:	4618      	mov	r0, r3
   24756:	f006 fdcb 	bl	2b2f0 <memcpy>
                    //  Check if data just read is identical as the last_flashed_data
                    if(last_flashed_data == temp)
   2475a:	4b22      	ldr	r3, [pc, #136]	; (247e4 <SD_flash_operation_callback+0xbc>)
   2475c:	681a      	ldr	r2, [r3, #0]
   2475e:	68fb      	ldr	r3, [r7, #12]
   24760:	429a      	cmp	r2, r3
   24762:	d103      	bne.n	2476c <SD_flash_operation_callback+0x44>
                    {
                        flash_operation_completed_flag = FLASH_OP_SUCCESS;  /// data ok
   24764:	4b20      	ldr	r3, [pc, #128]	; (247e8 <SD_flash_operation_callback+0xc0>)
   24766:	22ff      	movs	r2, #255	; 0xff
   24768:	701a      	strb	r2, [r3, #0]
                    }
                    else
                    {
                        flash_operation_completed_flag = FLASH_OP_WRITE_ERROR;  /// data corrupted
                    }
                    break;
   2476a:	e00c      	b.n	24786 <SD_flash_operation_callback+0x5e>
                        flash_operation_completed_flag = FLASH_OP_WRITE_ERROR;  /// data corrupted
   2476c:	4b1e      	ldr	r3, [pc, #120]	; (247e8 <SD_flash_operation_callback+0xc0>)
   2476e:	220f      	movs	r2, #15
   24770:	701a      	strb	r2, [r3, #0]
                    break;
   24772:	bf00      	nop
   24774:	e007      	b.n	24786 <SD_flash_operation_callback+0x5e>
                }
                case FLASH_ERASE_OPERATION:
                    flash_operation_completed_flag = FLASH_OP_SUCCESS;
   24776:	4b1c      	ldr	r3, [pc, #112]	; (247e8 <SD_flash_operation_callback+0xc0>)
   24778:	22ff      	movs	r2, #255	; 0xff
   2477a:	701a      	strb	r2, [r3, #0]
                    break;
   2477c:	e003      	b.n	24786 <SD_flash_operation_callback+0x5e>
                default:    //  If we do not want to check the stored data
                    flash_operation_completed_flag = FLASH_OP_SUCCESS;
   2477e:	4b1a      	ldr	r3, [pc, #104]	; (247e8 <SD_flash_operation_callback+0xc0>)
   24780:	22ff      	movs	r2, #255	; 0xff
   24782:	701a      	strb	r2, [r3, #0]
                    break;
   24784:	bf00      	nop
            }
            break;
   24786:	e022      	b.n	247ce <SD_flash_operation_callback+0xa6>
        }
        case NRF_EVT_FLASH_OPERATION_ERROR:
            switch(flash_write_or_erase_flag)
   24788:	4b14      	ldr	r3, [pc, #80]	; (247dc <SD_flash_operation_callback+0xb4>)
   2478a:	781b      	ldrb	r3, [r3, #0]
   2478c:	2b0f      	cmp	r3, #15
   2478e:	d118      	bne.n	247c2 <SD_flash_operation_callback+0x9a>
            {
                case FLASH_WRITE_OPERATION:
                    {
                        uint32_t temp;
                        //  read what was just flashed
                        memcpy(&temp, last_flashed_data_pointer, sizeof(uint32_t));
   24790:	4b13      	ldr	r3, [pc, #76]	; (247e0 <SD_flash_operation_callback+0xb8>)
   24792:	6819      	ldr	r1, [r3, #0]
   24794:	f107 0308 	add.w	r3, r7, #8
   24798:	2204      	movs	r2, #4
   2479a:	4618      	mov	r0, r3
   2479c:	f006 fda8 	bl	2b2f0 <memcpy>
                        //  If the data wasn't even stored
                        if(temp == 0xFFFFFFFF)
   247a0:	68bb      	ldr	r3, [r7, #8]
   247a2:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   247a6:	d103      	bne.n	247b0 <SD_flash_operation_callback+0x88>
                        {
                            flash_operation_completed_flag = FLASH_OPERATION_ERROR;
   247a8:	4b0f      	ldr	r3, [pc, #60]	; (247e8 <SD_flash_operation_callback+0xc0>)
   247aa:	22a0      	movs	r2, #160	; 0xa0
   247ac:	701a      	strb	r2, [r3, #0]
                        if(temp != last_flashed_data)
                        {
                            flash_operation_completed_flag = FLASH_OP_WRITE_ERROR;
                        }
                    }
                    break;
   247ae:	e00c      	b.n	247ca <SD_flash_operation_callback+0xa2>
                        if(temp != last_flashed_data)
   247b0:	68ba      	ldr	r2, [r7, #8]
   247b2:	4b0c      	ldr	r3, [pc, #48]	; (247e4 <SD_flash_operation_callback+0xbc>)
   247b4:	681b      	ldr	r3, [r3, #0]
   247b6:	429a      	cmp	r2, r3
   247b8:	d007      	beq.n	247ca <SD_flash_operation_callback+0xa2>
                            flash_operation_completed_flag = FLASH_OP_WRITE_ERROR;
   247ba:	4b0b      	ldr	r3, [pc, #44]	; (247e8 <SD_flash_operation_callback+0xc0>)
   247bc:	220f      	movs	r2, #15
   247be:	701a      	strb	r2, [r3, #0]
                    break;
   247c0:	e003      	b.n	247ca <SD_flash_operation_callback+0xa2>
                default:
                    flash_operation_completed_flag = FLASH_OP_ERASE_ERROR;
   247c2:	4b09      	ldr	r3, [pc, #36]	; (247e8 <SD_flash_operation_callback+0xc0>)
   247c4:	22f0      	movs	r2, #240	; 0xf0
   247c6:	701a      	strb	r2, [r3, #0]
                    break;
   247c8:	e000      	b.n	247cc <SD_flash_operation_callback+0xa4>
                    break;
   247ca:	bf00      	nop
            }
            break;
   247cc:	bf00      	nop
    }
    flash_write_or_erase_flag = 0;  //  clear the flag
   247ce:	4b03      	ldr	r3, [pc, #12]	; (247dc <SD_flash_operation_callback+0xb4>)
   247d0:	2200      	movs	r2, #0
   247d2:	701a      	strb	r2, [r3, #0]
}
   247d4:	bf00      	nop
   247d6:	3710      	adds	r7, #16
   247d8:	46bd      	mov	sp, r7
   247da:	bd80      	pop	{r7, pc}
   247dc:	20005140 	.word	0x20005140
   247e0:	20005148 	.word	0x20005148
   247e4:	20005144 	.word	0x20005144
   247e8:	20005068 	.word	0x20005068

000247ec <NVIC_SystemReset>:
/**
  \brief   System Reset
  \details Initiates a system reset request to reset the MCU.
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
   247ec:	b480      	push	{r7}
   247ee:	af00      	add	r7, sp, #0
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
   247f0:	f3bf 8f4f 	dsb	sy
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
   247f4:	4b05      	ldr	r3, [pc, #20]	; (2480c <NVIC_SystemReset+0x20>)
   247f6:	68db      	ldr	r3, [r3, #12]
   247f8:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
   247fc:	4903      	ldr	r1, [pc, #12]	; (2480c <NVIC_SystemReset+0x20>)
   247fe:	4b04      	ldr	r3, [pc, #16]	; (24810 <NVIC_SystemReset+0x24>)
   24800:	4313      	orrs	r3, r2
   24802:	60cb      	str	r3, [r1, #12]
   24804:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("nop");
   24808:	bf00      	nop
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for (;;)                                                           /* wait until reset */
  {
    __NOP();
   2480a:	e7fd      	b.n	24808 <NVIC_SystemReset+0x1c>
   2480c:	e000ed00 	.word	0xe000ed00
   24810:	05fa0004 	.word	0x05fa0004

00024814 <nrf_gpio_pin_port_decode>:
{
   24814:	b480      	push	{r7}
   24816:	b083      	sub	sp, #12
   24818:	af00      	add	r7, sp, #0
   2481a:	6078      	str	r0, [r7, #4]
    return NRF_GPIO;
   2481c:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
}
   24820:	4618      	mov	r0, r3
   24822:	370c      	adds	r7, #12
   24824:	46bd      	mov	sp, r7
   24826:	bc80      	pop	{r7}
   24828:	4770      	bx	lr

0002482a <nrf_gpio_pin_set>:
{
   2482a:	b580      	push	{r7, lr}
   2482c:	b084      	sub	sp, #16
   2482e:	af00      	add	r7, sp, #0
   24830:	6078      	str	r0, [r7, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   24832:	1d3b      	adds	r3, r7, #4
   24834:	4618      	mov	r0, r3
   24836:	f7ff ffed 	bl	24814 <nrf_gpio_pin_port_decode>
   2483a:	60f8      	str	r0, [r7, #12]
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   2483c:	687b      	ldr	r3, [r7, #4]
   2483e:	2201      	movs	r2, #1
   24840:	fa02 f303 	lsl.w	r3, r2, r3
   24844:	4619      	mov	r1, r3
   24846:	68f8      	ldr	r0, [r7, #12]
   24848:	f000 f819 	bl	2487e <nrf_gpio_port_out_set>
}
   2484c:	bf00      	nop
   2484e:	3710      	adds	r7, #16
   24850:	46bd      	mov	sp, r7
   24852:	bd80      	pop	{r7, pc}

00024854 <nrf_gpio_pin_clear>:
{
   24854:	b580      	push	{r7, lr}
   24856:	b084      	sub	sp, #16
   24858:	af00      	add	r7, sp, #0
   2485a:	6078      	str	r0, [r7, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   2485c:	1d3b      	adds	r3, r7, #4
   2485e:	4618      	mov	r0, r3
   24860:	f7ff ffd8 	bl	24814 <nrf_gpio_pin_port_decode>
   24864:	60f8      	str	r0, [r7, #12]
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   24866:	687b      	ldr	r3, [r7, #4]
   24868:	2201      	movs	r2, #1
   2486a:	fa02 f303 	lsl.w	r3, r2, r3
   2486e:	4619      	mov	r1, r3
   24870:	68f8      	ldr	r0, [r7, #12]
   24872:	f000 f812 	bl	2489a <nrf_gpio_port_out_clear>
}
   24876:	bf00      	nop
   24878:	3710      	adds	r7, #16
   2487a:	46bd      	mov	sp, r7
   2487c:	bd80      	pop	{r7, pc}

0002487e <nrf_gpio_port_out_set>:
{
   2487e:	b480      	push	{r7}
   24880:	b083      	sub	sp, #12
   24882:	af00      	add	r7, sp, #0
   24884:	6078      	str	r0, [r7, #4]
   24886:	6039      	str	r1, [r7, #0]
    p_reg->OUTSET = set_mask;
   24888:	687b      	ldr	r3, [r7, #4]
   2488a:	683a      	ldr	r2, [r7, #0]
   2488c:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
}
   24890:	bf00      	nop
   24892:	370c      	adds	r7, #12
   24894:	46bd      	mov	sp, r7
   24896:	bc80      	pop	{r7}
   24898:	4770      	bx	lr

0002489a <nrf_gpio_port_out_clear>:
{
   2489a:	b480      	push	{r7}
   2489c:	b083      	sub	sp, #12
   2489e:	af00      	add	r7, sp, #0
   248a0:	6078      	str	r0, [r7, #4]
   248a2:	6039      	str	r1, [r7, #0]
    p_reg->OUTCLR = clr_mask;
   248a4:	687b      	ldr	r3, [r7, #4]
   248a6:	683a      	ldr	r2, [r7, #0]
   248a8:	f8c3 250c 	str.w	r2, [r3, #1292]	; 0x50c
}
   248ac:	bf00      	nop
   248ae:	370c      	adds	r7, #12
   248b0:	46bd      	mov	sp, r7
   248b2:	bc80      	pop	{r7}
   248b4:	4770      	bx	lr

000248b6 <sd_nvic_SystemReset>:
    return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
  }
}

__STATIC_INLINE uint32_t sd_nvic_SystemReset(void)
{
   248b6:	b580      	push	{r7, lr}
   248b8:	af00      	add	r7, sp, #0
  NVIC_SystemReset();
   248ba:	f7ff ff97 	bl	247ec <NVIC_SystemReset>
  return NRF_ERROR_SOC_NVIC_SHOULD_NOT_RETURN;
   248be:	f242 0303 	movw	r3, #8195	; 0x2003
}
   248c2:	4618      	mov	r0, r3
   248c4:	bd80      	pop	{r7, pc}
	...

000248c8 <NFCT_IRQHandler>:
static uint8_t      _nfcRxBuffer[NFC_BUFFER_SIZE];

volatile nfc_initialization_state_e nfcInitState = E_NOT_INITIALIZED;

void NFCT_IRQHandler()
{
   248c8:	b580      	push	{r7, lr}
   248ca:	af00      	add	r7, sp, #0
    if (NRF_NFCT->EVENTS_FIELDDETECTED)
   248cc:	4b37      	ldr	r3, [pc, #220]	; (249ac <NFCT_IRQHandler+0xe4>)
   248ce:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   248d2:	2b00      	cmp	r3, #0
   248d4:	d008      	beq.n	248e8 <NFCT_IRQHandler+0x20>
    {
        NRF_NFCT->EVENTS_FIELDDETECTED = 0;
   248d6:	4b35      	ldr	r3, [pc, #212]	; (249ac <NFCT_IRQHandler+0xe4>)
   248d8:	2200      	movs	r2, #0
   248da:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
        NfcActivate();
   248de:	f000 f875 	bl	249cc <NfcActivate>
        nrf_gpio_pin_clear(17);
   248e2:	2011      	movs	r0, #17
   248e4:	f7ff ffb6 	bl	24854 <nrf_gpio_pin_clear>
    }


    if (NRF_NFCT->EVENTS_READY)
   248e8:	4b30      	ldr	r3, [pc, #192]	; (249ac <NFCT_IRQHandler+0xe4>)
   248ea:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
   248ee:	2b00      	cmp	r3, #0
   248f0:	d00d      	beq.n	2490e <NFCT_IRQHandler+0x46>
    {
        NRF_NFCT->EVENTS_READY = 0;
   248f2:	4b2e      	ldr	r3, [pc, #184]	; (249ac <NFCT_IRQHandler+0xe4>)
   248f4:	2200      	movs	r2, #0
   248f6:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
        if (nfcInitState == E_DEV_NAME_PREPARED)
   248fa:	4b2d      	ldr	r3, [pc, #180]	; (249b0 <NFCT_IRQHandler+0xe8>)
   248fc:	781b      	ldrb	r3, [r3, #0]
   248fe:	b2db      	uxtb	r3, r3
   24900:	2b01      	cmp	r3, #1
   24902:	d102      	bne.n	2490a <NFCT_IRQHandler+0x42>
        {
            NfcTriggerTx();
   24904:	f000 f86e 	bl	249e4 <NfcTriggerTx>
   24908:	e001      	b.n	2490e <NFCT_IRQHandler+0x46>
        }
        else
        {
            NfcActivate();
   2490a:	f000 f85f 	bl	249cc <NfcActivate>
        }
    }

    if (NRF_NFCT->EVENTS_ENDTX)
   2490e:	4b27      	ldr	r3, [pc, #156]	; (249ac <NFCT_IRQHandler+0xe4>)
   24910:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
   24914:	2b00      	cmp	r3, #0
   24916:	d019      	beq.n	2494c <NFCT_IRQHandler+0x84>
    {
        NRF_NFCT->EVENTS_ENDTX = 0;
   24918:	4b24      	ldr	r3, [pc, #144]	; (249ac <NFCT_IRQHandler+0xe4>)
   2491a:	2200      	movs	r2, #0
   2491c:	f8c3 2130 	str.w	r2, [r3, #304]	; 0x130
        if (nfcInitState == E_DEV_NAME_PREPARED)
   24920:	4b23      	ldr	r3, [pc, #140]	; (249b0 <NFCT_IRQHandler+0xe8>)
   24922:	781b      	ldrb	r3, [r3, #0]
   24924:	b2db      	uxtb	r3, r3
   24926:	2b01      	cmp	r3, #1
   24928:	d103      	bne.n	24932 <NFCT_IRQHandler+0x6a>
        {
            nfcInitState = E_SENT_DEVICE_NAME;
   2492a:	4b21      	ldr	r3, [pc, #132]	; (249b0 <NFCT_IRQHandler+0xe8>)
   2492c:	2202      	movs	r2, #2
   2492e:	701a      	strb	r2, [r3, #0]
   24930:	e00a      	b.n	24948 <NFCT_IRQHandler+0x80>
        }
        else
        if (nfcInitState == E_RECEIVED_MAIN_KEY)
   24932:	4b1f      	ldr	r3, [pc, #124]	; (249b0 <NFCT_IRQHandler+0xe8>)
   24934:	781b      	ldrb	r3, [r3, #0]
   24936:	b2db      	uxtb	r3, r3
   24938:	2b03      	cmp	r3, #3
   2493a:	d103      	bne.n	24944 <NFCT_IRQHandler+0x7c>
        {
            nfcInitState = E_SENT_DEACTIVATING_COMMAND;
   2493c:	4b1c      	ldr	r3, [pc, #112]	; (249b0 <NFCT_IRQHandler+0xe8>)
   2493e:	2204      	movs	r2, #4
   24940:	701a      	strb	r2, [r3, #0]
   24942:	e001      	b.n	24948 <NFCT_IRQHandler+0x80>
        }
        else    // FORBIDDEN STATE
        {
            sd_nvic_SystemReset();
   24944:	f7ff ffb7 	bl	248b6 <sd_nvic_SystemReset>
        }

        NfcEnableRx();
   24948:	f000 f85e 	bl	24a08 <NfcEnableRx>
    }

    if (NRF_NFCT->EVENTS_ENDRX)
   2494c:	4b17      	ldr	r3, [pc, #92]	; (249ac <NFCT_IRQHandler+0xe4>)
   2494e:	f8d3 312c 	ldr.w	r3, [r3, #300]	; 0x12c
   24952:	2b00      	cmp	r3, #0
   24954:	d019      	beq.n	2498a <NFCT_IRQHandler+0xc2>
    {
        NRF_NFCT->EVENTS_ENDRX = 0;
   24956:	4b15      	ldr	r3, [pc, #84]	; (249ac <NFCT_IRQHandler+0xe4>)
   24958:	2200      	movs	r2, #0
   2495a:	f8c3 212c 	str.w	r2, [r3, #300]	; 0x12c

        if (nfcInitState == E_SENT_DEVICE_NAME)
   2495e:	4b14      	ldr	r3, [pc, #80]	; (249b0 <NFCT_IRQHandler+0xe8>)
   24960:	781b      	ldrb	r3, [r3, #0]
   24962:	b2db      	uxtb	r3, r3
   24964:	2b02      	cmp	r3, #2
   24966:	d103      	bne.n	24970 <NFCT_IRQHandler+0xa8>
        {
            nfcInitState = E_RECEIVED_MAIN_KEY;
   24968:	4b11      	ldr	r3, [pc, #68]	; (249b0 <NFCT_IRQHandler+0xe8>)
   2496a:	2203      	movs	r2, #3
   2496c:	701a      	strb	r2, [r3, #0]
   2496e:	e00a      	b.n	24986 <NFCT_IRQHandler+0xbe>
        }
        else
        if (nfcInitState == E_SENT_DEACTIVATING_COMMAND)
   24970:	4b0f      	ldr	r3, [pc, #60]	; (249b0 <NFCT_IRQHandler+0xe8>)
   24972:	781b      	ldrb	r3, [r3, #0]
   24974:	b2db      	uxtb	r3, r3
   24976:	2b04      	cmp	r3, #4
   24978:	d103      	bne.n	24982 <NFCT_IRQHandler+0xba>
        {
            nfcInitState = E_RECEIVED_OK_RESPONSE;
   2497a:	4b0d      	ldr	r3, [pc, #52]	; (249b0 <NFCT_IRQHandler+0xe8>)
   2497c:	2205      	movs	r2, #5
   2497e:	701a      	strb	r2, [r3, #0]
   24980:	e001      	b.n	24986 <NFCT_IRQHandler+0xbe>
        }
        else    // FORBIDDEN STATE
        {
            sd_nvic_SystemReset();
   24982:	f7ff ff98 	bl	248b6 <sd_nvic_SystemReset>
        }

        NfcActivate();
   24986:	f000 f821 	bl	249cc <NfcActivate>
    }

    if (NRF_NFCT->EVENTS_FIELDLOST)
   2498a:	4b08      	ldr	r3, [pc, #32]	; (249ac <NFCT_IRQHandler+0xe4>)
   2498c:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
   24990:	2b00      	cmp	r3, #0
   24992:	d008      	beq.n	249a6 <NFCT_IRQHandler+0xde>
    {
        NRF_NFCT->EVENTS_FIELDLOST = 0;
   24994:	4b05      	ldr	r3, [pc, #20]	; (249ac <NFCT_IRQHandler+0xe4>)
   24996:	2200      	movs	r2, #0
   24998:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
        NfcStartSensingField();
   2499c:	f000 f80a 	bl	249b4 <NfcStartSensingField>
        nrf_gpio_pin_set(17);
   249a0:	2011      	movs	r0, #17
   249a2:	f7ff ff42 	bl	2482a <nrf_gpio_pin_set>
    }
}
   249a6:	bf00      	nop
   249a8:	bd80      	pop	{r7, pc}
   249aa:	bf00      	nop
   249ac:	40005000 	.word	0x40005000
   249b0:	200051d0 	.word	0x200051d0

000249b4 <NfcStartSensingField>:
    NRF_NFCT->SHORTS = NFCT_SHORTS_FIELDDETECTED_ACTIVATE_Enabled << NFCT_SHORTS_FIELDDETECTED_ACTIVATE_Pos;

}

void NfcStartSensingField()
{
   249b4:	b480      	push	{r7}
   249b6:	af00      	add	r7, sp, #0
    NRF_NFCT->TASKS_SENSE = 1;
   249b8:	4b03      	ldr	r3, [pc, #12]	; (249c8 <NfcStartSensingField+0x14>)
   249ba:	2201      	movs	r2, #1
   249bc:	609a      	str	r2, [r3, #8]
}
   249be:	bf00      	nop
   249c0:	46bd      	mov	sp, r7
   249c2:	bc80      	pop	{r7}
   249c4:	4770      	bx	lr
   249c6:	bf00      	nop
   249c8:	40005000 	.word	0x40005000

000249cc <NfcActivate>:

void NfcActivate()
{
   249cc:	b480      	push	{r7}
   249ce:	af00      	add	r7, sp, #0
    NRF_NFCT->TASKS_ACTIVATE = 1;
   249d0:	4b03      	ldr	r3, [pc, #12]	; (249e0 <NfcActivate+0x14>)
   249d2:	2201      	movs	r2, #1
   249d4:	601a      	str	r2, [r3, #0]
}
   249d6:	bf00      	nop
   249d8:	46bd      	mov	sp, r7
   249da:	bc80      	pop	{r7}
   249dc:	4770      	bx	lr
   249de:	bf00      	nop
   249e0:	40005000 	.word	0x40005000

000249e4 <NfcTriggerTx>:

    memcpy(_nfcTxBuffer, data, dataSize);
}

void NfcTriggerTx()
{
   249e4:	b480      	push	{r7}
   249e6:	af00      	add	r7, sp, #0
    NRF_NFCT->PACKETPTR = (uint32_t)_nfcTxBuffer;
   249e8:	4b05      	ldr	r3, [pc, #20]	; (24a00 <NfcTriggerTx+0x1c>)
   249ea:	4a06      	ldr	r2, [pc, #24]	; (24a04 <NfcTriggerTx+0x20>)
   249ec:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
    NRF_NFCT->TASKS_STARTTX = 1;
   249f0:	4b03      	ldr	r3, [pc, #12]	; (24a00 <NfcTriggerTx+0x1c>)
   249f2:	2201      	movs	r2, #1
   249f4:	60da      	str	r2, [r3, #12]
}
   249f6:	bf00      	nop
   249f8:	46bd      	mov	sp, r7
   249fa:	bc80      	pop	{r7}
   249fc:	4770      	bx	lr
   249fe:	bf00      	nop
   24a00:	40005000 	.word	0x40005000
   24a04:	20005150 	.word	0x20005150

00024a08 <NfcEnableRx>:

void NfcEnableRx()
{
   24a08:	b480      	push	{r7}
   24a0a:	af00      	add	r7, sp, #0
    NRF_NFCT->PACKETPTR = (uint32_t)_nfcRxBuffer;
   24a0c:	4b05      	ldr	r3, [pc, #20]	; (24a24 <NfcEnableRx+0x1c>)
   24a0e:	4a06      	ldr	r2, [pc, #24]	; (24a28 <NfcEnableRx+0x20>)
   24a10:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
    NRF_NFCT->TASKS_ENABLERXDATA = 1;
   24a14:	4b03      	ldr	r3, [pc, #12]	; (24a24 <NfcEnableRx+0x1c>)
   24a16:	2201      	movs	r2, #1
   24a18:	61da      	str	r2, [r3, #28]
}
   24a1a:	bf00      	nop
   24a1c:	46bd      	mov	sp, r7
   24a1e:	bc80      	pop	{r7}
   24a20:	4770      	bx	lr
   24a22:	bf00      	nop
   24a24:	40005000 	.word	0x40005000
   24a28:	20005190 	.word	0x20005190

00024a2c <NVIC_EnableIRQ>:
{
   24a2c:	b480      	push	{r7}
   24a2e:	b083      	sub	sp, #12
   24a30:	af00      	add	r7, sp, #0
   24a32:	4603      	mov	r3, r0
   24a34:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   24a36:	79fb      	ldrb	r3, [r7, #7]
   24a38:	f003 021f 	and.w	r2, r3, #31
   24a3c:	4906      	ldr	r1, [pc, #24]	; (24a58 <NVIC_EnableIRQ+0x2c>)
   24a3e:	f997 3007 	ldrsb.w	r3, [r7, #7]
   24a42:	095b      	lsrs	r3, r3, #5
   24a44:	2001      	movs	r0, #1
   24a46:	fa00 f202 	lsl.w	r2, r0, r2
   24a4a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   24a4e:	bf00      	nop
   24a50:	370c      	adds	r7, #12
   24a52:	46bd      	mov	sp, r7
   24a54:	bc80      	pop	{r7}
   24a56:	4770      	bx	lr
   24a58:	e000e100 	.word	0xe000e100

00024a5c <NVIC_SetPriority>:
{
   24a5c:	b480      	push	{r7}
   24a5e:	b083      	sub	sp, #12
   24a60:	af00      	add	r7, sp, #0
   24a62:	4603      	mov	r3, r0
   24a64:	6039      	str	r1, [r7, #0]
   24a66:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) < 0)
   24a68:	f997 3007 	ldrsb.w	r3, [r7, #7]
   24a6c:	2b00      	cmp	r3, #0
   24a6e:	da0b      	bge.n	24a88 <NVIC_SetPriority+0x2c>
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   24a70:	683b      	ldr	r3, [r7, #0]
   24a72:	b2da      	uxtb	r2, r3
   24a74:	490c      	ldr	r1, [pc, #48]	; (24aa8 <NVIC_SetPriority+0x4c>)
   24a76:	79fb      	ldrb	r3, [r7, #7]
   24a78:	f003 030f 	and.w	r3, r3, #15
   24a7c:	3b04      	subs	r3, #4
   24a7e:	0152      	lsls	r2, r2, #5
   24a80:	b2d2      	uxtb	r2, r2
   24a82:	440b      	add	r3, r1
   24a84:	761a      	strb	r2, [r3, #24]
}
   24a86:	e009      	b.n	24a9c <NVIC_SetPriority+0x40>
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   24a88:	683b      	ldr	r3, [r7, #0]
   24a8a:	b2da      	uxtb	r2, r3
   24a8c:	4907      	ldr	r1, [pc, #28]	; (24aac <NVIC_SetPriority+0x50>)
   24a8e:	f997 3007 	ldrsb.w	r3, [r7, #7]
   24a92:	0152      	lsls	r2, r2, #5
   24a94:	b2d2      	uxtb	r2, r2
   24a96:	440b      	add	r3, r1
   24a98:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
   24a9c:	bf00      	nop
   24a9e:	370c      	adds	r7, #12
   24aa0:	46bd      	mov	sp, r7
   24aa2:	bc80      	pop	{r7}
   24aa4:	4770      	bx	lr
   24aa6:	bf00      	nop
   24aa8:	e000ed00 	.word	0xe000ed00
   24aac:	e000e100 	.word	0xe000e100

00024ab0 <NVIC_GetPriority>:
{
   24ab0:	b480      	push	{r7}
   24ab2:	b083      	sub	sp, #12
   24ab4:	af00      	add	r7, sp, #0
   24ab6:	4603      	mov	r3, r0
   24ab8:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) < 0)
   24aba:	f997 3007 	ldrsb.w	r3, [r7, #7]
   24abe:	2b00      	cmp	r3, #0
   24ac0:	da0a      	bge.n	24ad8 <NVIC_GetPriority+0x28>
    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
   24ac2:	4a0c      	ldr	r2, [pc, #48]	; (24af4 <NVIC_GetPriority+0x44>)
   24ac4:	79fb      	ldrb	r3, [r7, #7]
   24ac6:	f003 030f 	and.w	r3, r3, #15
   24aca:	3b04      	subs	r3, #4
   24acc:	4413      	add	r3, r2
   24ace:	7e1b      	ldrb	r3, [r3, #24]
   24ad0:	b2db      	uxtb	r3, r3
   24ad2:	095b      	lsrs	r3, r3, #5
   24ad4:	b2db      	uxtb	r3, r3
   24ad6:	e008      	b.n	24aea <NVIC_GetPriority+0x3a>
    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
   24ad8:	4a07      	ldr	r2, [pc, #28]	; (24af8 <NVIC_GetPriority+0x48>)
   24ada:	f997 3007 	ldrsb.w	r3, [r7, #7]
   24ade:	4413      	add	r3, r2
   24ae0:	f893 3300 	ldrb.w	r3, [r3, #768]	; 0x300
   24ae4:	b2db      	uxtb	r3, r3
   24ae6:	095b      	lsrs	r3, r3, #5
   24ae8:	b2db      	uxtb	r3, r3
}
   24aea:	4618      	mov	r0, r3
   24aec:	370c      	adds	r7, #12
   24aee:	46bd      	mov	sp, r7
   24af0:	bc80      	pop	{r7}
   24af2:	4770      	bx	lr
   24af4:	e000ed00 	.word	0xe000ed00
   24af8:	e000e100 	.word	0xe000e100

00024afc <sd_app_evt_wait>:
SVCALL(SD_APP_EVT_WAIT, uint32_t, sd_app_evt_wait(void));
   24afc:	df3e      	svc	62	; 0x3e
   24afe:	4770      	bx	lr
   24b00:	bf00      	nop
   24b02:	4618      	mov	r0, r3

00024b04 <__sd_nvic_app_accessible_irq>:
{
   24b04:	b480      	push	{r7}
   24b06:	b083      	sub	sp, #12
   24b08:	af00      	add	r7, sp, #0
   24b0a:	4603      	mov	r3, r0
   24b0c:	71fb      	strb	r3, [r7, #7]
  if (IRQn < 32)
   24b0e:	f997 3007 	ldrsb.w	r3, [r7, #7]
   24b12:	2b1f      	cmp	r3, #31
   24b14:	dc0c      	bgt.n	24b30 <__sd_nvic_app_accessible_irq+0x2c>
    return ((1UL<<IRQn) & __NRF_NVIC_APP_IRQS_0) != 0;
   24b16:	f997 3007 	ldrsb.w	r3, [r7, #7]
   24b1a:	4a10      	ldr	r2, [pc, #64]	; (24b5c <__sd_nvic_app_accessible_irq+0x58>)
   24b1c:	fa22 f303 	lsr.w	r3, r2, r3
   24b20:	f003 0301 	and.w	r3, r3, #1
   24b24:	2b00      	cmp	r3, #0
   24b26:	bf14      	ite	ne
   24b28:	2301      	movne	r3, #1
   24b2a:	2300      	moveq	r3, #0
   24b2c:	b2db      	uxtb	r3, r3
   24b2e:	e010      	b.n	24b52 <__sd_nvic_app_accessible_irq+0x4e>
  else if (IRQn < 64)
   24b30:	f997 3007 	ldrsb.w	r3, [r7, #7]
   24b34:	2b3f      	cmp	r3, #63	; 0x3f
   24b36:	dc0b      	bgt.n	24b50 <__sd_nvic_app_accessible_irq+0x4c>
    return ((1UL<<(IRQn-32)) & __NRF_NVIC_APP_IRQS_1) != 0;
   24b38:	f997 3007 	ldrsb.w	r3, [r7, #7]
   24b3c:	3b20      	subs	r3, #32
   24b3e:	2201      	movs	r2, #1
   24b40:	fa02 f303 	lsl.w	r3, r2, r3
   24b44:	2b00      	cmp	r3, #0
   24b46:	bf14      	ite	ne
   24b48:	2301      	movne	r3, #1
   24b4a:	2300      	moveq	r3, #0
   24b4c:	b2db      	uxtb	r3, r3
   24b4e:	e000      	b.n	24b52 <__sd_nvic_app_accessible_irq+0x4e>
    return 1;
   24b50:	2301      	movs	r3, #1
}
   24b52:	4618      	mov	r0, r3
   24b54:	370c      	adds	r7, #12
   24b56:	46bd      	mov	sp, r7
   24b58:	bc80      	pop	{r7}
   24b5a:	4770      	bx	lr
   24b5c:	bdff06fc 	.word	0xbdff06fc

00024b60 <__sd_nvic_is_app_accessible_priority>:
{
   24b60:	b480      	push	{r7}
   24b62:	b083      	sub	sp, #12
   24b64:	af00      	add	r7, sp, #0
   24b66:	6078      	str	r0, [r7, #4]
  if(priority >= (1 << __NVIC_PRIO_BITS))
   24b68:	687b      	ldr	r3, [r7, #4]
   24b6a:	2b07      	cmp	r3, #7
   24b6c:	d901      	bls.n	24b72 <__sd_nvic_is_app_accessible_priority+0x12>
    return 0;
   24b6e:	2300      	movs	r3, #0
   24b70:	e00b      	b.n	24b8a <__sd_nvic_is_app_accessible_priority+0x2a>
  if(   priority == 0
   24b72:	687b      	ldr	r3, [r7, #4]
   24b74:	2b00      	cmp	r3, #0
   24b76:	d005      	beq.n	24b84 <__sd_nvic_is_app_accessible_priority+0x24>
     || priority == 1
   24b78:	687b      	ldr	r3, [r7, #4]
   24b7a:	2b01      	cmp	r3, #1
   24b7c:	d002      	beq.n	24b84 <__sd_nvic_is_app_accessible_priority+0x24>
     || priority == 4
   24b7e:	687b      	ldr	r3, [r7, #4]
   24b80:	2b04      	cmp	r3, #4
   24b82:	d101      	bne.n	24b88 <__sd_nvic_is_app_accessible_priority+0x28>
    return 0;
   24b84:	2300      	movs	r3, #0
   24b86:	e000      	b.n	24b8a <__sd_nvic_is_app_accessible_priority+0x2a>
  return 1;
   24b88:	2301      	movs	r3, #1
}
   24b8a:	4618      	mov	r0, r3
   24b8c:	370c      	adds	r7, #12
   24b8e:	46bd      	mov	sp, r7
   24b90:	bc80      	pop	{r7}
   24b92:	4770      	bx	lr

00024b94 <sd_nvic_EnableIRQ>:
{
   24b94:	b580      	push	{r7, lr}
   24b96:	b082      	sub	sp, #8
   24b98:	af00      	add	r7, sp, #0
   24b9a:	4603      	mov	r3, r0
   24b9c:	71fb      	strb	r3, [r7, #7]
  if (!__sd_nvic_app_accessible_irq(IRQn))
   24b9e:	f997 3007 	ldrsb.w	r3, [r7, #7]
   24ba2:	4618      	mov	r0, r3
   24ba4:	f7ff ffae 	bl	24b04 <__sd_nvic_app_accessible_irq>
   24ba8:	4603      	mov	r3, r0
   24baa:	2b00      	cmp	r3, #0
   24bac:	d102      	bne.n	24bb4 <sd_nvic_EnableIRQ+0x20>
    return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
   24bae:	f242 0301 	movw	r3, #8193	; 0x2001
   24bb2:	e02d      	b.n	24c10 <sd_nvic_EnableIRQ+0x7c>
  if (!__sd_nvic_is_app_accessible_priority(NVIC_GetPriority(IRQn)))
   24bb4:	f997 3007 	ldrsb.w	r3, [r7, #7]
   24bb8:	4618      	mov	r0, r3
   24bba:	f7ff ff79 	bl	24ab0 <NVIC_GetPriority>
   24bbe:	4603      	mov	r3, r0
   24bc0:	4618      	mov	r0, r3
   24bc2:	f7ff ffcd 	bl	24b60 <__sd_nvic_is_app_accessible_priority>
   24bc6:	4603      	mov	r3, r0
   24bc8:	2b00      	cmp	r3, #0
   24bca:	d102      	bne.n	24bd2 <sd_nvic_EnableIRQ+0x3e>
    return NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED;
   24bcc:	f242 0302 	movw	r3, #8194	; 0x2002
   24bd0:	e01e      	b.n	24c10 <sd_nvic_EnableIRQ+0x7c>
  if (nrf_nvic_state.__cr_flag)
   24bd2:	4b11      	ldr	r3, [pc, #68]	; (24c18 <sd_nvic_EnableIRQ+0x84>)
   24bd4:	689b      	ldr	r3, [r3, #8]
   24bd6:	2b00      	cmp	r3, #0
   24bd8:	d014      	beq.n	24c04 <sd_nvic_EnableIRQ+0x70>
    nrf_nvic_state.__irq_masks[(uint32_t)((int32_t)IRQn) >> 5] |= (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F));
   24bda:	f997 3007 	ldrsb.w	r3, [r7, #7]
   24bde:	095b      	lsrs	r3, r3, #5
   24be0:	4a0d      	ldr	r2, [pc, #52]	; (24c18 <sd_nvic_EnableIRQ+0x84>)
   24be2:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
   24be6:	79fb      	ldrb	r3, [r7, #7]
   24be8:	f003 031f 	and.w	r3, r3, #31
   24bec:	2101      	movs	r1, #1
   24bee:	fa01 f303 	lsl.w	r3, r1, r3
   24bf2:	4619      	mov	r1, r3
   24bf4:	f997 3007 	ldrsb.w	r3, [r7, #7]
   24bf8:	095b      	lsrs	r3, r3, #5
   24bfa:	430a      	orrs	r2, r1
   24bfc:	4906      	ldr	r1, [pc, #24]	; (24c18 <sd_nvic_EnableIRQ+0x84>)
   24bfe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
   24c02:	e004      	b.n	24c0e <sd_nvic_EnableIRQ+0x7a>
    NVIC_EnableIRQ(IRQn);
   24c04:	f997 3007 	ldrsb.w	r3, [r7, #7]
   24c08:	4618      	mov	r0, r3
   24c0a:	f7ff ff0f 	bl	24a2c <NVIC_EnableIRQ>
  return NRF_SUCCESS;
   24c0e:	2300      	movs	r3, #0
}
   24c10:	4618      	mov	r0, r3
   24c12:	3708      	adds	r7, #8
   24c14:	46bd      	mov	sp, r7
   24c16:	bd80      	pop	{r7, pc}
   24c18:	20005134 	.word	0x20005134

00024c1c <sd_nvic_SetPriority>:
{
   24c1c:	b580      	push	{r7, lr}
   24c1e:	b082      	sub	sp, #8
   24c20:	af00      	add	r7, sp, #0
   24c22:	4603      	mov	r3, r0
   24c24:	6039      	str	r1, [r7, #0]
   24c26:	71fb      	strb	r3, [r7, #7]
  if (!__sd_nvic_app_accessible_irq(IRQn))
   24c28:	f997 3007 	ldrsb.w	r3, [r7, #7]
   24c2c:	4618      	mov	r0, r3
   24c2e:	f7ff ff69 	bl	24b04 <__sd_nvic_app_accessible_irq>
   24c32:	4603      	mov	r3, r0
   24c34:	2b00      	cmp	r3, #0
   24c36:	d102      	bne.n	24c3e <sd_nvic_SetPriority+0x22>
    return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
   24c38:	f242 0301 	movw	r3, #8193	; 0x2001
   24c3c:	e00f      	b.n	24c5e <sd_nvic_SetPriority+0x42>
  if (!__sd_nvic_is_app_accessible_priority(priority))
   24c3e:	6838      	ldr	r0, [r7, #0]
   24c40:	f7ff ff8e 	bl	24b60 <__sd_nvic_is_app_accessible_priority>
   24c44:	4603      	mov	r3, r0
   24c46:	2b00      	cmp	r3, #0
   24c48:	d102      	bne.n	24c50 <sd_nvic_SetPriority+0x34>
    return NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED;
   24c4a:	f242 0302 	movw	r3, #8194	; 0x2002
   24c4e:	e006      	b.n	24c5e <sd_nvic_SetPriority+0x42>
  NVIC_SetPriority(IRQn, (uint32_t)priority);
   24c50:	f997 3007 	ldrsb.w	r3, [r7, #7]
   24c54:	6839      	ldr	r1, [r7, #0]
   24c56:	4618      	mov	r0, r3
   24c58:	f7ff ff00 	bl	24a5c <NVIC_SetPriority>
  return NRF_SUCCESS;
   24c5c:	2300      	movs	r3, #0
}
   24c5e:	4618      	mov	r0, r3
   24c60:	3708      	adds	r7, #8
   24c62:	46bd      	mov	sp, r7
   24c64:	bd80      	pop	{r7, pc}
	...

00024c68 <RTC1_IRQHandler>:
}
#endif


void RTC1_IRQHandler()
{
   24c68:	b580      	push	{r7, lr}
   24c6a:	af00      	add	r7, sp, #0
    if (NRF_RTC1->EVENTS_TICK)
   24c6c:	4b2a      	ldr	r3, [pc, #168]	; (24d18 <RTC1_IRQHandler+0xb0>)
   24c6e:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
   24c72:	2b00      	cmp	r3, #0
   24c74:	d003      	beq.n	24c7e <RTC1_IRQHandler+0x16>
    {
        NRF_RTC1->EVENTS_TICK = 0;
   24c76:	4b28      	ldr	r3, [pc, #160]	; (24d18 <RTC1_IRQHandler+0xb0>)
   24c78:	2200      	movs	r2, #0
   24c7a:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    }

	if (NRF_RTC1->EVENTS_COMPARE[DELAY_REGISTER_MAIN])			/*< RTC DELAY */
   24c7e:	4b26      	ldr	r3, [pc, #152]	; (24d18 <RTC1_IRQHandler+0xb0>)
   24c80:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
   24c84:	2b00      	cmp	r3, #0
   24c86:	d006      	beq.n	24c96 <RTC1_IRQHandler+0x2e>
	{
		NRF_RTC1->EVENTS_COMPARE[DELAY_REGISTER_MAIN] = 0;
   24c88:	4b23      	ldr	r3, [pc, #140]	; (24d18 <RTC1_IRQHandler+0xb0>)
   24c8a:	2200      	movs	r2, #0
   24c8c:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
		rtc1_delay_completed_flag = true;
   24c90:	4b22      	ldr	r3, [pc, #136]	; (24d1c <RTC1_IRQHandler+0xb4>)
   24c92:	2201      	movs	r2, #1
   24c94:	701a      	strb	r2, [r3, #0]
	}

	if (NRF_RTC1->EVENTS_COMPARE[TIMEOUT_REGISTER_MAIN])		/*< RTC TIMEOUT */
   24c96:	4b20      	ldr	r3, [pc, #128]	; (24d18 <RTC1_IRQHandler+0xb0>)
   24c98:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
   24c9c:	2b00      	cmp	r3, #0
   24c9e:	d00a      	beq.n	24cb6 <RTC1_IRQHandler+0x4e>
	{
		NRF_RTC1->EVENTS_COMPARE[TIMEOUT_REGISTER_MAIN] = 0;
   24ca0:	4b1d      	ldr	r3, [pc, #116]	; (24d18 <RTC1_IRQHandler+0xb0>)
   24ca2:	2200      	movs	r2, #0
   24ca4:	f8c3 2144 	str.w	r2, [r3, #324]	; 0x144
		RTCDisableComparingReg(NRF_RTC1, TIMEOUT_REGISTER_MAIN);
   24ca8:	2101      	movs	r1, #1
   24caa:	481b      	ldr	r0, [pc, #108]	; (24d18 <RTC1_IRQHandler+0xb0>)
   24cac:	f000 f99c 	bl	24fe8 <RTCDisableComparingReg>
		rtcTimeoutArray[TIMEOUT_REGISTER_MAIN - 1].timeoutTriggeredFlag = true;
   24cb0:	4b1b      	ldr	r3, [pc, #108]	; (24d20 <RTC1_IRQHandler+0xb8>)
   24cb2:	2201      	movs	r2, #1
   24cb4:	705a      	strb	r2, [r3, #1]
	}

	if (NRF_RTC1->EVENTS_COMPARE[TIMEOUT_REGISTER_SECOND])		/*< RTC TIMEOUT SECOND */
   24cb6:	4b18      	ldr	r3, [pc, #96]	; (24d18 <RTC1_IRQHandler+0xb0>)
   24cb8:	f8d3 3148 	ldr.w	r3, [r3, #328]	; 0x148
   24cbc:	2b00      	cmp	r3, #0
   24cbe:	d00a      	beq.n	24cd6 <RTC1_IRQHandler+0x6e>
	{
		NRF_RTC1->EVENTS_COMPARE[TIMEOUT_REGISTER_SECOND] = 0;
   24cc0:	4b15      	ldr	r3, [pc, #84]	; (24d18 <RTC1_IRQHandler+0xb0>)
   24cc2:	2200      	movs	r2, #0
   24cc4:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148
		RTCDisableComparingReg(NRF_RTC1, TIMEOUT_REGISTER_SECOND);
   24cc8:	2102      	movs	r1, #2
   24cca:	4813      	ldr	r0, [pc, #76]	; (24d18 <RTC1_IRQHandler+0xb0>)
   24ccc:	f000 f98c 	bl	24fe8 <RTCDisableComparingReg>
		rtcTimeoutArray[TIMEOUT_REGISTER_SECOND - 1].timeoutTriggeredFlag = true;
   24cd0:	4b13      	ldr	r3, [pc, #76]	; (24d20 <RTC1_IRQHandler+0xb8>)
   24cd2:	2201      	movs	r2, #1
   24cd4:	70da      	strb	r2, [r3, #3]
	}

	if (NRF_RTC1->EVENTS_COMPARE[TIMEOUT_REGISTER_THIRD])		/*< RTC TIMEOUT THIRD */
   24cd6:	4b10      	ldr	r3, [pc, #64]	; (24d18 <RTC1_IRQHandler+0xb0>)
   24cd8:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
   24cdc:	2b00      	cmp	r3, #0
   24cde:	d00a      	beq.n	24cf6 <RTC1_IRQHandler+0x8e>
	{
		NRF_RTC1->EVENTS_COMPARE[TIMEOUT_REGISTER_THIRD] = 0;
   24ce0:	4b0d      	ldr	r3, [pc, #52]	; (24d18 <RTC1_IRQHandler+0xb0>)
   24ce2:	2200      	movs	r2, #0
   24ce4:	f8c3 214c 	str.w	r2, [r3, #332]	; 0x14c
		RTCDisableComparingReg(NRF_RTC1, TIMEOUT_REGISTER_THIRD);
   24ce8:	2103      	movs	r1, #3
   24cea:	480b      	ldr	r0, [pc, #44]	; (24d18 <RTC1_IRQHandler+0xb0>)
   24cec:	f000 f97c 	bl	24fe8 <RTCDisableComparingReg>
		rtcTimeoutArray[TIMEOUT_REGISTER_THIRD - 1].timeoutTriggeredFlag = true;
   24cf0:	4b0b      	ldr	r3, [pc, #44]	; (24d20 <RTC1_IRQHandler+0xb8>)
   24cf2:	2201      	movs	r2, #1
   24cf4:	715a      	strb	r2, [r3, #5]
	}

	if (NRF_RTC1->EVENTS_OVRFLW)
   24cf6:	4b08      	ldr	r3, [pc, #32]	; (24d18 <RTC1_IRQHandler+0xb0>)
   24cf8:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   24cfc:	2b00      	cmp	r3, #0
   24cfe:	d009      	beq.n	24d14 <RTC1_IRQHandler+0xac>
	{
	    NRF_RTC1->EVENTS_OVRFLW = 0;
   24d00:	4b05      	ldr	r3, [pc, #20]	; (24d18 <RTC1_IRQHandler+0xb0>)
   24d02:	2200      	movs	r2, #0
   24d04:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
	    rtc_timestamp_partial += 512;
   24d08:	4b06      	ldr	r3, [pc, #24]	; (24d24 <RTC1_IRQHandler+0xbc>)
   24d0a:	681b      	ldr	r3, [r3, #0]
   24d0c:	f503 7300 	add.w	r3, r3, #512	; 0x200
   24d10:	4a04      	ldr	r2, [pc, #16]	; (24d24 <RTC1_IRQHandler+0xbc>)
   24d12:	6013      	str	r3, [r2, #0]
	}
}
   24d14:	bf00      	nop
   24d16:	bd80      	pop	{r7, pc}
   24d18:	40011000 	.word	0x40011000
   24d1c:	20005461 	.word	0x20005461
   24d20:	20005454 	.word	0x20005454
   24d24:	2000545c 	.word	0x2000545c

00024d28 <RTC2_IRQHandler>:

void RTC2_IRQHandler()
{
   24d28:	b480      	push	{r7}
   24d2a:	af00      	add	r7, sp, #0
    if (NRF_RTC2->EVENTS_TICK)
   24d2c:	4b1c      	ldr	r3, [pc, #112]	; (24da0 <RTC2_IRQHandler+0x78>)
   24d2e:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
   24d32:	2b00      	cmp	r3, #0
   24d34:	d003      	beq.n	24d3e <RTC2_IRQHandler+0x16>
    {
        NRF_RTC2->EVENTS_TICK = 0;
   24d36:	4b1a      	ldr	r3, [pc, #104]	; (24da0 <RTC2_IRQHandler+0x78>)
   24d38:	2200      	movs	r2, #0
   24d3a:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    }

	if (NRF_RTC2->EVENTS_COMPARE[DELAY_REGISTER_MAIN])			/*< RTC DELAY */
   24d3e:	4b18      	ldr	r3, [pc, #96]	; (24da0 <RTC2_IRQHandler+0x78>)
   24d40:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
   24d44:	2b00      	cmp	r3, #0
   24d46:	d007      	beq.n	24d58 <RTC2_IRQHandler+0x30>
	{
		NRF_RTC2->EVENTS_COMPARE[DELAY_REGISTER_MAIN] = 0;
   24d48:	4b15      	ldr	r3, [pc, #84]	; (24da0 <RTC2_IRQHandler+0x78>)
   24d4a:	2200      	movs	r2, #0
   24d4c:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
		rtc2_delay_completed_flag = true;
   24d50:	4b14      	ldr	r3, [pc, #80]	; (24da4 <RTC2_IRQHandler+0x7c>)
   24d52:	2201      	movs	r2, #1
   24d54:	701a      	strb	r2, [r3, #0]
	if (NRF_RTC2->EVENTS_COMPARE[3])
	{
		NRF_RTC2->EVENTS_COMPARE[3] = 0;
	}

}
   24d56:	e01f      	b.n	24d98 <RTC2_IRQHandler+0x70>
	if (NRF_RTC2->EVENTS_COMPARE[TIMEOUT_REGISTER_MAIN])		/*< RTC TIMEOUT */
   24d58:	4b11      	ldr	r3, [pc, #68]	; (24da0 <RTC2_IRQHandler+0x78>)
   24d5a:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
   24d5e:	2b00      	cmp	r3, #0
   24d60:	d007      	beq.n	24d72 <RTC2_IRQHandler+0x4a>
		NRF_RTC2->EVENTS_COMPARE[TIMEOUT_REGISTER_MAIN] = 0;
   24d62:	4b0f      	ldr	r3, [pc, #60]	; (24da0 <RTC2_IRQHandler+0x78>)
   24d64:	2200      	movs	r2, #0
   24d66:	f8c3 2144 	str.w	r2, [r3, #324]	; 0x144
		rtc2_timeout_triggered_flag = true;
   24d6a:	4b0f      	ldr	r3, [pc, #60]	; (24da8 <RTC2_IRQHandler+0x80>)
   24d6c:	2201      	movs	r2, #1
   24d6e:	701a      	strb	r2, [r3, #0]
}
   24d70:	e012      	b.n	24d98 <RTC2_IRQHandler+0x70>
	if (NRF_RTC2->EVENTS_COMPARE[2])
   24d72:	4b0b      	ldr	r3, [pc, #44]	; (24da0 <RTC2_IRQHandler+0x78>)
   24d74:	f8d3 3148 	ldr.w	r3, [r3, #328]	; 0x148
   24d78:	2b00      	cmp	r3, #0
   24d7a:	d004      	beq.n	24d86 <RTC2_IRQHandler+0x5e>
		NRF_RTC2->EVENTS_COMPARE[2] = 0;
   24d7c:	4b08      	ldr	r3, [pc, #32]	; (24da0 <RTC2_IRQHandler+0x78>)
   24d7e:	2200      	movs	r2, #0
   24d80:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148
}
   24d84:	e008      	b.n	24d98 <RTC2_IRQHandler+0x70>
	if (NRF_RTC2->EVENTS_COMPARE[3])
   24d86:	4b06      	ldr	r3, [pc, #24]	; (24da0 <RTC2_IRQHandler+0x78>)
   24d88:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
   24d8c:	2b00      	cmp	r3, #0
   24d8e:	d003      	beq.n	24d98 <RTC2_IRQHandler+0x70>
		NRF_RTC2->EVENTS_COMPARE[3] = 0;
   24d90:	4b03      	ldr	r3, [pc, #12]	; (24da0 <RTC2_IRQHandler+0x78>)
   24d92:	2200      	movs	r2, #0
   24d94:	f8c3 214c 	str.w	r2, [r3, #332]	; 0x14c
}
   24d98:	bf00      	nop
   24d9a:	46bd      	mov	sp, r7
   24d9c:	bc80      	pop	{r7}
   24d9e:	4770      	bx	lr
   24da0:	40024000 	.word	0x40024000
   24da4:	20005450 	.word	0x20005450
   24da8:	20005460 	.word	0x20005460

00024dac <RTCDelay>:

RTC_Error_e RTCDelay(NRF_RTC_Type* RTC, uint32_t time_ticks)
{
   24dac:	b580      	push	{r7, lr}
   24dae:	b084      	sub	sp, #16
   24db0:	af00      	add	r7, sp, #0
   24db2:	6078      	str	r0, [r7, #4]
   24db4:	6039      	str	r1, [r7, #0]
	volatile bool* delayFlag = NULL;
   24db6:	2300      	movs	r3, #0
   24db8:	60fb      	str	r3, [r7, #12]

	if (RTC == NRF_RTC1)
   24dba:	687b      	ldr	r3, [r7, #4]
   24dbc:	4a18      	ldr	r2, [pc, #96]	; (24e20 <RTCDelay+0x74>)
   24dbe:	4293      	cmp	r3, r2
   24dc0:	d105      	bne.n	24dce <RTCDelay+0x22>
	{
		rtc1_delay_completed_flag = false;
   24dc2:	4b18      	ldr	r3, [pc, #96]	; (24e24 <RTCDelay+0x78>)
   24dc4:	2200      	movs	r2, #0
   24dc6:	701a      	strb	r2, [r3, #0]
		delayFlag = &rtc1_delay_completed_flag;
   24dc8:	4b16      	ldr	r3, [pc, #88]	; (24e24 <RTCDelay+0x78>)
   24dca:	60fb      	str	r3, [r7, #12]
   24dcc:	e008      	b.n	24de0 <RTCDelay+0x34>
	}
	else
	if (RTC == NRF_RTC2)
   24dce:	687b      	ldr	r3, [r7, #4]
   24dd0:	4a15      	ldr	r2, [pc, #84]	; (24e28 <RTCDelay+0x7c>)
   24dd2:	4293      	cmp	r3, r2
   24dd4:	d104      	bne.n	24de0 <RTCDelay+0x34>
	{
		rtc2_delay_completed_flag = false;
   24dd6:	4b15      	ldr	r3, [pc, #84]	; (24e2c <RTCDelay+0x80>)
   24dd8:	2200      	movs	r2, #0
   24dda:	701a      	strb	r2, [r3, #0]
		delayFlag = &rtc2_delay_completed_flag;
   24ddc:	4b13      	ldr	r3, [pc, #76]	; (24e2c <RTCDelay+0x80>)
   24dde:	60fb      	str	r3, [r7, #12]
	}

	RTCEnableComparingReg(RTC, DELAY_REGISTER_MAIN);
   24de0:	2100      	movs	r1, #0
   24de2:	6878      	ldr	r0, [r7, #4]
   24de4:	f000 f8b2 	bl	24f4c <RTCEnableComparingReg>
	RTC->CC[DELAY_REGISTER_MAIN] = RTC->COUNTER + time_ticks;
   24de8:	687b      	ldr	r3, [r7, #4]
   24dea:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
   24dee:	683b      	ldr	r3, [r7, #0]
   24df0:	441a      	add	r2, r3
   24df2:	687b      	ldr	r3, [r7, #4]
   24df4:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540

	while (!(*delayFlag))
   24df8:	e001      	b.n	24dfe <RTCDelay+0x52>
	{
#if SOFTDEVICE_ENABLED
		sd_app_evt_wait();
   24dfa:	f7ff fe7f 	bl	24afc <sd_app_evt_wait>
	while (!(*delayFlag))
   24dfe:	68fb      	ldr	r3, [r7, #12]
   24e00:	781b      	ldrb	r3, [r3, #0]
   24e02:	b2db      	uxtb	r3, r3
   24e04:	f083 0301 	eor.w	r3, r3, #1
   24e08:	b2db      	uxtb	r3, r3
   24e0a:	2b00      	cmp	r3, #0
   24e0c:	d1f5      	bne.n	24dfa <RTCDelay+0x4e>
#else
		__WFE();
#endif
	}

	RTCDisableComparingReg(RTC, DELAY_REGISTER_MAIN);
   24e0e:	2100      	movs	r1, #0
   24e10:	6878      	ldr	r0, [r7, #4]
   24e12:	f000 f8e9 	bl	24fe8 <RTCDisableComparingReg>
	return E_RTC_OK;
   24e16:	2300      	movs	r3, #0
}
   24e18:	4618      	mov	r0, r3
   24e1a:	3710      	adds	r7, #16
   24e1c:	46bd      	mov	sp, r7
   24e1e:	bd80      	pop	{r7, pc}
   24e20:	40011000 	.word	0x40011000
   24e24:	20005461 	.word	0x20005461
   24e28:	40024000 	.word	0x40024000
   24e2c:	20005450 	.word	0x20005450

00024e30 <Rtc1DelayMs>:

RTC_Error_e Rtc1DelayMs(uint32_t ms)
{
   24e30:	b580      	push	{r7, lr}
   24e32:	b082      	sub	sp, #8
   24e34:	af00      	add	r7, sp, #0
   24e36:	6078      	str	r0, [r7, #4]
    return RTCDelay(NRF_RTC1, RTC1_MS_TO_TICKS(ms));
   24e38:	687b      	ldr	r3, [r7, #4]
   24e3a:	03db      	lsls	r3, r3, #15
   24e3c:	4a06      	ldr	r2, [pc, #24]	; (24e58 <Rtc1DelayMs+0x28>)
   24e3e:	fba2 2303 	umull	r2, r3, r2, r3
   24e42:	099b      	lsrs	r3, r3, #6
   24e44:	4619      	mov	r1, r3
   24e46:	4805      	ldr	r0, [pc, #20]	; (24e5c <Rtc1DelayMs+0x2c>)
   24e48:	f7ff ffb0 	bl	24dac <RTCDelay>
   24e4c:	4603      	mov	r3, r0
}
   24e4e:	4618      	mov	r0, r3
   24e50:	3708      	adds	r7, #8
   24e52:	46bd      	mov	sp, r7
   24e54:	bd80      	pop	{r7, pc}
   24e56:	bf00      	nop
   24e58:	10624dd3 	.word	0x10624dd3
   24e5c:	40011000 	.word	0x40011000

00024e60 <RTCInit>:

	return E_RTC_OK;
}

RTC_Error_e RTCInit(NRF_RTC_Type* RTC)
{
   24e60:	b580      	push	{r7, lr}
   24e62:	b084      	sub	sp, #16
   24e64:	af00      	add	r7, sp, #0
   24e66:	6078      	str	r0, [r7, #4]
	RTC_Error_e retval = 0;
   24e68:	2300      	movs	r3, #0
   24e6a:	73fb      	strb	r3, [r7, #15]
	if (RTC == NRF_RTC0)
		return E_RTC_PERIPH_TAKEN_BY_SOFTDEVICE;
#endif

#if SOFTDEVICE_ENABLED
	if (RTC == NRF_RTC1)
   24e6c:	687b      	ldr	r3, [r7, #4]
   24e6e:	4a34      	ldr	r2, [pc, #208]	; (24f40 <RTCInit+0xe0>)
   24e70:	4293      	cmp	r3, r2
   24e72:	d112      	bne.n	24e9a <RTCInit+0x3a>
	{
		sd_nvic_SetPriority(RTC1_IRQn, RTC1_PRIORITY);
   24e74:	2103      	movs	r1, #3
   24e76:	2011      	movs	r0, #17
   24e78:	f7ff fed0 	bl	24c1c <sd_nvic_SetPriority>
		sd_nvic_EnableIRQ(RTC1_IRQn);
   24e7c:	2011      	movs	r0, #17
   24e7e:	f7ff fe89 	bl	24b94 <sd_nvic_EnableIRQ>
		NRF_RTC1->EVTEN = RTC_EVTENSET_OVRFLW_Enabled << RTC_EVTENSET_OVRFLW_Pos;
   24e82:	4b2f      	ldr	r3, [pc, #188]	; (24f40 <RTCInit+0xe0>)
   24e84:	2202      	movs	r2, #2
   24e86:	f8c3 2340 	str.w	r2, [r3, #832]	; 0x340
		NRF_RTC1->INTENSET = RTC_INTENSET_OVRFLW_Enabled << RTC_INTENSET_OVRFLW_Pos;
   24e8a:	4b2d      	ldr	r3, [pc, #180]	; (24f40 <RTCInit+0xe0>)
   24e8c:	2202      	movs	r2, #2
   24e8e:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
	    RTC->EVTENCLR = RTC_EVTENCLR_TICK_Enabled << RTC_EVTENCLR_TICK_Pos;
   24e92:	687b      	ldr	r3, [r7, #4]
   24e94:	2201      	movs	r2, #1
   24e96:	f8c3 2348 	str.w	r2, [r3, #840]	; 0x348
	}

	if (RTC == NRF_RTC2)
   24e9a:	687b      	ldr	r3, [r7, #4]
   24e9c:	4a29      	ldr	r2, [pc, #164]	; (24f44 <RTCInit+0xe4>)
   24e9e:	4293      	cmp	r3, r2
   24ea0:	d10e      	bne.n	24ec0 <RTCInit+0x60>
	{
		sd_nvic_SetPriority(RTC2_IRQn, RTC2_PRIORITY);
   24ea2:	2103      	movs	r1, #3
   24ea4:	2024      	movs	r0, #36	; 0x24
   24ea6:	f7ff feb9 	bl	24c1c <sd_nvic_SetPriority>
		sd_nvic_EnableIRQ(RTC2_IRQn);
   24eaa:	2024      	movs	r0, #36	; 0x24
   24eac:	f7ff fe72 	bl	24b94 <sd_nvic_EnableIRQ>

        NRF_RTC2->EVTENSET = RTC_EVTENSET_TICK_Enabled << RTC_EVTENSET_TICK_Pos;
   24eb0:	4b24      	ldr	r3, [pc, #144]	; (24f44 <RTCInit+0xe4>)
   24eb2:	2201      	movs	r2, #1
   24eb4:	f8c3 2344 	str.w	r2, [r3, #836]	; 0x344
        NRF_RTC2->INTENSET = RTC_INTENSET_TICK_Enabled << RTC_INTENSET_TICK_Pos;
   24eb8:	4b22      	ldr	r3, [pc, #136]	; (24f44 <RTCInit+0xe4>)
   24eba:	2201      	movs	r2, #1
   24ebc:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		NVIC_SetPriority(RTC2_IRQn, RTC2_PRIORITY);
		NVIC_EnableIRQ(RTC2_IRQn);
	}
#endif

	RTCStop(RTC);
   24ec0:	6878      	ldr	r0, [r7, #4]
   24ec2:	f000 f8ec 	bl	2509e <RTCStop>

	RTC->EVTENCLR = RTC_EVTENCLR_COMPARE0_Enabled << RTC_EVTENCLR_COMPARE0_Pos;
   24ec6:	687b      	ldr	r3, [r7, #4]
   24ec8:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   24ecc:	f8c3 2348 	str.w	r2, [r3, #840]	; 0x348
	RTC->EVTENCLR = RTC_EVTENCLR_COMPARE1_Enabled << RTC_EVTENCLR_COMPARE1_Pos;
   24ed0:	687b      	ldr	r3, [r7, #4]
   24ed2:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   24ed6:	f8c3 2348 	str.w	r2, [r3, #840]	; 0x348
	RTC->EVTENCLR = RTC_EVTENCLR_COMPARE2_Enabled << RTC_EVTENCLR_COMPARE2_Pos;
   24eda:	687b      	ldr	r3, [r7, #4]
   24edc:	f44f 2280 	mov.w	r2, #262144	; 0x40000
   24ee0:	f8c3 2348 	str.w	r2, [r3, #840]	; 0x348

	if (RTC != NRF_RTC0)
   24ee4:	687b      	ldr	r3, [r7, #4]
   24ee6:	4a18      	ldr	r2, [pc, #96]	; (24f48 <RTCInit+0xe8>)
   24ee8:	4293      	cmp	r3, r2
   24eea:	d004      	beq.n	24ef6 <RTCInit+0x96>
		RTC->EVTENCLR = RTC_EVTENCLR_COMPARE3_Enabled << RTC_EVTENCLR_COMPARE3_Pos;
   24eec:	687b      	ldr	r3, [r7, #4]
   24eee:	f44f 2200 	mov.w	r2, #524288	; 0x80000
   24ef2:	f8c3 2348 	str.w	r2, [r3, #840]	; 0x348

	switch ((uint32_t)RTC)
   24ef6:	687b      	ldr	r3, [r7, #4]
   24ef8:	4a11      	ldr	r2, [pc, #68]	; (24f40 <RTCInit+0xe0>)
   24efa:	4293      	cmp	r3, r2
   24efc:	d00a      	beq.n	24f14 <RTCInit+0xb4>
   24efe:	4a11      	ldr	r2, [pc, #68]	; (24f44 <RTCInit+0xe4>)
   24f00:	4293      	cmp	r3, r2
   24f02:	d00c      	beq.n	24f1e <RTCInit+0xbe>
   24f04:	4a10      	ldr	r2, [pc, #64]	; (24f48 <RTCInit+0xe8>)
   24f06:	4293      	cmp	r3, r2
   24f08:	d10f      	bne.n	24f2a <RTCInit+0xca>
	{

		case (uint32_t)NRF_RTC0:
		{
			RTC->PRESCALER = RTC0_PRESCALER;
   24f0a:	687b      	ldr	r3, [r7, #4]
   24f0c:	2200      	movs	r2, #0
   24f0e:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
		}break;
   24f12:	e00c      	b.n	24f2e <RTCInit+0xce>

		case (uint32_t)NRF_RTC1:
		{
			RTC->PRESCALER = RTC1_PRESCALER;
   24f14:	687b      	ldr	r3, [r7, #4]
   24f16:	2200      	movs	r2, #0
   24f18:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
		}break;
   24f1c:	e007      	b.n	24f2e <RTCInit+0xce>

		case (uint32_t)NRF_RTC2:
		{
			RTC->PRESCALER = RTC2_PRESCALER;
   24f1e:	687b      	ldr	r3, [r7, #4]
   24f20:	f240 1247 	movw	r2, #327	; 0x147
   24f24:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
		}break;
   24f28:	e001      	b.n	24f2e <RTCInit+0xce>

		default:
			return E_RTC_PERIPH_TAKEN_BY_SOFTDEVICE;
   24f2a:	2302      	movs	r3, #2
   24f2c:	e003      	b.n	24f36 <RTCInit+0xd6>
	}

	RTCStart(RTC);
   24f2e:	6878      	ldr	r0, [r7, #4]
   24f30:	f000 f8a8 	bl	25084 <RTCStart>

	return E_RTC_OK;
   24f34:	2300      	movs	r3, #0
}
   24f36:	4618      	mov	r0, r3
   24f38:	3710      	adds	r7, #16
   24f3a:	46bd      	mov	sp, r7
   24f3c:	bd80      	pop	{r7, pc}
   24f3e:	bf00      	nop
   24f40:	40011000 	.word	0x40011000
   24f44:	40024000 	.word	0x40024000
   24f48:	4000b000 	.word	0x4000b000

00024f4c <RTCEnableComparingReg>:

RTC_Error_e RTCEnableComparingReg(NRF_RTC_Type* RTC, uint8_t registerNumber)
{
   24f4c:	b480      	push	{r7}
   24f4e:	b083      	sub	sp, #12
   24f50:	af00      	add	r7, sp, #0
   24f52:	6078      	str	r0, [r7, #4]
   24f54:	460b      	mov	r3, r1
   24f56:	70fb      	strb	r3, [r7, #3]
	switch (registerNumber)
   24f58:	78fb      	ldrb	r3, [r7, #3]
   24f5a:	2b03      	cmp	r3, #3
   24f5c:	d83c      	bhi.n	24fd8 <RTCEnableComparingReg+0x8c>
   24f5e:	a201      	add	r2, pc, #4	; (adr r2, 24f64 <RTCEnableComparingReg+0x18>)
   24f60:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   24f64:	00024f75 	.word	0x00024f75
   24f68:	00024f8b 	.word	0x00024f8b
   24f6c:	00024fa1 	.word	0x00024fa1
   24f70:	00024fb7 	.word	0x00024fb7
	{
		case 0:
		{
			RTC->EVTENSET = RTC_EVTENSET_COMPARE0_Enabled << RTC_EVTENSET_COMPARE0_Pos;
   24f74:	687b      	ldr	r3, [r7, #4]
   24f76:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   24f7a:	f8c3 2344 	str.w	r2, [r3, #836]	; 0x344
			RTC->INTENSET = RTC_INTENSET_COMPARE0_Enabled << RTC_INTENSET_COMPARE0_Pos;
   24f7e:	687b      	ldr	r3, [r7, #4]
   24f80:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   24f84:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		}break;
   24f88:	e026      	b.n	24fd8 <RTCEnableComparingReg+0x8c>

		case 1:
		{
			RTC->EVTENSET = RTC_EVTENSET_COMPARE1_Enabled << RTC_EVTENSET_COMPARE1_Pos;
   24f8a:	687b      	ldr	r3, [r7, #4]
   24f8c:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   24f90:	f8c3 2344 	str.w	r2, [r3, #836]	; 0x344
			RTC->INTENSET = RTC_INTENSET_COMPARE1_Enabled << RTC_INTENSET_COMPARE1_Pos;
   24f94:	687b      	ldr	r3, [r7, #4]
   24f96:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   24f9a:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		}break;
   24f9e:	e01b      	b.n	24fd8 <RTCEnableComparingReg+0x8c>

		case 2:
		{
			RTC->EVTENSET = RTC_EVTENSET_COMPARE2_Enabled << RTC_EVTENSET_COMPARE2_Pos;
   24fa0:	687b      	ldr	r3, [r7, #4]
   24fa2:	f44f 2280 	mov.w	r2, #262144	; 0x40000
   24fa6:	f8c3 2344 	str.w	r2, [r3, #836]	; 0x344
			RTC->INTENSET = RTC_INTENSET_COMPARE2_Enabled << RTC_INTENSET_COMPARE2_Pos;
   24faa:	687b      	ldr	r3, [r7, #4]
   24fac:	f44f 2280 	mov.w	r2, #262144	; 0x40000
   24fb0:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		}break;
   24fb4:	e010      	b.n	24fd8 <RTCEnableComparingReg+0x8c>

		case 3:
		{
			if (RTC == NRF_RTC0)
   24fb6:	687b      	ldr	r3, [r7, #4]
   24fb8:	4a0a      	ldr	r2, [pc, #40]	; (24fe4 <RTCEnableComparingReg+0x98>)
   24fba:	4293      	cmp	r3, r2
   24fbc:	d101      	bne.n	24fc2 <RTCEnableComparingReg+0x76>
				return E_RTC_REG_NOT_EXISTING;
   24fbe:	2301      	movs	r3, #1
   24fc0:	e00b      	b.n	24fda <RTCEnableComparingReg+0x8e>

			RTC->EVTENSET = RTC_EVTENSET_COMPARE3_Enabled << RTC_EVTENSET_COMPARE3_Pos;
   24fc2:	687b      	ldr	r3, [r7, #4]
   24fc4:	f44f 2200 	mov.w	r2, #524288	; 0x80000
   24fc8:	f8c3 2344 	str.w	r2, [r3, #836]	; 0x344
			RTC->INTENSET = RTC_INTENSET_COMPARE3_Enabled << RTC_INTENSET_COMPARE3_Pos;
   24fcc:	687b      	ldr	r3, [r7, #4]
   24fce:	f44f 2200 	mov.w	r2, #524288	; 0x80000
   24fd2:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		}break;
   24fd6:	bf00      	nop
	}

	return E_RTC_OK;
   24fd8:	2300      	movs	r3, #0
}
   24fda:	4618      	mov	r0, r3
   24fdc:	370c      	adds	r7, #12
   24fde:	46bd      	mov	sp, r7
   24fe0:	bc80      	pop	{r7}
   24fe2:	4770      	bx	lr
   24fe4:	4000b000 	.word	0x4000b000

00024fe8 <RTCDisableComparingReg>:

RTC_Error_e RTCDisableComparingReg(NRF_RTC_Type* RTC, uint8_t registerNumber)
{
   24fe8:	b480      	push	{r7}
   24fea:	b083      	sub	sp, #12
   24fec:	af00      	add	r7, sp, #0
   24fee:	6078      	str	r0, [r7, #4]
   24ff0:	460b      	mov	r3, r1
   24ff2:	70fb      	strb	r3, [r7, #3]
	switch (registerNumber)
   24ff4:	78fb      	ldrb	r3, [r7, #3]
   24ff6:	2b03      	cmp	r3, #3
   24ff8:	d83c      	bhi.n	25074 <RTCDisableComparingReg+0x8c>
   24ffa:	a201      	add	r2, pc, #4	; (adr r2, 25000 <RTCDisableComparingReg+0x18>)
   24ffc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   25000:	00025011 	.word	0x00025011
   25004:	00025027 	.word	0x00025027
   25008:	0002503d 	.word	0x0002503d
   2500c:	00025053 	.word	0x00025053
	{
		case 0:
		{
			RTC->EVTENCLR = RTC_EVTENCLR_COMPARE0_Enabled << RTC_EVTENCLR_COMPARE0_Pos;
   25010:	687b      	ldr	r3, [r7, #4]
   25012:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   25016:	f8c3 2348 	str.w	r2, [r3, #840]	; 0x348
			RTC->INTENCLR = RTC_INTENCLR_COMPARE0_Enabled << RTC_INTENCLR_COMPARE0_Pos;
   2501a:	687b      	ldr	r3, [r7, #4]
   2501c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   25020:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
		}break;
   25024:	e026      	b.n	25074 <RTCDisableComparingReg+0x8c>

		case 1:
		{
			RTC->EVTENCLR = RTC_EVTENCLR_COMPARE1_Enabled << RTC_EVTENCLR_COMPARE1_Pos;
   25026:	687b      	ldr	r3, [r7, #4]
   25028:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   2502c:	f8c3 2348 	str.w	r2, [r3, #840]	; 0x348
			RTC->INTENCLR = RTC_INTENCLR_COMPARE1_Enabled << RTC_INTENCLR_COMPARE1_Pos;
   25030:	687b      	ldr	r3, [r7, #4]
   25032:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   25036:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
		}break;
   2503a:	e01b      	b.n	25074 <RTCDisableComparingReg+0x8c>

		case 2:
		{
			RTC->EVTENCLR = RTC_EVTENCLR_COMPARE2_Enabled << RTC_EVTENCLR_COMPARE2_Pos;
   2503c:	687b      	ldr	r3, [r7, #4]
   2503e:	f44f 2280 	mov.w	r2, #262144	; 0x40000
   25042:	f8c3 2348 	str.w	r2, [r3, #840]	; 0x348
			RTC->INTENCLR = RTC_INTENCLR_COMPARE2_Enabled << RTC_INTENCLR_COMPARE2_Pos;
   25046:	687b      	ldr	r3, [r7, #4]
   25048:	f44f 2280 	mov.w	r2, #262144	; 0x40000
   2504c:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
		}break;
   25050:	e010      	b.n	25074 <RTCDisableComparingReg+0x8c>

		case 3:
		{
			if (RTC == NRF_RTC0)
   25052:	687b      	ldr	r3, [r7, #4]
   25054:	4a0a      	ldr	r2, [pc, #40]	; (25080 <RTCDisableComparingReg+0x98>)
   25056:	4293      	cmp	r3, r2
   25058:	d101      	bne.n	2505e <RTCDisableComparingReg+0x76>
				return E_RTC_REG_NOT_EXISTING;
   2505a:	2301      	movs	r3, #1
   2505c:	e00b      	b.n	25076 <RTCDisableComparingReg+0x8e>

			RTC->EVTENCLR = RTC_EVTENCLR_COMPARE3_Enabled << RTC_EVTENCLR_COMPARE3_Pos;
   2505e:	687b      	ldr	r3, [r7, #4]
   25060:	f44f 2200 	mov.w	r2, #524288	; 0x80000
   25064:	f8c3 2348 	str.w	r2, [r3, #840]	; 0x348
			RTC->INTENCLR = RTC_INTENCLR_COMPARE3_Enabled << RTC_INTENCLR_COMPARE3_Pos;
   25068:	687b      	ldr	r3, [r7, #4]
   2506a:	f44f 2200 	mov.w	r2, #524288	; 0x80000
   2506e:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
		}break;
   25072:	bf00      	nop
	}

	return E_RTC_OK;
   25074:	2300      	movs	r3, #0
}
   25076:	4618      	mov	r0, r3
   25078:	370c      	adds	r7, #12
   2507a:	46bd      	mov	sp, r7
   2507c:	bc80      	pop	{r7}
   2507e:	4770      	bx	lr
   25080:	4000b000 	.word	0x4000b000

00025084 <RTCStart>:

RTC_Error_e RTCStart(NRF_RTC_Type* RTC)
{
   25084:	b480      	push	{r7}
   25086:	b083      	sub	sp, #12
   25088:	af00      	add	r7, sp, #0
   2508a:	6078      	str	r0, [r7, #4]
	RTC->TASKS_START = 1;
   2508c:	687b      	ldr	r3, [r7, #4]
   2508e:	2201      	movs	r2, #1
   25090:	601a      	str	r2, [r3, #0]

	return E_RTC_OK;
   25092:	2300      	movs	r3, #0
}
   25094:	4618      	mov	r0, r3
   25096:	370c      	adds	r7, #12
   25098:	46bd      	mov	sp, r7
   2509a:	bc80      	pop	{r7}
   2509c:	4770      	bx	lr

0002509e <RTCStop>:

RTC_Error_e RTCStop(NRF_RTC_Type* RTC)
{
   2509e:	b480      	push	{r7}
   250a0:	b083      	sub	sp, #12
   250a2:	af00      	add	r7, sp, #0
   250a4:	6078      	str	r0, [r7, #4]
	RTC->TASKS_STOP = 1;
   250a6:	687b      	ldr	r3, [r7, #4]
   250a8:	2201      	movs	r2, #1
   250aa:	605a      	str	r2, [r3, #4]

	return E_RTC_OK;
   250ac:	2300      	movs	r3, #0
}
   250ae:	4618      	mov	r0, r3
   250b0:	370c      	adds	r7, #12
   250b2:	46bd      	mov	sp, r7
   250b4:	bc80      	pop	{r7}
   250b6:	4770      	bx	lr

000250b8 <sd_ble_gap_ppcp_set>:
 *
 * @retval ::NRF_SUCCESS Peripheral Preferred Connection Parameters set successfully.
 * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
 * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
 */
SVCALL(SD_BLE_GAP_PPCP_SET, uint32_t, sd_ble_gap_ppcp_set(ble_gap_conn_params_t const *p_conn_params));
   250b8:	df7a      	svc	122	; 0x7a
   250ba:	4770      	bx	lr
   250bc:	bf00      	nop
   250be:	4618      	mov	r0, r3

000250c0 <sd_ble_gap_device_name_set>:
 * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
 * @retval ::NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
 * @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.
 * @retval ::NRF_ERROR_FORBIDDEN Device name is not writable.
 */
SVCALL(SD_BLE_GAP_DEVICE_NAME_SET, uint32_t, sd_ble_gap_device_name_set(ble_gap_conn_sec_mode_t const *p_write_perm, uint8_t const *p_dev_name, uint16_t len));
   250c0:	df7c      	svc	124	; 0x7c
   250c2:	4770      	bx	lr
   250c4:	bf00      	nop
   250c6:	4618      	mov	r0, r3

000250c8 <on_ble_evt>:
/**@brief Function for handling BLE Stack events common to both the central and peripheral roles.
 * @param[in] conn_handle Connection Handle.
 * @param[in] p_ble_evt  Bluetooth stack event.
 */
static void on_ble_evt(uint16_t conn_handle, ble_evt_t const * p_ble_evt)
{
   250c8:	b580      	push	{r7, lr}
   250ca:	b086      	sub	sp, #24
   250cc:	af00      	add	r7, sp, #0
   250ce:	4603      	mov	r3, r0
   250d0:	6039      	str	r1, [r7, #0]
   250d2:	80fb      	strh	r3, [r7, #6]
    ret_code_t err_code;
    char passkey[BLE_GAP_PASSKEY_LEN + 1];
    uint16_t role = ble_conn_state_role(conn_handle);
   250d4:	88fb      	ldrh	r3, [r7, #6]
   250d6:	4618      	mov	r0, r3
   250d8:	f002 fc5a 	bl	27990 <ble_conn_state_role>
   250dc:	4603      	mov	r3, r0
   250de:	82fb      	strh	r3, [r7, #22]

    BleUartOnBleEvt(&m_ble_uart, p_ble_evt);
   250e0:	6839      	ldr	r1, [r7, #0]
   250e2:	480a      	ldr	r0, [pc, #40]	; (2510c <on_ble_evt+0x44>)
   250e4:	f000 fbef 	bl	258c6 <BleUartOnBleEvt>

    switch (p_ble_evt->header.evt_id)
   250e8:	683b      	ldr	r3, [r7, #0]
   250ea:	881b      	ldrh	r3, [r3, #0]
   250ec:	2b11      	cmp	r3, #17
   250ee:	d004      	beq.n	250fa <on_ble_evt+0x32>
   250f0:	2b13      	cmp	r3, #19
   250f2:	d004      	beq.n	250fe <on_ble_evt+0x36>
   250f4:	2b10      	cmp	r3, #16
   250f6:	d004      	beq.n	25102 <on_ble_evt+0x3a>
//                          *((uint8_t *)&p_ble_evt->evt.gap_evt.params.auth_status.kdist_peer));
//            break;

        default:
            // No implementation needed.
            break;
   250f8:	e004      	b.n	25104 <on_ble_evt+0x3c>
            break;
   250fa:	bf00      	nop
   250fc:	e002      	b.n	25104 <on_ble_evt+0x3c>
            break;
   250fe:	bf00      	nop
   25100:	e000      	b.n	25104 <on_ble_evt+0x3c>
            break;
   25102:	bf00      	nop
    }
}
   25104:	bf00      	nop
   25106:	3718      	adds	r7, #24
   25108:	46bd      	mov	sp, r7
   2510a:	bd80      	pop	{r7, pc}
   2510c:	20005468 	.word	0x20005468

00025110 <ble_evt_handler>:
 *
 * @param[in]   p_ble_evt   Bluetooth stack event.
 * @param[in]   p_context   Unused.
 */
static void ble_evt_handler(ble_evt_t const * p_ble_evt, void * p_context)
{
   25110:	b580      	push	{r7, lr}
   25112:	b084      	sub	sp, #16
   25114:	af00      	add	r7, sp, #0
   25116:	6078      	str	r0, [r7, #4]
   25118:	6039      	str	r1, [r7, #0]
    uint16_t conn_handle = p_ble_evt->evt.gap_evt.conn_handle;
   2511a:	687b      	ldr	r3, [r7, #4]
   2511c:	889b      	ldrh	r3, [r3, #4]
   2511e:	81fb      	strh	r3, [r7, #14]
    uint16_t role        = ble_conn_state_role(conn_handle);
   25120:	89fb      	ldrh	r3, [r7, #14]
   25122:	4618      	mov	r0, r3
   25124:	f002 fc34 	bl	27990 <ble_conn_state_role>
   25128:	4603      	mov	r3, r0
   2512a:	81bb      	strh	r3, [r7, #12]

    evtHistory[cnt++] = p_ble_evt->header.evt_id;
   2512c:	687b      	ldr	r3, [r7, #4]
   2512e:	8818      	ldrh	r0, [r3, #0]
   25130:	4b0b      	ldr	r3, [pc, #44]	; (25160 <ble_evt_handler+0x50>)
   25132:	681b      	ldr	r3, [r3, #0]
   25134:	1c5a      	adds	r2, r3, #1
   25136:	490a      	ldr	r1, [pc, #40]	; (25160 <ble_evt_handler+0x50>)
   25138:	600a      	str	r2, [r1, #0]
   2513a:	b2c1      	uxtb	r1, r0
   2513c:	4a09      	ldr	r2, [pc, #36]	; (25164 <ble_evt_handler+0x54>)
   2513e:	54d1      	strb	r1, [r2, r3]

    if (role == BLE_GAP_ROLE_PERIPH)
   25140:	89bb      	ldrh	r3, [r7, #12]
   25142:	2b01      	cmp	r3, #1
   25144:	d102      	bne.n	2514c <ble_evt_handler+0x3c>
    {
        // Manages peripheral LEDs.
        on_ble_peripheral_evt(p_ble_evt);
   25146:	6878      	ldr	r0, [r7, #4]
   25148:	f000 f928 	bl	2539c <on_ble_peripheral_evt>
    }

    on_ble_evt(conn_handle, p_ble_evt);
   2514c:	89fb      	ldrh	r3, [r7, #14]
   2514e:	6879      	ldr	r1, [r7, #4]
   25150:	4618      	mov	r0, r3
   25152:	f7ff ffb9 	bl	250c8 <on_ble_evt>

}
   25156:	bf00      	nop
   25158:	3710      	adds	r7, #16
   2515a:	46bd      	mov	sp, r7
   2515c:	bd80      	pop	{r7, pc}
   2515e:	bf00      	nop
   25160:	200051f0 	.word	0x200051f0
   25164:	2000506c 	.word	0x2000506c

00025168 <GapParamsInit>:
 *
 * @details This function sets up all the necessary GAP (Generic Access Profile) parameters of the
 *          device including the device name, appearance, and the preferred connection parameters.
 */
void GapParamsInit(void)
{
   25168:	b580      	push	{r7, lr}
   2516a:	b086      	sub	sp, #24
   2516c:	af00      	add	r7, sp, #0
    ret_code_t              err_code;
    ble_gap_conn_params_t   gap_conn_params;
    ble_gap_conn_sec_mode_t sec_mode;

    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&sec_mode);
   2516e:	783b      	ldrb	r3, [r7, #0]
   25170:	2201      	movs	r2, #1
   25172:	f362 0303 	bfi	r3, r2, #0, #4
   25176:	703b      	strb	r3, [r7, #0]
   25178:	783b      	ldrb	r3, [r7, #0]
   2517a:	2201      	movs	r2, #1
   2517c:	f362 1307 	bfi	r3, r2, #4, #4
   25180:	703b      	strb	r3, [r7, #0]

    err_code = sd_ble_gap_device_name_set(&sec_mode,
                                          (const uint8_t *)DEVICE_NAME,
                                          strlen(DEVICE_NAME));
   25182:	481b      	ldr	r0, [pc, #108]	; (251f0 <GapParamsInit+0x88>)
   25184:	f006 f97c 	bl	2b480 <strlen>
   25188:	4603      	mov	r3, r0
    err_code = sd_ble_gap_device_name_set(&sec_mode,
   2518a:	b29a      	uxth	r2, r3
   2518c:	463b      	mov	r3, r7
   2518e:	4918      	ldr	r1, [pc, #96]	; (251f0 <GapParamsInit+0x88>)
   25190:	4618      	mov	r0, r3
   25192:	f7ff ff95 	bl	250c0 <sd_ble_gap_device_name_set>
   25196:	6178      	str	r0, [r7, #20]
    APP_ERROR_CHECK(err_code);
   25198:	697b      	ldr	r3, [r7, #20]
   2519a:	613b      	str	r3, [r7, #16]
   2519c:	693b      	ldr	r3, [r7, #16]
   2519e:	2b00      	cmp	r3, #0
   251a0:	d004      	beq.n	251ac <GapParamsInit+0x44>
   251a2:	4a14      	ldr	r2, [pc, #80]	; (251f4 <GapParamsInit+0x8c>)
   251a4:	21cb      	movs	r1, #203	; 0xcb
   251a6:	6938      	ldr	r0, [r7, #16]
   251a8:	f001 fdba 	bl	26d20 <app_error_handler>

    memset(&gap_conn_params, 0, sizeof(gap_conn_params));
   251ac:	1d3b      	adds	r3, r7, #4
   251ae:	2208      	movs	r2, #8
   251b0:	2100      	movs	r1, #0
   251b2:	4618      	mov	r0, r3
   251b4:	f7fe fa32 	bl	2361c <memset>

    gap_conn_params.min_conn_interval = MIN_CONNECTION_INTERVAL;
   251b8:	2306      	movs	r3, #6
   251ba:	80bb      	strh	r3, [r7, #4]
    gap_conn_params.max_conn_interval = MAX_CONNECTION_INTERVAL;
   251bc:	2318      	movs	r3, #24
   251be:	80fb      	strh	r3, [r7, #6]
    gap_conn_params.slave_latency     = SLAVE_LATENCY;
   251c0:	2300      	movs	r3, #0
   251c2:	813b      	strh	r3, [r7, #8]
    gap_conn_params.conn_sup_timeout  = SUPERVISION_TIMEOUT;
   251c4:	f44f 73c8 	mov.w	r3, #400	; 0x190
   251c8:	817b      	strh	r3, [r7, #10]

    err_code = sd_ble_gap_ppcp_set(&gap_conn_params);
   251ca:	1d3b      	adds	r3, r7, #4
   251cc:	4618      	mov	r0, r3
   251ce:	f7ff ff73 	bl	250b8 <sd_ble_gap_ppcp_set>
   251d2:	6178      	str	r0, [r7, #20]
    APP_ERROR_CHECK(err_code);
   251d4:	697b      	ldr	r3, [r7, #20]
   251d6:	60fb      	str	r3, [r7, #12]
   251d8:	68fb      	ldr	r3, [r7, #12]
   251da:	2b00      	cmp	r3, #0
   251dc:	d004      	beq.n	251e8 <GapParamsInit+0x80>
   251de:	4a05      	ldr	r2, [pc, #20]	; (251f4 <GapParamsInit+0x8c>)
   251e0:	21d5      	movs	r1, #213	; 0xd5
   251e2:	68f8      	ldr	r0, [r7, #12]
   251e4:	f001 fd9c 	bl	26d20 <app_error_handler>
}
   251e8:	bf00      	nop
   251ea:	3718      	adds	r7, #24
   251ec:	46bd      	mov	sp, r7
   251ee:	bd80      	pop	{r7, pc}
   251f0:	0002b4fc 	.word	0x0002b4fc
   251f4:	0002b4e4 	.word	0x0002b4e4

000251f8 <GattInit>:


/**@brief Function for initializing the GATT module. */
void GattInit(void)
{
   251f8:	b580      	push	{r7, lr}
   251fa:	b082      	sub	sp, #8
   251fc:	af00      	add	r7, sp, #0
    ret_code_t err_code = nrf_ble_gatt_init(&m_gatt, NULL);
   251fe:	2100      	movs	r1, #0
   25200:	4808      	ldr	r0, [pc, #32]	; (25224 <GattInit+0x2c>)
   25202:	f002 fa39 	bl	27678 <nrf_ble_gatt_init>
   25206:	6078      	str	r0, [r7, #4]
    APP_ERROR_CHECK(err_code);
   25208:	687b      	ldr	r3, [r7, #4]
   2520a:	603b      	str	r3, [r7, #0]
   2520c:	683b      	ldr	r3, [r7, #0]
   2520e:	2b00      	cmp	r3, #0
   25210:	d004      	beq.n	2521c <GattInit+0x24>
   25212:	4a05      	ldr	r2, [pc, #20]	; (25228 <GattInit+0x30>)
   25214:	21dd      	movs	r1, #221	; 0xdd
   25216:	6838      	ldr	r0, [r7, #0]
   25218:	f001 fd82 	bl	26d20 <app_error_handler>
}
   2521c:	bf00      	nop
   2521e:	3708      	adds	r7, #8
   25220:	46bd      	mov	sp, r7
   25222:	bd80      	pop	{r7, pc}
   25224:	200051d4 	.word	0x200051d4
   25228:	0002b4e4 	.word	0x0002b4e4

0002522c <BleStackInit>:
/**@brief Function for initializing the BLE stack.
 *
 * @details Initializes the SoftDevice and the BLE event interrupt.
 */
void BleStackInit(void)
{
   2522c:	b580      	push	{r7, lr}
   2522e:	b086      	sub	sp, #24
   25230:	af00      	add	r7, sp, #0
    ret_code_t err_code;

    err_code = nrf_sdh_enable_request();
   25232:	f001 fe75 	bl	26f20 <nrf_sdh_enable_request>
   25236:	6178      	str	r0, [r7, #20]
    APP_ERROR_CHECK(err_code);
   25238:	697b      	ldr	r3, [r7, #20]
   2523a:	613b      	str	r3, [r7, #16]
   2523c:	693b      	ldr	r3, [r7, #16]
   2523e:	2b00      	cmp	r3, #0
   25240:	d005      	beq.n	2524e <BleStackInit+0x22>
   25242:	4a16      	ldr	r2, [pc, #88]	; (2529c <BleStackInit+0x70>)
   25244:	f44f 7194 	mov.w	r1, #296	; 0x128
   25248:	6938      	ldr	r0, [r7, #16]
   2524a:	f001 fd69 	bl	26d20 <app_error_handler>

    // Configure the BLE stack using the default settings.
    // Fetch the start address of the application RAM.
    uint32_t ram_start = 0;
   2524e:	2300      	movs	r3, #0
   25250:	607b      	str	r3, [r7, #4]
    err_code = nrf_sdh_ble_default_cfg_set(APP_BLE_CONN_CFG_TAG, &ram_start);
   25252:	1d3b      	adds	r3, r7, #4
   25254:	4619      	mov	r1, r3
   25256:	2001      	movs	r0, #1
   25258:	f001 ff02 	bl	27060 <nrf_sdh_ble_default_cfg_set>
   2525c:	6178      	str	r0, [r7, #20]
    APP_ERROR_CHECK(err_code);
   2525e:	697b      	ldr	r3, [r7, #20]
   25260:	60fb      	str	r3, [r7, #12]
   25262:	68fb      	ldr	r3, [r7, #12]
   25264:	2b00      	cmp	r3, #0
   25266:	d005      	beq.n	25274 <BleStackInit+0x48>
   25268:	4a0c      	ldr	r2, [pc, #48]	; (2529c <BleStackInit+0x70>)
   2526a:	f44f 7197 	mov.w	r1, #302	; 0x12e
   2526e:	68f8      	ldr	r0, [r7, #12]
   25270:	f001 fd56 	bl	26d20 <app_error_handler>

    // Enable BLE stack.
    err_code = nrf_sdh_ble_enable(&ram_start);
   25274:	1d3b      	adds	r3, r7, #4
   25276:	4618      	mov	r0, r3
   25278:	f001 ff6f 	bl	2715a <nrf_sdh_ble_enable>
   2527c:	6178      	str	r0, [r7, #20]
    APP_ERROR_CHECK(err_code);
   2527e:	697b      	ldr	r3, [r7, #20]
   25280:	60bb      	str	r3, [r7, #8]
   25282:	68bb      	ldr	r3, [r7, #8]
   25284:	2b00      	cmp	r3, #0
   25286:	d005      	beq.n	25294 <BleStackInit+0x68>
   25288:	4a04      	ldr	r2, [pc, #16]	; (2529c <BleStackInit+0x70>)
   2528a:	f44f 7199 	mov.w	r1, #306	; 0x132
   2528e:	68b8      	ldr	r0, [r7, #8]
   25290:	f001 fd46 	bl	26d20 <app_error_handler>

    // Register a handler for BLE events.
    NRF_SDH_BLE_OBSERVER(m_ble_observer, APP_BLE_OBSERVER_PRIO, ble_evt_handler, NULL);
}
   25294:	bf00      	nop
   25296:	3718      	adds	r7, #24
   25298:	46bd      	mov	sp, r7
   2529a:	bd80      	pop	{r7, pc}
   2529c:	0002b4e4 	.word	0x0002b4e4

000252a0 <ServicesInit>:

/**@brief Function for initializing services that will be used by the application.
 */
void ServicesInit()
{
   252a0:	b580      	push	{r7, lr}
   252a2:	b086      	sub	sp, #24
   252a4:	af00      	add	r7, sp, #0
    uint32_t                        err_code;
    ble_uart_init_t                 uart_init;

    //handler assignement
    uart_init.evt_handler = BleUartHandler;
   252a6:	4b0b      	ldr	r3, [pc, #44]	; (252d4 <ServicesInit+0x34>)
   252a8:	607b      	str	r3, [r7, #4]
    err_code = BleUartServiceInit(&m_ble_uart, &uart_init);
   252aa:	1d3b      	adds	r3, r7, #4
   252ac:	4619      	mov	r1, r3
   252ae:	480a      	ldr	r0, [pc, #40]	; (252d8 <ServicesInit+0x38>)
   252b0:	f000 ff32 	bl	26118 <BleUartServiceInit>
   252b4:	6178      	str	r0, [r7, #20]
    APP_ERROR_CHECK(err_code);
   252b6:	697b      	ldr	r3, [r7, #20]
   252b8:	613b      	str	r3, [r7, #16]
   252ba:	693b      	ldr	r3, [r7, #16]
   252bc:	2b00      	cmp	r3, #0
   252be:	d005      	beq.n	252cc <ServicesInit+0x2c>
   252c0:	4a06      	ldr	r2, [pc, #24]	; (252dc <ServicesInit+0x3c>)
   252c2:	f44f 71a1 	mov.w	r1, #322	; 0x142
   252c6:	6938      	ldr	r0, [r7, #16]
   252c8:	f001 fd2a 	bl	26d20 <app_error_handler>

}
   252cc:	bf00      	nop
   252ce:	3718      	adds	r7, #24
   252d0:	46bd      	mov	sp, r7
   252d2:	bd80      	pop	{r7, pc}
   252d4:	00025d6d 	.word	0x00025d6d
   252d8:	20005468 	.word	0x20005468
   252dc:	0002b4e4 	.word	0x0002b4e4

000252e0 <sd_ble_gap_disconnect>:
SVCALL(SD_BLE_GAP_DISCONNECT, uint32_t, sd_ble_gap_disconnect(uint16_t conn_handle, uint8_t hci_status_code));
   252e0:	df76      	svc	118	; 0x76
   252e2:	4770      	bx	lr
   252e4:	bf00      	nop
   252e6:	4618      	mov	r0, r3

000252e8 <sd_ble_gatts_rw_authorize_reply>:
 * @retval ::NRF_ERROR_INVALID_STATE   Invalid Connection State or no authorization request pending.
 * @retval ::NRF_ERROR_INVALID_PARAM   Authorization op invalid,
 *                                         handle supplied does not match requested handle,
 *                                         or invalid data to be written provided by the application.
 */
SVCALL(SD_BLE_GATTS_RW_AUTHORIZE_REPLY, uint32_t, sd_ble_gatts_rw_authorize_reply(uint16_t conn_handle, ble_gatts_rw_authorize_reply_params_t const *p_rw_authorize_reply_params));
   252e8:	dfa8      	svc	168	; 0xa8
   252ea:	4770      	bx	lr
   252ec:	bf00      	nop
   252ee:	4618      	mov	r0, r3

000252f0 <sd_ble_user_mem_reply>:
 * @retval ::NRF_ERROR_BUSY The stack is busy, process pending events and retry.
 * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
 * @retval ::NRF_ERROR_INVALID_LENGTH Invalid user memory block length supplied.
 * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection state or no user memory request pending.
 */
SVCALL(SD_BLE_USER_MEM_REPLY, uint32_t, sd_ble_user_mem_reply(uint16_t conn_handle, ble_user_mem_block_t const *p_block));
   252f0:	df66      	svc	102	; 0x66
   252f2:	4770      	bx	lr
   252f4:	bf00      	nop
   252f6:	4618      	mov	r0, r3

000252f8 <nrf_gpio_pin_port_decode>:
{
   252f8:	b480      	push	{r7}
   252fa:	b083      	sub	sp, #12
   252fc:	af00      	add	r7, sp, #0
   252fe:	6078      	str	r0, [r7, #4]
    return NRF_GPIO;
   25300:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
}
   25304:	4618      	mov	r0, r3
   25306:	370c      	adds	r7, #12
   25308:	46bd      	mov	sp, r7
   2530a:	bc80      	pop	{r7}
   2530c:	4770      	bx	lr

0002530e <nrf_gpio_pin_set>:
{
   2530e:	b580      	push	{r7, lr}
   25310:	b084      	sub	sp, #16
   25312:	af00      	add	r7, sp, #0
   25314:	6078      	str	r0, [r7, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   25316:	1d3b      	adds	r3, r7, #4
   25318:	4618      	mov	r0, r3
   2531a:	f7ff ffed 	bl	252f8 <nrf_gpio_pin_port_decode>
   2531e:	60f8      	str	r0, [r7, #12]
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   25320:	687b      	ldr	r3, [r7, #4]
   25322:	2201      	movs	r2, #1
   25324:	fa02 f303 	lsl.w	r3, r2, r3
   25328:	4619      	mov	r1, r3
   2532a:	68f8      	ldr	r0, [r7, #12]
   2532c:	f000 f819 	bl	25362 <nrf_gpio_port_out_set>
}
   25330:	bf00      	nop
   25332:	3710      	adds	r7, #16
   25334:	46bd      	mov	sp, r7
   25336:	bd80      	pop	{r7, pc}

00025338 <nrf_gpio_pin_clear>:
{
   25338:	b580      	push	{r7, lr}
   2533a:	b084      	sub	sp, #16
   2533c:	af00      	add	r7, sp, #0
   2533e:	6078      	str	r0, [r7, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   25340:	1d3b      	adds	r3, r7, #4
   25342:	4618      	mov	r0, r3
   25344:	f7ff ffd8 	bl	252f8 <nrf_gpio_pin_port_decode>
   25348:	60f8      	str	r0, [r7, #12]
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   2534a:	687b      	ldr	r3, [r7, #4]
   2534c:	2201      	movs	r2, #1
   2534e:	fa02 f303 	lsl.w	r3, r2, r3
   25352:	4619      	mov	r1, r3
   25354:	68f8      	ldr	r0, [r7, #12]
   25356:	f000 f812 	bl	2537e <nrf_gpio_port_out_clear>
}
   2535a:	bf00      	nop
   2535c:	3710      	adds	r7, #16
   2535e:	46bd      	mov	sp, r7
   25360:	bd80      	pop	{r7, pc}

00025362 <nrf_gpio_port_out_set>:
{
   25362:	b480      	push	{r7}
   25364:	b083      	sub	sp, #12
   25366:	af00      	add	r7, sp, #0
   25368:	6078      	str	r0, [r7, #4]
   2536a:	6039      	str	r1, [r7, #0]
    p_reg->OUTSET = set_mask;
   2536c:	687b      	ldr	r3, [r7, #4]
   2536e:	683a      	ldr	r2, [r7, #0]
   25370:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
}
   25374:	bf00      	nop
   25376:	370c      	adds	r7, #12
   25378:	46bd      	mov	sp, r7
   2537a:	bc80      	pop	{r7}
   2537c:	4770      	bx	lr

0002537e <nrf_gpio_port_out_clear>:
{
   2537e:	b480      	push	{r7}
   25380:	b083      	sub	sp, #12
   25382:	af00      	add	r7, sp, #0
   25384:	6078      	str	r0, [r7, #4]
   25386:	6039      	str	r1, [r7, #0]
    p_reg->OUTCLR = clr_mask;
   25388:	687b      	ldr	r3, [r7, #4]
   2538a:	683a      	ldr	r2, [r7, #0]
   2538c:	f8c3 250c 	str.w	r2, [r3, #1292]	; 0x50c
}
   25390:	bf00      	nop
   25392:	370c      	adds	r7, #12
   25394:	46bd      	mov	sp, r7
   25396:	bc80      	pop	{r7}
   25398:	4770      	bx	lr
	...

0002539c <on_ble_peripheral_evt>:
 * LEDs used to report the status of the peripheral applications.
 *
 * @param[in] p_ble_evt  Bluetooth stack event.
 */
void on_ble_peripheral_evt(ble_evt_t const * p_ble_evt)
{
   2539c:	b590      	push	{r4, r7, lr}
   2539e:	b091      	sub	sp, #68	; 0x44
   253a0:	af00      	add	r7, sp, #0
   253a2:	6078      	str	r0, [r7, #4]
    ret_code_t err_code;

    switch (p_ble_evt->header.evt_id)
   253a4:	687b      	ldr	r3, [r7, #4]
   253a6:	881b      	ldrh	r3, [r3, #0]
   253a8:	2b11      	cmp	r3, #17
   253aa:	d011      	beq.n	253d0 <on_ble_peripheral_evt+0x34>
   253ac:	2b11      	cmp	r3, #17
   253ae:	dc04      	bgt.n	253ba <on_ble_peripheral_evt+0x1e>
   253b0:	2b01      	cmp	r3, #1
   253b2:	d035      	beq.n	25420 <on_ble_peripheral_evt+0x84>
   253b4:	2b10      	cmp	r3, #16
   253b6:	d007      	beq.n	253c8 <on_ble_peripheral_evt+0x2c>
            }
        } break; // BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST

        default:
            // No implementation needed.
            break;
   253b8:	e082      	b.n	254c0 <on_ble_peripheral_evt+0x124>
    switch (p_ble_evt->header.evt_id)
   253ba:	2b51      	cmp	r3, #81	; 0x51
   253bc:	d042      	beq.n	25444 <on_ble_peripheral_evt+0xa8>
   253be:	2b56      	cmp	r3, #86	; 0x56
   253c0:	d01c      	beq.n	253fc <on_ble_peripheral_evt+0x60>
   253c2:	2b3b      	cmp	r3, #59	; 0x3b
   253c4:	d008      	beq.n	253d8 <on_ble_peripheral_evt+0x3c>
            break;
   253c6:	e07b      	b.n	254c0 <on_ble_peripheral_evt+0x124>
            nrf_gpio_pin_clear(BLUE_LED);
   253c8:	2010      	movs	r0, #16
   253ca:	f7ff ffb5 	bl	25338 <nrf_gpio_pin_clear>
            break;
   253ce:	e077      	b.n	254c0 <on_ble_peripheral_evt+0x124>
            nrf_gpio_pin_set(BLUE_LED);
   253d0:	2010      	movs	r0, #16
   253d2:	f7ff ff9c 	bl	2530e <nrf_gpio_pin_set>
        break;
   253d6:	e073      	b.n	254c0 <on_ble_peripheral_evt+0x124>
            err_code = sd_ble_gap_disconnect(p_ble_evt->evt.gattc_evt.conn_handle,
   253d8:	687b      	ldr	r3, [r7, #4]
   253da:	889b      	ldrh	r3, [r3, #4]
   253dc:	2113      	movs	r1, #19
   253de:	4618      	mov	r0, r3
   253e0:	f7ff ff7e 	bl	252e0 <sd_ble_gap_disconnect>
   253e4:	63f8      	str	r0, [r7, #60]	; 0x3c
            APP_ERROR_CHECK(err_code);
   253e6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   253e8:	633b      	str	r3, [r7, #48]	; 0x30
   253ea:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   253ec:	2b00      	cmp	r3, #0
   253ee:	d060      	beq.n	254b2 <on_ble_peripheral_evt+0x116>
   253f0:	4a35      	ldr	r2, [pc, #212]	; (254c8 <on_ble_peripheral_evt+0x12c>)
   253f2:	2147      	movs	r1, #71	; 0x47
   253f4:	6b38      	ldr	r0, [r7, #48]	; 0x30
   253f6:	f001 fc93 	bl	26d20 <app_error_handler>
            break;
   253fa:	e05a      	b.n	254b2 <on_ble_peripheral_evt+0x116>
            err_code = sd_ble_gap_disconnect(p_ble_evt->evt.gatts_evt.conn_handle,
   253fc:	687b      	ldr	r3, [r7, #4]
   253fe:	889b      	ldrh	r3, [r3, #4]
   25400:	2113      	movs	r1, #19
   25402:	4618      	mov	r0, r3
   25404:	f7ff ff6c 	bl	252e0 <sd_ble_gap_disconnect>
   25408:	63f8      	str	r0, [r7, #60]	; 0x3c
            APP_ERROR_CHECK(err_code);
   2540a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   2540c:	63bb      	str	r3, [r7, #56]	; 0x38
   2540e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   25410:	2b00      	cmp	r3, #0
   25412:	d050      	beq.n	254b6 <on_ble_peripheral_evt+0x11a>
   25414:	4a2c      	ldr	r2, [pc, #176]	; (254c8 <on_ble_peripheral_evt+0x12c>)
   25416:	214e      	movs	r1, #78	; 0x4e
   25418:	6bb8      	ldr	r0, [r7, #56]	; 0x38
   2541a:	f001 fc81 	bl	26d20 <app_error_handler>
            break;
   2541e:	e04a      	b.n	254b6 <on_ble_peripheral_evt+0x11a>
            err_code = sd_ble_user_mem_reply(p_ble_evt->evt.gap_evt.conn_handle, NULL);
   25420:	687b      	ldr	r3, [r7, #4]
   25422:	889b      	ldrh	r3, [r3, #4]
   25424:	2100      	movs	r1, #0
   25426:	4618      	mov	r0, r3
   25428:	f7ff ff62 	bl	252f0 <sd_ble_user_mem_reply>
   2542c:	63f8      	str	r0, [r7, #60]	; 0x3c
            APP_ERROR_CHECK(err_code);
   2542e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   25430:	62fb      	str	r3, [r7, #44]	; 0x2c
   25432:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   25434:	2b00      	cmp	r3, #0
   25436:	d040      	beq.n	254ba <on_ble_peripheral_evt+0x11e>
   25438:	4a23      	ldr	r2, [pc, #140]	; (254c8 <on_ble_peripheral_evt+0x12c>)
   2543a:	2153      	movs	r1, #83	; 0x53
   2543c:	6af8      	ldr	r0, [r7, #44]	; 0x2c
   2543e:	f001 fc6f 	bl	26d20 <app_error_handler>
            break;
   25442:	e03a      	b.n	254ba <on_ble_peripheral_evt+0x11e>
            req = p_ble_evt->evt.gatts_evt.params.authorize_request;
   25444:	687b      	ldr	r3, [r7, #4]
   25446:	f107 041c 	add.w	r4, r7, #28
   2544a:	3306      	adds	r3, #6
   2544c:	6818      	ldr	r0, [r3, #0]
   2544e:	6859      	ldr	r1, [r3, #4]
   25450:	689a      	ldr	r2, [r3, #8]
   25452:	68db      	ldr	r3, [r3, #12]
   25454:	c40f      	stmia	r4!, {r0, r1, r2, r3}
            if (req.type != BLE_GATTS_AUTHORIZE_TYPE_INVALID)
   25456:	7f3b      	ldrb	r3, [r7, #28]
   25458:	2b00      	cmp	r3, #0
   2545a:	d030      	beq.n	254be <on_ble_peripheral_evt+0x122>
                if ((req.request.write.op == BLE_GATTS_OP_PREP_WRITE_REQ)     ||
   2545c:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   25460:	2b04      	cmp	r3, #4
   25462:	d007      	beq.n	25474 <on_ble_peripheral_evt+0xd8>
                    (req.request.write.op == BLE_GATTS_OP_EXEC_WRITE_REQ_NOW) ||
   25464:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
                if ((req.request.write.op == BLE_GATTS_OP_PREP_WRITE_REQ)     ||
   25468:	2b06      	cmp	r3, #6
   2546a:	d003      	beq.n	25474 <on_ble_peripheral_evt+0xd8>
                    (req.request.write.op == BLE_GATTS_OP_EXEC_WRITE_REQ_CANCEL))
   2546c:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
                    (req.request.write.op == BLE_GATTS_OP_EXEC_WRITE_REQ_NOW) ||
   25470:	2b05      	cmp	r3, #5
   25472:	d124      	bne.n	254be <on_ble_peripheral_evt+0x122>
                    if (req.type == BLE_GATTS_AUTHORIZE_TYPE_WRITE)
   25474:	7f3b      	ldrb	r3, [r7, #28]
   25476:	2b02      	cmp	r3, #2
   25478:	d102      	bne.n	25480 <on_ble_peripheral_evt+0xe4>
                        auth_reply.type = BLE_GATTS_AUTHORIZE_TYPE_WRITE;
   2547a:	2302      	movs	r3, #2
   2547c:	733b      	strb	r3, [r7, #12]
   2547e:	e001      	b.n	25484 <on_ble_peripheral_evt+0xe8>
                        auth_reply.type = BLE_GATTS_AUTHORIZE_TYPE_READ;
   25480:	2301      	movs	r3, #1
   25482:	733b      	strb	r3, [r7, #12]
                    auth_reply.params.write.gatt_status = APP_FEATURE_NOT_SUPPORTED;
   25484:	f44f 73c1 	mov.w	r3, #386	; 0x182
   25488:	823b      	strh	r3, [r7, #16]
                    err_code = sd_ble_gatts_rw_authorize_reply(p_ble_evt->evt.gatts_evt.conn_handle,
   2548a:	687b      	ldr	r3, [r7, #4]
   2548c:	889b      	ldrh	r3, [r3, #4]
   2548e:	f107 020c 	add.w	r2, r7, #12
   25492:	4611      	mov	r1, r2
   25494:	4618      	mov	r0, r3
   25496:	f7ff ff27 	bl	252e8 <sd_ble_gatts_rw_authorize_reply>
   2549a:	63f8      	str	r0, [r7, #60]	; 0x3c
                    APP_ERROR_CHECK(err_code);
   2549c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   2549e:	637b      	str	r3, [r7, #52]	; 0x34
   254a0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   254a2:	2b00      	cmp	r3, #0
   254a4:	d00b      	beq.n	254be <on_ble_peripheral_evt+0x122>
   254a6:	4a08      	ldr	r2, [pc, #32]	; (254c8 <on_ble_peripheral_evt+0x12c>)
   254a8:	216e      	movs	r1, #110	; 0x6e
   254aa:	6b78      	ldr	r0, [r7, #52]	; 0x34
   254ac:	f001 fc38 	bl	26d20 <app_error_handler>
        } break; // BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST
   254b0:	e005      	b.n	254be <on_ble_peripheral_evt+0x122>
            break;
   254b2:	bf00      	nop
   254b4:	e004      	b.n	254c0 <on_ble_peripheral_evt+0x124>
            break;
   254b6:	bf00      	nop
   254b8:	e002      	b.n	254c0 <on_ble_peripheral_evt+0x124>
            break;
   254ba:	bf00      	nop
   254bc:	e000      	b.n	254c0 <on_ble_peripheral_evt+0x124>
        } break; // BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST
   254be:	bf00      	nop
    }
}
   254c0:	bf00      	nop
   254c2:	3744      	adds	r7, #68	; 0x44
   254c4:	46bd      	mov	sp, r7
   254c6:	bd90      	pop	{r4, r7, pc}
   254c8:	0002b504 	.word	0x0002b504

000254cc <on_adv_evt>:
/**@brief Function for handling advertising events.
 *
 * @param[in] ble_adv_evt  Advertising event.
 */
void on_adv_evt(ble_adv_evt_t ble_adv_evt)
{
   254cc:	b580      	push	{r7, lr}
   254ce:	b084      	sub	sp, #16
   254d0:	af00      	add	r7, sp, #0
   254d2:	4603      	mov	r3, r0
   254d4:	71fb      	strb	r3, [r7, #7]
    switch (ble_adv_evt)
   254d6:	79fb      	ldrb	r3, [r7, #7]
   254d8:	2b00      	cmp	r3, #0
   254da:	d002      	beq.n	254e2 <on_adv_evt+0x16>
   254dc:	2b03      	cmp	r3, #3
   254de:	d010      	beq.n	25502 <on_adv_evt+0x36>
            APP_ERROR_CHECK(err_code);
        } break;

        default:
            // No implementation needed.
            break;
   254e0:	e012      	b.n	25508 <on_adv_evt+0x3c>
            ret_code_t err_code = ble_advertising_start(&m_advertising, BLE_ADV_MODE_FAST);
   254e2:	2103      	movs	r1, #3
   254e4:	480a      	ldr	r0, [pc, #40]	; (25510 <on_adv_evt+0x44>)
   254e6:	f002 fd8b 	bl	28000 <ble_advertising_start>
   254ea:	60f8      	str	r0, [r7, #12]
            APP_ERROR_CHECK(err_code);
   254ec:	68fb      	ldr	r3, [r7, #12]
   254ee:	60bb      	str	r3, [r7, #8]
   254f0:	68bb      	ldr	r3, [r7, #8]
   254f2:	2b00      	cmp	r3, #0
   254f4:	d007      	beq.n	25506 <on_adv_evt+0x3a>
   254f6:	4a07      	ldr	r2, [pc, #28]	; (25514 <on_adv_evt+0x48>)
   254f8:	2188      	movs	r1, #136	; 0x88
   254fa:	68b8      	ldr	r0, [r7, #8]
   254fc:	f001 fc10 	bl	26d20 <app_error_handler>
        } break;
   25500:	e001      	b.n	25506 <on_adv_evt+0x3a>
            break;
   25502:	bf00      	nop
   25504:	e000      	b.n	25508 <on_adv_evt+0x3c>
        } break;
   25506:	bf00      	nop
    }
}
   25508:	bf00      	nop
   2550a:	3710      	adds	r7, #16
   2550c:	46bd      	mov	sp, r7
   2550e:	bd80      	pop	{r7, pc}
   25510:	200051f4 	.word	0x200051f4
   25514:	0002b504 	.word	0x0002b504

00025518 <AdvertisingInit>:
 *
 * @details Encodes the required advertising data and passes it to the stack.
 *          Also builds a structure to be passed to the stack when starting advertising.
 */
void AdvertisingInit(void)
{
   25518:	b580      	push	{r7, lr}
   2551a:	b0aa      	sub	sp, #168	; 0xa8
   2551c:	af00      	add	r7, sp, #0
    ret_code_t             err_code;
    ble_advertising_init_t init;

    memset(&init, 0, sizeof(init));
   2551e:	463b      	mov	r3, r7
   25520:	22a0      	movs	r2, #160	; 0xa0
   25522:	2100      	movs	r1, #0
   25524:	4618      	mov	r0, r3
   25526:	f7fe f879 	bl	2361c <memset>

    init.advdata.name_type               = BLE_ADVDATA_FULL_NAME;
   2552a:	2302      	movs	r3, #2
   2552c:	703b      	strb	r3, [r7, #0]
    init.advdata.include_appearance      = true;
   2552e:	2301      	movs	r3, #1
   25530:	70bb      	strb	r3, [r7, #2]
    init.advdata.flags                   = BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE;
   25532:	2306      	movs	r3, #6
   25534:	70fb      	strb	r3, [r7, #3]
    init.advdata.uuids_complete.uuid_cnt = sizeof(m_adv_uuids) / sizeof(m_adv_uuids[0]);
   25536:	2301      	movs	r3, #1
   25538:	823b      	strh	r3, [r7, #16]
    init.advdata.uuids_complete.p_uuids  = m_adv_uuids;
   2553a:	4b15      	ldr	r3, [pc, #84]	; (25590 <AdvertisingInit+0x78>)
   2553c:	617b      	str	r3, [r7, #20]

    init.config.ble_adv_fast_enabled  = true;
   2553e:	2301      	movs	r3, #1
   25540:	f887 307c 	strb.w	r3, [r7, #124]	; 0x7c
    init.config.ble_adv_fast_interval = ADV_INTERVAL;
   25544:	23a0      	movs	r3, #160	; 0xa0
   25546:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
    init.config.ble_adv_fast_timeout  = ADV_TIMEOUT_IN_SECONDS;
   2554a:	2300      	movs	r3, #0
   2554c:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c

    init.evt_handler = on_adv_evt;
   25550:	4b10      	ldr	r3, [pc, #64]	; (25594 <AdvertisingInit+0x7c>)
   25552:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98

    err_code = ble_advertising_init(&m_advertising, &init);
   25556:	463b      	mov	r3, r7
   25558:	4619      	mov	r1, r3
   2555a:	480f      	ldr	r0, [pc, #60]	; (25598 <AdvertisingInit+0x80>)
   2555c:	f002 fc3f 	bl	27dde <ble_advertising_init>
   25560:	f8c7 00a4 	str.w	r0, [r7, #164]	; 0xa4
    APP_ERROR_CHECK(err_code);
   25564:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
   25568:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
   2556c:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
   25570:	2b00      	cmp	r3, #0
   25572:	d005      	beq.n	25580 <AdvertisingInit+0x68>
   25574:	4a09      	ldr	r2, [pc, #36]	; (2559c <AdvertisingInit+0x84>)
   25576:	21ab      	movs	r1, #171	; 0xab
   25578:	f8d7 00a0 	ldr.w	r0, [r7, #160]	; 0xa0
   2557c:	f001 fbd0 	bl	26d20 <app_error_handler>

    ble_advertising_conn_cfg_tag_set(&m_advertising, APP_BLE_CONN_CFG_TAG);
   25580:	2101      	movs	r1, #1
   25582:	4805      	ldr	r0, [pc, #20]	; (25598 <AdvertisingInit+0x80>)
   25584:	f002 fc1c 	bl	27dc0 <ble_advertising_conn_cfg_tag_set>
}
   25588:	bf00      	nop
   2558a:	37a8      	adds	r7, #168	; 0xa8
   2558c:	46bd      	mov	sp, r7
   2558e:	bd80      	pop	{r7, pc}
   25590:	2000507c 	.word	0x2000507c
   25594:	000254cd 	.word	0x000254cd
   25598:	200051f4 	.word	0x200051f4
   2559c:	0002b504 	.word	0x0002b504

000255a0 <AdvertisingStart>:


/**@brief Function for starting advertising.
 */
void AdvertisingStart(void)
{
   255a0:	b580      	push	{r7, lr}
   255a2:	b082      	sub	sp, #8
   255a4:	af00      	add	r7, sp, #0
    ret_code_t err_code;

    err_code = ble_advertising_start(&m_advertising, BLE_ADV_MODE_FAST);
   255a6:	2103      	movs	r1, #3
   255a8:	4808      	ldr	r0, [pc, #32]	; (255cc <AdvertisingStart+0x2c>)
   255aa:	f002 fd29 	bl	28000 <ble_advertising_start>
   255ae:	6078      	str	r0, [r7, #4]
    APP_ERROR_CHECK(err_code);
   255b0:	687b      	ldr	r3, [r7, #4]
   255b2:	603b      	str	r3, [r7, #0]
   255b4:	683b      	ldr	r3, [r7, #0]
   255b6:	2b00      	cmp	r3, #0
   255b8:	d004      	beq.n	255c4 <AdvertisingStart+0x24>
   255ba:	4a05      	ldr	r2, [pc, #20]	; (255d0 <AdvertisingStart+0x30>)
   255bc:	21b8      	movs	r1, #184	; 0xb8
   255be:	6838      	ldr	r0, [r7, #0]
   255c0:	f001 fbae 	bl	26d20 <app_error_handler>
}
   255c4:	bf00      	nop
   255c6:	3708      	adds	r7, #8
   255c8:	46bd      	mov	sp, r7
   255ca:	bd80      	pop	{r7, pc}
   255cc:	200051f4 	.word	0x200051f4
   255d0:	0002b504 	.word	0x0002b504

000255d4 <sd_ble_gatts_service_add>:
SVCALL(SD_BLE_GATTS_SERVICE_ADD, uint32_t, sd_ble_gatts_service_add(uint8_t type, ble_uuid_t const *p_uuid, uint16_t *p_handle));
   255d4:	dfa0      	svc	160	; 0xa0
   255d6:	4770      	bx	lr
   255d8:	bf00      	nop
   255da:	4618      	mov	r0, r3

000255dc <sd_ble_gatts_characteristic_add>:
SVCALL(SD_BLE_GATTS_CHARACTERISTIC_ADD, uint32_t, sd_ble_gatts_characteristic_add(uint16_t service_handle, ble_gatts_char_md_t const *p_char_md, ble_gatts_attr_t const *p_attr_char_value, ble_gatts_char_handles_t *p_handles));
   255dc:	dfa2      	svc	162	; 0xa2
   255de:	4770      	bx	lr
   255e0:	bf00      	nop
   255e2:	4618      	mov	r0, r3

000255e4 <sd_ble_gatts_value_set>:
SVCALL(SD_BLE_GATTS_VALUE_SET, uint32_t, sd_ble_gatts_value_set(uint16_t conn_handle, uint16_t handle, ble_gatts_value_t *p_value));
   255e4:	dfa4      	svc	164	; 0xa4
   255e6:	4770      	bx	lr
   255e8:	bf00      	nop
   255ea:	4618      	mov	r0, r3

000255ec <sd_ble_gatts_hvx>:
SVCALL(SD_BLE_GATTS_HVX, uint32_t, sd_ble_gatts_hvx(uint16_t conn_handle, ble_gatts_hvx_params_t const *p_hvx_params));
   255ec:	dfa6      	svc	166	; 0xa6
   255ee:	4770      	bx	lr
   255f0:	bf00      	nop
   255f2:	4618      	mov	r0, r3

000255f4 <sd_ble_uuid_vs_add>:
SVCALL(SD_BLE_UUID_VS_ADD, uint32_t, sd_ble_uuid_vs_add(ble_uuid128_t const *p_vs_uuid, uint8_t *p_uuid_type));
   255f4:	df62      	svc	98	; 0x62
   255f6:	4770      	bx	lr
   255f8:	bf00      	nop
   255fa:	4618      	mov	r0, r3

000255fc <nrf_gpio_pin_port_decode>:
{
   255fc:	b480      	push	{r7}
   255fe:	b083      	sub	sp, #12
   25600:	af00      	add	r7, sp, #0
   25602:	6078      	str	r0, [r7, #4]
    return NRF_GPIO;
   25604:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
}
   25608:	4618      	mov	r0, r3
   2560a:	370c      	adds	r7, #12
   2560c:	46bd      	mov	sp, r7
   2560e:	bc80      	pop	{r7}
   25610:	4770      	bx	lr

00025612 <nrf_gpio_pin_set>:
{
   25612:	b580      	push	{r7, lr}
   25614:	b084      	sub	sp, #16
   25616:	af00      	add	r7, sp, #0
   25618:	6078      	str	r0, [r7, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   2561a:	1d3b      	adds	r3, r7, #4
   2561c:	4618      	mov	r0, r3
   2561e:	f7ff ffed 	bl	255fc <nrf_gpio_pin_port_decode>
   25622:	60f8      	str	r0, [r7, #12]
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   25624:	687b      	ldr	r3, [r7, #4]
   25626:	2201      	movs	r2, #1
   25628:	fa02 f303 	lsl.w	r3, r2, r3
   2562c:	4619      	mov	r1, r3
   2562e:	68f8      	ldr	r0, [r7, #12]
   25630:	f000 f819 	bl	25666 <nrf_gpio_port_out_set>
}
   25634:	bf00      	nop
   25636:	3710      	adds	r7, #16
   25638:	46bd      	mov	sp, r7
   2563a:	bd80      	pop	{r7, pc}

0002563c <nrf_gpio_pin_clear>:
{
   2563c:	b580      	push	{r7, lr}
   2563e:	b084      	sub	sp, #16
   25640:	af00      	add	r7, sp, #0
   25642:	6078      	str	r0, [r7, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   25644:	1d3b      	adds	r3, r7, #4
   25646:	4618      	mov	r0, r3
   25648:	f7ff ffd8 	bl	255fc <nrf_gpio_pin_port_decode>
   2564c:	60f8      	str	r0, [r7, #12]
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   2564e:	687b      	ldr	r3, [r7, #4]
   25650:	2201      	movs	r2, #1
   25652:	fa02 f303 	lsl.w	r3, r2, r3
   25656:	4619      	mov	r1, r3
   25658:	68f8      	ldr	r0, [r7, #12]
   2565a:	f000 f812 	bl	25682 <nrf_gpio_port_out_clear>
}
   2565e:	bf00      	nop
   25660:	3710      	adds	r7, #16
   25662:	46bd      	mov	sp, r7
   25664:	bd80      	pop	{r7, pc}

00025666 <nrf_gpio_port_out_set>:
{
   25666:	b480      	push	{r7}
   25668:	b083      	sub	sp, #12
   2566a:	af00      	add	r7, sp, #0
   2566c:	6078      	str	r0, [r7, #4]
   2566e:	6039      	str	r1, [r7, #0]
    p_reg->OUTSET = set_mask;
   25670:	687b      	ldr	r3, [r7, #4]
   25672:	683a      	ldr	r2, [r7, #0]
   25674:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
}
   25678:	bf00      	nop
   2567a:	370c      	adds	r7, #12
   2567c:	46bd      	mov	sp, r7
   2567e:	bc80      	pop	{r7}
   25680:	4770      	bx	lr

00025682 <nrf_gpio_port_out_clear>:
{
   25682:	b480      	push	{r7}
   25684:	b083      	sub	sp, #12
   25686:	af00      	add	r7, sp, #0
   25688:	6078      	str	r0, [r7, #4]
   2568a:	6039      	str	r1, [r7, #0]
    p_reg->OUTCLR = clr_mask;
   2568c:	687b      	ldr	r3, [r7, #4]
   2568e:	683a      	ldr	r2, [r7, #0]
   25690:	f8c3 250c 	str.w	r2, [r3, #1292]	; 0x50c
}
   25694:	bf00      	nop
   25696:	370c      	adds	r7, #12
   25698:	46bd      	mov	sp, r7
   2569a:	bc80      	pop	{r7}
   2569c:	4770      	bx	lr
	...

000256a0 <BleUartAddPendingTask>:

static fifo_t               ble_uart_pending_requests_fifo;
static uint8_t              ble_uart_pending_requests_fifo_buffer[16];

uint32_t BleUartAddPendingTask(ble_uart_communication_commands_e command)
{
   256a0:	b580      	push	{r7, lr}
   256a2:	b082      	sub	sp, #8
   256a4:	af00      	add	r7, sp, #0
   256a6:	4603      	mov	r3, r0
   256a8:	71fb      	strb	r3, [r7, #7]
    FifoPut(&ble_uart_pending_requests_fifo, command);
   256aa:	79fb      	ldrb	r3, [r7, #7]
   256ac:	4619      	mov	r1, r3
   256ae:	4804      	ldr	r0, [pc, #16]	; (256c0 <BleUartAddPendingTask+0x20>)
   256b0:	f7fe fc49 	bl	23f46 <FifoPut>

    return NRF_SUCCESS;
   256b4:	2300      	movs	r3, #0
}
   256b6:	4618      	mov	r0, r3
   256b8:	3708      	adds	r7, #8
   256ba:	46bd      	mov	sp, r7
   256bc:	bd80      	pop	{r7, pc}
   256be:	bf00      	nop
   256c0:	20005308 	.word	0x20005308

000256c4 <_OnConnect>:
 *
 * @param[in]   p_uart       Blood Pressure Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void _OnConnect(ble_uart_t * p_uart, ble_evt_t * p_ble_evt)
{
   256c4:	b480      	push	{r7}
   256c6:	b083      	sub	sp, #12
   256c8:	af00      	add	r7, sp, #0
   256ca:	6078      	str	r0, [r7, #4]
   256cc:	6039      	str	r1, [r7, #0]
    p_uart->conn_handle = p_ble_evt->evt.gatts_evt.conn_handle;
   256ce:	683b      	ldr	r3, [r7, #0]
   256d0:	889a      	ldrh	r2, [r3, #4]
   256d2:	687b      	ldr	r3, [r7, #4]
   256d4:	841a      	strh	r2, [r3, #32]
    m_conn_handle_peripheral = p_ble_evt->evt.gatts_evt.conn_handle;
   256d6:	683b      	ldr	r3, [r7, #0]
   256d8:	889a      	ldrh	r2, [r3, #4]
   256da:	4b03      	ldr	r3, [pc, #12]	; (256e8 <_OnConnect+0x24>)
   256dc:	801a      	strh	r2, [r3, #0]
}
   256de:	bf00      	nop
   256e0:	370c      	adds	r7, #12
   256e2:	46bd      	mov	sp, r7
   256e4:	bc80      	pop	{r7}
   256e6:	4770      	bx	lr
   256e8:	2000506a 	.word	0x2000506a

000256ec <_OnDisconnect>:
 *
 * @param[in]   p_uart       Blood Pressure Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void _OnDisconnect(ble_uart_t * p_uart, ble_evt_t * p_ble_evt)
{
   256ec:	b480      	push	{r7}
   256ee:	b083      	sub	sp, #12
   256f0:	af00      	add	r7, sp, #0
   256f2:	6078      	str	r0, [r7, #4]
   256f4:	6039      	str	r1, [r7, #0]
    UNUSED_PARAMETER(p_ble_evt);
    p_uart->conn_handle = BLE_CONN_HANDLE_INVALID;
   256f6:	687b      	ldr	r3, [r7, #4]
   256f8:	f64f 72ff 	movw	r2, #65535	; 0xffff
   256fc:	841a      	strh	r2, [r3, #32]
    m_conn_handle_peripheral = BLE_CONN_HANDLE_INVALID;
   256fe:	4b04      	ldr	r3, [pc, #16]	; (25710 <_OnDisconnect+0x24>)
   25700:	f64f 72ff 	movw	r2, #65535	; 0xffff
   25704:	801a      	strh	r2, [r3, #0]
}
   25706:	bf00      	nop
   25708:	370c      	adds	r7, #12
   2570a:	46bd      	mov	sp, r7
   2570c:	bc80      	pop	{r7}
   2570e:	4770      	bx	lr
   25710:	2000506a 	.word	0x2000506a

00025714 <_OnTxCccdWrite>:
 *
 * @param[in]   p_uart         Data Transfer Service structure.
 * @param[in]   p_evt_write   Write event received from the BLE stack.
 */
static void _OnTxCccdWrite(ble_uart_t * p_uart, ble_gatts_evt_write_t * p_evt_write)
{
   25714:	b590      	push	{r4, r7, lr}
   25716:	b087      	sub	sp, #28
   25718:	af00      	add	r7, sp, #0
   2571a:	6078      	str	r0, [r7, #4]
   2571c:	6039      	str	r1, [r7, #0]
    if (p_evt_write->len == 2)
   2571e:	683b      	ldr	r3, [r7, #0]
   25720:	895b      	ldrh	r3, [r3, #10]
   25722:	2b02      	cmp	r3, #2
   25724:	d11a      	bne.n	2575c <_OnTxCccdWrite+0x48>
    {
        // CCCD written, update indication state
        if (p_uart->evt_handler != NULL)
   25726:	687b      	ldr	r3, [r7, #4]
   25728:	681b      	ldr	r3, [r3, #0]
   2572a:	2b00      	cmp	r3, #0
   2572c:	d016      	beq.n	2575c <_OnTxCccdWrite+0x48>
        {
            ble_uart_evt_t evt;

            if (ble_srv_is_indication_enabled(p_evt_write->data))
   2572e:	683b      	ldr	r3, [r7, #0]
   25730:	330c      	adds	r3, #12
   25732:	4618      	mov	r0, r3
   25734:	f002 f97f 	bl	27a36 <ble_srv_is_indication_enabled>
   25738:	4603      	mov	r3, r0
   2573a:	2b00      	cmp	r3, #0
   2573c:	d002      	beq.n	25744 <_OnTxCccdWrite+0x30>
            {
                evt.evt_type = BLE_UART_EVT_INDICATION_ENABLED;
   2573e:	2300      	movs	r3, #0
   25740:	723b      	strb	r3, [r7, #8]
   25742:	e001      	b.n	25748 <_OnTxCccdWrite+0x34>
            }
            else
            {
                evt.evt_type = BLE_UART_EVT_INDICATION_DISABLED;
   25744:	2301      	movs	r3, #1
   25746:	723b      	strb	r3, [r7, #8]
            }

            p_uart->evt_handler(p_uart, &evt, p_evt_write->data, 0);
   25748:	687b      	ldr	r3, [r7, #4]
   2574a:	681c      	ldr	r4, [r3, #0]
   2574c:	683b      	ldr	r3, [r7, #0]
   2574e:	f103 020c 	add.w	r2, r3, #12
   25752:	f107 0108 	add.w	r1, r7, #8
   25756:	2300      	movs	r3, #0
   25758:	6878      	ldr	r0, [r7, #4]
   2575a:	47a0      	blx	r4
        }
    }
}
   2575c:	bf00      	nop
   2575e:	371c      	adds	r7, #28
   25760:	46bd      	mov	sp, r7
   25762:	bd90      	pop	{r4, r7, pc}

00025764 <_OnDevEventsCccdWrite>:
 *
 * @param[in]   p_uart         Data Transfer Service structure.
 * @param[in]   p_evt_write   Write event received from the BLE stack.
 */
static void _OnDevEventsCccdWrite(ble_uart_t * p_uart, ble_gatts_evt_write_t * p_evt_write)
{
   25764:	b590      	push	{r4, r7, lr}
   25766:	b087      	sub	sp, #28
   25768:	af00      	add	r7, sp, #0
   2576a:	6078      	str	r0, [r7, #4]
   2576c:	6039      	str	r1, [r7, #0]
    if (p_evt_write->len == 2)
   2576e:	683b      	ldr	r3, [r7, #0]
   25770:	895b      	ldrh	r3, [r3, #10]
   25772:	2b02      	cmp	r3, #2
   25774:	d11a      	bne.n	257ac <_OnDevEventsCccdWrite+0x48>
    {
        // CCCD written, update indication state
        if (p_uart->evt_handler != NULL)
   25776:	687b      	ldr	r3, [r7, #4]
   25778:	681b      	ldr	r3, [r3, #0]
   2577a:	2b00      	cmp	r3, #0
   2577c:	d016      	beq.n	257ac <_OnDevEventsCccdWrite+0x48>
        {
            ble_uart_evt_t evt;

            if (ble_srv_is_notification_enabled(p_evt_write->data))
   2577e:	683b      	ldr	r3, [r7, #0]
   25780:	330c      	adds	r3, #12
   25782:	4618      	mov	r0, r3
   25784:	f002 f942 	bl	27a0c <ble_srv_is_notification_enabled>
   25788:	4603      	mov	r3, r0
   2578a:	2b00      	cmp	r3, #0
   2578c:	d002      	beq.n	25794 <_OnDevEventsCccdWrite+0x30>
            {
                evt.evt_type = BLE_UART_EVT_NOTIFICATION_ENABLED;
   2578e:	2302      	movs	r3, #2
   25790:	723b      	strb	r3, [r7, #8]
   25792:	e001      	b.n	25798 <_OnDevEventsCccdWrite+0x34>
            }
            else
            {
                evt.evt_type = BLE_UART_EVT_NOTIFICATION_DISABLED;
   25794:	2303      	movs	r3, #3
   25796:	723b      	strb	r3, [r7, #8]
            }

            p_uart->evt_handler(p_uart, &evt, p_evt_write->data, 0);
   25798:	687b      	ldr	r3, [r7, #4]
   2579a:	681c      	ldr	r4, [r3, #0]
   2579c:	683b      	ldr	r3, [r7, #0]
   2579e:	f103 020c 	add.w	r2, r3, #12
   257a2:	f107 0108 	add.w	r1, r7, #8
   257a6:	2300      	movs	r3, #0
   257a8:	6878      	ldr	r0, [r7, #4]
   257aa:	47a0      	blx	r4
        }
    }
}
   257ac:	bf00      	nop
   257ae:	371c      	adds	r7, #28
   257b0:	46bd      	mov	sp, r7
   257b2:	bd90      	pop	{r4, r7, pc}

000257b4 <_OnRxWrite>:
 *
 * @param[in]   p_uart         Data Transfer Service structure.
 * @param[in]   p_evt_write   Write event received from the BLE stack.
 */
static void _OnRxWrite(ble_uart_t * p_uart, ble_gatts_evt_write_t * p_evt_write)
{
   257b4:	b590      	push	{r4, r7, lr}
   257b6:	b087      	sub	sp, #28
   257b8:	af00      	add	r7, sp, #0
   257ba:	6078      	str	r0, [r7, #4]
   257bc:	6039      	str	r1, [r7, #0]
    nrf_gpio_pin_set(BLUE_LED);
   257be:	2010      	movs	r0, #16
   257c0:	f7ff ff27 	bl	25612 <nrf_gpio_pin_set>
    nrf_gpio_pin_clear(GREEN_LED);
   257c4:	200f      	movs	r0, #15
   257c6:	f7ff ff39 	bl	2563c <nrf_gpio_pin_clear>
    if (p_evt_write->len)
   257ca:	683b      	ldr	r3, [r7, #0]
   257cc:	895b      	ldrh	r3, [r3, #10]
   257ce:	2b00      	cmp	r3, #0
   257d0:	d011      	beq.n	257f6 <_OnRxWrite+0x42>
    {
        // CCCD written, update indication state
        if (p_uart->evt_handler != NULL)
   257d2:	687b      	ldr	r3, [r7, #4]
   257d4:	681b      	ldr	r3, [r3, #0]
   257d6:	2b00      	cmp	r3, #0
   257d8:	d00d      	beq.n	257f6 <_OnRxWrite+0x42>
        {
            ble_uart_evt_t evt;
                        evt.evt_type = BLE_UART_EVT_RX_DATA_RECEIVED;
   257da:	2306      	movs	r3, #6
   257dc:	723b      	strb	r3, [r7, #8]
            p_uart->evt_handler(p_uart, &evt, p_evt_write->data, p_evt_write->len);
   257de:	687b      	ldr	r3, [r7, #4]
   257e0:	681c      	ldr	r4, [r3, #0]
   257e2:	683b      	ldr	r3, [r7, #0]
   257e4:	f103 020c 	add.w	r2, r3, #12
   257e8:	683b      	ldr	r3, [r7, #0]
   257ea:	895b      	ldrh	r3, [r3, #10]
   257ec:	b2db      	uxtb	r3, r3
   257ee:	f107 0108 	add.w	r1, r7, #8
   257f2:	6878      	ldr	r0, [r7, #4]
   257f4:	47a0      	blx	r4
        }
    }
}
   257f6:	bf00      	nop
   257f8:	371c      	adds	r7, #28
   257fa:	46bd      	mov	sp, r7
   257fc:	bd90      	pop	{r4, r7, pc}
	...

00025800 <_OnWrite>:
 *
 * @param[in]   p_uart       Blood Pressure Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void _OnWrite(ble_uart_t * p_uart, ble_evt_t * p_ble_evt)
{
   25800:	b580      	push	{r7, lr}
   25802:	b084      	sub	sp, #16
   25804:	af00      	add	r7, sp, #0
   25806:	6078      	str	r0, [r7, #4]
   25808:	6039      	str	r1, [r7, #0]
    ble_gatts_evt_write_t * p_evt_write = &p_ble_evt->evt.gatts_evt.params.write;
   2580a:	683b      	ldr	r3, [r7, #0]
   2580c:	3306      	adds	r3, #6
   2580e:	60fb      	str	r3, [r7, #12]
    static uint8_t tx_enabled = 0;
    static uint8_t evt_enabled = 0;

    if (p_evt_write->handle == p_uart->rx_handles.value_handle) //Handle VALUE write to RX characteristic
   25810:	68fb      	ldr	r3, [r7, #12]
   25812:	881a      	ldrh	r2, [r3, #0]
   25814:	687b      	ldr	r3, [r7, #4]
   25816:	89db      	ldrh	r3, [r3, #14]
   25818:	429a      	cmp	r2, r3
   2581a:	d103      	bne.n	25824 <_OnWrite+0x24>
    {
        _OnRxWrite(p_uart, p_evt_write);
   2581c:	68f9      	ldr	r1, [r7, #12]
   2581e:	6878      	ldr	r0, [r7, #4]
   25820:	f7ff ffc8 	bl	257b4 <_OnRxWrite>
    }

    if (p_evt_write->handle == p_uart->tx_handles.cccd_handle) //Handle CCCD write to TX characteristic
   25824:	68fb      	ldr	r3, [r7, #12]
   25826:	881a      	ldrh	r2, [r3, #0]
   25828:	687b      	ldr	r3, [r7, #4]
   2582a:	895b      	ldrh	r3, [r3, #10]
   2582c:	429a      	cmp	r2, r3
   2582e:	d106      	bne.n	2583e <_OnWrite+0x3e>
    {
        _OnTxCccdWrite(p_uart, p_evt_write);
   25830:	68f9      	ldr	r1, [r7, #12]
   25832:	6878      	ldr	r0, [r7, #4]
   25834:	f7ff ff6e 	bl	25714 <_OnTxCccdWrite>
        tx_enabled = 1;
   25838:	4b09      	ldr	r3, [pc, #36]	; (25860 <_OnWrite+0x60>)
   2583a:	2201      	movs	r2, #1
   2583c:	701a      	strb	r2, [r3, #0]
    }

    if (p_evt_write->handle == p_uart->dev_events_handles.cccd_handle) //Handle CCCD write to Device Events characteristic
   2583e:	68fb      	ldr	r3, [r7, #12]
   25840:	881a      	ldrh	r2, [r3, #0]
   25842:	687b      	ldr	r3, [r7, #4]
   25844:	8b5b      	ldrh	r3, [r3, #26]
   25846:	429a      	cmp	r2, r3
   25848:	d106      	bne.n	25858 <_OnWrite+0x58>
    {
        _OnDevEventsCccdWrite(p_uart, p_evt_write);
   2584a:	68f9      	ldr	r1, [r7, #12]
   2584c:	6878      	ldr	r0, [r7, #4]
   2584e:	f7ff ff89 	bl	25764 <_OnDevEventsCccdWrite>
        evt_enabled = 1;
   25852:	4b04      	ldr	r3, [pc, #16]	; (25864 <_OnWrite+0x64>)
   25854:	2201      	movs	r2, #1
   25856:	701a      	strb	r2, [r3, #0]
    }


}
   25858:	bf00      	nop
   2585a:	3710      	adds	r7, #16
   2585c:	46bd      	mov	sp, r7
   2585e:	bd80      	pop	{r7, pc}
   25860:	20005324 	.word	0x20005324
   25864:	20005325 	.word	0x20005325

00025868 <_OnHvc>:
 *
 * @param[in]   p_uart       Blood Pressure Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void _OnHvc(ble_uart_t * p_uart, ble_evt_t * p_ble_evt)
{
   25868:	b590      	push	{r4, r7, lr}
   2586a:	b089      	sub	sp, #36	; 0x24
   2586c:	af00      	add	r7, sp, #0
   2586e:	6078      	str	r0, [r7, #4]
   25870:	6039      	str	r1, [r7, #0]
    ble_gatts_evt_hvc_t * p_hvc = &p_ble_evt->evt.gatts_evt.params.hvc;
   25872:	683b      	ldr	r3, [r7, #0]
   25874:	3306      	adds	r3, #6
   25876:	61fb      	str	r3, [r7, #28]

    if (p_hvc->handle == p_uart->tx_handles.value_handle)
   25878:	69fb      	ldr	r3, [r7, #28]
   2587a:	881a      	ldrh	r2, [r3, #0]
   2587c:	687b      	ldr	r3, [r7, #4]
   2587e:	88db      	ldrh	r3, [r3, #6]
   25880:	429a      	cmp	r2, r3
   25882:	d109      	bne.n	25898 <_OnHvc+0x30>
    {
        ble_uart_evt_t evt;

        evt.evt_type = BLE_UART_EVT_INDICATION_CONFIRMED;
   25884:	2305      	movs	r3, #5
   25886:	733b      	strb	r3, [r7, #12]
        p_uart->evt_handler(p_uart, &evt, 0, 0);
   25888:	687b      	ldr	r3, [r7, #4]
   2588a:	681c      	ldr	r4, [r3, #0]
   2588c:	f107 010c 	add.w	r1, r7, #12
   25890:	2300      	movs	r3, #0
   25892:	2200      	movs	r2, #0
   25894:	6878      	ldr	r0, [r7, #4]
   25896:	47a0      	blx	r4
    }
}
   25898:	bf00      	nop
   2589a:	3724      	adds	r7, #36	; 0x24
   2589c:	46bd      	mov	sp, r7
   2589e:	bd90      	pop	{r4, r7, pc}

000258a0 <_OnNotifyCompleted>:

static void _OnNotifyCompleted(ble_uart_t * p_uart, ble_evt_t * p_ble_evt)
{
   258a0:	b590      	push	{r4, r7, lr}
   258a2:	b087      	sub	sp, #28
   258a4:	af00      	add	r7, sp, #0
   258a6:	6078      	str	r0, [r7, #4]
   258a8:	6039      	str	r1, [r7, #0]

    //if (p_hvc->handle == p_uart->dev_events_handles.value_handle)
   // {
        ble_uart_evt_t evt;

        evt.evt_type = BLE_UART_EVT_NOTIFICATION_TRANSMITTED;
   258aa:	2304      	movs	r3, #4
   258ac:	723b      	strb	r3, [r7, #8]
        p_uart->evt_handler(p_uart, &evt, 0, 0);
   258ae:	687b      	ldr	r3, [r7, #4]
   258b0:	681c      	ldr	r4, [r3, #0]
   258b2:	f107 0108 	add.w	r1, r7, #8
   258b6:	2300      	movs	r3, #0
   258b8:	2200      	movs	r2, #0
   258ba:	6878      	ldr	r0, [r7, #4]
   258bc:	47a0      	blx	r4
    //}
}
   258be:	bf00      	nop
   258c0:	371c      	adds	r7, #28
   258c2:	46bd      	mov	sp, r7
   258c4:	bd90      	pop	{r4, r7, pc}

000258c6 <BleUartOnBleEvt>:
 *
 * @param[in]   p_uart      Data Transfer Service structure.
 * @param[in]   p_ble_evt  Event received from the BLE stack.
 */
void BleUartOnBleEvt(ble_uart_t * p_uart, ble_evt_t const * p_ble_evt)
{
   258c6:	b580      	push	{r7, lr}
   258c8:	b084      	sub	sp, #16
   258ca:	af00      	add	r7, sp, #0
   258cc:	6078      	str	r0, [r7, #4]
   258ce:	6039      	str	r1, [r7, #0]
    ble_evt_t* ble_evt = (ble_evt_t*)p_ble_evt;
   258d0:	683b      	ldr	r3, [r7, #0]
   258d2:	60fb      	str	r3, [r7, #12]
    switch (p_ble_evt->header.evt_id)
   258d4:	683b      	ldr	r3, [r7, #0]
   258d6:	881b      	ldrh	r3, [r3, #0]
   258d8:	2b50      	cmp	r3, #80	; 0x50
   258da:	d017      	beq.n	2590c <BleUartOnBleEvt+0x46>
   258dc:	2b50      	cmp	r3, #80	; 0x50
   258de:	dc04      	bgt.n	258ea <BleUartOnBleEvt+0x24>
   258e0:	2b10      	cmp	r3, #16
   258e2:	d009      	beq.n	258f8 <BleUartOnBleEvt+0x32>
   258e4:	2b11      	cmp	r3, #17
   258e6:	d00c      	beq.n	25902 <BleUartOnBleEvt+0x3c>
        {
            break;
        }
        default:
            // No implementation needed.
            break;
   258e8:	e020      	b.n	2592c <BleUartOnBleEvt+0x66>
    switch (p_ble_evt->header.evt_id)
   258ea:	2b56      	cmp	r3, #86	; 0x56
   258ec:	d01d      	beq.n	2592a <BleUartOnBleEvt+0x64>
   258ee:	2b57      	cmp	r3, #87	; 0x57
   258f0:	d016      	beq.n	25920 <BleUartOnBleEvt+0x5a>
   258f2:	2b53      	cmp	r3, #83	; 0x53
   258f4:	d00f      	beq.n	25916 <BleUartOnBleEvt+0x50>
            break;
   258f6:	e019      	b.n	2592c <BleUartOnBleEvt+0x66>
            _OnConnect(p_uart, ble_evt);
   258f8:	68f9      	ldr	r1, [r7, #12]
   258fa:	6878      	ldr	r0, [r7, #4]
   258fc:	f7ff fee2 	bl	256c4 <_OnConnect>
            break;
   25900:	e014      	b.n	2592c <BleUartOnBleEvt+0x66>
            _OnDisconnect(p_uart, ble_evt);
   25902:	68f9      	ldr	r1, [r7, #12]
   25904:	6878      	ldr	r0, [r7, #4]
   25906:	f7ff fef1 	bl	256ec <_OnDisconnect>
            break;
   2590a:	e00f      	b.n	2592c <BleUartOnBleEvt+0x66>
            _OnWrite(p_uart, ble_evt);
   2590c:	68f9      	ldr	r1, [r7, #12]
   2590e:	6878      	ldr	r0, [r7, #4]
   25910:	f7ff ff76 	bl	25800 <_OnWrite>
            break;
   25914:	e00a      	b.n	2592c <BleUartOnBleEvt+0x66>
            _OnHvc(p_uart, ble_evt);
   25916:	68f9      	ldr	r1, [r7, #12]
   25918:	6878      	ldr	r0, [r7, #4]
   2591a:	f7ff ffa5 	bl	25868 <_OnHvc>
            break;
   2591e:	e005      	b.n	2592c <BleUartOnBleEvt+0x66>
            _OnNotifyCompleted(p_uart, ble_evt);
   25920:	68f9      	ldr	r1, [r7, #12]
   25922:	6878      	ldr	r0, [r7, #4]
   25924:	f7ff ffbc 	bl	258a0 <_OnNotifyCompleted>
            break;
   25928:	e000      	b.n	2592c <BleUartOnBleEvt+0x66>
            break;
   2592a:	bf00      	nop
    }
}
   2592c:	bf00      	nop
   2592e:	3710      	adds	r7, #16
   25930:	46bd      	mov	sp, r7
   25932:	bd80      	pop	{r7, pc}

00025934 <_BleUartWaitTillPacketTxInProgress>:

/**
 * \brief This function blocks program execution until the single BLE packet is transmitted
 */
static void _BleUartWaitTillPacketTxInProgress()
{
   25934:	b480      	push	{r7}
   25936:	af00      	add	r7, sp, #0
    while(ble_tx_packet_in_progress)
   25938:	e000      	b.n	2593c <_BleUartWaitTillPacketTxInProgress+0x8>
  __ASM volatile ("wfe");
   2593a:	bf20      	wfe
   2593c:	4b04      	ldr	r3, [pc, #16]	; (25950 <_BleUartWaitTillPacketTxInProgress+0x1c>)
   2593e:	781b      	ldrb	r3, [r3, #0]
   25940:	b2db      	uxtb	r3, r3
   25942:	2b00      	cmp	r3, #0
   25944:	d1f9      	bne.n	2593a <_BleUartWaitTillPacketTxInProgress+0x6>
    {
        __WFE();
    }

    return;
   25946:	bf00      	nop
}
   25948:	46bd      	mov	sp, r7
   2594a:	bc80      	pop	{r7}
   2594c:	4770      	bx	lr
   2594e:	bf00      	nop
   25950:	200052cc 	.word	0x200052cc

00025954 <_BleUartNotifyWaitTillPacketInProgress>:

/**
 * \brief This function blocks program execution until the single BLE packet is transmitted
 */
static uint32_t  _BleUartNotifyWaitTillPacketInProgress()
{
   25954:	b480      	push	{r7}
   25956:	af00      	add	r7, sp, #0
//    RTCTimeout(NRF_RTC1, RTC_S_TO_TICKS(1));
    while(ble_notification_packet_in_progress)// && !timeout_flag)
   25958:	e000      	b.n	2595c <_BleUartNotifyWaitTillPacketInProgress+0x8>
   2595a:	bf20      	wfe
   2595c:	4b04      	ldr	r3, [pc, #16]	; (25970 <_BleUartNotifyWaitTillPacketInProgress+0x1c>)
   2595e:	781b      	ldrb	r3, [r3, #0]
   25960:	b2db      	uxtb	r3, r3
   25962:	2b00      	cmp	r3, #0
   25964:	d1f9      	bne.n	2595a <_BleUartNotifyWaitTillPacketInProgress+0x6>
//        timeout_flag = 0;
//        return NRF_ERROR_INTERNAL;
//    }
//
//    timeout_flag = 0;
    return NRF_SUCCESS;;
   25966:	2300      	movs	r3, #0
}
   25968:	4618      	mov	r0, r3
   2596a:	46bd      	mov	sp, r7
   2596c:	bc80      	pop	{r7}
   2596e:	4770      	bx	lr
   25970:	200052cd 	.word	0x200052cd

00025974 <_BleUartRxHandler>:
 *
 * \param p_data - pointer to the data sent from central to the device
 * \param data_size - size of data sent from central to the device
 */
static uint32_t _BleUartRxHandler(uint8_t* p_data, uint8_t data_size)
{
   25974:	b580      	push	{r7, lr}
   25976:	b08a      	sub	sp, #40	; 0x28
   25978:	af02      	add	r7, sp, #8
   2597a:	6078      	str	r0, [r7, #4]
   2597c:	460b      	mov	r3, r1
   2597e:	70fb      	strb	r3, [r7, #3]
    uint32_t err_code = 0;
   25980:	2300      	movs	r3, #0
   25982:	61fb      	str	r3, [r7, #28]

    uint8_t request_code = p_data[0] & 0x7F;
   25984:	687b      	ldr	r3, [r7, #4]
   25986:	781b      	ldrb	r3, [r3, #0]
   25988:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   2598c:	76fb      	strb	r3, [r7, #27]
    uint8_t packetSize = p_data[1];
   2598e:	687b      	ldr	r3, [r7, #4]
   25990:	785b      	ldrb	r3, [r3, #1]
   25992:	76bb      	strb	r3, [r7, #26]

    uint8_t packet[16];

    switch(request_code)
   25994:	7efb      	ldrb	r3, [r7, #27]
   25996:	2b15      	cmp	r3, #21
   25998:	d000      	beq.n	2599c <_BleUartRxHandler+0x28>
            CryptoECBDecryptData(p_data + 2, CRYPTO_KEY_SIZE, mainEncryptionKey, CRYPTO_KEY_SIZE, tempEncryptionKey);
            BleUartAddPendingTask(E_BLE_UART_DEACTIVATE_ALARM);
        }break;

        default:
            break;
   2599a:	e00c      	b.n	259b6 <_BleUartRxHandler+0x42>
            CryptoECBDecryptData(p_data + 2, CRYPTO_KEY_SIZE, mainEncryptionKey, CRYPTO_KEY_SIZE, tempEncryptionKey);
   2599c:	687b      	ldr	r3, [r7, #4]
   2599e:	1c98      	adds	r0, r3, #2
   259a0:	4b07      	ldr	r3, [pc, #28]	; (259c0 <_BleUartRxHandler+0x4c>)
   259a2:	9300      	str	r3, [sp, #0]
   259a4:	2310      	movs	r3, #16
   259a6:	4a07      	ldr	r2, [pc, #28]	; (259c4 <_BleUartRxHandler+0x50>)
   259a8:	2110      	movs	r1, #16
   259aa:	f7fe fbeb 	bl	24184 <CryptoECBDecryptData>
            BleUartAddPendingTask(E_BLE_UART_DEACTIVATE_ALARM);
   259ae:	2016      	movs	r0, #22
   259b0:	f7ff fe76 	bl	256a0 <BleUartAddPendingTask>
        }break;
   259b4:	bf00      	nop
    }

    return NRF_SUCCESS;
   259b6:	2300      	movs	r3, #0
}
   259b8:	4618      	mov	r0, r3
   259ba:	3720      	adds	r7, #32
   259bc:	46bd      	mov	sp, r7
   259be:	bd80      	pop	{r7, pc}
   259c0:	20005430 	.word	0x20005430
   259c4:	20005410 	.word	0x20005410

000259c8 <BleExecutePendingRequests>:

uint32_t BleExecutePendingRequests()
{
   259c8:	b580      	push	{r7, lr}
   259ca:	b088      	sub	sp, #32
   259cc:	af02      	add	r7, sp, #8
    uint8_t request = 0;
   259ce:	2300      	movs	r3, #0
   259d0:	75fb      	strb	r3, [r7, #23]
    while (!FifoIsEmpty(&ble_uart_pending_requests_fifo))
   259d2:	e023      	b.n	25a1c <BleExecutePendingRequests+0x54>
    {
        FifoGet(&ble_uart_pending_requests_fifo, &request);
   259d4:	f107 0317 	add.w	r3, r7, #23
   259d8:	4619      	mov	r1, r3
   259da:	4816      	ldr	r0, [pc, #88]	; (25a34 <BleExecutePendingRequests+0x6c>)
   259dc:	f7fe fa79 	bl	23ed2 <FifoGet>

        switch (request)
   259e0:	7dfb      	ldrb	r3, [r7, #23]
   259e2:	2b16      	cmp	r3, #22
   259e4:	d119      	bne.n	25a1a <BleExecutePendingRequests+0x52>
        {
            case E_BLE_UART_DEACTIVATE_ALARM:
            {
                uint8_t encryptedDeactivationCmd[CRYPTO_KEY_SIZE];
                memcpy(encryptedDeactivationCmd, alarmDeactivationCmd, CRYPTO_KEY_SIZE);
   259e6:	1d3b      	adds	r3, r7, #4
   259e8:	2210      	movs	r2, #16
   259ea:	4913      	ldr	r1, [pc, #76]	; (25a38 <BleExecutePendingRequests+0x70>)
   259ec:	4618      	mov	r0, r3
   259ee:	f005 fc7f 	bl	2b2f0 <memcpy>
                CryptoCFBEncryptData(alarmDeactivationCmd, tempEncryptionKey, mainEncryptionKey, CRYPTO_KEY_SIZE, encryptedDeactivationCmd, CRYPTO_KEY_SIZE);
   259f2:	2310      	movs	r3, #16
   259f4:	9301      	str	r3, [sp, #4]
   259f6:	1d3b      	adds	r3, r7, #4
   259f8:	9300      	str	r3, [sp, #0]
   259fa:	2310      	movs	r3, #16
   259fc:	4a0f      	ldr	r2, [pc, #60]	; (25a3c <BleExecutePendingRequests+0x74>)
   259fe:	4910      	ldr	r1, [pc, #64]	; (25a40 <BleExecutePendingRequests+0x78>)
   25a00:	480d      	ldr	r0, [pc, #52]	; (25a38 <BleExecutePendingRequests+0x70>)
   25a02:	f7fe fbe9 	bl	241d8 <CryptoCFBEncryptData>
                BleUartDataIndicate(m_conn_handle_peripheral, E_BLE_UART_DEACTIVATE_ALARM, encryptedDeactivationCmd, CRYPTO_KEY_SIZE, false);
   25a06:	4b0f      	ldr	r3, [pc, #60]	; (25a44 <BleExecutePendingRequests+0x7c>)
   25a08:	8818      	ldrh	r0, [r3, #0]
   25a0a:	1d3a      	adds	r2, r7, #4
   25a0c:	2300      	movs	r3, #0
   25a0e:	9300      	str	r3, [sp, #0]
   25a10:	2310      	movs	r3, #16
   25a12:	2116      	movs	r1, #22
   25a14:	f000 f8b8 	bl	25b88 <BleUartDataIndicate>
            }break;
   25a18:	e000      	b.n	25a1c <BleExecutePendingRequests+0x54>

            default:
                break;
   25a1a:	bf00      	nop
    while (!FifoIsEmpty(&ble_uart_pending_requests_fifo))
   25a1c:	4805      	ldr	r0, [pc, #20]	; (25a34 <BleExecutePendingRequests+0x6c>)
   25a1e:	f7fe fac6 	bl	23fae <FifoIsEmpty>
   25a22:	4603      	mov	r3, r0
   25a24:	2b00      	cmp	r3, #0
   25a26:	d0d5      	beq.n	259d4 <BleExecutePendingRequests+0xc>
        }
    }

    return 0;
   25a28:	2300      	movs	r3, #0
}
   25a2a:	4618      	mov	r0, r3
   25a2c:	3718      	adds	r7, #24
   25a2e:	46bd      	mov	sp, r7
   25a30:	bd80      	pop	{r7, pc}
   25a32:	bf00      	nop
   25a34:	20005308 	.word	0x20005308
   25a38:	20005420 	.word	0x20005420
   25a3c:	20005410 	.word	0x20005410
   25a40:	20005430 	.word	0x20005430
   25a44:	2000506a 	.word	0x2000506a

00025a48 <_BleUartIndicateSendSinglePacket>:
 *  \param data - pointer to the data buffer
 *  \param data_size - size of data in the packet
 *
 */
static uint32_t _BleUartIndicateSendSinglePacket(ble_uart_t* p_uart, uint8_t* data, uint8_t actual_data_size)
{
   25a48:	b580      	push	{r7, lr}
   25a4a:	b08c      	sub	sp, #48	; 0x30
   25a4c:	af00      	add	r7, sp, #0
   25a4e:	60f8      	str	r0, [r7, #12]
   25a50:	60b9      	str	r1, [r7, #8]
   25a52:	4613      	mov	r3, r2
   25a54:	71fb      	strb	r3, [r7, #7]
    if(p_uart->conn_handle != BLE_CONN_HANDLE_INVALID)
   25a56:	68fb      	ldr	r3, [r7, #12]
   25a58:	8c1b      	ldrh	r3, [r3, #32]
   25a5a:	f64f 72ff 	movw	r2, #65535	; 0xffff
   25a5e:	4293      	cmp	r3, r2
   25a60:	d05b      	beq.n	25b1a <_BleUartIndicateSendSinglePacket+0xd2>
        {
            uint16_t                hvx_len;
            ble_gatts_hvx_params_t  hvx_params;
            ble_gatts_value_t       value_params;
            uint32_t                err_code = 0;
   25a62:	2300      	movs	r3, #0
   25a64:	62fb      	str	r3, [r7, #44]	; 0x2c

            memset(&hvx_params, 0, sizeof(hvx_params));
   25a66:	f107 0318 	add.w	r3, r7, #24
   25a6a:	2210      	movs	r2, #16
   25a6c:	2100      	movs	r1, #0
   25a6e:	4618      	mov	r0, r3
   25a70:	f7fd fdd4 	bl	2361c <memset>
            memset(&value_params,0,sizeof(value_params));
   25a74:	f107 0310 	add.w	r3, r7, #16
   25a78:	2208      	movs	r2, #8
   25a7a:	2100      	movs	r1, #0
   25a7c:	4618      	mov	r0, r3
   25a7e:	f7fd fdcd 	bl	2361c <memset>

            ble_uart_tx_buffer[1] = actual_data_size;
   25a82:	4a28      	ldr	r2, [pc, #160]	; (25b24 <_BleUartIndicateSendSinglePacket+0xdc>)
   25a84:	79fb      	ldrb	r3, [r7, #7]
   25a86:	7053      	strb	r3, [r2, #1]
            /// Copy the message to the buffer
            memcpy(ble_uart_tx_buffer+2, data, actual_data_size);
   25a88:	4827      	ldr	r0, [pc, #156]	; (25b28 <_BleUartIndicateSendSinglePacket+0xe0>)
   25a8a:	79fb      	ldrb	r3, [r7, #7]
   25a8c:	461a      	mov	r2, r3
   25a8e:	68b9      	ldr	r1, [r7, #8]
   25a90:	f005 fc2e 	bl	2b2f0 <memcpy>

            //Fill structure with data size. This will avoid sending empty bytes when sending <20 bytes
            value_params.len = actual_data_size + 2;
   25a94:	79fb      	ldrb	r3, [r7, #7]
   25a96:	b29b      	uxth	r3, r3
   25a98:	3302      	adds	r3, #2
   25a9a:	b29b      	uxth	r3, r3
   25a9c:	823b      	strh	r3, [r7, #16]
            value_params.offset = 0;
   25a9e:	2300      	movs	r3, #0
   25aa0:	827b      	strh	r3, [r7, #18]
            value_params.p_value = NULL;
   25aa2:	2300      	movs	r3, #0
   25aa4:	617b      	str	r3, [r7, #20]

            err_code = sd_ble_gatts_value_set(p_uart->conn_handle, p_uart->tx_handles.value_handle, &value_params);
   25aa6:	68fb      	ldr	r3, [r7, #12]
   25aa8:	8c18      	ldrh	r0, [r3, #32]
   25aaa:	68fb      	ldr	r3, [r7, #12]
   25aac:	88db      	ldrh	r3, [r3, #6]
   25aae:	f107 0210 	add.w	r2, r7, #16
   25ab2:	4619      	mov	r1, r3
   25ab4:	f7ff fd96 	bl	255e4 <sd_ble_gatts_value_set>
   25ab8:	62f8      	str	r0, [r7, #44]	; 0x2c

            hvx_len = actual_data_size + 2;
   25aba:	79fb      	ldrb	r3, [r7, #7]
   25abc:	b29b      	uxth	r3, r3
   25abe:	3302      	adds	r3, #2
   25ac0:	b29b      	uxth	r3, r3
   25ac2:	857b      	strh	r3, [r7, #42]	; 0x2a
            hvx_params.handle = p_uart->tx_handles.value_handle;
   25ac4:	68fb      	ldr	r3, [r7, #12]
   25ac6:	88db      	ldrh	r3, [r3, #6]
   25ac8:	833b      	strh	r3, [r7, #24]
            hvx_params.type   = BLE_GATT_HVX_INDICATION;
   25aca:	2302      	movs	r3, #2
   25acc:	76bb      	strb	r3, [r7, #26]
            hvx_params.offset = 0;
   25ace:	2300      	movs	r3, #0
   25ad0:	83bb      	strh	r3, [r7, #28]
            hvx_params.p_len  = &hvx_len;
   25ad2:	f107 032a 	add.w	r3, r7, #42	; 0x2a
   25ad6:	623b      	str	r3, [r7, #32]
            hvx_params.p_data = ble_uart_tx_buffer;
   25ad8:	4b12      	ldr	r3, [pc, #72]	; (25b24 <_BleUartIndicateSendSinglePacket+0xdc>)
   25ada:	627b      	str	r3, [r7, #36]	; 0x24

            _BleUartWaitTillPacketTxInProgress();
   25adc:	f7ff ff2a 	bl	25934 <_BleUartWaitTillPacketTxInProgress>
            /// Set the ble transmission flag high to indicate ongoing transmission
            ble_tx_packet_in_progress = true;
   25ae0:	4b12      	ldr	r3, [pc, #72]	; (25b2c <_BleUartIndicateSendSinglePacket+0xe4>)
   25ae2:	2201      	movs	r2, #1
   25ae4:	701a      	strb	r2, [r3, #0]
            /// Send the data
            err_code = sd_ble_gatts_hvx(p_uart->conn_handle, &hvx_params);
   25ae6:	68fb      	ldr	r3, [r7, #12]
   25ae8:	8c1b      	ldrh	r3, [r3, #32]
   25aea:	f107 0218 	add.w	r2, r7, #24
   25aee:	4611      	mov	r1, r2
   25af0:	4618      	mov	r0, r3
   25af2:	f7ff fd7b 	bl	255ec <sd_ble_gatts_hvx>
   25af6:	62f8      	str	r0, [r7, #44]	; 0x2c

            ble_uart_tx_data_size -= actual_data_size;
   25af8:	4b0d      	ldr	r3, [pc, #52]	; (25b30 <_BleUartIndicateSendSinglePacket+0xe8>)
   25afa:	881b      	ldrh	r3, [r3, #0]
   25afc:	b29a      	uxth	r2, r3
   25afe:	79fb      	ldrb	r3, [r7, #7]
   25b00:	b29b      	uxth	r3, r3
   25b02:	1ad3      	subs	r3, r2, r3
   25b04:	b29a      	uxth	r2, r3
   25b06:	4b0a      	ldr	r3, [pc, #40]	; (25b30 <_BleUartIndicateSendSinglePacket+0xe8>)
   25b08:	801a      	strh	r2, [r3, #0]
            ble_current_data_ptr += actual_data_size;
   25b0a:	4b0a      	ldr	r3, [pc, #40]	; (25b34 <_BleUartIndicateSendSinglePacket+0xec>)
   25b0c:	681a      	ldr	r2, [r3, #0]
   25b0e:	79fb      	ldrb	r3, [r7, #7]
   25b10:	4413      	add	r3, r2
   25b12:	4a08      	ldr	r2, [pc, #32]	; (25b34 <_BleUartIndicateSendSinglePacket+0xec>)
   25b14:	6013      	str	r3, [r2, #0]

            return NRF_SUCCESS;
   25b16:	2300      	movs	r3, #0
   25b18:	e000      	b.n	25b1c <_BleUartIndicateSendSinglePacket+0xd4>
        }

    return NRF_ERROR_INVALID_STATE;
   25b1a:	2308      	movs	r3, #8
}
   25b1c:	4618      	mov	r0, r3
   25b1e:	3730      	adds	r7, #48	; 0x30
   25b20:	46bd      	mov	sp, r7
   25b22:	bd80      	pop	{r7, pc}
   25b24:	200052d0 	.word	0x200052d0
   25b28:	200052d2 	.word	0x200052d2
   25b2c:	200052cc 	.word	0x200052cc
   25b30:	200052f8 	.word	0x200052f8
   25b34:	20005300 	.word	0x20005300

00025b38 <_BleUartIndicateSendNextPacket>:
 *
 *          \return NRF_SUCCESS - if the packet was successfully send
 *                  NRF_ERROR_INVALID_STATE - if the device is not in the BLE connection
 */
static uint32_t _BleUartIndicateSendNextPacket(ble_uart_t* p_uart)
{
   25b38:	b580      	push	{r7, lr}
   25b3a:	b084      	sub	sp, #16
   25b3c:	af00      	add	r7, sp, #0
   25b3e:	6078      	str	r0, [r7, #4]
    uint32_t err_code = 0;
   25b40:	2300      	movs	r3, #0
   25b42:	60fb      	str	r3, [r7, #12]
    if(ble_uart_tx_data_size > 19)
   25b44:	4b0e      	ldr	r3, [pc, #56]	; (25b80 <_BleUartIndicateSendNextPacket+0x48>)
   25b46:	881b      	ldrh	r3, [r3, #0]
   25b48:	b29b      	uxth	r3, r3
   25b4a:	2b13      	cmp	r3, #19
   25b4c:	d908      	bls.n	25b60 <_BleUartIndicateSendNextPacket+0x28>
        err_code = _BleUartIndicateSendSinglePacket(p_uart, ble_current_data_ptr, 19);
   25b4e:	4b0d      	ldr	r3, [pc, #52]	; (25b84 <_BleUartIndicateSendNextPacket+0x4c>)
   25b50:	681b      	ldr	r3, [r3, #0]
   25b52:	2213      	movs	r2, #19
   25b54:	4619      	mov	r1, r3
   25b56:	6878      	ldr	r0, [r7, #4]
   25b58:	f7ff ff76 	bl	25a48 <_BleUartIndicateSendSinglePacket>
   25b5c:	60f8      	str	r0, [r7, #12]
   25b5e:	e00a      	b.n	25b76 <_BleUartIndicateSendNextPacket+0x3e>
    else
        err_code = _BleUartIndicateSendSinglePacket(p_uart, ble_current_data_ptr, ble_uart_tx_data_size);
   25b60:	4b08      	ldr	r3, [pc, #32]	; (25b84 <_BleUartIndicateSendNextPacket+0x4c>)
   25b62:	6819      	ldr	r1, [r3, #0]
   25b64:	4b06      	ldr	r3, [pc, #24]	; (25b80 <_BleUartIndicateSendNextPacket+0x48>)
   25b66:	881b      	ldrh	r3, [r3, #0]
   25b68:	b29b      	uxth	r3, r3
   25b6a:	b2db      	uxtb	r3, r3
   25b6c:	461a      	mov	r2, r3
   25b6e:	6878      	ldr	r0, [r7, #4]
   25b70:	f7ff ff6a 	bl	25a48 <_BleUartIndicateSendSinglePacket>
   25b74:	60f8      	str	r0, [r7, #12]

    return err_code;
   25b76:	68fb      	ldr	r3, [r7, #12]
}
   25b78:	4618      	mov	r0, r3
   25b7a:	3710      	adds	r7, #16
   25b7c:	46bd      	mov	sp, r7
   25b7e:	bd80      	pop	{r7, pc}
   25b80:	200052f8 	.word	0x200052f8
   25b84:	20005300 	.word	0x20005300

00025b88 <BleUartDataIndicate>:
 *  \param data - pointer to the buffer with data which are to be sent. It should exist until the transmission ends. IT MUST BE DYNAMICALLY ALLOCATED
 *  \param data_size - size of data which are to be sent
 *  \param data_buf_dynamically_allocated - 1 if the buffer is created with malloc function, 0 if it lies on stack
 */
uint32_t BleUartDataIndicate( uint16_t conn_handle, uint8_t command_code, void* data, uint16_t data_size, uint8_t data_buf_dynamically_allocated)
{
   25b88:	b580      	push	{r7, lr}
   25b8a:	b084      	sub	sp, #16
   25b8c:	af00      	add	r7, sp, #0
   25b8e:	60ba      	str	r2, [r7, #8]
   25b90:	461a      	mov	r2, r3
   25b92:	4603      	mov	r3, r0
   25b94:	81fb      	strh	r3, [r7, #14]
   25b96:	460b      	mov	r3, r1
   25b98:	737b      	strb	r3, [r7, #13]
   25b9a:	4613      	mov	r3, r2
   25b9c:	80fb      	strh	r3, [r7, #6]
    if(conn_handle != BLE_CONN_HANDLE_INVALID)
   25b9e:	89fb      	ldrh	r3, [r7, #14]
   25ba0:	f64f 72ff 	movw	r2, #65535	; 0xffff
   25ba4:	4293      	cmp	r3, r2
   25ba6:	d024      	beq.n	25bf2 <BleUartDataIndicate+0x6a>
    {
        /// Set the flag to indicate that message is going to be sent
        ble_tx_in_progress = 1;
   25ba8:	4b14      	ldr	r3, [pc, #80]	; (25bfc <BleUartDataIndicate+0x74>)
   25baa:	2201      	movs	r2, #1
   25bac:	701a      	strb	r2, [r3, #0]
        /// Set the size of data which are to be sent
        ble_uart_tx_data_size = data_size;
   25bae:	4a14      	ldr	r2, [pc, #80]	; (25c00 <BleUartDataIndicate+0x78>)
   25bb0:	88fb      	ldrh	r3, [r7, #6]
   25bb2:	8013      	strh	r3, [r2, #0]
        /// Set the pointer to the data
        ble_data_ptr = data;
   25bb4:	4a13      	ldr	r2, [pc, #76]	; (25c04 <BleUartDataIndicate+0x7c>)
   25bb6:	68bb      	ldr	r3, [r7, #8]
   25bb8:	6013      	str	r3, [r2, #0]
        ble_current_data_ptr = data;
   25bba:	4a13      	ldr	r2, [pc, #76]	; (25c08 <BleUartDataIndicate+0x80>)
   25bbc:	68bb      	ldr	r3, [r7, #8]
   25bbe:	6013      	str	r3, [r2, #0]

        /// Set the command code in the buffer
        ble_uart_tx_buffer[0] = command_code;
   25bc0:	4a12      	ldr	r2, [pc, #72]	; (25c0c <BleUartDataIndicate+0x84>)
   25bc2:	7b7b      	ldrb	r3, [r7, #13]
   25bc4:	7013      	strb	r3, [r2, #0]
        /// Set the buffer allocation flasg
        ble_uart_data_dynamically_allocated = data_buf_dynamically_allocated;
   25bc6:	4a12      	ldr	r2, [pc, #72]	; (25c10 <BleUartDataIndicate+0x88>)
   25bc8:	7e3b      	ldrb	r3, [r7, #24]
   25bca:	7013      	strb	r3, [r2, #0]
        /// If there is more than one message to send
        if((data_size + 2) > 18)
   25bcc:	88fb      	ldrh	r3, [r7, #6]
   25bce:	3302      	adds	r3, #2
   25bd0:	2b12      	cmp	r3, #18
   25bd2:	dd05      	ble.n	25be0 <BleUartDataIndicate+0x58>
            _BleUartIndicateSendSinglePacket(&m_ble_uart, data, 18); /// Send the first packet (19 bytes, because the first one is command code)
   25bd4:	2212      	movs	r2, #18
   25bd6:	68b9      	ldr	r1, [r7, #8]
   25bd8:	480e      	ldr	r0, [pc, #56]	; (25c14 <BleUartDataIndicate+0x8c>)
   25bda:	f7ff ff35 	bl	25a48 <_BleUartIndicateSendSinglePacket>
   25bde:	e006      	b.n	25bee <BleUartDataIndicate+0x66>
        else
            _BleUartIndicateSendSinglePacket(&m_ble_uart, data, data_size);  /// If there is only 1 message to send
   25be0:	88fb      	ldrh	r3, [r7, #6]
   25be2:	b2db      	uxtb	r3, r3
   25be4:	461a      	mov	r2, r3
   25be6:	68b9      	ldr	r1, [r7, #8]
   25be8:	480a      	ldr	r0, [pc, #40]	; (25c14 <BleUartDataIndicate+0x8c>)
   25bea:	f7ff ff2d 	bl	25a48 <_BleUartIndicateSendSinglePacket>

        return NRF_SUCCESS;
   25bee:	2300      	movs	r3, #0
   25bf0:	e000      	b.n	25bf4 <BleUartDataIndicate+0x6c>
    }

    return NRF_ERROR_INVALID_STATE;
   25bf2:	2308      	movs	r3, #8
}
   25bf4:	4618      	mov	r0, r3
   25bf6:	3710      	adds	r7, #16
   25bf8:	46bd      	mov	sp, r7
   25bfa:	bd80      	pop	{r7, pc}
   25bfc:	20005465 	.word	0x20005465
   25c00:	200052f8 	.word	0x200052f8
   25c04:	200052fc 	.word	0x200052fc
   25c08:	20005300 	.word	0x20005300
   25c0c:	200052d0 	.word	0x200052d0
   25c10:	20005304 	.word	0x20005304
   25c14:	20005468 	.word	0x20005468

00025c18 <_BleUartNotifySendSinglePacket>:
 *  \param data - pointer to the data buffer
 *  \param data_size - size of data in the packet
 *
 */
static uint32_t _BleUartNotifySendSinglePacket(ble_uart_t* p_uart, uint8_t* data, uint8_t data_size)
{
   25c18:	b580      	push	{r7, lr}
   25c1a:	b08c      	sub	sp, #48	; 0x30
   25c1c:	af00      	add	r7, sp, #0
   25c1e:	60f8      	str	r0, [r7, #12]
   25c20:	60b9      	str	r1, [r7, #8]
   25c22:	4613      	mov	r3, r2
   25c24:	71fb      	strb	r3, [r7, #7]
    if(p_uart->conn_handle != BLE_CONN_HANDLE_INVALID)
   25c26:	68fb      	ldr	r3, [r7, #12]
   25c28:	8c1b      	ldrh	r3, [r3, #32]
   25c2a:	f64f 72ff 	movw	r2, #65535	; 0xffff
   25c2e:	4293      	cmp	r3, r2
   25c30:	d064      	beq.n	25cfc <_BleUartNotifySendSinglePacket+0xe4>
        {
            uint16_t                hvx_len;
            ble_gatts_hvx_params_t  hvx_params;
            ble_gatts_value_t       value_params;
            uint32_t                err_code = 0;
   25c32:	2300      	movs	r3, #0
   25c34:	62fb      	str	r3, [r7, #44]	; 0x2c

            memset(&hvx_params, 0, sizeof(hvx_params));
   25c36:	f107 0318 	add.w	r3, r7, #24
   25c3a:	2210      	movs	r2, #16
   25c3c:	2100      	movs	r1, #0
   25c3e:	4618      	mov	r0, r3
   25c40:	f7fd fcec 	bl	2361c <memset>
            memset(&value_params,0,sizeof(value_params));
   25c44:	f107 0310 	add.w	r3, r7, #16
   25c48:	2208      	movs	r2, #8
   25c4a:	2100      	movs	r1, #0
   25c4c:	4618      	mov	r0, r3
   25c4e:	f7fd fce5 	bl	2361c <memset>

            /// Copy the message to the buffer
            memcpy(ble_uart_tx_buffer+1, data, data_size);
   25c52:	482d      	ldr	r0, [pc, #180]	; (25d08 <_BleUartNotifySendSinglePacket+0xf0>)
   25c54:	79fb      	ldrb	r3, [r7, #7]
   25c56:	461a      	mov	r2, r3
   25c58:	68b9      	ldr	r1, [r7, #8]
   25c5a:	f005 fb49 	bl	2b2f0 <memcpy>

            //Fill structure with data size. This will avoid sending empty bytes when sending <20 bytes
            value_params.len = data_size + 1;
   25c5e:	79fb      	ldrb	r3, [r7, #7]
   25c60:	b29b      	uxth	r3, r3
   25c62:	3301      	adds	r3, #1
   25c64:	b29b      	uxth	r3, r3
   25c66:	823b      	strh	r3, [r7, #16]
            value_params.offset = 0;
   25c68:	2300      	movs	r3, #0
   25c6a:	827b      	strh	r3, [r7, #18]
            value_params.p_value = NULL;
   25c6c:	2300      	movs	r3, #0
   25c6e:	617b      	str	r3, [r7, #20]

            err_code = sd_ble_gatts_value_set(p_uart->conn_handle, p_uart->dev_events_handles.value_handle, &value_params);
   25c70:	68fb      	ldr	r3, [r7, #12]
   25c72:	8c18      	ldrh	r0, [r3, #32]
   25c74:	68fb      	ldr	r3, [r7, #12]
   25c76:	8adb      	ldrh	r3, [r3, #22]
   25c78:	f107 0210 	add.w	r2, r7, #16
   25c7c:	4619      	mov	r1, r3
   25c7e:	f7ff fcb1 	bl	255e4 <sd_ble_gatts_value_set>
   25c82:	62f8      	str	r0, [r7, #44]	; 0x2c

            hvx_len = data_size + 1;
   25c84:	79fb      	ldrb	r3, [r7, #7]
   25c86:	b29b      	uxth	r3, r3
   25c88:	3301      	adds	r3, #1
   25c8a:	b29b      	uxth	r3, r3
   25c8c:	857b      	strh	r3, [r7, #42]	; 0x2a
            hvx_params.handle = p_uart->dev_events_handles.value_handle;
   25c8e:	68fb      	ldr	r3, [r7, #12]
   25c90:	8adb      	ldrh	r3, [r3, #22]
   25c92:	833b      	strh	r3, [r7, #24]
            hvx_params.type   = BLE_GATT_HVX_NOTIFICATION;
   25c94:	2301      	movs	r3, #1
   25c96:	76bb      	strb	r3, [r7, #26]
            hvx_params.offset = 0;
   25c98:	2300      	movs	r3, #0
   25c9a:	83bb      	strh	r3, [r7, #28]
            hvx_params.p_len  = &hvx_len;
   25c9c:	f107 032a 	add.w	r3, r7, #42	; 0x2a
   25ca0:	623b      	str	r3, [r7, #32]
            hvx_params.p_data = ble_uart_tx_buffer;
   25ca2:	4b1a      	ldr	r3, [pc, #104]	; (25d0c <_BleUartNotifySendSinglePacket+0xf4>)
   25ca4:	627b      	str	r3, [r7, #36]	; 0x24


            /// Set the ble transmission flag high to indicate ongoing transmission
            ble_notification_packet_in_progress = true;
   25ca6:	4b1a      	ldr	r3, [pc, #104]	; (25d10 <_BleUartNotifySendSinglePacket+0xf8>)
   25ca8:	2201      	movs	r2, #1
   25caa:	701a      	strb	r2, [r3, #0]
            /// Send the data
            err_code = sd_ble_gatts_hvx(p_uart->conn_handle, &hvx_params);
   25cac:	68fb      	ldr	r3, [r7, #12]
   25cae:	8c1b      	ldrh	r3, [r3, #32]
   25cb0:	f107 0218 	add.w	r2, r7, #24
   25cb4:	4611      	mov	r1, r2
   25cb6:	4618      	mov	r0, r3
   25cb8:	f7ff fc98 	bl	255ec <sd_ble_gatts_hvx>
   25cbc:	62f8      	str	r0, [r7, #44]	; 0x2c

            err_code = _BleUartNotifyWaitTillPacketInProgress();
   25cbe:	f7ff fe49 	bl	25954 <_BleUartNotifyWaitTillPacketInProgress>
   25cc2:	62f8      	str	r0, [r7, #44]	; 0x2c
            /// If error occured, retransmit the packet
            if(err_code != NRF_SUCCESS)
   25cc4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   25cc6:	2b00      	cmp	r3, #0
   25cc8:	d007      	beq.n	25cda <_BleUartNotifySendSinglePacket+0xc2>
            {
                sd_ble_gatts_hvx(p_uart->conn_handle, &hvx_params);
   25cca:	68fb      	ldr	r3, [r7, #12]
   25ccc:	8c1b      	ldrh	r3, [r3, #32]
   25cce:	f107 0218 	add.w	r2, r7, #24
   25cd2:	4611      	mov	r1, r2
   25cd4:	4618      	mov	r0, r3
   25cd6:	f7ff fc89 	bl	255ec <sd_ble_gatts_hvx>
            }

            ble_uart_tx_data_size -= data_size;
   25cda:	4b0e      	ldr	r3, [pc, #56]	; (25d14 <_BleUartNotifySendSinglePacket+0xfc>)
   25cdc:	881b      	ldrh	r3, [r3, #0]
   25cde:	b29a      	uxth	r2, r3
   25ce0:	79fb      	ldrb	r3, [r7, #7]
   25ce2:	b29b      	uxth	r3, r3
   25ce4:	1ad3      	subs	r3, r2, r3
   25ce6:	b29a      	uxth	r2, r3
   25ce8:	4b0a      	ldr	r3, [pc, #40]	; (25d14 <_BleUartNotifySendSinglePacket+0xfc>)
   25cea:	801a      	strh	r2, [r3, #0]
            ble_current_data_ptr += data_size;
   25cec:	4b0a      	ldr	r3, [pc, #40]	; (25d18 <_BleUartNotifySendSinglePacket+0x100>)
   25cee:	681a      	ldr	r2, [r3, #0]
   25cf0:	79fb      	ldrb	r3, [r7, #7]
   25cf2:	4413      	add	r3, r2
   25cf4:	4a08      	ldr	r2, [pc, #32]	; (25d18 <_BleUartNotifySendSinglePacket+0x100>)
   25cf6:	6013      	str	r3, [r2, #0]

            return NRF_SUCCESS;
   25cf8:	2300      	movs	r3, #0
   25cfa:	e000      	b.n	25cfe <_BleUartNotifySendSinglePacket+0xe6>
        }

    return NRF_ERROR_INVALID_STATE;
   25cfc:	2308      	movs	r3, #8
}
   25cfe:	4618      	mov	r0, r3
   25d00:	3730      	adds	r7, #48	; 0x30
   25d02:	46bd      	mov	sp, r7
   25d04:	bd80      	pop	{r7, pc}
   25d06:	bf00      	nop
   25d08:	200052d1 	.word	0x200052d1
   25d0c:	200052d0 	.word	0x200052d0
   25d10:	200052cd 	.word	0x200052cd
   25d14:	200052f8 	.word	0x200052f8
   25d18:	20005300 	.word	0x20005300

00025d1c <_BleUartNotifySendNextPacket>:
 *
 *          \return NRF_SUCCESS - if the packet was successfully send
 *                  NRF_ERROR_INVALID_STATE - if the device is not in the BLE connection
 */
static uint32_t _BleUartNotifySendNextPacket(ble_uart_t* p_uart)
{
   25d1c:	b580      	push	{r7, lr}
   25d1e:	b084      	sub	sp, #16
   25d20:	af00      	add	r7, sp, #0
   25d22:	6078      	str	r0, [r7, #4]
    uint32_t err_code = 0;
   25d24:	2300      	movs	r3, #0
   25d26:	60fb      	str	r3, [r7, #12]
    if(ble_uart_tx_data_size > 19)
   25d28:	4b0e      	ldr	r3, [pc, #56]	; (25d64 <_BleUartNotifySendNextPacket+0x48>)
   25d2a:	881b      	ldrh	r3, [r3, #0]
   25d2c:	b29b      	uxth	r3, r3
   25d2e:	2b13      	cmp	r3, #19
   25d30:	d908      	bls.n	25d44 <_BleUartNotifySendNextPacket+0x28>
        err_code = _BleUartNotifySendSinglePacket(p_uart, ble_current_data_ptr, 19);
   25d32:	4b0d      	ldr	r3, [pc, #52]	; (25d68 <_BleUartNotifySendNextPacket+0x4c>)
   25d34:	681b      	ldr	r3, [r3, #0]
   25d36:	2213      	movs	r2, #19
   25d38:	4619      	mov	r1, r3
   25d3a:	6878      	ldr	r0, [r7, #4]
   25d3c:	f7ff ff6c 	bl	25c18 <_BleUartNotifySendSinglePacket>
   25d40:	60f8      	str	r0, [r7, #12]
   25d42:	e00a      	b.n	25d5a <_BleUartNotifySendNextPacket+0x3e>
    else
        err_code = _BleUartNotifySendSinglePacket(p_uart, ble_current_data_ptr, ble_uart_tx_data_size);
   25d44:	4b08      	ldr	r3, [pc, #32]	; (25d68 <_BleUartNotifySendNextPacket+0x4c>)
   25d46:	6819      	ldr	r1, [r3, #0]
   25d48:	4b06      	ldr	r3, [pc, #24]	; (25d64 <_BleUartNotifySendNextPacket+0x48>)
   25d4a:	881b      	ldrh	r3, [r3, #0]
   25d4c:	b29b      	uxth	r3, r3
   25d4e:	b2db      	uxtb	r3, r3
   25d50:	461a      	mov	r2, r3
   25d52:	6878      	ldr	r0, [r7, #4]
   25d54:	f7ff ff60 	bl	25c18 <_BleUartNotifySendSinglePacket>
   25d58:	60f8      	str	r0, [r7, #12]

    return err_code;
   25d5a:	68fb      	ldr	r3, [r7, #12]
}
   25d5c:	4618      	mov	r0, r3
   25d5e:	3710      	adds	r7, #16
   25d60:	46bd      	mov	sp, r7
   25d62:	bd80      	pop	{r7, pc}
   25d64:	200052f8 	.word	0x200052f8
   25d68:	20005300 	.word	0x20005300

00025d6c <BleUartHandler>:

/**
 * \brief This is the Handler assigned to the BLE Uart Service. It should be attached in services_init function.
 */
void BleUartHandler(ble_uart_t * p_uart, ble_uart_evt_t * p_evt, ble_uart_data_t p_data, uint8_t data_size)
{
   25d6c:	b580      	push	{r7, lr}
   25d6e:	b084      	sub	sp, #16
   25d70:	af00      	add	r7, sp, #0
   25d72:	60f8      	str	r0, [r7, #12]
   25d74:	60b9      	str	r1, [r7, #8]
   25d76:	607a      	str	r2, [r7, #4]
   25d78:	70fb      	strb	r3, [r7, #3]
    switch (p_evt->evt_type)
   25d7a:	68bb      	ldr	r3, [r7, #8]
   25d7c:	781b      	ldrb	r3, [r3, #0]
   25d7e:	2b06      	cmp	r3, #6
   25d80:	d84a      	bhi.n	25e18 <BleUartHandler+0xac>
   25d82:	a201      	add	r2, pc, #4	; (adr r2, 25d88 <BleUartHandler+0x1c>)
   25d84:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   25d88:	00025e19 	.word	0x00025e19
   25d8c:	00025e19 	.word	0x00025e19
   25d90:	00025e19 	.word	0x00025e19
   25d94:	00025e19 	.word	0x00025e19
   25d98:	00025dd9 	.word	0x00025dd9
   25d9c:	00025da5 	.word	0x00025da5
   25da0:	00025e0d 	.word	0x00025e0d
            break;

        case BLE_UART_EVT_INDICATION_CONFIRMED:
        {
           ///  Clear the flag to indicate that transmission has ended
           ble_tx_packet_in_progress = false;
   25da4:	4b1f      	ldr	r3, [pc, #124]	; (25e24 <BleUartHandler+0xb8>)
   25da6:	2200      	movs	r2, #0
   25da8:	701a      	strb	r2, [r3, #0]
            /// If there is more data to be send, send next packet
           if(ble_uart_tx_data_size > 0)
   25daa:	4b1f      	ldr	r3, [pc, #124]	; (25e28 <BleUartHandler+0xbc>)
   25dac:	881b      	ldrh	r3, [r3, #0]
   25dae:	b29b      	uxth	r3, r3
   25db0:	2b00      	cmp	r3, #0
   25db2:	d003      	beq.n	25dbc <BleUartHandler+0x50>
               _BleUartIndicateSendNextPacket(p_uart);
   25db4:	68f8      	ldr	r0, [r7, #12]
   25db6:	f7ff febf 	bl	25b38 <_BleUartIndicateSendNextPacket>
                   ///  Free the data resources
                   free(ble_data_ptr);
               }
               ble_tx_in_progress = false;
           }
            break;
   25dba:	e02e      	b.n	25e1a <BleUartHandler+0xae>
               if(ble_uart_data_dynamically_allocated)
   25dbc:	4b1b      	ldr	r3, [pc, #108]	; (25e2c <BleUartHandler+0xc0>)
   25dbe:	781b      	ldrb	r3, [r3, #0]
   25dc0:	b2db      	uxtb	r3, r3
   25dc2:	2b00      	cmp	r3, #0
   25dc4:	d004      	beq.n	25dd0 <BleUartHandler+0x64>
                   free(ble_data_ptr);
   25dc6:	4b1a      	ldr	r3, [pc, #104]	; (25e30 <BleUartHandler+0xc4>)
   25dc8:	681b      	ldr	r3, [r3, #0]
   25dca:	4618      	mov	r0, r3
   25dcc:	f005 fa88 	bl	2b2e0 <free>
               ble_tx_in_progress = false;
   25dd0:	4b18      	ldr	r3, [pc, #96]	; (25e34 <BleUartHandler+0xc8>)
   25dd2:	2200      	movs	r2, #0
   25dd4:	701a      	strb	r2, [r3, #0]
            break;
   25dd6:	e020      	b.n	25e1a <BleUartHandler+0xae>
        case BLE_UART_EVT_NOTIFICATION_ENABLED:
            break;
        case BLE_UART_EVT_NOTIFICATION_TRANSMITTED:
        {
           ///  Clear the flag to indicate that transmission has ended
           ble_notification_packet_in_progress = false;
   25dd8:	4b17      	ldr	r3, [pc, #92]	; (25e38 <BleUartHandler+0xcc>)
   25dda:	2200      	movs	r2, #0
   25ddc:	701a      	strb	r2, [r3, #0]
            /// If there is more data to be send, send next packet
            if(ble_uart_tx_data_size > 0)
   25dde:	4b12      	ldr	r3, [pc, #72]	; (25e28 <BleUartHandler+0xbc>)
   25de0:	881b      	ldrh	r3, [r3, #0]
   25de2:	b29b      	uxth	r3, r3
   25de4:	2b00      	cmp	r3, #0
   25de6:	d003      	beq.n	25df0 <BleUartHandler+0x84>
               _BleUartNotifySendNextPacket(p_uart);
   25de8:	68f8      	ldr	r0, [r7, #12]
   25dea:	f7ff ff97 	bl	25d1c <_BleUartNotifySendNextPacket>
                   ///  Free the data resources
                   free(ble_data_ptr);
               }
               ble_notification_in_progress = false;
            }
            break;
   25dee:	e014      	b.n	25e1a <BleUartHandler+0xae>
               if(ble_uart_data_dynamically_allocated)
   25df0:	4b0e      	ldr	r3, [pc, #56]	; (25e2c <BleUartHandler+0xc0>)
   25df2:	781b      	ldrb	r3, [r3, #0]
   25df4:	b2db      	uxtb	r3, r3
   25df6:	2b00      	cmp	r3, #0
   25df8:	d004      	beq.n	25e04 <BleUartHandler+0x98>
                   free(ble_data_ptr);
   25dfa:	4b0d      	ldr	r3, [pc, #52]	; (25e30 <BleUartHandler+0xc4>)
   25dfc:	681b      	ldr	r3, [r3, #0]
   25dfe:	4618      	mov	r0, r3
   25e00:	f005 fa6e 	bl	2b2e0 <free>
               ble_notification_in_progress = false;
   25e04:	4b0d      	ldr	r3, [pc, #52]	; (25e3c <BleUartHandler+0xd0>)
   25e06:	2200      	movs	r2, #0
   25e08:	701a      	strb	r2, [r3, #0]
            break;
   25e0a:	e006      	b.n	25e1a <BleUartHandler+0xae>
        }
        case BLE_UART_EVT_RX_DATA_RECEIVED:
            _BleUartRxHandler(p_data, data_size);
   25e0c:	78fb      	ldrb	r3, [r7, #3]
   25e0e:	4619      	mov	r1, r3
   25e10:	6878      	ldr	r0, [r7, #4]
   25e12:	f7ff fdaf 	bl	25974 <_BleUartRxHandler>
            break;
   25e16:	e000      	b.n	25e1a <BleUartHandler+0xae>
        default:
            // No implementation needed.
            break;
   25e18:	bf00      	nop
    }
}
   25e1a:	bf00      	nop
   25e1c:	3710      	adds	r7, #16
   25e1e:	46bd      	mov	sp, r7
   25e20:	bd80      	pop	{r7, pc}
   25e22:	bf00      	nop
   25e24:	200052cc 	.word	0x200052cc
   25e28:	200052f8 	.word	0x200052f8
   25e2c:	20005304 	.word	0x20005304
   25e30:	200052fc 	.word	0x200052fc
   25e34:	20005465 	.word	0x20005465
   25e38:	200052cd 	.word	0x200052cd
   25e3c:	20005464 	.word	0x20005464

00025e40 <UartTxCharAdd>:
 * @param[in]   p_uart_init   Information needed to initialize the service.
 *
 * @return      NRF_SUCCESS on success, otherwise an error code.
 */
static uint32_t UartTxCharAdd(ble_uart_t * p_uart, const ble_uart_init_t * p_uart_init)
{
   25e40:	b580      	push	{r7, lr}
   25e42:	b090      	sub	sp, #64	; 0x40
   25e44:	af00      	add	r7, sp, #0
   25e46:	6078      	str	r0, [r7, #4]
   25e48:	6039      	str	r1, [r7, #0]
    ble_gatts_attr_t    attr_char_value;
    ble_uuid_t          ble_uuid;
    ble_gatts_attr_md_t attr_md;

    // Clear char_md structure
    memset(&char_md, 0, sizeof(char_md));
   25e4a:	f107 0324 	add.w	r3, r7, #36	; 0x24
   25e4e:	221c      	movs	r2, #28
   25e50:	2100      	movs	r1, #0
   25e52:	4618      	mov	r0, r3
   25e54:	f7fd fbe2 	bl	2361c <memset>

        //  Set indicate avaliability
    char_md.char_props.indicate  = 1;
   25e58:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   25e5c:	f043 0320 	orr.w	r3, r3, #32
   25e60:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
        //  Setup descriptor
#ifdef LIGHT_CHARACTERISTICS
    char_md.p_char_user_desc = NULL;
#else
    // Human-friendly descriptor to debug
    char_md.p_char_user_desc = (uint8_t*)"Tx";
   25e64:	4b31      	ldr	r3, [pc, #196]	; (25f2c <UartTxCharAdd+0xec>)
   25e66:	62bb      	str	r3, [r7, #40]	; 0x28
    char_md.char_user_desc_size = 2;
   25e68:	2302      	movs	r3, #2
   25e6a:	85fb      	strh	r3, [r7, #46]	; 0x2e
    char_md.char_user_desc_max_size = 20;
   25e6c:	2314      	movs	r3, #20
   25e6e:	85bb      	strh	r3, [r7, #44]	; 0x2c
#endif
    char_md.p_char_pf        = NULL;
   25e70:	2300      	movs	r3, #0
   25e72:	633b      	str	r3, [r7, #48]	; 0x30
    char_md.p_user_desc_md   = NULL;
   25e74:	2300      	movs	r3, #0
   25e76:	637b      	str	r3, [r7, #52]	; 0x34
    char_md.p_cccd_md        = NULL;
   25e78:	2300      	movs	r3, #0
   25e7a:	63bb      	str	r3, [r7, #56]	; 0x38
    char_md.p_sccd_md        = NULL;
   25e7c:	2300      	movs	r3, #0
   25e7e:	63fb      	str	r3, [r7, #60]	; 0x3c

    //  Inform the characteristic that it will have a custom vendor UUID
    ble_uuid.type = p_uart->uuid_type;
   25e80:	687b      	ldr	r3, [r7, #4]
   25e82:	7f9b      	ldrb	r3, [r3, #30]
   25e84:	73bb      	strb	r3, [r7, #14]
    //  Set the 16-bit UUID for the characteristic
    ble_uuid.uuid = TX_CHAR_UUID;
   25e86:	2303      	movs	r3, #3
   25e88:	81bb      	strh	r3, [r7, #12]

    memset(&attr_md, 0, sizeof(attr_md));
   25e8a:	f107 0308 	add.w	r3, r7, #8
   25e8e:	2203      	movs	r2, #3
   25e90:	2100      	movs	r1, #0
   25e92:	4618      	mov	r0, r3
   25e94:	f7fd fbc2 	bl	2361c <memset>

    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attr_md.read_perm);
   25e98:	7a3b      	ldrb	r3, [r7, #8]
   25e9a:	2201      	movs	r2, #1
   25e9c:	f362 0303 	bfi	r3, r2, #0, #4
   25ea0:	723b      	strb	r3, [r7, #8]
   25ea2:	7a3b      	ldrb	r3, [r7, #8]
   25ea4:	2201      	movs	r2, #1
   25ea6:	f362 1307 	bfi	r3, r2, #4, #4
   25eaa:	723b      	strb	r3, [r7, #8]
    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attr_md.write_perm);
   25eac:	7a7b      	ldrb	r3, [r7, #9]
   25eae:	2201      	movs	r2, #1
   25eb0:	f362 0303 	bfi	r3, r2, #0, #4
   25eb4:	727b      	strb	r3, [r7, #9]
   25eb6:	7a7b      	ldrb	r3, [r7, #9]
   25eb8:	2201      	movs	r2, #1
   25eba:	f362 1307 	bfi	r3, r2, #4, #4
   25ebe:	727b      	strb	r3, [r7, #9]
    attr_md.vloc       = BLE_GATTS_VLOC_USER;
   25ec0:	7abb      	ldrb	r3, [r7, #10]
   25ec2:	2202      	movs	r2, #2
   25ec4:	f362 0342 	bfi	r3, r2, #1, #2
   25ec8:	72bb      	strb	r3, [r7, #10]
    attr_md.rd_auth    = 0;
   25eca:	7abb      	ldrb	r3, [r7, #10]
   25ecc:	f36f 03c3 	bfc	r3, #3, #1
   25ed0:	72bb      	strb	r3, [r7, #10]
    attr_md.wr_auth    = 0;
   25ed2:	7abb      	ldrb	r3, [r7, #10]
   25ed4:	f36f 1304 	bfc	r3, #4, #1
   25ed8:	72bb      	strb	r3, [r7, #10]
    attr_md.vlen       = 1;
   25eda:	7abb      	ldrb	r3, [r7, #10]
   25edc:	f043 0301 	orr.w	r3, r3, #1
   25ee0:	72bb      	strb	r3, [r7, #10]

    memset(&attr_char_value, 0, sizeof(attr_char_value));
   25ee2:	f107 0310 	add.w	r3, r7, #16
   25ee6:	2214      	movs	r2, #20
   25ee8:	2100      	movs	r1, #0
   25eea:	4618      	mov	r0, r3
   25eec:	f7fd fb96 	bl	2361c <memset>

    attr_char_value.p_uuid       = &ble_uuid;
   25ef0:	f107 030c 	add.w	r3, r7, #12
   25ef4:	613b      	str	r3, [r7, #16]
    attr_char_value.p_attr_md    = &attr_md;
   25ef6:	f107 0308 	add.w	r3, r7, #8
   25efa:	617b      	str	r3, [r7, #20]
    attr_char_value.init_len     = sizeof(ble_uart_tx_buffer);
   25efc:	2314      	movs	r3, #20
   25efe:	833b      	strh	r3, [r7, #24]
    attr_char_value.init_offs    = 0;
   25f00:	2300      	movs	r3, #0
   25f02:	837b      	strh	r3, [r7, #26]
    attr_char_value.max_len      = sizeof(ble_uart_tx_buffer);
   25f04:	2314      	movs	r3, #20
   25f06:	83bb      	strh	r3, [r7, #28]
    attr_char_value.p_value      = ble_uart_tx_buffer;
   25f08:	4b09      	ldr	r3, [pc, #36]	; (25f30 <UartTxCharAdd+0xf0>)
   25f0a:	623b      	str	r3, [r7, #32]


    return sd_ble_gatts_characteristic_add(p_uart->service_handle,
   25f0c:	687b      	ldr	r3, [r7, #4]
   25f0e:	8898      	ldrh	r0, [r3, #4]
   25f10:	687b      	ldr	r3, [r7, #4]
   25f12:	3306      	adds	r3, #6
   25f14:	f107 0210 	add.w	r2, r7, #16
   25f18:	f107 0124 	add.w	r1, r7, #36	; 0x24
   25f1c:	f7ff fb5e 	bl	255dc <sd_ble_gatts_characteristic_add>
   25f20:	4603      	mov	r3, r0
                                           &char_md,
                                           &attr_char_value,
                                           &p_uart->tx_handles);
}
   25f22:	4618      	mov	r0, r3
   25f24:	3740      	adds	r7, #64	; 0x40
   25f26:	46bd      	mov	sp, r7
   25f28:	bd80      	pop	{r7, pc}
   25f2a:	bf00      	nop
   25f2c:	0002b548 	.word	0x0002b548
   25f30:	200052d0 	.word	0x200052d0

00025f34 <UartRxCharAdd>:
 * @param[in]   p_uart_init   Information needed to initialize the service.
 *
 * @return      NRF_SUCCESS on success, otherwise an error code.
 */
static uint32_t UartRxCharAdd(ble_uart_t * p_uart, const ble_uart_init_t * p_uart_init)
{
   25f34:	b580      	push	{r7, lr}
   25f36:	b090      	sub	sp, #64	; 0x40
   25f38:	af00      	add	r7, sp, #0
   25f3a:	6078      	str	r0, [r7, #4]
   25f3c:	6039      	str	r1, [r7, #0]
    ble_gatts_attr_t    attr_char_value;
    ble_uuid_t          ble_uuid;
    ble_gatts_attr_md_t attr_md;

        // clear the fields of char_md structure
    memset(&char_md, 0, sizeof(char_md));
   25f3e:	f107 0324 	add.w	r3, r7, #36	; 0x24
   25f42:	221c      	movs	r2, #28
   25f44:	2100      	movs	r1, #0
   25f46:	4618      	mov	r0, r3
   25f48:	f7fd fb68 	bl	2361c <memset>

    //  Set the read availability
    char_md.char_props.write    = 1;
   25f4c:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   25f50:	f043 0308 	orr.w	r3, r3, #8
   25f54:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24


    char_md.p_char_user_desc  = NULL;
   25f58:	2300      	movs	r3, #0
   25f5a:	62bb      	str	r3, [r7, #40]	; 0x28
    char_md.char_user_desc_max_size = 20;
   25f5c:	2314      	movs	r3, #20
   25f5e:	85bb      	strh	r3, [r7, #44]	; 0x2c
    char_md.char_user_desc_size = 0;
   25f60:	2300      	movs	r3, #0
   25f62:	85fb      	strh	r3, [r7, #46]	; 0x2e
    char_md.p_char_pf         = NULL;
   25f64:	2300      	movs	r3, #0
   25f66:	633b      	str	r3, [r7, #48]	; 0x30
    char_md.p_user_desc_md    = NULL;
   25f68:	2300      	movs	r3, #0
   25f6a:	637b      	str	r3, [r7, #52]	; 0x34
    char_md.p_cccd_md         = NULL;
   25f6c:	2300      	movs	r3, #0
   25f6e:	63bb      	str	r3, [r7, #56]	; 0x38
    char_md.p_sccd_md         = NULL;
   25f70:	2300      	movs	r3, #0
   25f72:	63fb      	str	r3, [r7, #60]	; 0x3c

    //  Inform the characteristic that it will have a custom vendor UUID
    ble_uuid.type = p_uart->uuid_type;
   25f74:	687b      	ldr	r3, [r7, #4]
   25f76:	7f9b      	ldrb	r3, [r3, #30]
   25f78:	73bb      	strb	r3, [r7, #14]
    //  Set the 16-bit UUID for the characteristic
    ble_uuid.uuid = RX_CHAR_UUID;
   25f7a:	2302      	movs	r3, #2
   25f7c:	81bb      	strh	r3, [r7, #12]

    memset(&attr_md, 0, sizeof(attr_md));
   25f7e:	f107 0308 	add.w	r3, r7, #8
   25f82:	2203      	movs	r2, #3
   25f84:	2100      	movs	r1, #0
   25f86:	4618      	mov	r0, r3
   25f88:	f7fd fb48 	bl	2361c <memset>

    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attr_md.read_perm);
   25f8c:	7a3b      	ldrb	r3, [r7, #8]
   25f8e:	2201      	movs	r2, #1
   25f90:	f362 0303 	bfi	r3, r2, #0, #4
   25f94:	723b      	strb	r3, [r7, #8]
   25f96:	7a3b      	ldrb	r3, [r7, #8]
   25f98:	2201      	movs	r2, #1
   25f9a:	f362 1307 	bfi	r3, r2, #4, #4
   25f9e:	723b      	strb	r3, [r7, #8]
    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attr_md.write_perm);
   25fa0:	7a7b      	ldrb	r3, [r7, #9]
   25fa2:	2201      	movs	r2, #1
   25fa4:	f362 0303 	bfi	r3, r2, #0, #4
   25fa8:	727b      	strb	r3, [r7, #9]
   25faa:	7a7b      	ldrb	r3, [r7, #9]
   25fac:	2201      	movs	r2, #1
   25fae:	f362 1307 	bfi	r3, r2, #4, #4
   25fb2:	727b      	strb	r3, [r7, #9]
    attr_md.vloc       = BLE_GATTS_VLOC_USER;
   25fb4:	7abb      	ldrb	r3, [r7, #10]
   25fb6:	2202      	movs	r2, #2
   25fb8:	f362 0342 	bfi	r3, r2, #1, #2
   25fbc:	72bb      	strb	r3, [r7, #10]
    attr_md.rd_auth    = 0;
   25fbe:	7abb      	ldrb	r3, [r7, #10]
   25fc0:	f36f 03c3 	bfc	r3, #3, #1
   25fc4:	72bb      	strb	r3, [r7, #10]
    attr_md.wr_auth    = 0;
   25fc6:	7abb      	ldrb	r3, [r7, #10]
   25fc8:	f36f 1304 	bfc	r3, #4, #1
   25fcc:	72bb      	strb	r3, [r7, #10]
    attr_md.vlen       = 0;
   25fce:	7abb      	ldrb	r3, [r7, #10]
   25fd0:	f36f 0300 	bfc	r3, #0, #1
   25fd4:	72bb      	strb	r3, [r7, #10]

    memset(&attr_char_value, 0, sizeof(attr_char_value));
   25fd6:	f107 0310 	add.w	r3, r7, #16
   25fda:	2214      	movs	r2, #20
   25fdc:	2100      	movs	r1, #0
   25fde:	4618      	mov	r0, r3
   25fe0:	f7fd fb1c 	bl	2361c <memset>

    attr_char_value.p_uuid    = &ble_uuid;
   25fe4:	f107 030c 	add.w	r3, r7, #12
   25fe8:	613b      	str	r3, [r7, #16]
    attr_char_value.p_attr_md = &attr_md;
   25fea:	f107 0308 	add.w	r3, r7, #8
   25fee:	617b      	str	r3, [r7, #20]
    attr_char_value.init_len  = sizeof(ble_uart_rx_buffer);
   25ff0:	2314      	movs	r3, #20
   25ff2:	833b      	strh	r3, [r7, #24]
    attr_char_value.init_offs = 0;
   25ff4:	2300      	movs	r3, #0
   25ff6:	837b      	strh	r3, [r7, #26]
    attr_char_value.max_len   = sizeof(ble_uart_rx_buffer);
   25ff8:	2314      	movs	r3, #20
   25ffa:	83bb      	strh	r3, [r7, #28]
    attr_char_value.p_value   = ble_uart_rx_buffer;
   25ffc:	4b08      	ldr	r3, [pc, #32]	; (26020 <UartRxCharAdd+0xec>)
   25ffe:	623b      	str	r3, [r7, #32]

    return sd_ble_gatts_characteristic_add(p_uart->service_handle, &char_md,
   26000:	687b      	ldr	r3, [r7, #4]
   26002:	8898      	ldrh	r0, [r3, #4]
   26004:	687b      	ldr	r3, [r7, #4]
   26006:	330e      	adds	r3, #14
   26008:	f107 0210 	add.w	r2, r7, #16
   2600c:	f107 0124 	add.w	r1, r7, #36	; 0x24
   26010:	f7ff fae4 	bl	255dc <sd_ble_gatts_characteristic_add>
   26014:	4603      	mov	r3, r0
                                               &attr_char_value,
                                               &p_uart->rx_handles);
}
   26016:	4618      	mov	r0, r3
   26018:	3740      	adds	r7, #64	; 0x40
   2601a:	46bd      	mov	sp, r7
   2601c:	bd80      	pop	{r7, pc}
   2601e:	bf00      	nop
   26020:	200052e4 	.word	0x200052e4

00026024 <UartDeviceEventsCharAdd>:
 * @param[in]   p_uart_init   Information needed to initialize the service.
 *
 * @return      NRF_SUCCESS on success, otherwise an error code.
 */
static uint32_t UartDeviceEventsCharAdd(ble_uart_t * p_uart, const ble_uart_init_t * p_uart_init)
{
   26024:	b580      	push	{r7, lr}
   26026:	b090      	sub	sp, #64	; 0x40
   26028:	af00      	add	r7, sp, #0
   2602a:	6078      	str	r0, [r7, #4]
   2602c:	6039      	str	r1, [r7, #0]
    ble_gatts_attr_t    attr_char_value;
    ble_uuid_t          ble_uuid;
    ble_gatts_attr_md_t attr_md;

    // Clear char_md structure
    memset(&char_md, 0, sizeof(char_md));
   2602e:	f107 0324 	add.w	r3, r7, #36	; 0x24
   26032:	221c      	movs	r2, #28
   26034:	2100      	movs	r1, #0
   26036:	4618      	mov	r0, r3
   26038:	f7fd faf0 	bl	2361c <memset>

        //  Set indicate avaliability
    char_md.char_props.notify  = 1;
   2603c:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   26040:	f043 0310 	orr.w	r3, r3, #16
   26044:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
        //  Setup descriptor
#ifdef LIGHT_CHARACTERISTICS
    char_md.p_char_user_desc = NULL;
#else
    // Human-friendly descriptor to debug
    char_md.p_char_user_desc = (uint8_t*)"Events";
   26048:	4b31      	ldr	r3, [pc, #196]	; (26110 <UartDeviceEventsCharAdd+0xec>)
   2604a:	62bb      	str	r3, [r7, #40]	; 0x28
    char_md.char_user_desc_size = sizeof("Events");
   2604c:	2307      	movs	r3, #7
   2604e:	85fb      	strh	r3, [r7, #46]	; 0x2e
    char_md.char_user_desc_max_size = 20;
   26050:	2314      	movs	r3, #20
   26052:	85bb      	strh	r3, [r7, #44]	; 0x2c
#endif
    char_md.p_char_pf        = NULL;
   26054:	2300      	movs	r3, #0
   26056:	633b      	str	r3, [r7, #48]	; 0x30
    char_md.p_user_desc_md   = NULL;
   26058:	2300      	movs	r3, #0
   2605a:	637b      	str	r3, [r7, #52]	; 0x34
    char_md.p_cccd_md        = NULL;
   2605c:	2300      	movs	r3, #0
   2605e:	63bb      	str	r3, [r7, #56]	; 0x38
    char_md.p_sccd_md        = NULL;
   26060:	2300      	movs	r3, #0
   26062:	63fb      	str	r3, [r7, #60]	; 0x3c

    //  Inform the characteristic that it will have a custom vendor UUID
    ble_uuid.type = p_uart->uuid_type;
   26064:	687b      	ldr	r3, [r7, #4]
   26066:	7f9b      	ldrb	r3, [r3, #30]
   26068:	73bb      	strb	r3, [r7, #14]
    //  Set the 16-bit UUID for the characteristic
    ble_uuid.uuid = DEV_EVENTS_UUID;
   2606a:	2304      	movs	r3, #4
   2606c:	81bb      	strh	r3, [r7, #12]

    memset(&attr_md, 0, sizeof(attr_md));
   2606e:	f107 0308 	add.w	r3, r7, #8
   26072:	2203      	movs	r2, #3
   26074:	2100      	movs	r1, #0
   26076:	4618      	mov	r0, r3
   26078:	f7fd fad0 	bl	2361c <memset>

    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attr_md.read_perm);
   2607c:	7a3b      	ldrb	r3, [r7, #8]
   2607e:	2201      	movs	r2, #1
   26080:	f362 0303 	bfi	r3, r2, #0, #4
   26084:	723b      	strb	r3, [r7, #8]
   26086:	7a3b      	ldrb	r3, [r7, #8]
   26088:	2201      	movs	r2, #1
   2608a:	f362 1307 	bfi	r3, r2, #4, #4
   2608e:	723b      	strb	r3, [r7, #8]
    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attr_md.write_perm);
   26090:	7a7b      	ldrb	r3, [r7, #9]
   26092:	2201      	movs	r2, #1
   26094:	f362 0303 	bfi	r3, r2, #0, #4
   26098:	727b      	strb	r3, [r7, #9]
   2609a:	7a7b      	ldrb	r3, [r7, #9]
   2609c:	2201      	movs	r2, #1
   2609e:	f362 1307 	bfi	r3, r2, #4, #4
   260a2:	727b      	strb	r3, [r7, #9]
    attr_md.vloc       = BLE_GATTS_VLOC_USER;                   /*< Set the characteristics buffer on the user's side of RAM **/
   260a4:	7abb      	ldrb	r3, [r7, #10]
   260a6:	2202      	movs	r2, #2
   260a8:	f362 0342 	bfi	r3, r2, #1, #2
   260ac:	72bb      	strb	r3, [r7, #10]
    attr_md.rd_auth    = 0;                                     /*< Read authentication */
   260ae:	7abb      	ldrb	r3, [r7, #10]
   260b0:	f36f 03c3 	bfc	r3, #3, #1
   260b4:	72bb      	strb	r3, [r7, #10]
    attr_md.wr_auth    = 0;
   260b6:	7abb      	ldrb	r3, [r7, #10]
   260b8:	f36f 1304 	bfc	r3, #4, #1
   260bc:	72bb      	strb	r3, [r7, #10]
    attr_md.vlen       = 1;                                     /*< Various length **/
   260be:	7abb      	ldrb	r3, [r7, #10]
   260c0:	f043 0301 	orr.w	r3, r3, #1
   260c4:	72bb      	strb	r3, [r7, #10]

    memset(&attr_char_value, 0, sizeof(attr_char_value));
   260c6:	f107 0310 	add.w	r3, r7, #16
   260ca:	2214      	movs	r2, #20
   260cc:	2100      	movs	r1, #0
   260ce:	4618      	mov	r0, r3
   260d0:	f7fd faa4 	bl	2361c <memset>

    attr_char_value.p_uuid       = &ble_uuid;
   260d4:	f107 030c 	add.w	r3, r7, #12
   260d8:	613b      	str	r3, [r7, #16]
    attr_char_value.p_attr_md    = &attr_md;
   260da:	f107 0308 	add.w	r3, r7, #8
   260de:	617b      	str	r3, [r7, #20]
    attr_char_value.init_len     = 20;
   260e0:	2314      	movs	r3, #20
   260e2:	833b      	strh	r3, [r7, #24]
    attr_char_value.init_offs    = 0;
   260e4:	2300      	movs	r3, #0
   260e6:	837b      	strh	r3, [r7, #26]
    attr_char_value.max_len      = 20;
   260e8:	2314      	movs	r3, #20
   260ea:	83bb      	strh	r3, [r7, #28]
    attr_char_value.p_value      = ble_uart_tx_buffer;
   260ec:	4b09      	ldr	r3, [pc, #36]	; (26114 <UartDeviceEventsCharAdd+0xf0>)
   260ee:	623b      	str	r3, [r7, #32]


    return sd_ble_gatts_characteristic_add(p_uart->service_handle,
   260f0:	687b      	ldr	r3, [r7, #4]
   260f2:	8898      	ldrh	r0, [r3, #4]
   260f4:	687b      	ldr	r3, [r7, #4]
   260f6:	3316      	adds	r3, #22
   260f8:	f107 0210 	add.w	r2, r7, #16
   260fc:	f107 0124 	add.w	r1, r7, #36	; 0x24
   26100:	f7ff fa6c 	bl	255dc <sd_ble_gatts_characteristic_add>
   26104:	4603      	mov	r3, r0
                                           &char_md,
                                           &attr_char_value,
                                           &p_uart->dev_events_handles);
}
   26106:	4618      	mov	r0, r3
   26108:	3740      	adds	r7, #64	; 0x40
   2610a:	46bd      	mov	sp, r7
   2610c:	bd80      	pop	{r7, pc}
   2610e:	bf00      	nop
   26110:	0002b54c 	.word	0x0002b54c
   26114:	200052d0 	.word	0x200052d0

00026118 <BleUartServiceInit>:
 * @param[in]   p_uart_init  Information needed to initialize the service.
 *
 * @return      NRF_SUCCESS on successful initialization of service, otherwise an error code.
 */
uint32_t BleUartServiceInit(ble_uart_t * p_uart, const ble_uart_init_t * p_uart_init)
{
   26118:	b590      	push	{r4, r7, lr}
   2611a:	b089      	sub	sp, #36	; 0x24
   2611c:	af00      	add	r7, sp, #0
   2611e:	6078      	str	r0, [r7, #4]
   26120:	6039      	str	r1, [r7, #0]
    uint32_t   err_code;
    ble_uuid128_t base_uuid = SECUCAR_UUID_BASE;
   26122:	4b2c      	ldr	r3, [pc, #176]	; (261d4 <BleUartServiceInit+0xbc>)
   26124:	f107 040c 	add.w	r4, r7, #12
   26128:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
   2612a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

    /// Initialize the fifo for arguments
//    Fifo_Init(&ble_uart_argument_fifo, ble_uart_arg_buffer, sizeof(ble_uart_arg_buffer));

    // Initialize service structure
    p_uart->evt_handler = p_uart_init->evt_handler;
   2612e:	683b      	ldr	r3, [r7, #0]
   26130:	681a      	ldr	r2, [r3, #0]
   26132:	687b      	ldr	r3, [r7, #4]
   26134:	601a      	str	r2, [r3, #0]
    p_uart->conn_handle = BLE_CONN_HANDLE_INVALID;
   26136:	687b      	ldr	r3, [r7, #4]
   26138:	f64f 72ff 	movw	r2, #65535	; 0xffff
   2613c:	841a      	strh	r2, [r3, #32]

    // Assign base UUID
    err_code = sd_ble_uuid_vs_add(&base_uuid, &(p_uart->uuid_type));
   2613e:	687b      	ldr	r3, [r7, #4]
   26140:	f103 021e 	add.w	r2, r3, #30
   26144:	f107 030c 	add.w	r3, r7, #12
   26148:	4611      	mov	r1, r2
   2614a:	4618      	mov	r0, r3
   2614c:	f7ff fa52 	bl	255f4 <sd_ble_uuid_vs_add>
   26150:	61f8      	str	r0, [r7, #28]
    if(err_code != NRF_SUCCESS)
   26152:	69fb      	ldr	r3, [r7, #28]
   26154:	2b00      	cmp	r3, #0
   26156:	d001      	beq.n	2615c <BleUartServiceInit+0x44>
    {
            return err_code;
   26158:	69fb      	ldr	r3, [r7, #28]
   2615a:	e037      	b.n	261cc <BleUartServiceInit+0xb4>
    }


    ble_uuid_t ble_uuid;
    //  Set the vendor specific UUID to the newly created service (?)
    ble_uuid.type = p_uart->uuid_type;
   2615c:	687b      	ldr	r3, [r7, #4]
   2615e:	7f9b      	ldrb	r3, [r3, #30]
   26160:	72bb      	strb	r3, [r7, #10]
    //  Set the 16-bit UUID
    ble_uuid.uuid = BLE_UART_SERVICE_UUID;
   26162:	2301      	movs	r3, #1
   26164:	813b      	strh	r3, [r7, #8]
    //  Add the service and create a service_handle to it
    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &(p_uart->service_handle));
   26166:	687b      	ldr	r3, [r7, #4]
   26168:	1d1a      	adds	r2, r3, #4
   2616a:	f107 0308 	add.w	r3, r7, #8
   2616e:	4619      	mov	r1, r3
   26170:	2001      	movs	r0, #1
   26172:	f7ff fa2f 	bl	255d4 <sd_ble_gatts_service_add>
   26176:	61f8      	str	r0, [r7, #28]
    if(err_code != NRF_SUCCESS)
   26178:	69fb      	ldr	r3, [r7, #28]
   2617a:	2b00      	cmp	r3, #0
   2617c:	d001      	beq.n	26182 <BleUartServiceInit+0x6a>
    {
        return err_code;
   2617e:	69fb      	ldr	r3, [r7, #28]
   26180:	e024      	b.n	261cc <BleUartServiceInit+0xb4>
    }

    // Add measurement characteristic
    err_code = UartRxCharAdd(p_uart, p_uart_init);
   26182:	6839      	ldr	r1, [r7, #0]
   26184:	6878      	ldr	r0, [r7, #4]
   26186:	f7ff fed5 	bl	25f34 <UartRxCharAdd>
   2618a:	61f8      	str	r0, [r7, #28]
    if (err_code != NRF_SUCCESS)
   2618c:	69fb      	ldr	r3, [r7, #28]
   2618e:	2b00      	cmp	r3, #0
   26190:	d001      	beq.n	26196 <BleUartServiceInit+0x7e>
    {
        return err_code;
   26192:	69fb      	ldr	r3, [r7, #28]
   26194:	e01a      	b.n	261cc <BleUartServiceInit+0xb4>
    }

    // Add feature characteristic
    err_code = UartTxCharAdd(p_uart, p_uart_init);
   26196:	6839      	ldr	r1, [r7, #0]
   26198:	6878      	ldr	r0, [r7, #4]
   2619a:	f7ff fe51 	bl	25e40 <UartTxCharAdd>
   2619e:	61f8      	str	r0, [r7, #28]
    if (err_code != NRF_SUCCESS)
   261a0:	69fb      	ldr	r3, [r7, #28]
   261a2:	2b00      	cmp	r3, #0
   261a4:	d001      	beq.n	261aa <BleUartServiceInit+0x92>
    {
        return err_code;
   261a6:	69fb      	ldr	r3, [r7, #28]
   261a8:	e010      	b.n	261cc <BleUartServiceInit+0xb4>
    }

    err_code = UartDeviceEventsCharAdd(p_uart, p_uart_init);
   261aa:	6839      	ldr	r1, [r7, #0]
   261ac:	6878      	ldr	r0, [r7, #4]
   261ae:	f7ff ff39 	bl	26024 <UartDeviceEventsCharAdd>
   261b2:	61f8      	str	r0, [r7, #28]
    if (err_code != NRF_SUCCESS)
   261b4:	69fb      	ldr	r3, [r7, #28]
   261b6:	2b00      	cmp	r3, #0
   261b8:	d001      	beq.n	261be <BleUartServiceInit+0xa6>
    {
        return err_code;
   261ba:	69fb      	ldr	r3, [r7, #28]
   261bc:	e006      	b.n	261cc <BleUartServiceInit+0xb4>
    }

    FifoInit(&ble_uart_pending_requests_fifo, ble_uart_pending_requests_fifo_buffer, sizeof(ble_uart_pending_requests_fifo_buffer), sizeof(uint8_t));
   261be:	2301      	movs	r3, #1
   261c0:	2210      	movs	r2, #16
   261c2:	4905      	ldr	r1, [pc, #20]	; (261d8 <BleUartServiceInit+0xc0>)
   261c4:	4805      	ldr	r0, [pc, #20]	; (261dc <BleUartServiceInit+0xc4>)
   261c6:	f7fd fe65 	bl	23e94 <FifoInit>
    return NRF_SUCCESS;
   261ca:	2300      	movs	r3, #0
}
   261cc:	4618      	mov	r0, r3
   261ce:	3724      	adds	r7, #36	; 0x24
   261d0:	46bd      	mov	sp, r7
   261d2:	bd90      	pop	{r4, r7, pc}
   261d4:	0002b554 	.word	0x0002b554
   261d8:	20005314 	.word	0x20005314
   261dc:	20005308 	.word	0x20005308

000261e0 <sd_ble_gap_addr_get>:
SVCALL(SD_BLE_GAP_ADDR_GET, uint32_t, sd_ble_gap_addr_get(ble_gap_addr_t *p_addr));
   261e0:	df6d      	svc	109	; 0x6d
   261e2:	4770      	bx	lr
   261e4:	bf00      	nop
   261e6:	4618      	mov	r0, r3

000261e8 <sd_ble_gap_adv_data_set>:
SVCALL(SD_BLE_GAP_ADV_DATA_SET, uint32_t, sd_ble_gap_adv_data_set(uint8_t const *p_data, uint8_t dlen, uint8_t const *p_sr_data, uint8_t srdlen));
   261e8:	df72      	svc	114	; 0x72
   261ea:	4770      	bx	lr
   261ec:	bf00      	nop
   261ee:	4618      	mov	r0, r3

000261f0 <sd_ble_gap_appearance_get>:
SVCALL(SD_BLE_GAP_APPEARANCE_GET, uint32_t, sd_ble_gap_appearance_get(uint16_t *p_appearance));
   261f0:	df79      	svc	121	; 0x79
   261f2:	4770      	bx	lr
   261f4:	bf00      	nop
   261f6:	4618      	mov	r0, r3

000261f8 <sd_ble_gap_device_name_get>:
 *
 * @retval ::NRF_SUCCESS GAP device name retrieved successfully.
 * @retval ::NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
 * @retval ::NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.
 */
SVCALL(SD_BLE_GAP_DEVICE_NAME_GET, uint32_t, sd_ble_gap_device_name_get(uint8_t *p_dev_name, uint16_t *p_len));
   261f8:	df7d      	svc	125	; 0x7d
   261fa:	4770      	bx	lr
   261fc:	bf00      	nop
   261fe:	4618      	mov	r0, r3

00026200 <sd_ble_uuid_encode>:
SVCALL(SD_BLE_UUID_ENCODE, uint32_t, sd_ble_uuid_encode(ble_uuid_t const *p_uuid, uint8_t *p_uuid_le_len, uint8_t *p_uuid_le));
   26200:	df64      	svc	100	; 0x64
   26202:	4770      	bx	lr
   26204:	bf00      	nop
   26206:	4618      	mov	r0, r3

00026208 <uint16_encode>:
 * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
 *
 * @return      Number of bytes written.
 */
static __INLINE uint8_t uint16_encode(uint16_t value, uint8_t * p_encoded_data)
{
   26208:	b480      	push	{r7}
   2620a:	b083      	sub	sp, #12
   2620c:	af00      	add	r7, sp, #0
   2620e:	4603      	mov	r3, r0
   26210:	6039      	str	r1, [r7, #0]
   26212:	80fb      	strh	r3, [r7, #6]
    p_encoded_data[0] = (uint8_t) ((value & 0x00FF) >> 0);
   26214:	88fb      	ldrh	r3, [r7, #6]
   26216:	b2da      	uxtb	r2, r3
   26218:	683b      	ldr	r3, [r7, #0]
   2621a:	701a      	strb	r2, [r3, #0]
    p_encoded_data[1] = (uint8_t) ((value & 0xFF00) >> 8);
   2621c:	88fb      	ldrh	r3, [r7, #6]
   2621e:	0a1b      	lsrs	r3, r3, #8
   26220:	b29a      	uxth	r2, r3
   26222:	683b      	ldr	r3, [r7, #0]
   26224:	3301      	adds	r3, #1
   26226:	b2d2      	uxtb	r2, r2
   26228:	701a      	strb	r2, [r3, #0]
    return sizeof(uint16_t);
   2622a:	2302      	movs	r3, #2
}
   2622c:	4618      	mov	r0, r3
   2622e:	370c      	adds	r7, #12
   26230:	46bd      	mov	sp, r7
   26232:	bc80      	pop	{r7}
   26234:	4770      	bx	lr

00026236 <ble_device_addr_encode>:
#define AD_TYPE_BLE_DEVICE_ADDR_TYPE_RANDOM 1UL

static uint32_t ble_device_addr_encode(uint8_t  * p_encoded_data,
                                       uint16_t * p_offset,
                                       uint16_t   max_size)
{
   26236:	b580      	push	{r7, lr}
   26238:	b088      	sub	sp, #32
   2623a:	af00      	add	r7, sp, #0
   2623c:	60f8      	str	r0, [r7, #12]
   2623e:	60b9      	str	r1, [r7, #8]
   26240:	4613      	mov	r3, r2
   26242:	80fb      	strh	r3, [r7, #6]
    uint32_t err_code;
    ble_gap_addr_t device_addr;

    // Check for buffer overflow.
    if (((*p_offset) + AD_TYPE_BLE_DEVICE_ADDR_SIZE) > max_size)
   26244:	68bb      	ldr	r3, [r7, #8]
   26246:	881b      	ldrh	r3, [r3, #0]
   26248:	f103 0209 	add.w	r2, r3, #9
   2624c:	88fb      	ldrh	r3, [r7, #6]
   2624e:	429a      	cmp	r2, r3
   26250:	d901      	bls.n	26256 <ble_device_addr_encode+0x20>
    {
        return NRF_ERROR_DATA_SIZE;
   26252:	230c      	movs	r3, #12
   26254:	e052      	b.n	262fc <ble_device_addr_encode+0xc6>
    }

    // Get BLE address.
    #if (NRF_SD_BLE_API_VERSION >= 3)
        err_code = sd_ble_gap_addr_get(&device_addr);
   26256:	f107 0314 	add.w	r3, r7, #20
   2625a:	4618      	mov	r0, r3
   2625c:	f7ff ffc0 	bl	261e0 <sd_ble_gap_addr_get>
   26260:	61f8      	str	r0, [r7, #28]
    #else
        err_code = sd_ble_gap_address_get(&device_addr);
    #endif
    VERIFY_SUCCESS(err_code);
   26262:	69fb      	ldr	r3, [r7, #28]
   26264:	2b00      	cmp	r3, #0
   26266:	d001      	beq.n	2626c <ble_device_addr_encode+0x36>
   26268:	69fb      	ldr	r3, [r7, #28]
   2626a:	e047      	b.n	262fc <ble_device_addr_encode+0xc6>

    // Encode LE Bluetooth Device Address.
    p_encoded_data[*p_offset]  = (uint8_t)(AD_TYPE_FIELD_SIZE +
   2626c:	68bb      	ldr	r3, [r7, #8]
   2626e:	881b      	ldrh	r3, [r3, #0]
   26270:	461a      	mov	r2, r3
   26272:	68fb      	ldr	r3, [r7, #12]
   26274:	4413      	add	r3, r2
   26276:	2208      	movs	r2, #8
   26278:	701a      	strb	r2, [r3, #0]
                                               AD_TYPE_BLE_DEVICE_ADDR_DATA_SIZE);
    *p_offset                 += AD_LENGTH_FIELD_SIZE;
   2627a:	68bb      	ldr	r3, [r7, #8]
   2627c:	881b      	ldrh	r3, [r3, #0]
   2627e:	3301      	adds	r3, #1
   26280:	b29a      	uxth	r2, r3
   26282:	68bb      	ldr	r3, [r7, #8]
   26284:	801a      	strh	r2, [r3, #0]
    p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_LE_BLUETOOTH_DEVICE_ADDRESS;
   26286:	68bb      	ldr	r3, [r7, #8]
   26288:	881b      	ldrh	r3, [r3, #0]
   2628a:	461a      	mov	r2, r3
   2628c:	68fb      	ldr	r3, [r7, #12]
   2628e:	4413      	add	r3, r2
   26290:	221b      	movs	r2, #27
   26292:	701a      	strb	r2, [r3, #0]
    *p_offset                 += AD_TYPE_FIELD_SIZE;
   26294:	68bb      	ldr	r3, [r7, #8]
   26296:	881b      	ldrh	r3, [r3, #0]
   26298:	3301      	adds	r3, #1
   2629a:	b29a      	uxth	r2, r3
   2629c:	68bb      	ldr	r3, [r7, #8]
   2629e:	801a      	strh	r2, [r3, #0]
    memcpy(&p_encoded_data[*p_offset], &device_addr.addr[0], BLE_GAP_ADDR_LEN);
   262a0:	68bb      	ldr	r3, [r7, #8]
   262a2:	881b      	ldrh	r3, [r3, #0]
   262a4:	461a      	mov	r2, r3
   262a6:	68fb      	ldr	r3, [r7, #12]
   262a8:	1898      	adds	r0, r3, r2
   262aa:	f107 0314 	add.w	r3, r7, #20
   262ae:	3301      	adds	r3, #1
   262b0:	2206      	movs	r2, #6
   262b2:	4619      	mov	r1, r3
   262b4:	f005 f81c 	bl	2b2f0 <memcpy>
    *p_offset                 += BLE_GAP_ADDR_LEN;
   262b8:	68bb      	ldr	r3, [r7, #8]
   262ba:	881b      	ldrh	r3, [r3, #0]
   262bc:	3306      	adds	r3, #6
   262be:	b29a      	uxth	r2, r3
   262c0:	68bb      	ldr	r3, [r7, #8]
   262c2:	801a      	strh	r2, [r3, #0]
    if (BLE_GAP_ADDR_TYPE_PUBLIC == device_addr.addr_type)
   262c4:	7d3b      	ldrb	r3, [r7, #20]
   262c6:	f023 0301 	bic.w	r3, r3, #1
   262ca:	b2db      	uxtb	r3, r3
   262cc:	2b00      	cmp	r3, #0
   262ce:	d107      	bne.n	262e0 <ble_device_addr_encode+0xaa>
    {
        p_encoded_data[*p_offset] = AD_TYPE_BLE_DEVICE_ADDR_TYPE_PUBLIC;
   262d0:	68bb      	ldr	r3, [r7, #8]
   262d2:	881b      	ldrh	r3, [r3, #0]
   262d4:	461a      	mov	r2, r3
   262d6:	68fb      	ldr	r3, [r7, #12]
   262d8:	4413      	add	r3, r2
   262da:	2200      	movs	r2, #0
   262dc:	701a      	strb	r2, [r3, #0]
   262de:	e006      	b.n	262ee <ble_device_addr_encode+0xb8>
    }
    else
    {
        p_encoded_data[*p_offset] = AD_TYPE_BLE_DEVICE_ADDR_TYPE_RANDOM;
   262e0:	68bb      	ldr	r3, [r7, #8]
   262e2:	881b      	ldrh	r3, [r3, #0]
   262e4:	461a      	mov	r2, r3
   262e6:	68fb      	ldr	r3, [r7, #12]
   262e8:	4413      	add	r3, r2
   262ea:	2201      	movs	r2, #1
   262ec:	701a      	strb	r2, [r3, #0]
    }
    *p_offset += AD_TYPE_BLE_DEVICE_ADDR_TYPE_SIZE;
   262ee:	68bb      	ldr	r3, [r7, #8]
   262f0:	881b      	ldrh	r3, [r3, #0]
   262f2:	3301      	adds	r3, #1
   262f4:	b29a      	uxth	r2, r3
   262f6:	68bb      	ldr	r3, [r7, #8]
   262f8:	801a      	strh	r2, [r3, #0]

    return NRF_SUCCESS;
   262fa:	2300      	movs	r3, #0
}
   262fc:	4618      	mov	r0, r3
   262fe:	3720      	adds	r7, #32
   26300:	46bd      	mov	sp, r7
   26302:	bd80      	pop	{r7, pc}

00026304 <name_encode>:

static uint32_t name_encode(const ble_advdata_t * p_advdata,
                            uint8_t             * p_encoded_data,
                            uint16_t            * p_offset,
                            uint16_t              max_size)
{
   26304:	b580      	push	{r7, lr}
   26306:	b088      	sub	sp, #32
   26308:	af00      	add	r7, sp, #0
   2630a:	60f8      	str	r0, [r7, #12]
   2630c:	60b9      	str	r1, [r7, #8]
   2630e:	607a      	str	r2, [r7, #4]
   26310:	807b      	strh	r3, [r7, #2]
    uint16_t actual_length;
    uint8_t  adv_data_format;


    // Validate parameters
    if ((BLE_ADVDATA_SHORT_NAME == p_advdata->name_type) && (0 == p_advdata->short_name_len))
   26312:	68fb      	ldr	r3, [r7, #12]
   26314:	781b      	ldrb	r3, [r3, #0]
   26316:	2b01      	cmp	r3, #1
   26318:	d105      	bne.n	26326 <name_encode+0x22>
   2631a:	68fb      	ldr	r3, [r7, #12]
   2631c:	785b      	ldrb	r3, [r3, #1]
   2631e:	2b00      	cmp	r3, #0
   26320:	d101      	bne.n	26326 <name_encode+0x22>
    {
        return NRF_ERROR_INVALID_PARAM;
   26322:	2307      	movs	r3, #7
   26324:	e077      	b.n	26416 <name_encode+0x112>
    }

    // Check for buffer overflow.
    if ( (((*p_offset) + AD_DATA_OFFSET) > max_size) ||
   26326:	687b      	ldr	r3, [r7, #4]
   26328:	881b      	ldrh	r3, [r3, #0]
   2632a:	1c9a      	adds	r2, r3, #2
   2632c:	887b      	ldrh	r3, [r7, #2]
   2632e:	429a      	cmp	r2, r3
   26330:	d80d      	bhi.n	2634e <name_encode+0x4a>
         ( (BLE_ADVDATA_SHORT_NAME == p_advdata->name_type) &&
   26332:	68fb      	ldr	r3, [r7, #12]
   26334:	781b      	ldrb	r3, [r3, #0]
    if ( (((*p_offset) + AD_DATA_OFFSET) > max_size) ||
   26336:	2b01      	cmp	r3, #1
   26338:	d10b      	bne.n	26352 <name_encode+0x4e>
           (((*p_offset) + AD_DATA_OFFSET + p_advdata->short_name_len) > max_size)))
   2633a:	687b      	ldr	r3, [r7, #4]
   2633c:	881b      	ldrh	r3, [r3, #0]
   2633e:	461a      	mov	r2, r3
   26340:	68fb      	ldr	r3, [r7, #12]
   26342:	785b      	ldrb	r3, [r3, #1]
   26344:	4413      	add	r3, r2
   26346:	1c9a      	adds	r2, r3, #2
   26348:	887b      	ldrh	r3, [r7, #2]
         ( (BLE_ADVDATA_SHORT_NAME == p_advdata->name_type) &&
   2634a:	429a      	cmp	r2, r3
   2634c:	d901      	bls.n	26352 <name_encode+0x4e>
    {
        return NRF_ERROR_DATA_SIZE;
   2634e:	230c      	movs	r3, #12
   26350:	e061      	b.n	26416 <name_encode+0x112>
    }

    rem_adv_data_len = max_size - (*p_offset) - AD_DATA_OFFSET;
   26352:	687b      	ldr	r3, [r7, #4]
   26354:	881b      	ldrh	r3, [r3, #0]
   26356:	887a      	ldrh	r2, [r7, #2]
   26358:	1ad3      	subs	r3, r2, r3
   2635a:	b29b      	uxth	r3, r3
   2635c:	3b02      	subs	r3, #2
   2635e:	83bb      	strh	r3, [r7, #28]
    actual_length    = rem_adv_data_len;
   26360:	8bbb      	ldrh	r3, [r7, #28]
   26362:	82fb      	strh	r3, [r7, #22]

    // Get GAP device name and length
    err_code = sd_ble_gap_device_name_get(&p_encoded_data[(*p_offset) + AD_DATA_OFFSET],
   26364:	687b      	ldr	r3, [r7, #4]
   26366:	881b      	ldrh	r3, [r3, #0]
   26368:	3302      	adds	r3, #2
   2636a:	68ba      	ldr	r2, [r7, #8]
   2636c:	4413      	add	r3, r2
   2636e:	f107 0216 	add.w	r2, r7, #22
   26372:	4611      	mov	r1, r2
   26374:	4618      	mov	r0, r3
   26376:	f7ff ff3f 	bl	261f8 <sd_ble_gap_device_name_get>
   2637a:	61b8      	str	r0, [r7, #24]
                                          &actual_length);
    VERIFY_SUCCESS(err_code);
   2637c:	69bb      	ldr	r3, [r7, #24]
   2637e:	2b00      	cmp	r3, #0
   26380:	d001      	beq.n	26386 <name_encode+0x82>
   26382:	69bb      	ldr	r3, [r7, #24]
   26384:	e047      	b.n	26416 <name_encode+0x112>

    // Check if device intend to use short name and it can fit available data size.
    if ((p_advdata->name_type == BLE_ADVDATA_FULL_NAME) && (actual_length <= rem_adv_data_len))
   26386:	68fb      	ldr	r3, [r7, #12]
   26388:	781b      	ldrb	r3, [r3, #0]
   2638a:	2b02      	cmp	r3, #2
   2638c:	d106      	bne.n	2639c <name_encode+0x98>
   2638e:	8afb      	ldrh	r3, [r7, #22]
   26390:	8bba      	ldrh	r2, [r7, #28]
   26392:	429a      	cmp	r2, r3
   26394:	d302      	bcc.n	2639c <name_encode+0x98>
    {
        // Complete device name can fit, setting Complete Name in Adv Data.
        adv_data_format = BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME;
   26396:	2309      	movs	r3, #9
   26398:	77fb      	strb	r3, [r7, #31]
   2639a:	e012      	b.n	263c2 <name_encode+0xbe>
    }
    else
    {
        // Else short name needs to be used. Or application has requested use of short name.
        adv_data_format = BLE_GAP_AD_TYPE_SHORT_LOCAL_NAME;
   2639c:	2308      	movs	r3, #8
   2639e:	77fb      	strb	r3, [r7, #31]

        // If application has set a preference on the short name size, it needs to be considered,
        // else fit what can be fit.
        if ((BLE_ADVDATA_SHORT_NAME == p_advdata->name_type) &&
   263a0:	68fb      	ldr	r3, [r7, #12]
   263a2:	781b      	ldrb	r3, [r3, #0]
   263a4:	2b01      	cmp	r3, #1
   263a6:	d10a      	bne.n	263be <name_encode+0xba>
                (p_advdata->short_name_len <= rem_adv_data_len))
   263a8:	68fb      	ldr	r3, [r7, #12]
   263aa:	785b      	ldrb	r3, [r3, #1]
   263ac:	b29b      	uxth	r3, r3
        if ((BLE_ADVDATA_SHORT_NAME == p_advdata->name_type) &&
   263ae:	8bba      	ldrh	r2, [r7, #28]
   263b0:	429a      	cmp	r2, r3
   263b2:	d304      	bcc.n	263be <name_encode+0xba>
        {
            // Short name fits available size.
            actual_length = p_advdata->short_name_len;
   263b4:	68fb      	ldr	r3, [r7, #12]
   263b6:	785b      	ldrb	r3, [r3, #1]
   263b8:	b29b      	uxth	r3, r3
   263ba:	82fb      	strh	r3, [r7, #22]
   263bc:	e001      	b.n	263c2 <name_encode+0xbe>
        }
        // Else whatever can fit the data buffer will be packed.
        else
        {
            actual_length = rem_adv_data_len;
   263be:	8bbb      	ldrh	r3, [r7, #28]
   263c0:	82fb      	strh	r3, [r7, #22]
        }
    }

    // There is only 1 byte intended to encode length which is (actual_length + AD_TYPE_FIELD_SIZE)
    if (actual_length > (0x00FF - AD_TYPE_FIELD_SIZE))
   263c2:	8afb      	ldrh	r3, [r7, #22]
   263c4:	2bfe      	cmp	r3, #254	; 0xfe
   263c6:	d901      	bls.n	263cc <name_encode+0xc8>
    {
        return NRF_ERROR_DATA_SIZE;
   263c8:	230c      	movs	r3, #12
   263ca:	e024      	b.n	26416 <name_encode+0x112>
    }

    // Complete name field in encoded data.
    p_encoded_data[*p_offset]  = (uint8_t)(AD_TYPE_FIELD_SIZE + actual_length);
   263cc:	8afb      	ldrh	r3, [r7, #22]
   263ce:	b2da      	uxtb	r2, r3
   263d0:	687b      	ldr	r3, [r7, #4]
   263d2:	881b      	ldrh	r3, [r3, #0]
   263d4:	4619      	mov	r1, r3
   263d6:	68bb      	ldr	r3, [r7, #8]
   263d8:	440b      	add	r3, r1
   263da:	3201      	adds	r2, #1
   263dc:	b2d2      	uxtb	r2, r2
   263de:	701a      	strb	r2, [r3, #0]
    *p_offset                 += AD_LENGTH_FIELD_SIZE;
   263e0:	687b      	ldr	r3, [r7, #4]
   263e2:	881b      	ldrh	r3, [r3, #0]
   263e4:	3301      	adds	r3, #1
   263e6:	b29a      	uxth	r2, r3
   263e8:	687b      	ldr	r3, [r7, #4]
   263ea:	801a      	strh	r2, [r3, #0]
    p_encoded_data[*p_offset]  = adv_data_format;
   263ec:	687b      	ldr	r3, [r7, #4]
   263ee:	881b      	ldrh	r3, [r3, #0]
   263f0:	461a      	mov	r2, r3
   263f2:	68bb      	ldr	r3, [r7, #8]
   263f4:	4413      	add	r3, r2
   263f6:	7ffa      	ldrb	r2, [r7, #31]
   263f8:	701a      	strb	r2, [r3, #0]
    *p_offset                 += AD_TYPE_FIELD_SIZE;
   263fa:	687b      	ldr	r3, [r7, #4]
   263fc:	881b      	ldrh	r3, [r3, #0]
   263fe:	3301      	adds	r3, #1
   26400:	b29a      	uxth	r2, r3
   26402:	687b      	ldr	r3, [r7, #4]
   26404:	801a      	strh	r2, [r3, #0]
    *p_offset                 += actual_length;
   26406:	687b      	ldr	r3, [r7, #4]
   26408:	881a      	ldrh	r2, [r3, #0]
   2640a:	8afb      	ldrh	r3, [r7, #22]
   2640c:	4413      	add	r3, r2
   2640e:	b29a      	uxth	r2, r3
   26410:	687b      	ldr	r3, [r7, #4]
   26412:	801a      	strh	r2, [r3, #0]

    return NRF_SUCCESS;
   26414:	2300      	movs	r3, #0
}
   26416:	4618      	mov	r0, r3
   26418:	3720      	adds	r7, #32
   2641a:	46bd      	mov	sp, r7
   2641c:	bd80      	pop	{r7, pc}

0002641e <appearance_encode>:


static uint32_t appearance_encode(uint8_t  * p_encoded_data,
                                  uint16_t * p_offset,
                                  uint16_t   max_size)
{
   2641e:	b580      	push	{r7, lr}
   26420:	b086      	sub	sp, #24
   26422:	af00      	add	r7, sp, #0
   26424:	60f8      	str	r0, [r7, #12]
   26426:	60b9      	str	r1, [r7, #8]
   26428:	4613      	mov	r3, r2
   2642a:	80fb      	strh	r3, [r7, #6]
    uint32_t err_code;
    uint16_t appearance;

    // Check for buffer overflow.
    if (((*p_offset) + AD_TYPE_APPEARANCE_SIZE) > max_size)
   2642c:	68bb      	ldr	r3, [r7, #8]
   2642e:	881b      	ldrh	r3, [r3, #0]
   26430:	1d1a      	adds	r2, r3, #4
   26432:	88fb      	ldrh	r3, [r7, #6]
   26434:	429a      	cmp	r2, r3
   26436:	d901      	bls.n	2643c <appearance_encode+0x1e>
    {
        return NRF_ERROR_DATA_SIZE;
   26438:	230c      	movs	r3, #12
   2643a:	e038      	b.n	264ae <appearance_encode+0x90>
    }

    // Get GAP appearance field.
    err_code = sd_ble_gap_appearance_get(&appearance);
   2643c:	f107 0312 	add.w	r3, r7, #18
   26440:	4618      	mov	r0, r3
   26442:	f7ff fed5 	bl	261f0 <sd_ble_gap_appearance_get>
   26446:	6178      	str	r0, [r7, #20]
    VERIFY_SUCCESS(err_code);
   26448:	697b      	ldr	r3, [r7, #20]
   2644a:	2b00      	cmp	r3, #0
   2644c:	d001      	beq.n	26452 <appearance_encode+0x34>
   2644e:	697b      	ldr	r3, [r7, #20]
   26450:	e02d      	b.n	264ae <appearance_encode+0x90>

    // Encode Length, AD Type and Appearance.
    p_encoded_data[*p_offset]  = (uint8_t)(AD_TYPE_FIELD_SIZE + AD_TYPE_APPEARANCE_DATA_SIZE);
   26452:	68bb      	ldr	r3, [r7, #8]
   26454:	881b      	ldrh	r3, [r3, #0]
   26456:	461a      	mov	r2, r3
   26458:	68fb      	ldr	r3, [r7, #12]
   2645a:	4413      	add	r3, r2
   2645c:	2203      	movs	r2, #3
   2645e:	701a      	strb	r2, [r3, #0]
    *p_offset                 += AD_LENGTH_FIELD_SIZE;
   26460:	68bb      	ldr	r3, [r7, #8]
   26462:	881b      	ldrh	r3, [r3, #0]
   26464:	3301      	adds	r3, #1
   26466:	b29a      	uxth	r2, r3
   26468:	68bb      	ldr	r3, [r7, #8]
   2646a:	801a      	strh	r2, [r3, #0]
    p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_APPEARANCE;
   2646c:	68bb      	ldr	r3, [r7, #8]
   2646e:	881b      	ldrh	r3, [r3, #0]
   26470:	461a      	mov	r2, r3
   26472:	68fb      	ldr	r3, [r7, #12]
   26474:	4413      	add	r3, r2
   26476:	2219      	movs	r2, #25
   26478:	701a      	strb	r2, [r3, #0]
    *p_offset                 += AD_TYPE_FIELD_SIZE;
   2647a:	68bb      	ldr	r3, [r7, #8]
   2647c:	881b      	ldrh	r3, [r3, #0]
   2647e:	3301      	adds	r3, #1
   26480:	b29a      	uxth	r2, r3
   26482:	68bb      	ldr	r3, [r7, #8]
   26484:	801a      	strh	r2, [r3, #0]
    *p_offset                 += uint16_encode(appearance, &p_encoded_data[*p_offset]);
   26486:	8a7a      	ldrh	r2, [r7, #18]
   26488:	68bb      	ldr	r3, [r7, #8]
   2648a:	881b      	ldrh	r3, [r3, #0]
   2648c:	4619      	mov	r1, r3
   2648e:	68fb      	ldr	r3, [r7, #12]
   26490:	440b      	add	r3, r1
   26492:	4619      	mov	r1, r3
   26494:	4610      	mov	r0, r2
   26496:	f7ff feb7 	bl	26208 <uint16_encode>
   2649a:	4603      	mov	r3, r0
   2649c:	4619      	mov	r1, r3
   2649e:	68bb      	ldr	r3, [r7, #8]
   264a0:	881a      	ldrh	r2, [r3, #0]
   264a2:	b28b      	uxth	r3, r1
   264a4:	4413      	add	r3, r2
   264a6:	b29a      	uxth	r2, r3
   264a8:	68bb      	ldr	r3, [r7, #8]
   264aa:	801a      	strh	r2, [r3, #0]

    return NRF_SUCCESS;
   264ac:	2300      	movs	r3, #0
}
   264ae:	4618      	mov	r0, r3
   264b0:	3718      	adds	r7, #24
   264b2:	46bd      	mov	sp, r7
   264b4:	bd80      	pop	{r7, pc}

000264b6 <flags_encode>:

static uint32_t flags_encode(int8_t     flags,
                             uint8_t  * p_encoded_data,
                             uint16_t * p_offset,
                             uint16_t   max_size)
{
   264b6:	b480      	push	{r7}
   264b8:	b085      	sub	sp, #20
   264ba:	af00      	add	r7, sp, #0
   264bc:	60b9      	str	r1, [r7, #8]
   264be:	607a      	str	r2, [r7, #4]
   264c0:	461a      	mov	r2, r3
   264c2:	4603      	mov	r3, r0
   264c4:	73fb      	strb	r3, [r7, #15]
   264c6:	4613      	mov	r3, r2
   264c8:	81bb      	strh	r3, [r7, #12]
    // Check for buffer overflow.
    if (((*p_offset) + AD_TYPE_FLAGS_SIZE) > max_size)
   264ca:	687b      	ldr	r3, [r7, #4]
   264cc:	881b      	ldrh	r3, [r3, #0]
   264ce:	1cda      	adds	r2, r3, #3
   264d0:	89bb      	ldrh	r3, [r7, #12]
   264d2:	429a      	cmp	r2, r3
   264d4:	d901      	bls.n	264da <flags_encode+0x24>
    {
        return NRF_ERROR_DATA_SIZE;
   264d6:	230c      	movs	r3, #12
   264d8:	e027      	b.n	2652a <flags_encode+0x74>
    }

    // Encode flags.
    p_encoded_data[*p_offset]  = (uint8_t)(AD_TYPE_FIELD_SIZE + AD_TYPE_FLAGS_DATA_SIZE);
   264da:	687b      	ldr	r3, [r7, #4]
   264dc:	881b      	ldrh	r3, [r3, #0]
   264de:	461a      	mov	r2, r3
   264e0:	68bb      	ldr	r3, [r7, #8]
   264e2:	4413      	add	r3, r2
   264e4:	2202      	movs	r2, #2
   264e6:	701a      	strb	r2, [r3, #0]
    *p_offset                 += AD_LENGTH_FIELD_SIZE;
   264e8:	687b      	ldr	r3, [r7, #4]
   264ea:	881b      	ldrh	r3, [r3, #0]
   264ec:	3301      	adds	r3, #1
   264ee:	b29a      	uxth	r2, r3
   264f0:	687b      	ldr	r3, [r7, #4]
   264f2:	801a      	strh	r2, [r3, #0]
    p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_FLAGS;
   264f4:	687b      	ldr	r3, [r7, #4]
   264f6:	881b      	ldrh	r3, [r3, #0]
   264f8:	461a      	mov	r2, r3
   264fa:	68bb      	ldr	r3, [r7, #8]
   264fc:	4413      	add	r3, r2
   264fe:	2201      	movs	r2, #1
   26500:	701a      	strb	r2, [r3, #0]
    *p_offset                 += AD_TYPE_FIELD_SIZE;
   26502:	687b      	ldr	r3, [r7, #4]
   26504:	881b      	ldrh	r3, [r3, #0]
   26506:	3301      	adds	r3, #1
   26508:	b29a      	uxth	r2, r3
   2650a:	687b      	ldr	r3, [r7, #4]
   2650c:	801a      	strh	r2, [r3, #0]
    p_encoded_data[*p_offset]  = flags;
   2650e:	687b      	ldr	r3, [r7, #4]
   26510:	881b      	ldrh	r3, [r3, #0]
   26512:	461a      	mov	r2, r3
   26514:	68bb      	ldr	r3, [r7, #8]
   26516:	4413      	add	r3, r2
   26518:	7bfa      	ldrb	r2, [r7, #15]
   2651a:	701a      	strb	r2, [r3, #0]
    *p_offset                 += AD_TYPE_FLAGS_DATA_SIZE;
   2651c:	687b      	ldr	r3, [r7, #4]
   2651e:	881b      	ldrh	r3, [r3, #0]
   26520:	3301      	adds	r3, #1
   26522:	b29a      	uxth	r2, r3
   26524:	687b      	ldr	r3, [r7, #4]
   26526:	801a      	strh	r2, [r3, #0]

    return NRF_SUCCESS;
   26528:	2300      	movs	r3, #0
}
   2652a:	4618      	mov	r0, r3
   2652c:	3714      	adds	r7, #20
   2652e:	46bd      	mov	sp, r7
   26530:	bc80      	pop	{r7}
   26532:	4770      	bx	lr

00026534 <tx_power_level_encode>:

static uint32_t tx_power_level_encode(int8_t     tx_power_level,
                                      uint8_t  * p_encoded_data,
                                      uint16_t * p_offset,
                                      uint16_t   max_size)
{
   26534:	b480      	push	{r7}
   26536:	b085      	sub	sp, #20
   26538:	af00      	add	r7, sp, #0
   2653a:	60b9      	str	r1, [r7, #8]
   2653c:	607a      	str	r2, [r7, #4]
   2653e:	461a      	mov	r2, r3
   26540:	4603      	mov	r3, r0
   26542:	73fb      	strb	r3, [r7, #15]
   26544:	4613      	mov	r3, r2
   26546:	81bb      	strh	r3, [r7, #12]
    // Check for buffer overflow.
    if (((*p_offset) + AD_TYPE_TX_POWER_LEVEL_SIZE) > max_size)
   26548:	687b      	ldr	r3, [r7, #4]
   2654a:	881b      	ldrh	r3, [r3, #0]
   2654c:	1cda      	adds	r2, r3, #3
   2654e:	89bb      	ldrh	r3, [r7, #12]
   26550:	429a      	cmp	r2, r3
   26552:	d901      	bls.n	26558 <tx_power_level_encode+0x24>
    {
        return NRF_ERROR_DATA_SIZE;
   26554:	230c      	movs	r3, #12
   26556:	e027      	b.n	265a8 <tx_power_level_encode+0x74>
    }

    // Encode TX Power Level.
    p_encoded_data[*p_offset]  = (uint8_t)(AD_TYPE_FIELD_SIZE +
   26558:	687b      	ldr	r3, [r7, #4]
   2655a:	881b      	ldrh	r3, [r3, #0]
   2655c:	461a      	mov	r2, r3
   2655e:	68bb      	ldr	r3, [r7, #8]
   26560:	4413      	add	r3, r2
   26562:	2202      	movs	r2, #2
   26564:	701a      	strb	r2, [r3, #0]
                                                  AD_TYPE_TX_POWER_LEVEL_DATA_SIZE);
    *p_offset                 += AD_LENGTH_FIELD_SIZE;
   26566:	687b      	ldr	r3, [r7, #4]
   26568:	881b      	ldrh	r3, [r3, #0]
   2656a:	3301      	adds	r3, #1
   2656c:	b29a      	uxth	r2, r3
   2656e:	687b      	ldr	r3, [r7, #4]
   26570:	801a      	strh	r2, [r3, #0]
    p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_TX_POWER_LEVEL;
   26572:	687b      	ldr	r3, [r7, #4]
   26574:	881b      	ldrh	r3, [r3, #0]
   26576:	461a      	mov	r2, r3
   26578:	68bb      	ldr	r3, [r7, #8]
   2657a:	4413      	add	r3, r2
   2657c:	220a      	movs	r2, #10
   2657e:	701a      	strb	r2, [r3, #0]
    *p_offset                 += AD_TYPE_FIELD_SIZE;
   26580:	687b      	ldr	r3, [r7, #4]
   26582:	881b      	ldrh	r3, [r3, #0]
   26584:	3301      	adds	r3, #1
   26586:	b29a      	uxth	r2, r3
   26588:	687b      	ldr	r3, [r7, #4]
   2658a:	801a      	strh	r2, [r3, #0]
    p_encoded_data[*p_offset]  = tx_power_level;
   2658c:	687b      	ldr	r3, [r7, #4]
   2658e:	881b      	ldrh	r3, [r3, #0]
   26590:	461a      	mov	r2, r3
   26592:	68bb      	ldr	r3, [r7, #8]
   26594:	4413      	add	r3, r2
   26596:	7bfa      	ldrb	r2, [r7, #15]
   26598:	701a      	strb	r2, [r3, #0]
    *p_offset                 += AD_TYPE_TX_POWER_LEVEL_DATA_SIZE;
   2659a:	687b      	ldr	r3, [r7, #4]
   2659c:	881b      	ldrh	r3, [r3, #0]
   2659e:	3301      	adds	r3, #1
   265a0:	b29a      	uxth	r2, r3
   265a2:	687b      	ldr	r3, [r7, #4]
   265a4:	801a      	strh	r2, [r3, #0]

    return NRF_SUCCESS;
   265a6:	2300      	movs	r3, #0
}
   265a8:	4618      	mov	r0, r3
   265aa:	3714      	adds	r7, #20
   265ac:	46bd      	mov	sp, r7
   265ae:	bc80      	pop	{r7}
   265b0:	4770      	bx	lr

000265b2 <uuid_list_sized_encode>:
                                       uint8_t                         adv_type,
                                       uint8_t                         uuid_size,
                                       uint8_t                       * p_encoded_data,
                                       uint16_t                      * p_offset,
                                       uint16_t                        max_size)
{
   265b2:	b580      	push	{r7, lr}
   265b4:	b08a      	sub	sp, #40	; 0x28
   265b6:	af00      	add	r7, sp, #0
   265b8:	60f8      	str	r0, [r7, #12]
   265ba:	607b      	str	r3, [r7, #4]
   265bc:	460b      	mov	r3, r1
   265be:	72fb      	strb	r3, [r7, #11]
   265c0:	4613      	mov	r3, r2
   265c2:	72bb      	strb	r3, [r7, #10]
    int      i;
    bool     is_heading_written = false;
   265c4:	2300      	movs	r3, #0
   265c6:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    uint16_t start_pos          = *p_offset;
   265ca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   265cc:	881b      	ldrh	r3, [r3, #0]
   265ce:	843b      	strh	r3, [r7, #32]
    uint16_t length;

    for (i = 0; i < p_uuid_list->uuid_cnt; i++)
   265d0:	2300      	movs	r3, #0
   265d2:	627b      	str	r3, [r7, #36]	; 0x24
   265d4:	e068      	b.n	266a8 <uuid_list_sized_encode+0xf6>
    {
        uint32_t   err_code;
        uint8_t    encoded_size;
        ble_uuid_t uuid = p_uuid_list->p_uuids[i];
   265d6:	68fb      	ldr	r3, [r7, #12]
   265d8:	685a      	ldr	r2, [r3, #4]
   265da:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   265dc:	009b      	lsls	r3, r3, #2
   265de:	441a      	add	r2, r3
   265e0:	f107 0310 	add.w	r3, r7, #16
   265e4:	6810      	ldr	r0, [r2, #0]
   265e6:	6018      	str	r0, [r3, #0]

        // Find encoded uuid size.
        err_code = sd_ble_uuid_encode(&uuid, &encoded_size, NULL);
   265e8:	f107 0116 	add.w	r1, r7, #22
   265ec:	f107 0310 	add.w	r3, r7, #16
   265f0:	2200      	movs	r2, #0
   265f2:	4618      	mov	r0, r3
   265f4:	f7ff fe04 	bl	26200 <sd_ble_uuid_encode>
   265f8:	61b8      	str	r0, [r7, #24]
        VERIFY_SUCCESS(err_code);
   265fa:	69bb      	ldr	r3, [r7, #24]
   265fc:	2b00      	cmp	r3, #0
   265fe:	d001      	beq.n	26604 <uuid_list_sized_encode+0x52>
   26600:	69bb      	ldr	r3, [r7, #24]
   26602:	e06e      	b.n	266e2 <uuid_list_sized_encode+0x130>

        // Check size.
        if (encoded_size == uuid_size)
   26604:	7dbb      	ldrb	r3, [r7, #22]
   26606:	7aba      	ldrb	r2, [r7, #10]
   26608:	429a      	cmp	r2, r3
   2660a:	d14a      	bne.n	266a2 <uuid_list_sized_encode+0xf0>
        {
            uint8_t heading_bytes = (is_heading_written) ? 0 : AD_DATA_OFFSET;
   2660c:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   26610:	2b00      	cmp	r3, #0
   26612:	d001      	beq.n	26618 <uuid_list_sized_encode+0x66>
   26614:	2300      	movs	r3, #0
   26616:	e000      	b.n	2661a <uuid_list_sized_encode+0x68>
   26618:	2302      	movs	r3, #2
   2661a:	75fb      	strb	r3, [r7, #23]

            // Check for buffer overflow
            if (((*p_offset) + encoded_size + heading_bytes) > max_size)
   2661c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   2661e:	881b      	ldrh	r3, [r3, #0]
   26620:	461a      	mov	r2, r3
   26622:	7dbb      	ldrb	r3, [r7, #22]
   26624:	441a      	add	r2, r3
   26626:	7dfb      	ldrb	r3, [r7, #23]
   26628:	441a      	add	r2, r3
   2662a:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
   2662c:	429a      	cmp	r2, r3
   2662e:	dd01      	ble.n	26634 <uuid_list_sized_encode+0x82>
            {
                return NRF_ERROR_DATA_SIZE;
   26630:	230c      	movs	r3, #12
   26632:	e056      	b.n	266e2 <uuid_list_sized_encode+0x130>
            }

            if (!is_heading_written)
   26634:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   26638:	f083 0301 	eor.w	r3, r3, #1
   2663c:	b2db      	uxtb	r3, r3
   2663e:	2b00      	cmp	r3, #0
   26640:	d015      	beq.n	2666e <uuid_list_sized_encode+0xbc>
            {
                // Write AD structure heading.
                *p_offset                 += AD_LENGTH_FIELD_SIZE;
   26642:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   26644:	881b      	ldrh	r3, [r3, #0]
   26646:	3301      	adds	r3, #1
   26648:	b29a      	uxth	r2, r3
   2664a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   2664c:	801a      	strh	r2, [r3, #0]
                p_encoded_data[*p_offset]  = adv_type;
   2664e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   26650:	881b      	ldrh	r3, [r3, #0]
   26652:	461a      	mov	r2, r3
   26654:	687b      	ldr	r3, [r7, #4]
   26656:	4413      	add	r3, r2
   26658:	7afa      	ldrb	r2, [r7, #11]
   2665a:	701a      	strb	r2, [r3, #0]
                *p_offset                 += AD_TYPE_FIELD_SIZE;
   2665c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   2665e:	881b      	ldrh	r3, [r3, #0]
   26660:	3301      	adds	r3, #1
   26662:	b29a      	uxth	r2, r3
   26664:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   26666:	801a      	strh	r2, [r3, #0]
                is_heading_written         = true;
   26668:	2301      	movs	r3, #1
   2666a:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
            }

            // Write UUID.
            err_code = sd_ble_uuid_encode(&uuid, &encoded_size, &p_encoded_data[*p_offset]);
   2666e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   26670:	881b      	ldrh	r3, [r3, #0]
   26672:	461a      	mov	r2, r3
   26674:	687b      	ldr	r3, [r7, #4]
   26676:	441a      	add	r2, r3
   26678:	f107 0116 	add.w	r1, r7, #22
   2667c:	f107 0310 	add.w	r3, r7, #16
   26680:	4618      	mov	r0, r3
   26682:	f7ff fdbd 	bl	26200 <sd_ble_uuid_encode>
   26686:	61b8      	str	r0, [r7, #24]
            VERIFY_SUCCESS(err_code);
   26688:	69bb      	ldr	r3, [r7, #24]
   2668a:	2b00      	cmp	r3, #0
   2668c:	d001      	beq.n	26692 <uuid_list_sized_encode+0xe0>
   2668e:	69bb      	ldr	r3, [r7, #24]
   26690:	e027      	b.n	266e2 <uuid_list_sized_encode+0x130>
            *p_offset += encoded_size;
   26692:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   26694:	881a      	ldrh	r2, [r3, #0]
   26696:	7dbb      	ldrb	r3, [r7, #22]
   26698:	b29b      	uxth	r3, r3
   2669a:	4413      	add	r3, r2
   2669c:	b29a      	uxth	r2, r3
   2669e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   266a0:	801a      	strh	r2, [r3, #0]
    for (i = 0; i < p_uuid_list->uuid_cnt; i++)
   266a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   266a4:	3301      	adds	r3, #1
   266a6:	627b      	str	r3, [r7, #36]	; 0x24
   266a8:	68fb      	ldr	r3, [r7, #12]
   266aa:	881b      	ldrh	r3, [r3, #0]
   266ac:	461a      	mov	r2, r3
   266ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   266b0:	4293      	cmp	r3, r2
   266b2:	db90      	blt.n	265d6 <uuid_list_sized_encode+0x24>
        }
    }

    if (is_heading_written)
   266b4:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   266b8:	2b00      	cmp	r3, #0
   266ba:	d011      	beq.n	266e0 <uuid_list_sized_encode+0x12e>
    {
        // Write length.
        length = (*p_offset) - (start_pos + AD_LENGTH_FIELD_SIZE);
   266bc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   266be:	881a      	ldrh	r2, [r3, #0]
   266c0:	8c3b      	ldrh	r3, [r7, #32]
   266c2:	1ad3      	subs	r3, r2, r3
   266c4:	b29b      	uxth	r3, r3
   266c6:	3b01      	subs	r3, #1
   266c8:	83fb      	strh	r3, [r7, #30]
        // There is only 1 byte intended to encode length
        if (length > 0x00FF)
   266ca:	8bfb      	ldrh	r3, [r7, #30]
   266cc:	2bff      	cmp	r3, #255	; 0xff
   266ce:	d901      	bls.n	266d4 <uuid_list_sized_encode+0x122>
        {
            return NRF_ERROR_DATA_SIZE;
   266d0:	230c      	movs	r3, #12
   266d2:	e006      	b.n	266e2 <uuid_list_sized_encode+0x130>
        }
        p_encoded_data[start_pos] = (uint8_t)length;
   266d4:	8c3b      	ldrh	r3, [r7, #32]
   266d6:	687a      	ldr	r2, [r7, #4]
   266d8:	4413      	add	r3, r2
   266da:	8bfa      	ldrh	r2, [r7, #30]
   266dc:	b2d2      	uxtb	r2, r2
   266de:	701a      	strb	r2, [r3, #0]
    }

    return NRF_SUCCESS;
   266e0:	2300      	movs	r3, #0
}
   266e2:	4618      	mov	r0, r3
   266e4:	3728      	adds	r7, #40	; 0x28
   266e6:	46bd      	mov	sp, r7
   266e8:	bd80      	pop	{r7, pc}

000266ea <uuid_list_encode>:
                                 uint8_t                         adv_type_16,
                                 uint8_t                         adv_type_128,
                                 uint8_t                       * p_encoded_data,
                                 uint16_t                      * p_offset,
                                 uint16_t                        max_size)
{
   266ea:	b580      	push	{r7, lr}
   266ec:	b088      	sub	sp, #32
   266ee:	af02      	add	r7, sp, #8
   266f0:	60f8      	str	r0, [r7, #12]
   266f2:	607b      	str	r3, [r7, #4]
   266f4:	460b      	mov	r3, r1
   266f6:	72fb      	strb	r3, [r7, #11]
   266f8:	4613      	mov	r3, r2
   266fa:	72bb      	strb	r3, [r7, #10]
    uint32_t err_code;

    // Encode 16 bit UUIDs.
    err_code = uuid_list_sized_encode(p_uuid_list,
   266fc:	7af9      	ldrb	r1, [r7, #11]
   266fe:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   26700:	9301      	str	r3, [sp, #4]
   26702:	6a3b      	ldr	r3, [r7, #32]
   26704:	9300      	str	r3, [sp, #0]
   26706:	687b      	ldr	r3, [r7, #4]
   26708:	2202      	movs	r2, #2
   2670a:	68f8      	ldr	r0, [r7, #12]
   2670c:	f7ff ff51 	bl	265b2 <uuid_list_sized_encode>
   26710:	6178      	str	r0, [r7, #20]
                                      adv_type_16,
                                      sizeof(uint16_le_t),
                                      p_encoded_data,
                                      p_offset,
                                      max_size);
    VERIFY_SUCCESS(err_code);
   26712:	697b      	ldr	r3, [r7, #20]
   26714:	2b00      	cmp	r3, #0
   26716:	d001      	beq.n	2671c <uuid_list_encode+0x32>
   26718:	697b      	ldr	r3, [r7, #20]
   2671a:	e010      	b.n	2673e <uuid_list_encode+0x54>

    // Encode 128 bit UUIDs.
    err_code = uuid_list_sized_encode(p_uuid_list,
   2671c:	7ab9      	ldrb	r1, [r7, #10]
   2671e:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   26720:	9301      	str	r3, [sp, #4]
   26722:	6a3b      	ldr	r3, [r7, #32]
   26724:	9300      	str	r3, [sp, #0]
   26726:	687b      	ldr	r3, [r7, #4]
   26728:	2210      	movs	r2, #16
   2672a:	68f8      	ldr	r0, [r7, #12]
   2672c:	f7ff ff41 	bl	265b2 <uuid_list_sized_encode>
   26730:	6178      	str	r0, [r7, #20]
                                      adv_type_128,
                                      sizeof(ble_uuid128_t),
                                      p_encoded_data,
                                      p_offset,
                                      max_size);
    VERIFY_SUCCESS(err_code);
   26732:	697b      	ldr	r3, [r7, #20]
   26734:	2b00      	cmp	r3, #0
   26736:	d001      	beq.n	2673c <uuid_list_encode+0x52>
   26738:	697b      	ldr	r3, [r7, #20]
   2673a:	e000      	b.n	2673e <uuid_list_encode+0x54>

    return NRF_SUCCESS;
   2673c:	2300      	movs	r3, #0
}
   2673e:	4618      	mov	r0, r3
   26740:	3718      	adds	r7, #24
   26742:	46bd      	mov	sp, r7
   26744:	bd80      	pop	{r7, pc}

00026746 <conn_int_check>:


static uint32_t conn_int_check(const ble_advdata_conn_int_t *p_conn_int)
{
   26746:	b480      	push	{r7}
   26748:	b083      	sub	sp, #12
   2674a:	af00      	add	r7, sp, #0
   2674c:	6078      	str	r0, [r7, #4]
    // Check Minimum Connection Interval.
    if ((p_conn_int->min_conn_interval < 0x0006) ||
   2674e:	687b      	ldr	r3, [r7, #4]
   26750:	881b      	ldrh	r3, [r3, #0]
   26752:	2b05      	cmp	r3, #5
   26754:	d90a      	bls.n	2676c <conn_int_check+0x26>
        (
            (p_conn_int->min_conn_interval > 0x0c80) &&
   26756:	687b      	ldr	r3, [r7, #4]
   26758:	881b      	ldrh	r3, [r3, #0]
    if ((p_conn_int->min_conn_interval < 0x0006) ||
   2675a:	f5b3 6f48 	cmp.w	r3, #3200	; 0xc80
   2675e:	d907      	bls.n	26770 <conn_int_check+0x2a>
            (p_conn_int->min_conn_interval != 0xffff)
   26760:	687b      	ldr	r3, [r7, #4]
   26762:	881b      	ldrh	r3, [r3, #0]
            (p_conn_int->min_conn_interval > 0x0c80) &&
   26764:	f64f 72ff 	movw	r2, #65535	; 0xffff
   26768:	4293      	cmp	r3, r2
   2676a:	d001      	beq.n	26770 <conn_int_check+0x2a>
        )
       )
    {
        return NRF_ERROR_INVALID_PARAM;
   2676c:	2307      	movs	r3, #7
   2676e:	e025      	b.n	267bc <conn_int_check+0x76>
    }

    // Check Maximum Connection Interval.
    if ((p_conn_int->max_conn_interval < 0x0006) ||
   26770:	687b      	ldr	r3, [r7, #4]
   26772:	885b      	ldrh	r3, [r3, #2]
   26774:	2b05      	cmp	r3, #5
   26776:	d90a      	bls.n	2678e <conn_int_check+0x48>
        (
            (p_conn_int->max_conn_interval > 0x0c80) &&
   26778:	687b      	ldr	r3, [r7, #4]
   2677a:	885b      	ldrh	r3, [r3, #2]
    if ((p_conn_int->max_conn_interval < 0x0006) ||
   2677c:	f5b3 6f48 	cmp.w	r3, #3200	; 0xc80
   26780:	d907      	bls.n	26792 <conn_int_check+0x4c>
            (p_conn_int->max_conn_interval != 0xffff)
   26782:	687b      	ldr	r3, [r7, #4]
   26784:	885b      	ldrh	r3, [r3, #2]
            (p_conn_int->max_conn_interval > 0x0c80) &&
   26786:	f64f 72ff 	movw	r2, #65535	; 0xffff
   2678a:	4293      	cmp	r3, r2
   2678c:	d001      	beq.n	26792 <conn_int_check+0x4c>
        )
       )
    {
        return NRF_ERROR_INVALID_PARAM;
   2678e:	2307      	movs	r3, #7
   26790:	e014      	b.n	267bc <conn_int_check+0x76>
    }

    // Make sure Minimum Connection Interval is not bigger than Maximum Connection Interval.
    if ((p_conn_int->min_conn_interval != 0xffff) &&
   26792:	687b      	ldr	r3, [r7, #4]
   26794:	881b      	ldrh	r3, [r3, #0]
   26796:	f64f 72ff 	movw	r2, #65535	; 0xffff
   2679a:	4293      	cmp	r3, r2
   2679c:	d00d      	beq.n	267ba <conn_int_check+0x74>
        (p_conn_int->max_conn_interval != 0xffff) &&
   2679e:	687b      	ldr	r3, [r7, #4]
   267a0:	885b      	ldrh	r3, [r3, #2]
    if ((p_conn_int->min_conn_interval != 0xffff) &&
   267a2:	f64f 72ff 	movw	r2, #65535	; 0xffff
   267a6:	4293      	cmp	r3, r2
   267a8:	d007      	beq.n	267ba <conn_int_check+0x74>
        (p_conn_int->min_conn_interval > p_conn_int->max_conn_interval)
   267aa:	687b      	ldr	r3, [r7, #4]
   267ac:	881a      	ldrh	r2, [r3, #0]
   267ae:	687b      	ldr	r3, [r7, #4]
   267b0:	885b      	ldrh	r3, [r3, #2]
        (p_conn_int->max_conn_interval != 0xffff) &&
   267b2:	429a      	cmp	r2, r3
   267b4:	d901      	bls.n	267ba <conn_int_check+0x74>
        )
    {
        return NRF_ERROR_INVALID_PARAM;
   267b6:	2307      	movs	r3, #7
   267b8:	e000      	b.n	267bc <conn_int_check+0x76>
    }

    return NRF_SUCCESS;
   267ba:	2300      	movs	r3, #0
}
   267bc:	4618      	mov	r0, r3
   267be:	370c      	adds	r7, #12
   267c0:	46bd      	mov	sp, r7
   267c2:	bc80      	pop	{r7}
   267c4:	4770      	bx	lr

000267c6 <conn_int_encode>:

static uint32_t conn_int_encode(const ble_advdata_conn_int_t * p_conn_int,
                                uint8_t                      * p_encoded_data,
                                uint16_t                     * p_offset,
                                uint16_t                       max_size)
{
   267c6:	b580      	push	{r7, lr}
   267c8:	b086      	sub	sp, #24
   267ca:	af00      	add	r7, sp, #0
   267cc:	60f8      	str	r0, [r7, #12]
   267ce:	60b9      	str	r1, [r7, #8]
   267d0:	607a      	str	r2, [r7, #4]
   267d2:	807b      	strh	r3, [r7, #2]
    uint32_t err_code;

    // Check for buffer overflow.
    if (((*p_offset) + AD_TYPE_CONN_INT_SIZE) > max_size)
   267d4:	687b      	ldr	r3, [r7, #4]
   267d6:	881b      	ldrh	r3, [r3, #0]
   267d8:	1d9a      	adds	r2, r3, #6
   267da:	887b      	ldrh	r3, [r7, #2]
   267dc:	429a      	cmp	r2, r3
   267de:	d901      	bls.n	267e4 <conn_int_encode+0x1e>
    {
        return NRF_ERROR_DATA_SIZE;
   267e0:	230c      	movs	r3, #12
   267e2:	e04b      	b.n	2687c <conn_int_encode+0xb6>
    }

    // Check parameters.
    err_code = conn_int_check(p_conn_int);
   267e4:	68f8      	ldr	r0, [r7, #12]
   267e6:	f7ff ffae 	bl	26746 <conn_int_check>
   267ea:	6178      	str	r0, [r7, #20]
    VERIFY_SUCCESS(err_code);
   267ec:	697b      	ldr	r3, [r7, #20]
   267ee:	2b00      	cmp	r3, #0
   267f0:	d001      	beq.n	267f6 <conn_int_encode+0x30>
   267f2:	697b      	ldr	r3, [r7, #20]
   267f4:	e042      	b.n	2687c <conn_int_encode+0xb6>

    // Encode Length and AD Type.
    p_encoded_data[*p_offset]  = (uint8_t)(AD_TYPE_FIELD_SIZE + AD_TYPE_CONN_INT_DATA_SIZE);
   267f6:	687b      	ldr	r3, [r7, #4]
   267f8:	881b      	ldrh	r3, [r3, #0]
   267fa:	461a      	mov	r2, r3
   267fc:	68bb      	ldr	r3, [r7, #8]
   267fe:	4413      	add	r3, r2
   26800:	2205      	movs	r2, #5
   26802:	701a      	strb	r2, [r3, #0]
    *p_offset                 += AD_LENGTH_FIELD_SIZE;
   26804:	687b      	ldr	r3, [r7, #4]
   26806:	881b      	ldrh	r3, [r3, #0]
   26808:	3301      	adds	r3, #1
   2680a:	b29a      	uxth	r2, r3
   2680c:	687b      	ldr	r3, [r7, #4]
   2680e:	801a      	strh	r2, [r3, #0]
    p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_SLAVE_CONNECTION_INTERVAL_RANGE;
   26810:	687b      	ldr	r3, [r7, #4]
   26812:	881b      	ldrh	r3, [r3, #0]
   26814:	461a      	mov	r2, r3
   26816:	68bb      	ldr	r3, [r7, #8]
   26818:	4413      	add	r3, r2
   2681a:	2212      	movs	r2, #18
   2681c:	701a      	strb	r2, [r3, #0]
    *p_offset                 += AD_TYPE_FIELD_SIZE;
   2681e:	687b      	ldr	r3, [r7, #4]
   26820:	881b      	ldrh	r3, [r3, #0]
   26822:	3301      	adds	r3, #1
   26824:	b29a      	uxth	r2, r3
   26826:	687b      	ldr	r3, [r7, #4]
   26828:	801a      	strh	r2, [r3, #0]

    // Encode Minimum and Maximum Connection Intervals.
    *p_offset += uint16_encode(p_conn_int->min_conn_interval, &p_encoded_data[*p_offset]);
   2682a:	68fb      	ldr	r3, [r7, #12]
   2682c:	881a      	ldrh	r2, [r3, #0]
   2682e:	687b      	ldr	r3, [r7, #4]
   26830:	881b      	ldrh	r3, [r3, #0]
   26832:	4619      	mov	r1, r3
   26834:	68bb      	ldr	r3, [r7, #8]
   26836:	440b      	add	r3, r1
   26838:	4619      	mov	r1, r3
   2683a:	4610      	mov	r0, r2
   2683c:	f7ff fce4 	bl	26208 <uint16_encode>
   26840:	4603      	mov	r3, r0
   26842:	4619      	mov	r1, r3
   26844:	687b      	ldr	r3, [r7, #4]
   26846:	881a      	ldrh	r2, [r3, #0]
   26848:	b28b      	uxth	r3, r1
   2684a:	4413      	add	r3, r2
   2684c:	b29a      	uxth	r2, r3
   2684e:	687b      	ldr	r3, [r7, #4]
   26850:	801a      	strh	r2, [r3, #0]
    *p_offset += uint16_encode(p_conn_int->max_conn_interval, &p_encoded_data[*p_offset]);
   26852:	68fb      	ldr	r3, [r7, #12]
   26854:	885a      	ldrh	r2, [r3, #2]
   26856:	687b      	ldr	r3, [r7, #4]
   26858:	881b      	ldrh	r3, [r3, #0]
   2685a:	4619      	mov	r1, r3
   2685c:	68bb      	ldr	r3, [r7, #8]
   2685e:	440b      	add	r3, r1
   26860:	4619      	mov	r1, r3
   26862:	4610      	mov	r0, r2
   26864:	f7ff fcd0 	bl	26208 <uint16_encode>
   26868:	4603      	mov	r3, r0
   2686a:	4619      	mov	r1, r3
   2686c:	687b      	ldr	r3, [r7, #4]
   2686e:	881a      	ldrh	r2, [r3, #0]
   26870:	b28b      	uxth	r3, r1
   26872:	4413      	add	r3, r2
   26874:	b29a      	uxth	r2, r3
   26876:	687b      	ldr	r3, [r7, #4]
   26878:	801a      	strh	r2, [r3, #0]

    return NRF_SUCCESS;
   2687a:	2300      	movs	r3, #0
}
   2687c:	4618      	mov	r0, r3
   2687e:	3718      	adds	r7, #24
   26880:	46bd      	mov	sp, r7
   26882:	bd80      	pop	{r7, pc}

00026884 <manuf_specific_data_encode>:

static uint32_t manuf_specific_data_encode(const ble_advdata_manuf_data_t * p_manuf_sp_data,
                                           uint8_t                        * p_encoded_data,
                                           uint16_t                       * p_offset,
                                           uint16_t                         max_size)
{
   26884:	b580      	push	{r7, lr}
   26886:	b086      	sub	sp, #24
   26888:	af00      	add	r7, sp, #0
   2688a:	60f8      	str	r0, [r7, #12]
   2688c:	60b9      	str	r1, [r7, #8]
   2688e:	607a      	str	r2, [r7, #4]
   26890:	807b      	strh	r3, [r7, #2]
    uint32_t data_size = AD_TYPE_MANUF_SPEC_DATA_ID_SIZE + p_manuf_sp_data->data.size;
   26892:	68fb      	ldr	r3, [r7, #12]
   26894:	889b      	ldrh	r3, [r3, #4]
   26896:	3302      	adds	r3, #2
   26898:	617b      	str	r3, [r7, #20]

    // Check for buffer overflow.
    if (((*p_offset) + AD_DATA_OFFSET + data_size) > max_size)
   2689a:	687b      	ldr	r3, [r7, #4]
   2689c:	881b      	ldrh	r3, [r3, #0]
   2689e:	461a      	mov	r2, r3
   268a0:	697b      	ldr	r3, [r7, #20]
   268a2:	4413      	add	r3, r2
   268a4:	1c9a      	adds	r2, r3, #2
   268a6:	887b      	ldrh	r3, [r7, #2]
   268a8:	429a      	cmp	r2, r3
   268aa:	d901      	bls.n	268b0 <manuf_specific_data_encode+0x2c>
    {
        return NRF_ERROR_DATA_SIZE;
   268ac:	230c      	movs	r3, #12
   268ae:	e054      	b.n	2695a <manuf_specific_data_encode+0xd6>
    }

    // There is only 1 byte intended to encode length which is (data_size + AD_TYPE_FIELD_SIZE)
    if (data_size > (0x00FF - AD_TYPE_FIELD_SIZE))
   268b0:	697b      	ldr	r3, [r7, #20]
   268b2:	2bfe      	cmp	r3, #254	; 0xfe
   268b4:	d901      	bls.n	268ba <manuf_specific_data_encode+0x36>
    {
        return NRF_ERROR_DATA_SIZE;
   268b6:	230c      	movs	r3, #12
   268b8:	e04f      	b.n	2695a <manuf_specific_data_encode+0xd6>
    }

    // Encode Length and AD Type.
    p_encoded_data[*p_offset]  = (uint8_t)(AD_TYPE_FIELD_SIZE + data_size);
   268ba:	697b      	ldr	r3, [r7, #20]
   268bc:	b2da      	uxtb	r2, r3
   268be:	687b      	ldr	r3, [r7, #4]
   268c0:	881b      	ldrh	r3, [r3, #0]
   268c2:	4619      	mov	r1, r3
   268c4:	68bb      	ldr	r3, [r7, #8]
   268c6:	440b      	add	r3, r1
   268c8:	3201      	adds	r2, #1
   268ca:	b2d2      	uxtb	r2, r2
   268cc:	701a      	strb	r2, [r3, #0]
    *p_offset                 += AD_LENGTH_FIELD_SIZE;
   268ce:	687b      	ldr	r3, [r7, #4]
   268d0:	881b      	ldrh	r3, [r3, #0]
   268d2:	3301      	adds	r3, #1
   268d4:	b29a      	uxth	r2, r3
   268d6:	687b      	ldr	r3, [r7, #4]
   268d8:	801a      	strh	r2, [r3, #0]
    p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA;
   268da:	687b      	ldr	r3, [r7, #4]
   268dc:	881b      	ldrh	r3, [r3, #0]
   268de:	461a      	mov	r2, r3
   268e0:	68bb      	ldr	r3, [r7, #8]
   268e2:	4413      	add	r3, r2
   268e4:	22ff      	movs	r2, #255	; 0xff
   268e6:	701a      	strb	r2, [r3, #0]
    *p_offset                 += AD_TYPE_FIELD_SIZE;
   268e8:	687b      	ldr	r3, [r7, #4]
   268ea:	881b      	ldrh	r3, [r3, #0]
   268ec:	3301      	adds	r3, #1
   268ee:	b29a      	uxth	r2, r3
   268f0:	687b      	ldr	r3, [r7, #4]
   268f2:	801a      	strh	r2, [r3, #0]

    // Encode Company Identifier.
    *p_offset += uint16_encode(p_manuf_sp_data->company_identifier, &p_encoded_data[*p_offset]);
   268f4:	68fb      	ldr	r3, [r7, #12]
   268f6:	881a      	ldrh	r2, [r3, #0]
   268f8:	687b      	ldr	r3, [r7, #4]
   268fa:	881b      	ldrh	r3, [r3, #0]
   268fc:	4619      	mov	r1, r3
   268fe:	68bb      	ldr	r3, [r7, #8]
   26900:	440b      	add	r3, r1
   26902:	4619      	mov	r1, r3
   26904:	4610      	mov	r0, r2
   26906:	f7ff fc7f 	bl	26208 <uint16_encode>
   2690a:	4603      	mov	r3, r0
   2690c:	4619      	mov	r1, r3
   2690e:	687b      	ldr	r3, [r7, #4]
   26910:	881a      	ldrh	r2, [r3, #0]
   26912:	b28b      	uxth	r3, r1
   26914:	4413      	add	r3, r2
   26916:	b29a      	uxth	r2, r3
   26918:	687b      	ldr	r3, [r7, #4]
   2691a:	801a      	strh	r2, [r3, #0]

    // Encode additional manufacturer specific data.
    if (p_manuf_sp_data->data.size > 0)
   2691c:	68fb      	ldr	r3, [r7, #12]
   2691e:	889b      	ldrh	r3, [r3, #4]
   26920:	2b00      	cmp	r3, #0
   26922:	d019      	beq.n	26958 <manuf_specific_data_encode+0xd4>
    {
        if (p_manuf_sp_data->data.p_data == NULL)
   26924:	68fb      	ldr	r3, [r7, #12]
   26926:	689b      	ldr	r3, [r3, #8]
   26928:	2b00      	cmp	r3, #0
   2692a:	d101      	bne.n	26930 <manuf_specific_data_encode+0xac>
        {
            return NRF_ERROR_INVALID_PARAM;
   2692c:	2307      	movs	r3, #7
   2692e:	e014      	b.n	2695a <manuf_specific_data_encode+0xd6>
        }
        memcpy(&p_encoded_data[*p_offset], p_manuf_sp_data->data.p_data, p_manuf_sp_data->data.size);
   26930:	687b      	ldr	r3, [r7, #4]
   26932:	881b      	ldrh	r3, [r3, #0]
   26934:	461a      	mov	r2, r3
   26936:	68bb      	ldr	r3, [r7, #8]
   26938:	1898      	adds	r0, r3, r2
   2693a:	68fb      	ldr	r3, [r7, #12]
   2693c:	6899      	ldr	r1, [r3, #8]
   2693e:	68fb      	ldr	r3, [r7, #12]
   26940:	889b      	ldrh	r3, [r3, #4]
   26942:	461a      	mov	r2, r3
   26944:	f004 fcd4 	bl	2b2f0 <memcpy>
        *p_offset += p_manuf_sp_data->data.size;
   26948:	687b      	ldr	r3, [r7, #4]
   2694a:	881a      	ldrh	r2, [r3, #0]
   2694c:	68fb      	ldr	r3, [r7, #12]
   2694e:	889b      	ldrh	r3, [r3, #4]
   26950:	4413      	add	r3, r2
   26952:	b29a      	uxth	r2, r3
   26954:	687b      	ldr	r3, [r7, #4]
   26956:	801a      	strh	r2, [r3, #0]
    }

    return NRF_SUCCESS;
   26958:	2300      	movs	r3, #0
}
   2695a:	4618      	mov	r0, r3
   2695c:	3718      	adds	r7, #24
   2695e:	46bd      	mov	sp, r7
   26960:	bd80      	pop	{r7, pc}

00026962 <service_data_encode>:
// Implemented only for 16-bit UUIDs
static uint32_t service_data_encode(const ble_advdata_t * p_advdata,
                                    uint8_t             * p_encoded_data,
                                    uint16_t            * p_offset,
                                    uint16_t              max_size)
{
   26962:	b580      	push	{r7, lr}
   26964:	b088      	sub	sp, #32
   26966:	af00      	add	r7, sp, #0
   26968:	60f8      	str	r0, [r7, #12]
   2696a:	60b9      	str	r1, [r7, #8]
   2696c:	607a      	str	r2, [r7, #4]
   2696e:	807b      	strh	r3, [r7, #2]
    uint8_t i;

    // Check parameter consistency.
    if (p_advdata->p_service_data_array == NULL)
   26970:	68fb      	ldr	r3, [r7, #12]
   26972:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   26974:	2b00      	cmp	r3, #0
   26976:	d101      	bne.n	2697c <service_data_encode+0x1a>
    {
        return NRF_ERROR_INVALID_PARAM;
   26978:	2307      	movs	r3, #7
   2697a:	e06d      	b.n	26a58 <service_data_encode+0xf6>
    }

    for (i = 0; i < p_advdata->service_data_count; i++)
   2697c:	2300      	movs	r3, #0
   2697e:	77fb      	strb	r3, [r7, #31]
   26980:	e063      	b.n	26a4a <service_data_encode+0xe8>
    {
        ble_advdata_service_data_t * p_service_data;
        uint32_t                     data_size;

        p_service_data = &p_advdata->p_service_data_array[i];
   26982:	68fb      	ldr	r3, [r7, #12]
   26984:	6a99      	ldr	r1, [r3, #40]	; 0x28
   26986:	7ffa      	ldrb	r2, [r7, #31]
   26988:	4613      	mov	r3, r2
   2698a:	005b      	lsls	r3, r3, #1
   2698c:	4413      	add	r3, r2
   2698e:	009b      	lsls	r3, r3, #2
   26990:	440b      	add	r3, r1
   26992:	61bb      	str	r3, [r7, #24]
        // For now implemented only for 16-bit UUIDs
        data_size      = AD_TYPE_SERV_DATA_16BIT_UUID_SIZE + p_service_data->data.size;
   26994:	69bb      	ldr	r3, [r7, #24]
   26996:	889b      	ldrh	r3, [r3, #4]
   26998:	3302      	adds	r3, #2
   2699a:	617b      	str	r3, [r7, #20]

        // There is only 1 byte intended to encode length which is (data_size + AD_TYPE_FIELD_SIZE)
        if (data_size > (0x00FF - AD_TYPE_FIELD_SIZE))
   2699c:	697b      	ldr	r3, [r7, #20]
   2699e:	2bfe      	cmp	r3, #254	; 0xfe
   269a0:	d901      	bls.n	269a6 <service_data_encode+0x44>
        {
            return NRF_ERROR_DATA_SIZE;
   269a2:	230c      	movs	r3, #12
   269a4:	e058      	b.n	26a58 <service_data_encode+0xf6>
        }

        // Encode Length and AD Type.
        p_encoded_data[*p_offset]  = (uint8_t)(AD_TYPE_FIELD_SIZE + data_size);
   269a6:	697b      	ldr	r3, [r7, #20]
   269a8:	b2da      	uxtb	r2, r3
   269aa:	687b      	ldr	r3, [r7, #4]
   269ac:	881b      	ldrh	r3, [r3, #0]
   269ae:	4619      	mov	r1, r3
   269b0:	68bb      	ldr	r3, [r7, #8]
   269b2:	440b      	add	r3, r1
   269b4:	3201      	adds	r2, #1
   269b6:	b2d2      	uxtb	r2, r2
   269b8:	701a      	strb	r2, [r3, #0]
        *p_offset                 += AD_LENGTH_FIELD_SIZE;
   269ba:	687b      	ldr	r3, [r7, #4]
   269bc:	881b      	ldrh	r3, [r3, #0]
   269be:	3301      	adds	r3, #1
   269c0:	b29a      	uxth	r2, r3
   269c2:	687b      	ldr	r3, [r7, #4]
   269c4:	801a      	strh	r2, [r3, #0]
        p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_SERVICE_DATA;
   269c6:	687b      	ldr	r3, [r7, #4]
   269c8:	881b      	ldrh	r3, [r3, #0]
   269ca:	461a      	mov	r2, r3
   269cc:	68bb      	ldr	r3, [r7, #8]
   269ce:	4413      	add	r3, r2
   269d0:	2216      	movs	r2, #22
   269d2:	701a      	strb	r2, [r3, #0]
        *p_offset                 += AD_TYPE_FIELD_SIZE;
   269d4:	687b      	ldr	r3, [r7, #4]
   269d6:	881b      	ldrh	r3, [r3, #0]
   269d8:	3301      	adds	r3, #1
   269da:	b29a      	uxth	r2, r3
   269dc:	687b      	ldr	r3, [r7, #4]
   269de:	801a      	strh	r2, [r3, #0]

        // Encode service 16-bit UUID.
        *p_offset += uint16_encode(p_service_data->service_uuid, &p_encoded_data[*p_offset]);
   269e0:	69bb      	ldr	r3, [r7, #24]
   269e2:	881a      	ldrh	r2, [r3, #0]
   269e4:	687b      	ldr	r3, [r7, #4]
   269e6:	881b      	ldrh	r3, [r3, #0]
   269e8:	4619      	mov	r1, r3
   269ea:	68bb      	ldr	r3, [r7, #8]
   269ec:	440b      	add	r3, r1
   269ee:	4619      	mov	r1, r3
   269f0:	4610      	mov	r0, r2
   269f2:	f7ff fc09 	bl	26208 <uint16_encode>
   269f6:	4603      	mov	r3, r0
   269f8:	4619      	mov	r1, r3
   269fa:	687b      	ldr	r3, [r7, #4]
   269fc:	881a      	ldrh	r2, [r3, #0]
   269fe:	b28b      	uxth	r3, r1
   26a00:	4413      	add	r3, r2
   26a02:	b29a      	uxth	r2, r3
   26a04:	687b      	ldr	r3, [r7, #4]
   26a06:	801a      	strh	r2, [r3, #0]

        // Encode additional service data.
        if (p_service_data->data.size > 0)
   26a08:	69bb      	ldr	r3, [r7, #24]
   26a0a:	889b      	ldrh	r3, [r3, #4]
   26a0c:	2b00      	cmp	r3, #0
   26a0e:	d019      	beq.n	26a44 <service_data_encode+0xe2>
        {
            if (p_service_data->data.p_data == NULL)
   26a10:	69bb      	ldr	r3, [r7, #24]
   26a12:	689b      	ldr	r3, [r3, #8]
   26a14:	2b00      	cmp	r3, #0
   26a16:	d101      	bne.n	26a1c <service_data_encode+0xba>
            {
                return NRF_ERROR_INVALID_PARAM;
   26a18:	2307      	movs	r3, #7
   26a1a:	e01d      	b.n	26a58 <service_data_encode+0xf6>
            }
            memcpy(&p_encoded_data[*p_offset], p_service_data->data.p_data, p_service_data->data.size);
   26a1c:	687b      	ldr	r3, [r7, #4]
   26a1e:	881b      	ldrh	r3, [r3, #0]
   26a20:	461a      	mov	r2, r3
   26a22:	68bb      	ldr	r3, [r7, #8]
   26a24:	1898      	adds	r0, r3, r2
   26a26:	69bb      	ldr	r3, [r7, #24]
   26a28:	6899      	ldr	r1, [r3, #8]
   26a2a:	69bb      	ldr	r3, [r7, #24]
   26a2c:	889b      	ldrh	r3, [r3, #4]
   26a2e:	461a      	mov	r2, r3
   26a30:	f004 fc5e 	bl	2b2f0 <memcpy>
            *p_offset += p_service_data->data.size;
   26a34:	687b      	ldr	r3, [r7, #4]
   26a36:	881a      	ldrh	r2, [r3, #0]
   26a38:	69bb      	ldr	r3, [r7, #24]
   26a3a:	889b      	ldrh	r3, [r3, #4]
   26a3c:	4413      	add	r3, r2
   26a3e:	b29a      	uxth	r2, r3
   26a40:	687b      	ldr	r3, [r7, #4]
   26a42:	801a      	strh	r2, [r3, #0]
    for (i = 0; i < p_advdata->service_data_count; i++)
   26a44:	7ffb      	ldrb	r3, [r7, #31]
   26a46:	3301      	adds	r3, #1
   26a48:	77fb      	strb	r3, [r7, #31]
   26a4a:	68fb      	ldr	r3, [r7, #12]
   26a4c:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
   26a50:	7ffa      	ldrb	r2, [r7, #31]
   26a52:	429a      	cmp	r2, r3
   26a54:	d395      	bcc.n	26982 <service_data_encode+0x20>
        }
    }

    return NRF_SUCCESS;
   26a56:	2300      	movs	r3, #0
}
   26a58:	4618      	mov	r0, r3
   26a5a:	3720      	adds	r7, #32
   26a5c:	46bd      	mov	sp, r7
   26a5e:	bd80      	pop	{r7, pc}

00026a60 <ble_advdata_encode>:

uint32_t ble_advdata_encode(ble_advdata_t const * const p_advdata,
                            uint8_t             * const p_encoded_data,
                            uint16_t            * const p_len)
{
   26a60:	b580      	push	{r7, lr}
   26a62:	b088      	sub	sp, #32
   26a64:	af02      	add	r7, sp, #8
   26a66:	60f8      	str	r0, [r7, #12]
   26a68:	60b9      	str	r1, [r7, #8]
   26a6a:	607a      	str	r2, [r7, #4]
    uint32_t err_code = NRF_SUCCESS;
   26a6c:	2300      	movs	r3, #0
   26a6e:	617b      	str	r3, [r7, #20]
    uint16_t max_size = *p_len;
   26a70:	687b      	ldr	r3, [r7, #4]
   26a72:	881b      	ldrh	r3, [r3, #0]
   26a74:	827b      	strh	r3, [r7, #18]
    *p_len = 0;
   26a76:	687b      	ldr	r3, [r7, #4]
   26a78:	2200      	movs	r2, #0
   26a7a:	801a      	strh	r2, [r3, #0]

    // Encode LE Bluetooth Device Address
    if (p_advdata->include_ble_device_addr)
   26a7c:	68fb      	ldr	r3, [r7, #12]
   26a7e:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
   26a82:	2b00      	cmp	r3, #0
   26a84:	d00b      	beq.n	26a9e <ble_advdata_encode+0x3e>
    {
        err_code = ble_device_addr_encode(p_encoded_data, p_len, max_size);
   26a86:	8a7b      	ldrh	r3, [r7, #18]
   26a88:	461a      	mov	r2, r3
   26a8a:	6879      	ldr	r1, [r7, #4]
   26a8c:	68b8      	ldr	r0, [r7, #8]
   26a8e:	f7ff fbd2 	bl	26236 <ble_device_addr_encode>
   26a92:	6178      	str	r0, [r7, #20]
        VERIFY_SUCCESS(err_code);
   26a94:	697b      	ldr	r3, [r7, #20]
   26a96:	2b00      	cmp	r3, #0
   26a98:	d001      	beq.n	26a9e <ble_advdata_encode+0x3e>
   26a9a:	697b      	ldr	r3, [r7, #20]
   26a9c:	e0ba      	b.n	26c14 <ble_advdata_encode+0x1b4>
    }

    // Encode appearance.
    if (p_advdata->include_appearance)
   26a9e:	68fb      	ldr	r3, [r7, #12]
   26aa0:	789b      	ldrb	r3, [r3, #2]
   26aa2:	2b00      	cmp	r3, #0
   26aa4:	d00b      	beq.n	26abe <ble_advdata_encode+0x5e>
    {
        err_code = appearance_encode(p_encoded_data, p_len, max_size);
   26aa6:	8a7b      	ldrh	r3, [r7, #18]
   26aa8:	461a      	mov	r2, r3
   26aaa:	6879      	ldr	r1, [r7, #4]
   26aac:	68b8      	ldr	r0, [r7, #8]
   26aae:	f7ff fcb6 	bl	2641e <appearance_encode>
   26ab2:	6178      	str	r0, [r7, #20]
        VERIFY_SUCCESS(err_code);
   26ab4:	697b      	ldr	r3, [r7, #20]
   26ab6:	2b00      	cmp	r3, #0
   26ab8:	d001      	beq.n	26abe <ble_advdata_encode+0x5e>
   26aba:	697b      	ldr	r3, [r7, #20]
   26abc:	e0aa      	b.n	26c14 <ble_advdata_encode+0x1b4>
    }

    //Encode Flags
    if (p_advdata->flags != 0 )
   26abe:	68fb      	ldr	r3, [r7, #12]
   26ac0:	78db      	ldrb	r3, [r3, #3]
   26ac2:	2b00      	cmp	r3, #0
   26ac4:	d00d      	beq.n	26ae2 <ble_advdata_encode+0x82>
    {
        err_code = flags_encode(p_advdata->flags, p_encoded_data, p_len, max_size);
   26ac6:	68fb      	ldr	r3, [r7, #12]
   26ac8:	78db      	ldrb	r3, [r3, #3]
   26aca:	b258      	sxtb	r0, r3
   26acc:	8a7b      	ldrh	r3, [r7, #18]
   26ace:	687a      	ldr	r2, [r7, #4]
   26ad0:	68b9      	ldr	r1, [r7, #8]
   26ad2:	f7ff fcf0 	bl	264b6 <flags_encode>
   26ad6:	6178      	str	r0, [r7, #20]
        VERIFY_SUCCESS(err_code);
   26ad8:	697b      	ldr	r3, [r7, #20]
   26ada:	2b00      	cmp	r3, #0
   26adc:	d001      	beq.n	26ae2 <ble_advdata_encode+0x82>
   26ade:	697b      	ldr	r3, [r7, #20]
   26ae0:	e098      	b.n	26c14 <ble_advdata_encode+0x1b4>
    }

    // Encode TX power level.
    if (p_advdata->p_tx_power_level != NULL)
   26ae2:	68fb      	ldr	r3, [r7, #12]
   26ae4:	685b      	ldr	r3, [r3, #4]
   26ae6:	2b00      	cmp	r3, #0
   26ae8:	d00e      	beq.n	26b08 <ble_advdata_encode+0xa8>
    {
        err_code = tx_power_level_encode(*p_advdata->p_tx_power_level,
   26aea:	68fb      	ldr	r3, [r7, #12]
   26aec:	685b      	ldr	r3, [r3, #4]
   26aee:	f993 0000 	ldrsb.w	r0, [r3]
   26af2:	8a7b      	ldrh	r3, [r7, #18]
   26af4:	687a      	ldr	r2, [r7, #4]
   26af6:	68b9      	ldr	r1, [r7, #8]
   26af8:	f7ff fd1c 	bl	26534 <tx_power_level_encode>
   26afc:	6178      	str	r0, [r7, #20]
                                         p_encoded_data,
                                         p_len,
                                         max_size);
        VERIFY_SUCCESS(err_code);
   26afe:	697b      	ldr	r3, [r7, #20]
   26b00:	2b00      	cmp	r3, #0
   26b02:	d001      	beq.n	26b08 <ble_advdata_encode+0xa8>
   26b04:	697b      	ldr	r3, [r7, #20]
   26b06:	e085      	b.n	26c14 <ble_advdata_encode+0x1b4>
    }

    // Encode 'more available' uuid list.
    if (p_advdata->uuids_more_available.uuid_cnt > 0)
   26b08:	68fb      	ldr	r3, [r7, #12]
   26b0a:	891b      	ldrh	r3, [r3, #8]
   26b0c:	2b00      	cmp	r3, #0
   26b0e:	d011      	beq.n	26b34 <ble_advdata_encode+0xd4>
    {
        err_code = uuid_list_encode(&p_advdata->uuids_more_available,
   26b10:	68fb      	ldr	r3, [r7, #12]
   26b12:	f103 0008 	add.w	r0, r3, #8
   26b16:	8a7b      	ldrh	r3, [r7, #18]
   26b18:	9301      	str	r3, [sp, #4]
   26b1a:	687b      	ldr	r3, [r7, #4]
   26b1c:	9300      	str	r3, [sp, #0]
   26b1e:	68bb      	ldr	r3, [r7, #8]
   26b20:	2206      	movs	r2, #6
   26b22:	2102      	movs	r1, #2
   26b24:	f7ff fde1 	bl	266ea <uuid_list_encode>
   26b28:	6178      	str	r0, [r7, #20]
                                    BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_MORE_AVAILABLE,
                                    BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_MORE_AVAILABLE,
                                    p_encoded_data,
                                    p_len,
                                    max_size);
        VERIFY_SUCCESS(err_code);
   26b2a:	697b      	ldr	r3, [r7, #20]
   26b2c:	2b00      	cmp	r3, #0
   26b2e:	d001      	beq.n	26b34 <ble_advdata_encode+0xd4>
   26b30:	697b      	ldr	r3, [r7, #20]
   26b32:	e06f      	b.n	26c14 <ble_advdata_encode+0x1b4>
    }

    // Encode 'complete' uuid list.
    if (p_advdata->uuids_complete.uuid_cnt > 0)
   26b34:	68fb      	ldr	r3, [r7, #12]
   26b36:	8a1b      	ldrh	r3, [r3, #16]
   26b38:	2b00      	cmp	r3, #0
   26b3a:	d011      	beq.n	26b60 <ble_advdata_encode+0x100>
    {
        err_code = uuid_list_encode(&p_advdata->uuids_complete,
   26b3c:	68fb      	ldr	r3, [r7, #12]
   26b3e:	f103 0010 	add.w	r0, r3, #16
   26b42:	8a7b      	ldrh	r3, [r7, #18]
   26b44:	9301      	str	r3, [sp, #4]
   26b46:	687b      	ldr	r3, [r7, #4]
   26b48:	9300      	str	r3, [sp, #0]
   26b4a:	68bb      	ldr	r3, [r7, #8]
   26b4c:	2207      	movs	r2, #7
   26b4e:	2103      	movs	r1, #3
   26b50:	f7ff fdcb 	bl	266ea <uuid_list_encode>
   26b54:	6178      	str	r0, [r7, #20]
                                    BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_COMPLETE,
                                    BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_COMPLETE,
                                    p_encoded_data,
                                    p_len,
                                    max_size);
        VERIFY_SUCCESS(err_code);
   26b56:	697b      	ldr	r3, [r7, #20]
   26b58:	2b00      	cmp	r3, #0
   26b5a:	d001      	beq.n	26b60 <ble_advdata_encode+0x100>
   26b5c:	697b      	ldr	r3, [r7, #20]
   26b5e:	e059      	b.n	26c14 <ble_advdata_encode+0x1b4>
    }

    // Encode 'solicited service' uuid list.
    if (p_advdata->uuids_solicited.uuid_cnt > 0)
   26b60:	68fb      	ldr	r3, [r7, #12]
   26b62:	8b1b      	ldrh	r3, [r3, #24]
   26b64:	2b00      	cmp	r3, #0
   26b66:	d011      	beq.n	26b8c <ble_advdata_encode+0x12c>
    {
        err_code = uuid_list_encode(&p_advdata->uuids_solicited,
   26b68:	68fb      	ldr	r3, [r7, #12]
   26b6a:	f103 0018 	add.w	r0, r3, #24
   26b6e:	8a7b      	ldrh	r3, [r7, #18]
   26b70:	9301      	str	r3, [sp, #4]
   26b72:	687b      	ldr	r3, [r7, #4]
   26b74:	9300      	str	r3, [sp, #0]
   26b76:	68bb      	ldr	r3, [r7, #8]
   26b78:	2215      	movs	r2, #21
   26b7a:	2114      	movs	r1, #20
   26b7c:	f7ff fdb5 	bl	266ea <uuid_list_encode>
   26b80:	6178      	str	r0, [r7, #20]
                                    BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_16BIT,
                                    BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_128BIT,
                                    p_encoded_data,
                                    p_len,
                                    max_size);
        VERIFY_SUCCESS(err_code);
   26b82:	697b      	ldr	r3, [r7, #20]
   26b84:	2b00      	cmp	r3, #0
   26b86:	d001      	beq.n	26b8c <ble_advdata_encode+0x12c>
   26b88:	697b      	ldr	r3, [r7, #20]
   26b8a:	e043      	b.n	26c14 <ble_advdata_encode+0x1b4>
    }

    // Encode Slave Connection Interval Range.
    if (p_advdata->p_slave_conn_int != NULL)
   26b8c:	68fb      	ldr	r3, [r7, #12]
   26b8e:	6a1b      	ldr	r3, [r3, #32]
   26b90:	2b00      	cmp	r3, #0
   26b92:	d00c      	beq.n	26bae <ble_advdata_encode+0x14e>
    {
        err_code = conn_int_encode(p_advdata->p_slave_conn_int, p_encoded_data, p_len, max_size);
   26b94:	68fb      	ldr	r3, [r7, #12]
   26b96:	6a18      	ldr	r0, [r3, #32]
   26b98:	8a7b      	ldrh	r3, [r7, #18]
   26b9a:	687a      	ldr	r2, [r7, #4]
   26b9c:	68b9      	ldr	r1, [r7, #8]
   26b9e:	f7ff fe12 	bl	267c6 <conn_int_encode>
   26ba2:	6178      	str	r0, [r7, #20]
        VERIFY_SUCCESS(err_code);
   26ba4:	697b      	ldr	r3, [r7, #20]
   26ba6:	2b00      	cmp	r3, #0
   26ba8:	d001      	beq.n	26bae <ble_advdata_encode+0x14e>
   26baa:	697b      	ldr	r3, [r7, #20]
   26bac:	e032      	b.n	26c14 <ble_advdata_encode+0x1b4>
    }

    // Encode Manufacturer Specific Data.
    if (p_advdata->p_manuf_specific_data != NULL)
   26bae:	68fb      	ldr	r3, [r7, #12]
   26bb0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   26bb2:	2b00      	cmp	r3, #0
   26bb4:	d00c      	beq.n	26bd0 <ble_advdata_encode+0x170>
    {
        err_code = manuf_specific_data_encode(p_advdata->p_manuf_specific_data,
   26bb6:	68fb      	ldr	r3, [r7, #12]
   26bb8:	6a58      	ldr	r0, [r3, #36]	; 0x24
   26bba:	8a7b      	ldrh	r3, [r7, #18]
   26bbc:	687a      	ldr	r2, [r7, #4]
   26bbe:	68b9      	ldr	r1, [r7, #8]
   26bc0:	f7ff fe60 	bl	26884 <manuf_specific_data_encode>
   26bc4:	6178      	str	r0, [r7, #20]
                                              p_encoded_data,
                                              p_len,
                                              max_size);
        VERIFY_SUCCESS(err_code);
   26bc6:	697b      	ldr	r3, [r7, #20]
   26bc8:	2b00      	cmp	r3, #0
   26bca:	d001      	beq.n	26bd0 <ble_advdata_encode+0x170>
   26bcc:	697b      	ldr	r3, [r7, #20]
   26bce:	e021      	b.n	26c14 <ble_advdata_encode+0x1b4>
    }

    // Encode Service Data.
    if (p_advdata->service_data_count > 0)
   26bd0:	68fb      	ldr	r3, [r7, #12]
   26bd2:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
   26bd6:	2b00      	cmp	r3, #0
   26bd8:	d00b      	beq.n	26bf2 <ble_advdata_encode+0x192>
    {
        err_code = service_data_encode(p_advdata, p_encoded_data, p_len, max_size);
   26bda:	8a7b      	ldrh	r3, [r7, #18]
   26bdc:	687a      	ldr	r2, [r7, #4]
   26bde:	68b9      	ldr	r1, [r7, #8]
   26be0:	68f8      	ldr	r0, [r7, #12]
   26be2:	f7ff febe 	bl	26962 <service_data_encode>
   26be6:	6178      	str	r0, [r7, #20]
        VERIFY_SUCCESS(err_code);
   26be8:	697b      	ldr	r3, [r7, #20]
   26bea:	2b00      	cmp	r3, #0
   26bec:	d001      	beq.n	26bf2 <ble_advdata_encode+0x192>
   26bee:	697b      	ldr	r3, [r7, #20]
   26bf0:	e010      	b.n	26c14 <ble_advdata_encode+0x1b4>
    }

    // Encode name. WARNING: it is encoded last on purpose since too long device name is truncated.
    if (p_advdata->name_type != BLE_ADVDATA_NO_NAME)
   26bf2:	68fb      	ldr	r3, [r7, #12]
   26bf4:	781b      	ldrb	r3, [r3, #0]
   26bf6:	2b00      	cmp	r3, #0
   26bf8:	d00b      	beq.n	26c12 <ble_advdata_encode+0x1b2>
    {
        err_code = name_encode(p_advdata, p_encoded_data, p_len, max_size);
   26bfa:	8a7b      	ldrh	r3, [r7, #18]
   26bfc:	687a      	ldr	r2, [r7, #4]
   26bfe:	68b9      	ldr	r1, [r7, #8]
   26c00:	68f8      	ldr	r0, [r7, #12]
   26c02:	f7ff fb7f 	bl	26304 <name_encode>
   26c06:	6178      	str	r0, [r7, #20]
        VERIFY_SUCCESS(err_code);
   26c08:	697b      	ldr	r3, [r7, #20]
   26c0a:	2b00      	cmp	r3, #0
   26c0c:	d001      	beq.n	26c12 <ble_advdata_encode+0x1b2>
   26c0e:	697b      	ldr	r3, [r7, #20]
   26c10:	e000      	b.n	26c14 <ble_advdata_encode+0x1b4>
    }

    return err_code;
   26c12:	697b      	ldr	r3, [r7, #20]
}
   26c14:	4618      	mov	r0, r3
   26c16:	3718      	adds	r7, #24
   26c18:	46bd      	mov	sp, r7
   26c1a:	bd80      	pop	{r7, pc}

00026c1c <advdata_check>:


static uint32_t advdata_check(const ble_advdata_t * p_advdata)
{
   26c1c:	b480      	push	{r7}
   26c1e:	b083      	sub	sp, #12
   26c20:	af00      	add	r7, sp, #0
   26c22:	6078      	str	r0, [r7, #4]
    // Flags must be included in advertising data, and the BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED flag must be set.
    if (
        ((p_advdata->flags & BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED) == 0)
   26c24:	687b      	ldr	r3, [r7, #4]
   26c26:	78db      	ldrb	r3, [r3, #3]
   26c28:	f003 0304 	and.w	r3, r3, #4
    if (
   26c2c:	2b00      	cmp	r3, #0
   26c2e:	d101      	bne.n	26c34 <advdata_check+0x18>
       )
    {
        return NRF_ERROR_INVALID_PARAM;
   26c30:	2307      	movs	r3, #7
   26c32:	e000      	b.n	26c36 <advdata_check+0x1a>
    }

    return NRF_SUCCESS;
   26c34:	2300      	movs	r3, #0
}
   26c36:	4618      	mov	r0, r3
   26c38:	370c      	adds	r7, #12
   26c3a:	46bd      	mov	sp, r7
   26c3c:	bc80      	pop	{r7}
   26c3e:	4770      	bx	lr

00026c40 <srdata_check>:


static uint32_t srdata_check(const ble_advdata_t * p_srdata)
{
   26c40:	b480      	push	{r7}
   26c42:	b083      	sub	sp, #12
   26c44:	af00      	add	r7, sp, #0
   26c46:	6078      	str	r0, [r7, #4]
    // Flags shall not be included in the scan response data.
    if (p_srdata->flags)
   26c48:	687b      	ldr	r3, [r7, #4]
   26c4a:	78db      	ldrb	r3, [r3, #3]
   26c4c:	2b00      	cmp	r3, #0
   26c4e:	d001      	beq.n	26c54 <srdata_check+0x14>
    {
        return NRF_ERROR_INVALID_PARAM;
   26c50:	2307      	movs	r3, #7
   26c52:	e000      	b.n	26c56 <srdata_check+0x16>
    }

    return NRF_SUCCESS;
   26c54:	2300      	movs	r3, #0
}
   26c56:	4618      	mov	r0, r3
   26c58:	370c      	adds	r7, #12
   26c5a:	46bd      	mov	sp, r7
   26c5c:	bc80      	pop	{r7}
   26c5e:	4770      	bx	lr

00026c60 <ble_advdata_set>:


uint32_t ble_advdata_set(const ble_advdata_t * p_advdata, const ble_advdata_t * p_srdata)
{
   26c60:	b580      	push	{r7, lr}
   26c62:	b096      	sub	sp, #88	; 0x58
   26c64:	af00      	add	r7, sp, #0
   26c66:	6078      	str	r0, [r7, #4]
   26c68:	6039      	str	r1, [r7, #0]
    uint32_t  err_code;
    uint16_t  len_advdata = BLE_GAP_ADV_MAX_SIZE;
   26c6a:	231f      	movs	r3, #31
   26c6c:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
    uint16_t  len_srdata  = BLE_GAP_ADV_MAX_SIZE;
   26c70:	231f      	movs	r3, #31
   26c72:	f8a7 3048 	strh.w	r3, [r7, #72]	; 0x48
    uint8_t   encoded_srdata[BLE_GAP_ADV_MAX_SIZE];
    uint8_t * p_encoded_advdata;
    uint8_t * p_encoded_srdata;

    // Encode advertising data (if supplied).
    if (p_advdata != NULL)
   26c76:	687b      	ldr	r3, [r7, #4]
   26c78:	2b00      	cmp	r3, #0
   26c7a:	d01a      	beq.n	26cb2 <ble_advdata_set+0x52>
    {
        err_code = advdata_check(p_advdata);
   26c7c:	6878      	ldr	r0, [r7, #4]
   26c7e:	f7ff ffcd 	bl	26c1c <advdata_check>
   26c82:	64f8      	str	r0, [r7, #76]	; 0x4c
        VERIFY_SUCCESS(err_code);
   26c84:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   26c86:	2b00      	cmp	r3, #0
   26c88:	d001      	beq.n	26c8e <ble_advdata_set+0x2e>
   26c8a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   26c8c:	e044      	b.n	26d18 <ble_advdata_set+0xb8>

        err_code = ble_advdata_encode(p_advdata, encoded_advdata, &len_advdata);
   26c8e:	f107 024a 	add.w	r2, r7, #74	; 0x4a
   26c92:	f107 0328 	add.w	r3, r7, #40	; 0x28
   26c96:	4619      	mov	r1, r3
   26c98:	6878      	ldr	r0, [r7, #4]
   26c9a:	f7ff fee1 	bl	26a60 <ble_advdata_encode>
   26c9e:	64f8      	str	r0, [r7, #76]	; 0x4c
        VERIFY_SUCCESS(err_code);
   26ca0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   26ca2:	2b00      	cmp	r3, #0
   26ca4:	d001      	beq.n	26caa <ble_advdata_set+0x4a>
   26ca6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   26ca8:	e036      	b.n	26d18 <ble_advdata_set+0xb8>
        p_encoded_advdata = encoded_advdata;
   26caa:	f107 0328 	add.w	r3, r7, #40	; 0x28
   26cae:	657b      	str	r3, [r7, #84]	; 0x54
   26cb0:	e004      	b.n	26cbc <ble_advdata_set+0x5c>
    }
    else
    {
        p_encoded_advdata = NULL;
   26cb2:	2300      	movs	r3, #0
   26cb4:	657b      	str	r3, [r7, #84]	; 0x54
        len_advdata = 0;
   26cb6:	2300      	movs	r3, #0
   26cb8:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
    }

    // Encode scan response data (if supplied).
    if (p_srdata != NULL)
   26cbc:	683b      	ldr	r3, [r7, #0]
   26cbe:	2b00      	cmp	r3, #0
   26cc0:	d01a      	beq.n	26cf8 <ble_advdata_set+0x98>
    {
        err_code = srdata_check(p_srdata);
   26cc2:	6838      	ldr	r0, [r7, #0]
   26cc4:	f7ff ffbc 	bl	26c40 <srdata_check>
   26cc8:	64f8      	str	r0, [r7, #76]	; 0x4c
        VERIFY_SUCCESS(err_code);
   26cca:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   26ccc:	2b00      	cmp	r3, #0
   26cce:	d001      	beq.n	26cd4 <ble_advdata_set+0x74>
   26cd0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   26cd2:	e021      	b.n	26d18 <ble_advdata_set+0xb8>

        err_code = ble_advdata_encode(p_srdata, encoded_srdata, &len_srdata);
   26cd4:	f107 0248 	add.w	r2, r7, #72	; 0x48
   26cd8:	f107 0308 	add.w	r3, r7, #8
   26cdc:	4619      	mov	r1, r3
   26cde:	6838      	ldr	r0, [r7, #0]
   26ce0:	f7ff febe 	bl	26a60 <ble_advdata_encode>
   26ce4:	64f8      	str	r0, [r7, #76]	; 0x4c
        VERIFY_SUCCESS(err_code);
   26ce6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   26ce8:	2b00      	cmp	r3, #0
   26cea:	d001      	beq.n	26cf0 <ble_advdata_set+0x90>
   26cec:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   26cee:	e013      	b.n	26d18 <ble_advdata_set+0xb8>
        p_encoded_srdata = encoded_srdata;
   26cf0:	f107 0308 	add.w	r3, r7, #8
   26cf4:	653b      	str	r3, [r7, #80]	; 0x50
   26cf6:	e004      	b.n	26d02 <ble_advdata_set+0xa2>
    }
    else
    {
        p_encoded_srdata = NULL;
   26cf8:	2300      	movs	r3, #0
   26cfa:	653b      	str	r3, [r7, #80]	; 0x50
        len_srdata = 0;
   26cfc:	2300      	movs	r3, #0
   26cfe:	f8a7 3048 	strh.w	r3, [r7, #72]	; 0x48
    }

    // Pass encoded advertising data and/or scan response data to the stack.
    return sd_ble_gap_adv_data_set(p_encoded_advdata, len_advdata, p_encoded_srdata, len_srdata);
   26d02:	f8b7 304a 	ldrh.w	r3, [r7, #74]	; 0x4a
   26d06:	b2d9      	uxtb	r1, r3
   26d08:	f8b7 3048 	ldrh.w	r3, [r7, #72]	; 0x48
   26d0c:	b2db      	uxtb	r3, r3
   26d0e:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   26d10:	6d78      	ldr	r0, [r7, #84]	; 0x54
   26d12:	f7ff fa69 	bl	261e8 <sd_ble_gap_adv_data_set>
   26d16:	4603      	mov	r3, r0
}
   26d18:	4618      	mov	r0, r3
   26d1a:	3758      	adds	r7, #88	; 0x58
   26d1c:	46bd      	mov	sp, r7
   26d1e:	bd80      	pop	{r7, pc}

00026d20 <app_error_handler>:
 * @param[in] p_file_name Pointer to the file name.
 */

/*lint -save -e14 */
void app_error_handler(ret_code_t error_code, uint32_t line_num, const uint8_t * p_file_name)
{
   26d20:	b580      	push	{r7, lr}
   26d22:	b088      	sub	sp, #32
   26d24:	af00      	add	r7, sp, #0
   26d26:	60f8      	str	r0, [r7, #12]
   26d28:	60b9      	str	r1, [r7, #8]
   26d2a:	607a      	str	r2, [r7, #4]
    error_info_t error_info =
   26d2c:	68bb      	ldr	r3, [r7, #8]
   26d2e:	b29b      	uxth	r3, r3
   26d30:	82bb      	strh	r3, [r7, #20]
   26d32:	687b      	ldr	r3, [r7, #4]
   26d34:	61bb      	str	r3, [r7, #24]
   26d36:	68fb      	ldr	r3, [r7, #12]
   26d38:	61fb      	str	r3, [r7, #28]
    {
        .line_num    = line_num,
        .p_file_name = p_file_name,
        .err_code    = error_code,
    };
    app_error_fault_handler(NRF_FAULT_ID_SDK_ERROR, 0, (uint32_t)(&error_info));
   26d3a:	f107 0314 	add.w	r3, r7, #20
   26d3e:	461a      	mov	r2, r3
   26d40:	2100      	movs	r1, #0
   26d42:	f244 0001 	movw	r0, #16385	; 0x4001
   26d46:	f000 f851 	bl	26dec <app_error_fault_handler>

    UNUSED_VARIABLE(error_info);
}
   26d4a:	bf00      	nop
   26d4c:	3720      	adds	r7, #32
   26d4e:	46bd      	mov	sp, r7
   26d50:	bd80      	pop	{r7, pc}
	...

00026d54 <app_error_save_and_stop>:
    UNUSED_VARIABLE(error_info);
}


void app_error_save_and_stop(uint32_t id, uint32_t pc, uint32_t info)
{
   26d54:	b480      	push	{r7}
   26d56:	b087      	sub	sp, #28
   26d58:	af00      	add	r7, sp, #0
   26d5a:	60f8      	str	r0, [r7, #12]
   26d5c:	60b9      	str	r1, [r7, #8]
   26d5e:	607a      	str	r2, [r7, #4]
        const uint8_t * p_file_name;
    } m_error_data = {0};

    // The following variable helps Keil keep the call stack visible, in addition, it can be set to
    // 0 in the debugger to continue executing code after the error check.
    volatile bool loop = true;
   26d60:	2301      	movs	r3, #1
   26d62:	75fb      	strb	r3, [r7, #23]
    UNUSED_VARIABLE(loop);
   26d64:	7dfb      	ldrb	r3, [r7, #23]

    m_error_data.fault_id   = id;
   26d66:	4a20      	ldr	r2, [pc, #128]	; (26de8 <app_error_save_and_stop+0x94>)
   26d68:	68fb      	ldr	r3, [r7, #12]
   26d6a:	6013      	str	r3, [r2, #0]
    m_error_data.pc         = pc;
   26d6c:	4a1e      	ldr	r2, [pc, #120]	; (26de8 <app_error_save_and_stop+0x94>)
   26d6e:	68bb      	ldr	r3, [r7, #8]
   26d70:	6053      	str	r3, [r2, #4]
    m_error_data.error_info = info;
   26d72:	4a1d      	ldr	r2, [pc, #116]	; (26de8 <app_error_save_and_stop+0x94>)
   26d74:	687b      	ldr	r3, [r7, #4]
   26d76:	6093      	str	r3, [r2, #8]

    switch (id)
   26d78:	68fb      	ldr	r3, [r7, #12]
   26d7a:	f244 0201 	movw	r2, #16385	; 0x4001
   26d7e:	4293      	cmp	r3, r2
   26d80:	d012      	beq.n	26da8 <app_error_save_and_stop+0x54>
   26d82:	f244 0202 	movw	r2, #16386	; 0x4002
   26d86:	4293      	cmp	r3, r2
   26d88:	d122      	bne.n	26dd0 <app_error_save_and_stop+0x7c>
    {
        case NRF_FAULT_ID_SDK_ASSERT:
            m_error_data.p_assert_info = (assert_info_t *)info;
   26d8a:	687b      	ldr	r3, [r7, #4]
   26d8c:	4a16      	ldr	r2, [pc, #88]	; (26de8 <app_error_save_and_stop+0x94>)
   26d8e:	60d3      	str	r3, [r2, #12]
            m_error_data.line_num      = m_error_data.p_assert_info->line_num;
   26d90:	4b15      	ldr	r3, [pc, #84]	; (26de8 <app_error_save_and_stop+0x94>)
   26d92:	68db      	ldr	r3, [r3, #12]
   26d94:	881b      	ldrh	r3, [r3, #0]
   26d96:	461a      	mov	r2, r3
   26d98:	4b13      	ldr	r3, [pc, #76]	; (26de8 <app_error_save_and_stop+0x94>)
   26d9a:	619a      	str	r2, [r3, #24]
            m_error_data.p_file_name   = m_error_data.p_assert_info->p_file_name;
   26d9c:	4b12      	ldr	r3, [pc, #72]	; (26de8 <app_error_save_and_stop+0x94>)
   26d9e:	68db      	ldr	r3, [r3, #12]
   26da0:	685b      	ldr	r3, [r3, #4]
   26da2:	4a11      	ldr	r2, [pc, #68]	; (26de8 <app_error_save_and_stop+0x94>)
   26da4:	61d3      	str	r3, [r2, #28]
            break;
   26da6:	e013      	b.n	26dd0 <app_error_save_and_stop+0x7c>

        case NRF_FAULT_ID_SDK_ERROR:
            m_error_data.p_error_info = (error_info_t *)info;
   26da8:	687b      	ldr	r3, [r7, #4]
   26daa:	4a0f      	ldr	r2, [pc, #60]	; (26de8 <app_error_save_and_stop+0x94>)
   26dac:	6113      	str	r3, [r2, #16]
            m_error_data.err_code     = m_error_data.p_error_info->err_code;
   26dae:	4b0e      	ldr	r3, [pc, #56]	; (26de8 <app_error_save_and_stop+0x94>)
   26db0:	691b      	ldr	r3, [r3, #16]
   26db2:	689b      	ldr	r3, [r3, #8]
   26db4:	4a0c      	ldr	r2, [pc, #48]	; (26de8 <app_error_save_and_stop+0x94>)
   26db6:	6153      	str	r3, [r2, #20]
            m_error_data.line_num     = m_error_data.p_error_info->line_num;
   26db8:	4b0b      	ldr	r3, [pc, #44]	; (26de8 <app_error_save_and_stop+0x94>)
   26dba:	691b      	ldr	r3, [r3, #16]
   26dbc:	881b      	ldrh	r3, [r3, #0]
   26dbe:	461a      	mov	r2, r3
   26dc0:	4b09      	ldr	r3, [pc, #36]	; (26de8 <app_error_save_and_stop+0x94>)
   26dc2:	619a      	str	r2, [r3, #24]
            m_error_data.p_file_name  = m_error_data.p_error_info->p_file_name;
   26dc4:	4b08      	ldr	r3, [pc, #32]	; (26de8 <app_error_save_and_stop+0x94>)
   26dc6:	691b      	ldr	r3, [r3, #16]
   26dc8:	685b      	ldr	r3, [r3, #4]
   26dca:	4a07      	ldr	r2, [pc, #28]	; (26de8 <app_error_save_and_stop+0x94>)
   26dcc:	61d3      	str	r3, [r2, #28]
            break;
   26dce:	bf00      	nop
  __ASM volatile ("cpsid i" : : : "memory");
   26dd0:	b672      	cpsid	i

    UNUSED_VARIABLE(m_error_data);

    // If printing is disrupted, remove the irq calls, or set the loop variable to 0 in the debugger.
    __disable_irq();
    while (loop);
   26dd2:	bf00      	nop
   26dd4:	7dfb      	ldrb	r3, [r7, #23]
   26dd6:	b2db      	uxtb	r3, r3
   26dd8:	2b00      	cmp	r3, #0
   26dda:	d1fb      	bne.n	26dd4 <app_error_save_and_stop+0x80>
  __ASM volatile ("cpsie i" : : : "memory");
   26ddc:	b662      	cpsie	i

    __enable_irq();
}
   26dde:	bf00      	nop
   26de0:	371c      	adds	r7, #28
   26de2:	46bd      	mov	sp, r7
   26de4:	bc80      	pop	{r7}
   26de6:	4770      	bx	lr
   26de8:	20005328 	.word	0x20005328

00026dec <app_error_fault_handler>:
/**
 * Function is implemented as weak so that it can be overwritten by custom application error handler
 * when needed.
 */
__WEAK void app_error_fault_handler(uint32_t id, uint32_t pc, uint32_t info)
{
   26dec:	b580      	push	{r7, lr}
   26dee:	b084      	sub	sp, #16
   26df0:	af00      	add	r7, sp, #0
   26df2:	60f8      	str	r0, [r7, #12]
   26df4:	60b9      	str	r1, [r7, #8]
   26df6:	607a      	str	r2, [r7, #4]
    // On assert, the system can only recover with a reset.
#ifndef DEBUG
    NVIC_SystemReset();
#else
    app_error_save_and_stop(id, pc, info);
   26df8:	687a      	ldr	r2, [r7, #4]
   26dfa:	68b9      	ldr	r1, [r7, #8]
   26dfc:	68f8      	ldr	r0, [r7, #12]
   26dfe:	f7ff ffa9 	bl	26d54 <app_error_save_and_stop>
#endif // DEBUG
}
   26e02:	bf00      	nop
   26e04:	3710      	adds	r7, #16
   26e06:	46bd      	mov	sp, r7
   26e08:	bd80      	pop	{r7, pc}
	...

00026e0c <NVIC_EnableIRQ>:
{
   26e0c:	b480      	push	{r7}
   26e0e:	b083      	sub	sp, #12
   26e10:	af00      	add	r7, sp, #0
   26e12:	4603      	mov	r3, r0
   26e14:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   26e16:	79fb      	ldrb	r3, [r7, #7]
   26e18:	f003 021f 	and.w	r2, r3, #31
   26e1c:	4906      	ldr	r1, [pc, #24]	; (26e38 <NVIC_EnableIRQ+0x2c>)
   26e1e:	f997 3007 	ldrsb.w	r3, [r7, #7]
   26e22:	095b      	lsrs	r3, r3, #5
   26e24:	2001      	movs	r0, #1
   26e26:	fa00 f202 	lsl.w	r2, r0, r2
   26e2a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   26e2e:	bf00      	nop
   26e30:	370c      	adds	r7, #12
   26e32:	46bd      	mov	sp, r7
   26e34:	bc80      	pop	{r7}
   26e36:	4770      	bx	lr
   26e38:	e000e100 	.word	0xe000e100

00026e3c <nrf_section_iter_get>:
 * @param[in]   p_iter  Pointer to the iterator.
 *
 * @retval  Pointer to the element or NULL if iterator points end of the set.
 */
static inline void * nrf_section_iter_get(nrf_section_iter_t const * p_iter)
{
   26e3c:	b480      	push	{r7}
   26e3e:	b083      	sub	sp, #12
   26e40:	af00      	add	r7, sp, #0
   26e42:	6078      	str	r0, [r7, #4]
    ASSERT(p_iter);
    return p_iter->p_item;
   26e44:	687b      	ldr	r3, [r7, #4]
   26e46:	685b      	ldr	r3, [r3, #4]
}
   26e48:	4618      	mov	r0, r3
   26e4a:	370c      	adds	r7, #12
   26e4c:	46bd      	mov	sp, r7
   26e4e:	bc80      	pop	{r7}
   26e50:	4770      	bx	lr

00026e52 <sd_softdevice_enable>:
 * @retval ::NRF_ERROR_INVALID_ADDR  Invalid or NULL pointer supplied.
 * @retval ::NRF_ERROR_INVALID_STATE SoftDevice is already enabled, and the clock source and fault handler cannot be updated.
 * @retval ::NRF_ERROR_SDM_INCORRECT_INTERRUPT_CONFIGURATION SoftDevice interrupt is already enabled, or an enabled interrupt has an illegal priority level.
 * @retval ::NRF_ERROR_SDM_LFCLK_SOURCE_UNKNOWN Unknown low frequency clock source selected.
 */
SVCALL(SD_SOFTDEVICE_ENABLE, uint32_t, sd_softdevice_enable(nrf_clock_lf_cfg_t const * p_clock_lf_cfg, nrf_fault_handler_t fault_handler));
   26e52:	df10      	svc	16
   26e54:	4770      	bx	lr
   26e56:	bf00      	nop
   26e58:	4618      	mov	r0, r3
	...

00026e5c <sdh_request_observer_notify>:
/**@brief   Function for notifying request observers.
 *
 * @param[in]   evt     Type of request event.
 */
static ret_code_t sdh_request_observer_notify(nrf_sdh_req_evt_t req)
{
   26e5c:	b580      	push	{r7, lr}
   26e5e:	b086      	sub	sp, #24
   26e60:	af00      	add	r7, sp, #0
   26e62:	4603      	mov	r3, r0
   26e64:	71fb      	strb	r3, [r7, #7]
    nrf_section_iter_t iter;

    NRF_LOG_DEBUG("State request: 0x%08X", req);

    for (nrf_section_iter_init(&iter, &sdh_req_observers);
   26e66:	f107 0308 	add.w	r3, r7, #8
   26e6a:	4915      	ldr	r1, [pc, #84]	; (26ec0 <sdh_request_observer_notify+0x64>)
   26e6c:	4618      	mov	r0, r3
   26e6e:	f000 fa23 	bl	272b8 <nrf_section_iter_init>
   26e72:	e018      	b.n	26ea6 <sdh_request_observer_notify+0x4a>
         nrf_section_iter_next(&iter))
    {
        nrf_sdh_req_observer_t    * p_observer;
        nrf_sdh_req_evt_handler_t   handler;

        p_observer = (nrf_sdh_req_observer_t *) nrf_section_iter_get(&iter);
   26e74:	f107 0308 	add.w	r3, r7, #8
   26e78:	4618      	mov	r0, r3
   26e7a:	f7ff ffdf 	bl	26e3c <nrf_section_iter_get>
   26e7e:	6178      	str	r0, [r7, #20]
        handler    = p_observer->handler;
   26e80:	697b      	ldr	r3, [r7, #20]
   26e82:	681b      	ldr	r3, [r3, #0]
   26e84:	613b      	str	r3, [r7, #16]

        if (handler(req, p_observer->p_context))
   26e86:	697b      	ldr	r3, [r7, #20]
   26e88:	6859      	ldr	r1, [r3, #4]
   26e8a:	79fa      	ldrb	r2, [r7, #7]
   26e8c:	693b      	ldr	r3, [r7, #16]
   26e8e:	4610      	mov	r0, r2
   26e90:	4798      	blx	r3
   26e92:	4603      	mov	r3, r0
   26e94:	2b00      	cmp	r3, #0
   26e96:	d101      	bne.n	26e9c <sdh_request_observer_notify+0x40>
        }
        else
        {
            // Process is stopped.
            NRF_LOG_DEBUG("Notify observer 0x%08X => blocking", p_observer);
            return NRF_ERROR_BUSY;
   26e98:	2311      	movs	r3, #17
   26e9a:	e00d      	b.n	26eb8 <sdh_request_observer_notify+0x5c>
         nrf_section_iter_next(&iter))
   26e9c:	f107 0308 	add.w	r3, r7, #8
   26ea0:	4618      	mov	r0, r3
   26ea2:	f000 fa25 	bl	272f0 <nrf_section_iter_next>
         nrf_section_iter_get(&iter) != NULL;
   26ea6:	f107 0308 	add.w	r3, r7, #8
   26eaa:	4618      	mov	r0, r3
   26eac:	f7ff ffc6 	bl	26e3c <nrf_section_iter_get>
   26eb0:	4603      	mov	r3, r0
    for (nrf_section_iter_init(&iter, &sdh_req_observers);
   26eb2:	2b00      	cmp	r3, #0
   26eb4:	d1de      	bne.n	26e74 <sdh_request_observer_notify+0x18>
        }
    }
    return NRF_SUCCESS;
   26eb6:	2300      	movs	r3, #0
}
   26eb8:	4618      	mov	r0, r3
   26eba:	3718      	adds	r7, #24
   26ebc:	46bd      	mov	sp, r7
   26ebe:	bd80      	pop	{r7, pc}
   26ec0:	0002b564 	.word	0x0002b564

00026ec4 <sdh_state_observer_notify>:
/**@brief   Function for stage request observers.
 *
 * @param[in]   evt Type of stage event.
 */
static void sdh_state_observer_notify(nrf_sdh_state_evt_t evt)
{
   26ec4:	b580      	push	{r7, lr}
   26ec6:	b086      	sub	sp, #24
   26ec8:	af00      	add	r7, sp, #0
   26eca:	4603      	mov	r3, r0
   26ecc:	71fb      	strb	r3, [r7, #7]
    nrf_section_iter_t iter;

    NRF_LOG_DEBUG("State change: 0x%08X", evt);

    for (nrf_section_iter_init(&iter, &sdh_state_observers);
   26ece:	f107 0308 	add.w	r3, r7, #8
   26ed2:	4912      	ldr	r1, [pc, #72]	; (26f1c <sdh_state_observer_notify+0x58>)
   26ed4:	4618      	mov	r0, r3
   26ed6:	f000 f9ef 	bl	272b8 <nrf_section_iter_init>
   26eda:	e013      	b.n	26f04 <sdh_state_observer_notify+0x40>
         nrf_section_iter_next(&iter))
    {
        nrf_sdh_state_observer_t    * p_observer;
        nrf_sdh_state_evt_handler_t   handler;

        p_observer = (nrf_sdh_state_observer_t *) nrf_section_iter_get(&iter);
   26edc:	f107 0308 	add.w	r3, r7, #8
   26ee0:	4618      	mov	r0, r3
   26ee2:	f7ff ffab 	bl	26e3c <nrf_section_iter_get>
   26ee6:	6178      	str	r0, [r7, #20]
        handler    = p_observer->handler;
   26ee8:	697b      	ldr	r3, [r7, #20]
   26eea:	681b      	ldr	r3, [r3, #0]
   26eec:	613b      	str	r3, [r7, #16]

        handler(evt, p_observer->p_context);
   26eee:	697b      	ldr	r3, [r7, #20]
   26ef0:	6859      	ldr	r1, [r3, #4]
   26ef2:	79fa      	ldrb	r2, [r7, #7]
   26ef4:	693b      	ldr	r3, [r7, #16]
   26ef6:	4610      	mov	r0, r2
   26ef8:	4798      	blx	r3
         nrf_section_iter_next(&iter))
   26efa:	f107 0308 	add.w	r3, r7, #8
   26efe:	4618      	mov	r0, r3
   26f00:	f000 f9f6 	bl	272f0 <nrf_section_iter_next>
         nrf_section_iter_get(&iter) != NULL;
   26f04:	f107 0308 	add.w	r3, r7, #8
   26f08:	4618      	mov	r0, r3
   26f0a:	f7ff ff97 	bl	26e3c <nrf_section_iter_get>
   26f0e:	4603      	mov	r3, r0
    for (nrf_section_iter_init(&iter, &sdh_state_observers);
   26f10:	2b00      	cmp	r3, #0
   26f12:	d1e3      	bne.n	26edc <sdh_state_observer_notify+0x18>
    }
}
   26f14:	bf00      	nop
   26f16:	3718      	adds	r7, #24
   26f18:	46bd      	mov	sp, r7
   26f1a:	bd80      	pop	{r7, pc}
   26f1c:	0002b570 	.word	0x0002b570

00026f20 <nrf_sdh_enable_request>:


ret_code_t nrf_sdh_enable_request(void)
{
   26f20:	b580      	push	{r7, lr}
   26f22:	b082      	sub	sp, #8
   26f24:	af00      	add	r7, sp, #0
    ret_code_t ret_code;

    if (m_nrf_sdh_enabled)
   26f26:	4b1b      	ldr	r3, [pc, #108]	; (26f94 <nrf_sdh_enable_request+0x74>)
   26f28:	781b      	ldrb	r3, [r3, #0]
   26f2a:	2b00      	cmp	r3, #0
   26f2c:	d001      	beq.n	26f32 <nrf_sdh_enable_request+0x12>
    {
        return NRF_ERROR_INVALID_STATE;
   26f2e:	2308      	movs	r3, #8
   26f30:	e02b      	b.n	26f8a <nrf_sdh_enable_request+0x6a>
    }

    m_nrf_sdh_continue = true;
   26f32:	4b19      	ldr	r3, [pc, #100]	; (26f98 <nrf_sdh_enable_request+0x78>)
   26f34:	2201      	movs	r2, #1
   26f36:	701a      	strb	r2, [r3, #0]

    // Notify observers about SoftDevice enable request.
    if (sdh_request_observer_notify(NRF_SDH_EVT_ENABLE_REQUEST) == NRF_ERROR_BUSY)
   26f38:	2000      	movs	r0, #0
   26f3a:	f7ff ff8f 	bl	26e5c <sdh_request_observer_notify>
   26f3e:	4603      	mov	r3, r0
   26f40:	2b11      	cmp	r3, #17
   26f42:	d101      	bne.n	26f48 <nrf_sdh_enable_request+0x28>
    {
        // Enable process was stopped.
        return NRF_SUCCESS;
   26f44:	2300      	movs	r3, #0
   26f46:	e020      	b.n	26f8a <nrf_sdh_enable_request+0x6a>
    }

    // Notify observers about starting SoftDevice enable process.
    sdh_state_observer_notify(NRF_SDH_EVT_STATE_ENABLE_PREPARE);
   26f48:	2000      	movs	r0, #0
   26f4a:	f7ff ffbb 	bl	26ec4 <sdh_state_observer_notify>

    nrf_clock_lf_cfg_t const clock_lf_cfg =
   26f4e:	4b13      	ldr	r3, [pc, #76]	; (26f9c <nrf_sdh_enable_request+0x7c>)
   26f50:	681b      	ldr	r3, [r3, #0]
   26f52:	603b      	str	r3, [r7, #0]
    };

    #ifdef ANT_LICENSE_KEY
        ret_code = sd_softdevice_enable(&clock_lf_cfg, app_error_fault_handler, ANT_LICENSE_KEY);
    #else
        ret_code = sd_softdevice_enable(&clock_lf_cfg, app_error_fault_handler);
   26f54:	463b      	mov	r3, r7
   26f56:	4912      	ldr	r1, [pc, #72]	; (26fa0 <nrf_sdh_enable_request+0x80>)
   26f58:	4618      	mov	r0, r3
   26f5a:	f7ff ff7a 	bl	26e52 <sd_softdevice_enable>
   26f5e:	6078      	str	r0, [r7, #4]
    #endif

    if (ret_code != NRF_SUCCESS)
   26f60:	687b      	ldr	r3, [r7, #4]
   26f62:	2b00      	cmp	r3, #0
   26f64:	d001      	beq.n	26f6a <nrf_sdh_enable_request+0x4a>
    {
        return ret_code;
   26f66:	687b      	ldr	r3, [r7, #4]
   26f68:	e00f      	b.n	26f8a <nrf_sdh_enable_request+0x6a>
    }

    m_nrf_sdh_enabled   = true;
   26f6a:	4b0a      	ldr	r3, [pc, #40]	; (26f94 <nrf_sdh_enable_request+0x74>)
   26f6c:	2201      	movs	r2, #1
   26f6e:	701a      	strb	r2, [r3, #0]
    m_nrf_sdh_continue  = false;
   26f70:	4b09      	ldr	r3, [pc, #36]	; (26f98 <nrf_sdh_enable_request+0x78>)
   26f72:	2200      	movs	r2, #0
   26f74:	701a      	strb	r2, [r3, #0]
    m_nrf_sdh_suspended = false;
   26f76:	4b0b      	ldr	r3, [pc, #44]	; (26fa4 <nrf_sdh_enable_request+0x84>)
   26f78:	2200      	movs	r2, #0
   26f7a:	701a      	strb	r2, [r3, #0]
    {
        return ret_code;
    }
#else
    //In case of serialization, NVIC must be accessed directly.
    NVIC_EnableIRQ(SD_EVT_IRQn);
   26f7c:	2016      	movs	r0, #22
   26f7e:	f7ff ff45 	bl	26e0c <NVIC_EnableIRQ>
#endif

    // Notify observers about a finished SoftDevice enable process.
    sdh_state_observer_notify(NRF_SDH_EVT_STATE_ENABLED);
   26f82:	2001      	movs	r0, #1
   26f84:	f7ff ff9e 	bl	26ec4 <sdh_state_observer_notify>

    return NRF_SUCCESS;
   26f88:	2300      	movs	r3, #0
}
   26f8a:	4618      	mov	r0, r3
   26f8c:	3708      	adds	r7, #8
   26f8e:	46bd      	mov	sp, r7
   26f90:	bd80      	pop	{r7, pc}
   26f92:	bf00      	nop
   26f94:	20005348 	.word	0x20005348
   26f98:	2000534a 	.word	0x2000534a
   26f9c:	0002b588 	.word	0x0002b588
   26fa0:	00026ded 	.word	0x00026ded
   26fa4:	20005349 	.word	0x20005349

00026fa8 <nrf_sdh_evts_poll>:
    return (!m_nrf_sdh_enabled) || (m_nrf_sdh_suspended);
}


void nrf_sdh_evts_poll(void)
{
   26fa8:	b580      	push	{r7, lr}
   26faa:	b084      	sub	sp, #16
   26fac:	af00      	add	r7, sp, #0
    nrf_section_iter_t iter;

    // Notify observers about pending SoftDevice event.
    for (nrf_section_iter_init(&iter, &sdh_stack_observers);
   26fae:	463b      	mov	r3, r7
   26fb0:	4910      	ldr	r1, [pc, #64]	; (26ff4 <nrf_sdh_evts_poll+0x4c>)
   26fb2:	4618      	mov	r0, r3
   26fb4:	f000 f980 	bl	272b8 <nrf_section_iter_init>
   26fb8:	e010      	b.n	26fdc <nrf_sdh_evts_poll+0x34>
         nrf_section_iter_next(&iter))
    {
        nrf_sdh_stack_observer_t    * p_observer;
        nrf_sdh_stack_evt_handler_t   handler;

        p_observer = (nrf_sdh_stack_observer_t *) nrf_section_iter_get(&iter);
   26fba:	463b      	mov	r3, r7
   26fbc:	4618      	mov	r0, r3
   26fbe:	f7ff ff3d 	bl	26e3c <nrf_section_iter_get>
   26fc2:	60f8      	str	r0, [r7, #12]
        handler    = p_observer->handler;
   26fc4:	68fb      	ldr	r3, [r7, #12]
   26fc6:	681b      	ldr	r3, [r3, #0]
   26fc8:	60bb      	str	r3, [r7, #8]

        handler(p_observer->p_context);
   26fca:	68fb      	ldr	r3, [r7, #12]
   26fcc:	685a      	ldr	r2, [r3, #4]
   26fce:	68bb      	ldr	r3, [r7, #8]
   26fd0:	4610      	mov	r0, r2
   26fd2:	4798      	blx	r3
         nrf_section_iter_next(&iter))
   26fd4:	463b      	mov	r3, r7
   26fd6:	4618      	mov	r0, r3
   26fd8:	f000 f98a 	bl	272f0 <nrf_section_iter_next>
         nrf_section_iter_get(&iter) != NULL;
   26fdc:	463b      	mov	r3, r7
   26fde:	4618      	mov	r0, r3
   26fe0:	f7ff ff2c 	bl	26e3c <nrf_section_iter_get>
   26fe4:	4603      	mov	r3, r0
    for (nrf_section_iter_init(&iter, &sdh_stack_observers);
   26fe6:	2b00      	cmp	r3, #0
   26fe8:	d1e7      	bne.n	26fba <nrf_sdh_evts_poll+0x12>
    }
}
   26fea:	bf00      	nop
   26fec:	3710      	adds	r7, #16
   26fee:	46bd      	mov	sp, r7
   26ff0:	bd80      	pop	{r7, pc}
   26ff2:	bf00      	nop
   26ff4:	0002b57c 	.word	0x0002b57c

00026ff8 <SWI2_EGU2_IRQHandler>:


#if (NRF_SDH_DISPATCH_MODEL == NRF_SDH_DISPATCH_MODEL_INTERRUPT)

void SD_EVT_IRQHandler(void)
{
   26ff8:	b580      	push	{r7, lr}
   26ffa:	af00      	add	r7, sp, #0
    nrf_sdh_evts_poll();
   26ffc:	f7ff ffd4 	bl	26fa8 <nrf_sdh_evts_poll>
}
   27000:	bf00      	nop
   27002:	bd80      	pop	{r7, pc}

00027004 <sd_ble_enable>:
SVCALL(SD_BLE_ENABLE, uint32_t, sd_ble_enable(uint32_t * p_app_ram_base));
   27004:	df60      	svc	96	; 0x60
   27006:	4770      	bx	lr
   27008:	bf00      	nop
   2700a:	4618      	mov	r0, r3

0002700c <sd_ble_cfg_set>:
SVCALL(SD_BLE_CFG_SET, uint32_t, sd_ble_cfg_set(uint32_t cfg_id, ble_cfg_t const * p_cfg, uint32_t app_ram_base));
   2700c:	df69      	svc	105	; 0x69
   2700e:	4770      	bx	lr
   27010:	bf00      	nop
   27012:	4618      	mov	r0, r3

00027014 <sd_ble_evt_get>:
SVCALL(SD_BLE_EVT_GET, uint32_t, sd_ble_evt_get(uint8_t *p_dest, uint16_t *p_len));
   27014:	df61      	svc	97	; 0x61
   27016:	4770      	bx	lr
   27018:	bf00      	nop
   2701a:	4618      	mov	r0, r3

0002701c <nrf_section_iter_get>:
{
   2701c:	b480      	push	{r7}
   2701e:	b083      	sub	sp, #12
   27020:	af00      	add	r7, sp, #0
   27022:	6078      	str	r0, [r7, #4]
    return p_iter->p_item;
   27024:	687b      	ldr	r3, [r7, #4]
   27026:	685b      	ldr	r3, [r3, #4]
}
   27028:	4618      	mov	r0, r3
   2702a:	370c      	adds	r7, #12
   2702c:	46bd      	mov	sp, r7
   2702e:	bc80      	pop	{r7}
   27030:	4770      	bx	lr
	...

00027034 <nrf_sdh_ble_app_ram_start_get>:
#define RAM_START       0x20000000
#define APP_RAM_START   (uint32_t)m_ram_start


ret_code_t nrf_sdh_ble_app_ram_start_get(uint32_t * p_app_ram_start)
{
   27034:	b480      	push	{r7}
   27036:	b083      	sub	sp, #12
   27038:	af00      	add	r7, sp, #0
   2703a:	6078      	str	r0, [r7, #4]
    if (p_app_ram_start == NULL)
   2703c:	687b      	ldr	r3, [r7, #4]
   2703e:	2b00      	cmp	r3, #0
   27040:	d101      	bne.n	27046 <nrf_sdh_ble_app_ram_start_get+0x12>
    {
        return NRF_ERROR_NULL;
   27042:	230e      	movs	r3, #14
   27044:	e004      	b.n	27050 <nrf_sdh_ble_app_ram_start_get+0x1c>
    }

    *p_app_ram_start = APP_RAM_START;
   27046:	4b05      	ldr	r3, [pc, #20]	; (2705c <nrf_sdh_ble_app_ram_start_get+0x28>)
   27048:	461a      	mov	r2, r3
   2704a:	687b      	ldr	r3, [r7, #4]
   2704c:	601a      	str	r2, [r3, #0]

    return NRF_SUCCESS;
   2704e:	2300      	movs	r3, #0
}
   27050:	4618      	mov	r0, r3
   27052:	370c      	adds	r7, #12
   27054:	46bd      	mov	sp, r7
   27056:	bc80      	pop	{r7}
   27058:	4770      	bx	lr
   2705a:	bf00      	nop
   2705c:	20005000 	.word	0x20005000

00027060 <nrf_sdh_ble_default_cfg_set>:


ret_code_t nrf_sdh_ble_default_cfg_set(uint8_t conn_cfg_tag, uint32_t * p_ram_start)
{
   27060:	b580      	push	{r7, lr}
   27062:	b088      	sub	sp, #32
   27064:	af00      	add	r7, sp, #0
   27066:	4603      	mov	r3, r0
   27068:	6039      	str	r1, [r7, #0]
   2706a:	71fb      	strb	r3, [r7, #7]
    uint32_t ret_code;

    ret_code = nrf_sdh_ble_app_ram_start_get(p_ram_start);
   2706c:	6838      	ldr	r0, [r7, #0]
   2706e:	f7ff ffe1 	bl	27034 <nrf_sdh_ble_app_ram_start_get>
   27072:	61f8      	str	r0, [r7, #28]
    if (ret_code != NRF_SUCCESS)
   27074:	69fb      	ldr	r3, [r7, #28]
   27076:	2b00      	cmp	r3, #0
   27078:	d001      	beq.n	2707e <nrf_sdh_ble_default_cfg_set+0x1e>
    {
        return ret_code;
   2707a:	69fb      	ldr	r3, [r7, #28]
   2707c:	e069      	b.n	27152 <nrf_sdh_ble_default_cfg_set+0xf2>
    // message will be printed to the user suggesting the correct value.
    ble_cfg_t ble_cfg;

#if (NRF_SDH_BLE_TOTAL_LINK_COUNT != 0)
    // Configure the connection count.
    memset(&ble_cfg, 0, sizeof(ble_cfg));
   2707e:	f107 0310 	add.w	r3, r7, #16
   27082:	220c      	movs	r2, #12
   27084:	2100      	movs	r1, #0
   27086:	4618      	mov	r0, r3
   27088:	f7fc fac8 	bl	2361c <memset>
    ble_cfg.conn_cfg.conn_cfg_tag                     = conn_cfg_tag;
   2708c:	79fb      	ldrb	r3, [r7, #7]
   2708e:	743b      	strb	r3, [r7, #16]
    ble_cfg.conn_cfg.params.gap_conn_cfg.conn_count   = NRF_SDH_BLE_TOTAL_LINK_COUNT;
   27090:	2302      	movs	r3, #2
   27092:	74bb      	strb	r3, [r7, #18]
    ble_cfg.conn_cfg.params.gap_conn_cfg.event_length = NRF_SDH_BLE_GAP_EVENT_LENGTH;
   27094:	2303      	movs	r3, #3
   27096:	82bb      	strh	r3, [r7, #20]

    ret_code = sd_ble_cfg_set(BLE_CONN_CFG_GAP, &ble_cfg, *p_ram_start);
   27098:	683b      	ldr	r3, [r7, #0]
   2709a:	681a      	ldr	r2, [r3, #0]
   2709c:	f107 0310 	add.w	r3, r7, #16
   270a0:	4619      	mov	r1, r3
   270a2:	2020      	movs	r0, #32
   270a4:	f7ff ffb2 	bl	2700c <sd_ble_cfg_set>
   270a8:	61f8      	str	r0, [r7, #28]
                      nrf_strerror_get(ret_code));

    }

    // Configure the connection roles.
    memset(&ble_cfg, 0, sizeof(ble_cfg));
   270aa:	f107 0310 	add.w	r3, r7, #16
   270ae:	220c      	movs	r2, #12
   270b0:	2100      	movs	r1, #0
   270b2:	4618      	mov	r0, r3
   270b4:	f7fc fab2 	bl	2361c <memset>
    ble_cfg.gap_cfg.role_count_cfg.periph_role_count  = NRF_SDH_BLE_PERIPHERAL_LINK_COUNT;
   270b8:	2301      	movs	r3, #1
   270ba:	743b      	strb	r3, [r7, #16]
    ble_cfg.gap_cfg.role_count_cfg.central_role_count = NRF_SDH_BLE_CENTRAL_LINK_COUNT;
   270bc:	2301      	movs	r3, #1
   270be:	747b      	strb	r3, [r7, #17]
    ble_cfg.gap_cfg.role_count_cfg.central_sec_count  = NRF_SDH_BLE_CENTRAL_LINK_COUNT ?
   270c0:	2301      	movs	r3, #1
   270c2:	74bb      	strb	r3, [r7, #18]
                                                        BLE_GAP_ROLE_COUNT_CENTRAL_SEC_DEFAULT : 0;

    ret_code = sd_ble_cfg_set(BLE_GAP_CFG_ROLE_COUNT, &ble_cfg, *p_ram_start);
   270c4:	683b      	ldr	r3, [r7, #0]
   270c6:	681a      	ldr	r2, [r3, #0]
   270c8:	f107 0310 	add.w	r3, r7, #16
   270cc:	4619      	mov	r1, r3
   270ce:	2040      	movs	r0, #64	; 0x40
   270d0:	f7ff ff9c 	bl	2700c <sd_ble_cfg_set>
   270d4:	61f8      	str	r0, [r7, #28]
#endif

#endif  // NRF_SDH_BLE_TOTAL_LINK_COUNT

    // Configure number of custom UUIDS.
    memset(&ble_cfg, 0, sizeof(ble_cfg));
   270d6:	f107 0310 	add.w	r3, r7, #16
   270da:	220c      	movs	r2, #12
   270dc:	2100      	movs	r1, #0
   270de:	4618      	mov	r0, r3
   270e0:	f7fc fa9c 	bl	2361c <memset>
    ble_cfg.common_cfg.vs_uuid_cfg.vs_uuid_count = NRF_SDH_BLE_VS_UUID_COUNT;
   270e4:	2301      	movs	r3, #1
   270e6:	743b      	strb	r3, [r7, #16]

    ret_code = sd_ble_cfg_set(BLE_COMMON_CFG_VS_UUID, &ble_cfg, *p_ram_start);
   270e8:	683b      	ldr	r3, [r7, #0]
   270ea:	681a      	ldr	r2, [r3, #0]
   270ec:	f107 0310 	add.w	r3, r7, #16
   270f0:	4619      	mov	r1, r3
   270f2:	2001      	movs	r0, #1
   270f4:	f7ff ff8a 	bl	2700c <sd_ble_cfg_set>
   270f8:	61f8      	str	r0, [r7, #28]
        NRF_LOG_ERROR("sd_ble_cfg_set() returned %s when attempting to set BLE_COMMON_CFG_VS_UUID.",
                      nrf_strerror_get(ret_code));
    }

    // Configure the GATTS attribute table.
    memset(&ble_cfg, 0x00, sizeof(ble_cfg));
   270fa:	f107 0310 	add.w	r3, r7, #16
   270fe:	220c      	movs	r2, #12
   27100:	2100      	movs	r1, #0
   27102:	4618      	mov	r0, r3
   27104:	f7fc fa8a 	bl	2361c <memset>
    ble_gatts_cfg_attr_tab_size_t table =
   27108:	f44f 63b0 	mov.w	r3, #1408	; 0x580
   2710c:	60fb      	str	r3, [r7, #12]
    {
        .attr_tab_size = NRF_SDH_BLE_GATTS_ATTR_TAB_SIZE
    };
    ble_cfg.gatts_cfg.attr_tab_size = table;
   2710e:	68fb      	ldr	r3, [r7, #12]
   27110:	613b      	str	r3, [r7, #16]

    ret_code = sd_ble_cfg_set(BLE_GATTS_CFG_ATTR_TAB_SIZE, &ble_cfg, *p_ram_start);
   27112:	683b      	ldr	r3, [r7, #0]
   27114:	681a      	ldr	r2, [r3, #0]
   27116:	f107 0310 	add.w	r3, r7, #16
   2711a:	4619      	mov	r1, r3
   2711c:	20a1      	movs	r0, #161	; 0xa1
   2711e:	f7ff ff75 	bl	2700c <sd_ble_cfg_set>
   27122:	61f8      	str	r0, [r7, #28]
        NRF_LOG_ERROR("sd_ble_cfg_set() returned %s when attempting to set BLE_GATTS_CFG_ATTR_TAB_SIZE.",
                      nrf_strerror_get(ret_code));
    }

    // Configure Service Changed characteristic.
    memset(&ble_cfg, 0x00, sizeof(ble_cfg));
   27124:	f107 0310 	add.w	r3, r7, #16
   27128:	220c      	movs	r2, #12
   2712a:	2100      	movs	r1, #0
   2712c:	4618      	mov	r0, r3
   2712e:	f7fc fa75 	bl	2361c <memset>
    ble_gatts_cfg_service_changed_t sc =
   27132:	7a3b      	ldrb	r3, [r7, #8]
   27134:	f36f 0300 	bfc	r3, #0, #1
   27138:	723b      	strb	r3, [r7, #8]
    {
        .service_changed = NRF_SDH_BLE_SERVICE_CHANGED
    };
    ble_cfg.gatts_cfg.service_changed = sc;
   2713a:	7a3b      	ldrb	r3, [r7, #8]
   2713c:	743b      	strb	r3, [r7, #16]

    ret_code = sd_ble_cfg_set(BLE_GATTS_CFG_SERVICE_CHANGED, &ble_cfg, *p_ram_start);
   2713e:	683b      	ldr	r3, [r7, #0]
   27140:	681a      	ldr	r2, [r3, #0]
   27142:	f107 0310 	add.w	r3, r7, #16
   27146:	4619      	mov	r1, r3
   27148:	20a0      	movs	r0, #160	; 0xa0
   2714a:	f7ff ff5f 	bl	2700c <sd_ble_cfg_set>
   2714e:	61f8      	str	r0, [r7, #28]
    {
        NRF_LOG_ERROR("sd_ble_cfg_set() returned %s when attempting to set BLE_GATTS_CFG_SERVICE_CHANGED.",
                      nrf_strerror_get(ret_code));
    }

    return NRF_SUCCESS;
   27150:	2300      	movs	r3, #0
}
   27152:	4618      	mov	r0, r3
   27154:	3720      	adds	r7, #32
   27156:	46bd      	mov	sp, r7
   27158:	bd80      	pop	{r7, pc}

0002715a <nrf_sdh_ble_enable>:
    return RAM_START + ram_total_size;
}


ret_code_t nrf_sdh_ble_enable(uint32_t * const p_app_ram_start)
{
   2715a:	b580      	push	{r7, lr}
   2715c:	b084      	sub	sp, #16
   2715e:	af00      	add	r7, sp, #0
   27160:	6078      	str	r0, [r7, #4]
    uint32_t const app_ram_start = *p_app_ram_start;
   27162:	687b      	ldr	r3, [r7, #4]
   27164:	681b      	ldr	r3, [r3, #0]
   27166:	60fb      	str	r3, [r7, #12]

    NRF_LOG_DEBUG("RAM starts at 0x%x", *p_app_ram_start);

    ret_code_t ret_code = sd_ble_enable(p_app_ram_start);
   27168:	6878      	ldr	r0, [r7, #4]
   2716a:	f7ff ff4b 	bl	27004 <sd_ble_enable>
   2716e:	60b8      	str	r0, [r7, #8]
    if (ret_code != NRF_SUCCESS)
    {
        NRF_LOG_ERROR("sd_ble_enable() returned %s.", nrf_strerror_get(ret_code));
    }

    return ret_code;
   27170:	68bb      	ldr	r3, [r7, #8]
}
   27172:	4618      	mov	r0, r3
   27174:	3710      	adds	r7, #16
   27176:	46bd      	mov	sp, r7
   27178:	bd80      	pop	{r7, pc}
	...

0002717c <nrf_sdh_ble_evts_poll>:
/**@brief       Function for polling BLE events.
 *
 * @param[in]   p_context   Context of the observer.
 */
static void nrf_sdh_ble_evts_poll(void * p_context)
{
   2717c:	b580      	push	{r7, lr}
   2717e:	b098      	sub	sp, #96	; 0x60
   27180:	af00      	add	r7, sp, #0
   27182:	6078      	str	r0, [r7, #4]
    while (true)
    {
        __ALIGN(4) uint8_t evt_buffer[NRF_SDH_BLE_EVT_BUF_SIZE];

        ble_evt_t * p_ble_evt;
        uint16_t    evt_len = (uint16_t)sizeof(evt_buffer);
   27184:	2338      	movs	r3, #56	; 0x38
   27186:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

        ret_code = sd_ble_evt_get(evt_buffer, &evt_len);
   2718a:	f107 024e 	add.w	r2, r7, #78	; 0x4e
   2718e:	f107 030c 	add.w	r3, r7, #12
   27192:	4611      	mov	r1, r2
   27194:	4618      	mov	r0, r3
   27196:	f7ff ff3d 	bl	27014 <sd_ble_evt_get>
   2719a:	65f8      	str	r0, [r7, #92]	; 0x5c
        if (ret_code != NRF_SUCCESS)
   2719c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   2719e:	2b00      	cmp	r3, #0
   271a0:	d003      	beq.n	271aa <nrf_sdh_ble_evts_poll+0x2e>

            handler(p_ble_evt, p_observer->p_context);
        }
    }

    if (ret_code != NRF_ERROR_NOT_FOUND)
   271a2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   271a4:	2b05      	cmp	r3, #5
   271a6:	d127      	bne.n	271f8 <nrf_sdh_ble_evts_poll+0x7c>
    {
        APP_ERROR_HANDLER(ret_code);
    }
}
   271a8:	e02c      	b.n	27204 <nrf_sdh_ble_evts_poll+0x88>
        p_ble_evt = (ble_evt_t *)evt_buffer;
   271aa:	f107 030c 	add.w	r3, r7, #12
   271ae:	65bb      	str	r3, [r7, #88]	; 0x58
        for (nrf_section_iter_init(&iter, &sdh_ble_observers);
   271b0:	f107 0344 	add.w	r3, r7, #68	; 0x44
   271b4:	4915      	ldr	r1, [pc, #84]	; (2720c <nrf_sdh_ble_evts_poll+0x90>)
   271b6:	4618      	mov	r0, r3
   271b8:	f000 f87e 	bl	272b8 <nrf_section_iter_init>
   271bc:	e013      	b.n	271e6 <nrf_sdh_ble_evts_poll+0x6a>
            p_observer = (nrf_sdh_ble_evt_observer_t *)nrf_section_iter_get(&iter);
   271be:	f107 0344 	add.w	r3, r7, #68	; 0x44
   271c2:	4618      	mov	r0, r3
   271c4:	f7ff ff2a 	bl	2701c <nrf_section_iter_get>
   271c8:	6578      	str	r0, [r7, #84]	; 0x54
            handler    = p_observer->handler;
   271ca:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   271cc:	681b      	ldr	r3, [r3, #0]
   271ce:	653b      	str	r3, [r7, #80]	; 0x50
            handler(p_ble_evt, p_observer->p_context);
   271d0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   271d2:	685a      	ldr	r2, [r3, #4]
   271d4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   271d6:	4611      	mov	r1, r2
   271d8:	6db8      	ldr	r0, [r7, #88]	; 0x58
   271da:	4798      	blx	r3
             nrf_section_iter_next(&iter))
   271dc:	f107 0344 	add.w	r3, r7, #68	; 0x44
   271e0:	4618      	mov	r0, r3
   271e2:	f000 f885 	bl	272f0 <nrf_section_iter_next>
             nrf_section_iter_get(&iter) != NULL;
   271e6:	f107 0344 	add.w	r3, r7, #68	; 0x44
   271ea:	4618      	mov	r0, r3
   271ec:	f7ff ff16 	bl	2701c <nrf_section_iter_get>
   271f0:	4603      	mov	r3, r0
        for (nrf_section_iter_init(&iter, &sdh_ble_observers);
   271f2:	2b00      	cmp	r3, #0
   271f4:	d1e3      	bne.n	271be <nrf_sdh_ble_evts_poll+0x42>
    {
   271f6:	e7c5      	b.n	27184 <nrf_sdh_ble_evts_poll+0x8>
        APP_ERROR_HANDLER(ret_code);
   271f8:	4a05      	ldr	r2, [pc, #20]	; (27210 <nrf_sdh_ble_evts_poll+0x94>)
   271fa:	f240 1123 	movw	r1, #291	; 0x123
   271fe:	6df8      	ldr	r0, [r7, #92]	; 0x5c
   27200:	f7ff fd8e 	bl	26d20 <app_error_handler>
}
   27204:	bf00      	nop
   27206:	3760      	adds	r7, #96	; 0x60
   27208:	46bd      	mov	sp, r7
   2720a:	bd80      	pop	{r7, pc}
   2720c:	0002b58c 	.word	0x0002b58c
   27210:	0002b598 	.word	0x0002b598

00027214 <nrf_section_iter_get>:
{
   27214:	b480      	push	{r7}
   27216:	b083      	sub	sp, #12
   27218:	af00      	add	r7, sp, #0
   2721a:	6078      	str	r0, [r7, #4]
    return p_iter->p_item;
   2721c:	687b      	ldr	r3, [r7, #4]
   2721e:	685b      	ldr	r3, [r3, #4]
}
   27220:	4618      	mov	r0, r3
   27222:	370c      	adds	r7, #12
   27224:	46bd      	mov	sp, r7
   27226:	bc80      	pop	{r7}
   27228:	4770      	bx	lr

0002722a <sd_evt_get>:
SVCALL(SD_EVT_GET, uint32_t, sd_evt_get(uint32_t * p_evt_id));
   2722a:	df48      	svc	72	; 0x48
   2722c:	4770      	bx	lr
   2722e:	bf00      	nop
   27230:	4618      	mov	r0, r3
	...

00027234 <nrf_sdh_soc_evts_poll>:
/**@brief   Function for polling SoC events.
 *
 * @param[in]   p_context   Context of the observer.
 */
static void nrf_sdh_soc_evts_poll(void * p_context)
{
   27234:	b580      	push	{r7, lr}
   27236:	b088      	sub	sp, #32
   27238:	af00      	add	r7, sp, #0
   2723a:	6078      	str	r0, [r7, #4]

    while (true)
    {
        uint32_t evt_id;

        ret_code = sd_evt_get(&evt_id);
   2723c:	f107 0310 	add.w	r3, r7, #16
   27240:	4618      	mov	r0, r3
   27242:	f7ff fff2 	bl	2722a <sd_evt_get>
   27246:	61f8      	str	r0, [r7, #28]
        if (ret_code != NRF_SUCCESS)
   27248:	69fb      	ldr	r3, [r7, #28]
   2724a:	2b00      	cmp	r3, #0
   2724c:	d003      	beq.n	27256 <nrf_sdh_soc_evts_poll+0x22>

            handler(evt_id, p_observer->p_context);
        }
    }

    if (ret_code != NRF_ERROR_NOT_FOUND)
   2724e:	69fb      	ldr	r3, [r7, #28]
   27250:	2b05      	cmp	r3, #5
   27252:	d124      	bne.n	2729e <nrf_sdh_soc_evts_poll+0x6a>
    {
        APP_ERROR_HANDLER(ret_code);
    }
}
   27254:	e028      	b.n	272a8 <nrf_sdh_soc_evts_poll+0x74>
        for (nrf_section_iter_init(&iter, &sdh_soc_observers);
   27256:	f107 0308 	add.w	r3, r7, #8
   2725a:	4915      	ldr	r1, [pc, #84]	; (272b0 <nrf_sdh_soc_evts_poll+0x7c>)
   2725c:	4618      	mov	r0, r3
   2725e:	f000 f82b 	bl	272b8 <nrf_section_iter_init>
   27262:	e013      	b.n	2728c <nrf_sdh_soc_evts_poll+0x58>
            p_observer = (nrf_sdh_soc_evt_observer_t *) nrf_section_iter_get(&iter);
   27264:	f107 0308 	add.w	r3, r7, #8
   27268:	4618      	mov	r0, r3
   2726a:	f7ff ffd3 	bl	27214 <nrf_section_iter_get>
   2726e:	61b8      	str	r0, [r7, #24]
            handler    = p_observer->handler;
   27270:	69bb      	ldr	r3, [r7, #24]
   27272:	681b      	ldr	r3, [r3, #0]
   27274:	617b      	str	r3, [r7, #20]
            handler(evt_id, p_observer->p_context);
   27276:	693a      	ldr	r2, [r7, #16]
   27278:	69bb      	ldr	r3, [r7, #24]
   2727a:	6859      	ldr	r1, [r3, #4]
   2727c:	697b      	ldr	r3, [r7, #20]
   2727e:	4610      	mov	r0, r2
   27280:	4798      	blx	r3
             nrf_section_iter_next(&iter))
   27282:	f107 0308 	add.w	r3, r7, #8
   27286:	4618      	mov	r0, r3
   27288:	f000 f832 	bl	272f0 <nrf_section_iter_next>
             nrf_section_iter_get(&iter) != NULL;
   2728c:	f107 0308 	add.w	r3, r7, #8
   27290:	4618      	mov	r0, r3
   27292:	f7ff ffbf 	bl	27214 <nrf_section_iter_get>
   27296:	4603      	mov	r3, r0
        for (nrf_section_iter_init(&iter, &sdh_soc_observers);
   27298:	2b00      	cmp	r3, #0
   2729a:	d1e3      	bne.n	27264 <nrf_sdh_soc_evts_poll+0x30>
    {
   2729c:	e7ce      	b.n	2723c <nrf_sdh_soc_evts_poll+0x8>
        APP_ERROR_HANDLER(ret_code);
   2729e:	4a05      	ldr	r2, [pc, #20]	; (272b4 <nrf_sdh_soc_evts_poll+0x80>)
   272a0:	216b      	movs	r1, #107	; 0x6b
   272a2:	69f8      	ldr	r0, [r7, #28]
   272a4:	f7ff fd3c 	bl	26d20 <app_error_handler>
}
   272a8:	bf00      	nop
   272aa:	3720      	adds	r7, #32
   272ac:	46bd      	mov	sp, r7
   272ae:	bd80      	pop	{r7, pc}
   272b0:	0002b5d4 	.word	0x0002b5d4
   272b4:	0002b5e0 	.word	0x0002b5e0

000272b8 <nrf_section_iter_init>:
}
#endif


void nrf_section_iter_init(nrf_section_iter_t * p_iter, nrf_section_set_t const * p_set)
{
   272b8:	b480      	push	{r7}
   272ba:	b083      	sub	sp, #12
   272bc:	af00      	add	r7, sp, #0
   272be:	6078      	str	r0, [r7, #4]
   272c0:	6039      	str	r1, [r7, #0]
    ASSERT(p_iter != NULL);
    ASSERT(p_set  != NULL);

    p_iter->p_set = p_set;
   272c2:	687b      	ldr	r3, [r7, #4]
   272c4:	683a      	ldr	r2, [r7, #0]
   272c6:	601a      	str	r2, [r3, #0]

#if defined(__GNUC__)
    p_iter->p_item = p_iter->p_set->section.p_start;
   272c8:	687b      	ldr	r3, [r7, #4]
   272ca:	681b      	ldr	r3, [r3, #0]
   272cc:	681a      	ldr	r2, [r3, #0]
   272ce:	687b      	ldr	r3, [r7, #4]
   272d0:	605a      	str	r2, [r3, #4]
    if (p_iter->p_item == p_iter->p_set->section.p_end)
   272d2:	687b      	ldr	r3, [r7, #4]
   272d4:	685a      	ldr	r2, [r3, #4]
   272d6:	687b      	ldr	r3, [r7, #4]
   272d8:	681b      	ldr	r3, [r3, #0]
   272da:	685b      	ldr	r3, [r3, #4]
   272dc:	429a      	cmp	r2, r3
   272de:	d102      	bne.n	272e6 <nrf_section_iter_init+0x2e>
    {
        p_iter->p_item = NULL;
   272e0:	687b      	ldr	r3, [r7, #4]
   272e2:	2200      	movs	r2, #0
   272e4:	605a      	str	r2, [r3, #4]
    }
#else
    p_iter->p_section = p_set->p_first;
    nrf_section_iter_item_set(p_iter);
#endif
}
   272e6:	bf00      	nop
   272e8:	370c      	adds	r7, #12
   272ea:	46bd      	mov	sp, r7
   272ec:	bc80      	pop	{r7}
   272ee:	4770      	bx	lr

000272f0 <nrf_section_iter_next>:

void nrf_section_iter_next(nrf_section_iter_t * p_iter)
{
   272f0:	b480      	push	{r7}
   272f2:	b083      	sub	sp, #12
   272f4:	af00      	add	r7, sp, #0
   272f6:	6078      	str	r0, [r7, #4]
    ASSERT(p_iter        != NULL);
    ASSERT(p_iter->p_set != NULL);

    if (p_iter->p_item == NULL)
   272f8:	687b      	ldr	r3, [r7, #4]
   272fa:	685b      	ldr	r3, [r3, #4]
   272fc:	2b00      	cmp	r3, #0
   272fe:	d014      	beq.n	2732a <nrf_section_iter_next+0x3a>
    {
        return;
    }

    p_iter->p_item = (void *)((size_t)(p_iter->p_item) + p_iter->p_set->item_size);
   27300:	687b      	ldr	r3, [r7, #4]
   27302:	685b      	ldr	r3, [r3, #4]
   27304:	461a      	mov	r2, r3
   27306:	687b      	ldr	r3, [r7, #4]
   27308:	681b      	ldr	r3, [r3, #0]
   2730a:	689b      	ldr	r3, [r3, #8]
   2730c:	4413      	add	r3, r2
   2730e:	461a      	mov	r2, r3
   27310:	687b      	ldr	r3, [r7, #4]
   27312:	605a      	str	r2, [r3, #4]

#if defined(__GNUC__)
    if (p_iter->p_item == p_iter->p_set->section.p_end)
   27314:	687b      	ldr	r3, [r7, #4]
   27316:	685a      	ldr	r2, [r3, #4]
   27318:	687b      	ldr	r3, [r7, #4]
   2731a:	681b      	ldr	r3, [r3, #0]
   2731c:	685b      	ldr	r3, [r3, #4]
   2731e:	429a      	cmp	r2, r3
   27320:	d104      	bne.n	2732c <nrf_section_iter_next+0x3c>
    {
        p_iter->p_item = NULL;
   27322:	687b      	ldr	r3, [r7, #4]
   27324:	2200      	movs	r2, #0
   27326:	605a      	str	r2, [r3, #4]
   27328:	e000      	b.n	2732c <nrf_section_iter_next+0x3c>
        return;
   2732a:	bf00      	nop
    {
        p_iter->p_section++;
        nrf_section_iter_item_set(p_iter);
    }
#endif
}
   2732c:	370c      	adds	r7, #12
   2732e:	46bd      	mov	sp, r7
   27330:	bc80      	pop	{r7}
   27332:	4770      	bx	lr

00027334 <sd_ble_gap_data_length_update>:
 * @retval ::NRF_ERROR_RESOURCES The requested parameters can not be accommodated. Inspect
 *                               p_dl_limitation so see where the limitation is.
 * @retval ::NRF_ERROR_BUSY Peer has already initiated a Data Length Update Procedure. Process the
 *                          pending @ref BLE_GAP_EVT_DATA_LENGTH_UPDATE_REQUEST event to respond.
 */
SVCALL(SD_BLE_GAP_DATA_LENGTH_UPDATE, uint32_t, sd_ble_gap_data_length_update(uint16_t conn_handle, ble_gap_data_length_params_t const *p_dl_params, ble_gap_data_length_limitation_t *p_dl_limitation));
   27334:	df90      	svc	144	; 0x90
   27336:	4770      	bx	lr
   27338:	bf00      	nop
   2733a:	4618      	mov	r0, r3

0002733c <sd_ble_gattc_exchange_mtu_request>:
 * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle.
 * @retval ::NRF_ERROR_INVALID_STATE Invalid connection state or an ATT_MTU exchange was already requested once.
 * @retval ::NRF_ERROR_INVALID_PARAM Invalid Client RX MTU size supplied.
 * @retval ::NRF_ERROR_BUSY Client procedure already in progress.
 */
SVCALL(SD_BLE_GATTC_EXCHANGE_MTU_REQUEST, uint32_t, sd_ble_gattc_exchange_mtu_request(uint16_t conn_handle, uint16_t client_rx_mtu));
   2733c:	df9e      	svc	158	; 0x9e
   2733e:	4770      	bx	lr
   27340:	bf00      	nop
   27342:	4618      	mov	r0, r3

00027344 <sd_ble_gatts_exchange_mtu_reply>:
 * @retval ::NRF_SUCCESS Successfully sent response to the client.
 * @retval ::BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
 * @retval ::NRF_ERROR_INVALID_STATE Invalid Connection State or no ATT_MTU exchange request pending.
 * @retval ::NRF_ERROR_INVALID_PARAM Invalid Server RX MTU size supplied.
 */
SVCALL(SD_BLE_GATTS_EXCHANGE_MTU_REPLY, uint32_t, sd_ble_gatts_exchange_mtu_reply(uint16_t conn_handle, uint16_t server_rx_mtu));
   27344:	dfad      	svc	173	; 0xad
   27346:	4770      	bx	lr
   27348:	bf00      	nop
   2734a:	4618      	mov	r0, r3

0002734c <link_init>:
STATIC_ASSERT(NRF_SDH_BLE_GATT_MAX_MTU_SIZE + L2CAP_HDR_LEN <= 255);


/**@brief Initialize a link's parameters to defaults. */
static void link_init(nrf_ble_gatt_link_t * p_link)
{
   2734c:	b480      	push	{r7}
   2734e:	b083      	sub	sp, #12
   27350:	af00      	add	r7, sp, #0
   27352:	6078      	str	r0, [r7, #4]
    p_link->att_mtu_desired            = NRF_SDH_BLE_GATT_MAX_MTU_SIZE;
   27354:	687b      	ldr	r3, [r7, #4]
   27356:	2217      	movs	r2, #23
   27358:	801a      	strh	r2, [r3, #0]
    p_link->att_mtu_effective          = BLE_GATT_ATT_MTU_DEFAULT;
   2735a:	687b      	ldr	r3, [r7, #4]
   2735c:	2217      	movs	r2, #23
   2735e:	805a      	strh	r2, [r3, #2]
    p_link->att_mtu_exchange_pending   = false;
   27360:	687b      	ldr	r3, [r7, #4]
   27362:	2200      	movs	r2, #0
   27364:	711a      	strb	r2, [r3, #4]
    p_link->att_mtu_exchange_requested = false;
   27366:	687b      	ldr	r3, [r7, #4]
   27368:	2200      	movs	r2, #0
   2736a:	715a      	strb	r2, [r3, #5]
    p_link->data_length_desired        = NRF_SDH_BLE_GATT_MAX_MTU_SIZE + L2CAP_HDR_LEN;
   2736c:	687b      	ldr	r3, [r7, #4]
   2736e:	221b      	movs	r2, #27
   27370:	719a      	strb	r2, [r3, #6]
    p_link->data_length_effective      = BLE_GATT_ATT_MTU_DEFAULT + L2CAP_HDR_LEN;
   27372:	687b      	ldr	r3, [r7, #4]
   27374:	221b      	movs	r2, #27
   27376:	71da      	strb	r2, [r3, #7]
}
   27378:	bf00      	nop
   2737a:	370c      	adds	r7, #12
   2737c:	46bd      	mov	sp, r7
   2737e:	bc80      	pop	{r7}
   27380:	4770      	bx	lr

00027382 <data_length_update>:
 *          When the peer requests a data length update, sd_ble_gap_data_length_update()
 *          is called directly in response to the BLE_GAP_EVT_DATA_LENGTH_UPDATE event in
 *          on_data_length_update_evt().
 */
static void data_length_update(uint16_t conn_handle, nrf_ble_gatt_t const * p_gatt)
{
   27382:	b580      	push	{r7, lr}
   27384:	b086      	sub	sp, #24
   27386:	af00      	add	r7, sp, #0
   27388:	4603      	mov	r3, r0
   2738a:	6039      	str	r1, [r7, #0]
   2738c:	80fb      	strh	r3, [r7, #6]
                  p_gatt->links[conn_handle].data_length_desired, conn_handle);

    ble_gap_data_length_params_t const dlp =
    {
        .max_rx_octets  = p_gatt->links[conn_handle].data_length_desired,
        .max_tx_octets  = p_gatt->links[conn_handle].data_length_desired,
   2738e:	88fb      	ldrh	r3, [r7, #6]
   27390:	683a      	ldr	r2, [r7, #0]
   27392:	00db      	lsls	r3, r3, #3
   27394:	4413      	add	r3, r2
   27396:	7b1b      	ldrb	r3, [r3, #12]
   27398:	b29b      	uxth	r3, r3
    ble_gap_data_length_params_t const dlp =
   2739a:	81bb      	strh	r3, [r7, #12]
        .max_rx_octets  = p_gatt->links[conn_handle].data_length_desired,
   2739c:	88fb      	ldrh	r3, [r7, #6]
   2739e:	683a      	ldr	r2, [r7, #0]
   273a0:	00db      	lsls	r3, r3, #3
   273a2:	4413      	add	r3, r2
   273a4:	7b1b      	ldrb	r3, [r3, #12]
   273a6:	b29b      	uxth	r3, r3
    ble_gap_data_length_params_t const dlp =
   273a8:	81fb      	strh	r3, [r7, #14]
   273aa:	2300      	movs	r3, #0
   273ac:	823b      	strh	r3, [r7, #16]
   273ae:	2300      	movs	r3, #0
   273b0:	827b      	strh	r3, [r7, #18]
        .max_rx_time_us = BLE_GAP_DATA_LENGTH_AUTO,
        .max_tx_time_us = BLE_GAP_DATA_LENGTH_AUTO,
    };

    ret_code_t err_code = sd_ble_gap_data_length_update(conn_handle, &dlp, NULL);
   273b2:	f107 010c 	add.w	r1, r7, #12
   273b6:	88fb      	ldrh	r3, [r7, #6]
   273b8:	2200      	movs	r2, #0
   273ba:	4618      	mov	r0, r3
   273bc:	f7ff ffba 	bl	27334 <sd_ble_gap_data_length_update>
   273c0:	6178      	str	r0, [r7, #20]
    {
        NRF_LOG_ERROR("sd_ble_gap_data_length_update() (request)"
                      " on connection 0x%x returned unexpected value 0x%x.",
                      conn_handle, err_code);
    }
}
   273c2:	bf00      	nop
   273c4:	3718      	adds	r7, #24
   273c6:	46bd      	mov	sp, r7
   273c8:	bd80      	pop	{r7, pc}

000273ca <on_connected_evt>:
 *
 * @param[in]   p_gatt      GATT structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_connected_evt(nrf_ble_gatt_t * p_gatt, ble_evt_t const * p_ble_evt)
{
   273ca:	b580      	push	{r7, lr}
   273cc:	b086      	sub	sp, #24
   273ce:	af00      	add	r7, sp, #0
   273d0:	6078      	str	r0, [r7, #4]
   273d2:	6039      	str	r1, [r7, #0]
    ret_code_t            err_code;
    uint16_t              conn_handle = p_ble_evt->evt.common_evt.conn_handle;
   273d4:	683b      	ldr	r3, [r7, #0]
   273d6:	889b      	ldrh	r3, [r3, #4]
   273d8:	82fb      	strh	r3, [r7, #22]
    nrf_ble_gatt_link_t * p_link      = &p_gatt->links[conn_handle];
   273da:	8afb      	ldrh	r3, [r7, #22]
   273dc:	00db      	lsls	r3, r3, #3
   273de:	687a      	ldr	r2, [r7, #4]
   273e0:	4413      	add	r3, r2
   273e2:	3306      	adds	r3, #6
   273e4:	613b      	str	r3, [r7, #16]

    // Update the link desired settings to reflect the current global settings.

    p_link->data_length_desired = p_gatt->data_length;
   273e6:	687b      	ldr	r3, [r7, #4]
   273e8:	791a      	ldrb	r2, [r3, #4]
   273ea:	693b      	ldr	r3, [r7, #16]
   273ec:	719a      	strb	r2, [r3, #6]

    switch (p_ble_evt->evt.gap_evt.params.connected.role)
   273ee:	683b      	ldr	r3, [r7, #0]
   273f0:	7bdb      	ldrb	r3, [r3, #15]
   273f2:	2b01      	cmp	r3, #1
   273f4:	d002      	beq.n	273fc <on_connected_evt+0x32>
   273f6:	2b02      	cmp	r3, #2
   273f8:	d005      	beq.n	27406 <on_connected_evt+0x3c>
            p_link->att_mtu_desired = p_gatt->att_mtu_desired_central;
            break;

        default:
            // Ignore.
            break;
   273fa:	e009      	b.n	27410 <on_connected_evt+0x46>
            p_link->att_mtu_desired = p_gatt->att_mtu_desired_periph;
   273fc:	687b      	ldr	r3, [r7, #4]
   273fe:	881a      	ldrh	r2, [r3, #0]
   27400:	693b      	ldr	r3, [r7, #16]
   27402:	801a      	strh	r2, [r3, #0]
            break;
   27404:	e004      	b.n	27410 <on_connected_evt+0x46>
            p_link->att_mtu_desired = p_gatt->att_mtu_desired_central;
   27406:	687b      	ldr	r3, [r7, #4]
   27408:	885a      	ldrh	r2, [r3, #2]
   2740a:	693b      	ldr	r3, [r7, #16]
   2740c:	801a      	strh	r2, [r3, #0]
            break;
   2740e:	bf00      	nop
    }

    // Begin an ATT MTU exchange if necessary.
    if (p_link->att_mtu_desired > p_link->att_mtu_effective)
   27410:	693b      	ldr	r3, [r7, #16]
   27412:	881a      	ldrh	r2, [r3, #0]
   27414:	693b      	ldr	r3, [r7, #16]
   27416:	885b      	ldrh	r3, [r3, #2]
   27418:	429a      	cmp	r2, r3
   2741a:	d914      	bls.n	27446 <on_connected_evt+0x7c>
    {
        NRF_LOG_DEBUG("Requesting to update ATT MTU to %u bytes on connection 0x%x.",
                      p_link->att_mtu_desired, conn_handle);

        err_code = sd_ble_gattc_exchange_mtu_request(conn_handle, p_link->att_mtu_desired);
   2741c:	693b      	ldr	r3, [r7, #16]
   2741e:	881a      	ldrh	r2, [r3, #0]
   27420:	8afb      	ldrh	r3, [r7, #22]
   27422:	4611      	mov	r1, r2
   27424:	4618      	mov	r0, r3
   27426:	f7ff ff89 	bl	2733c <sd_ble_gattc_exchange_mtu_request>
   2742a:	60f8      	str	r0, [r7, #12]

        if (err_code == NRF_SUCCESS)
   2742c:	68fb      	ldr	r3, [r7, #12]
   2742e:	2b00      	cmp	r3, #0
   27430:	d103      	bne.n	2743a <on_connected_evt+0x70>
        {
            p_link->att_mtu_exchange_requested = true;
   27432:	693b      	ldr	r3, [r7, #16]
   27434:	2201      	movs	r2, #1
   27436:	715a      	strb	r2, [r3, #5]
   27438:	e005      	b.n	27446 <on_connected_evt+0x7c>
        }
        else if (err_code == NRF_ERROR_BUSY)
   2743a:	68fb      	ldr	r3, [r7, #12]
   2743c:	2b11      	cmp	r3, #17
   2743e:	d102      	bne.n	27446 <on_connected_evt+0x7c>
        {
            p_link->att_mtu_exchange_pending = true;
   27440:	693b      	ldr	r3, [r7, #16]
   27442:	2201      	movs	r2, #1
   27444:	711a      	strb	r2, [r3, #4]
                          err_code);
        }
    }

    // Send a data length update request if necessary.
    if (p_link->data_length_desired > p_link->data_length_effective)
   27446:	693b      	ldr	r3, [r7, #16]
   27448:	799a      	ldrb	r2, [r3, #6]
   2744a:	693b      	ldr	r3, [r7, #16]
   2744c:	79db      	ldrb	r3, [r3, #7]
   2744e:	429a      	cmp	r2, r3
   27450:	d904      	bls.n	2745c <on_connected_evt+0x92>
    {
        data_length_update(conn_handle, p_gatt);
   27452:	8afb      	ldrh	r3, [r7, #22]
   27454:	6879      	ldr	r1, [r7, #4]
   27456:	4618      	mov	r0, r3
   27458:	f7ff ff93 	bl	27382 <data_length_update>
    }
}
   2745c:	bf00      	nop
   2745e:	3718      	adds	r7, #24
   27460:	46bd      	mov	sp, r7
   27462:	bd80      	pop	{r7, pc}

00027464 <on_disconnected_evt>:


static void on_disconnected_evt(nrf_ble_gatt_t * p_gatt, ble_evt_t const * p_ble_evt)
{
   27464:	b580      	push	{r7, lr}
   27466:	b082      	sub	sp, #8
   27468:	af00      	add	r7, sp, #0
   2746a:	6078      	str	r0, [r7, #4]
   2746c:	6039      	str	r1, [r7, #0]
    // Reset connection parameters.
    link_init(&p_gatt->links[p_ble_evt->evt.gap_evt.conn_handle]);
   2746e:	683b      	ldr	r3, [r7, #0]
   27470:	889b      	ldrh	r3, [r3, #4]
   27472:	00db      	lsls	r3, r3, #3
   27474:	687a      	ldr	r2, [r7, #4]
   27476:	4413      	add	r3, r2
   27478:	3306      	adds	r3, #6
   2747a:	4618      	mov	r0, r3
   2747c:	f7ff ff66 	bl	2734c <link_init>
}
   27480:	bf00      	nop
   27482:	3708      	adds	r7, #8
   27484:	46bd      	mov	sp, r7
   27486:	bd80      	pop	{r7, pc}

00027488 <on_exchange_mtu_rsp_evt>:
 *
 * @param[in]   p_gatt      GATT structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_exchange_mtu_rsp_evt(nrf_ble_gatt_t * p_gatt, ble_evt_t const * p_ble_evt)
{
   27488:	b580      	push	{r7, lr}
   2748a:	b086      	sub	sp, #24
   2748c:	af00      	add	r7, sp, #0
   2748e:	6078      	str	r0, [r7, #4]
   27490:	6039      	str	r1, [r7, #0]
    uint16_t conn_handle   = p_ble_evt->evt.gattc_evt.conn_handle;
   27492:	683b      	ldr	r3, [r7, #0]
   27494:	889b      	ldrh	r3, [r3, #4]
   27496:	82fb      	strh	r3, [r7, #22]
    uint16_t server_rx_mtu = p_ble_evt->evt.gattc_evt.params.exchange_mtu_rsp.server_rx_mtu;
   27498:	683b      	ldr	r3, [r7, #0]
   2749a:	895b      	ldrh	r3, [r3, #10]
   2749c:	82bb      	strh	r3, [r7, #20]

    nrf_ble_gatt_link_t * p_link = &p_gatt->links[conn_handle];
   2749e:	8afb      	ldrh	r3, [r7, #22]
   274a0:	00db      	lsls	r3, r3, #3
   274a2:	687a      	ldr	r2, [r7, #4]
   274a4:	4413      	add	r3, r2
   274a6:	3306      	adds	r3, #6
   274a8:	613b      	str	r3, [r7, #16]

    // Determine the lowest MTU between our own desired MTU and the peer's.
    // The MTU may not be less than BLE_GATT_ATT_MTU_DEFAULT.
    p_link->att_mtu_effective = MIN(server_rx_mtu, p_link->att_mtu_desired);
   274aa:	693b      	ldr	r3, [r7, #16]
   274ac:	881b      	ldrh	r3, [r3, #0]
   274ae:	8aba      	ldrh	r2, [r7, #20]
   274b0:	4293      	cmp	r3, r2
   274b2:	bf28      	it	cs
   274b4:	4613      	movcs	r3, r2
   274b6:	b29a      	uxth	r2, r3
   274b8:	693b      	ldr	r3, [r7, #16]
   274ba:	805a      	strh	r2, [r3, #2]
    p_link->att_mtu_effective = MAX(p_link->att_mtu_effective, BLE_GATT_ATT_MTU_DEFAULT);
   274bc:	693b      	ldr	r3, [r7, #16]
   274be:	885b      	ldrh	r3, [r3, #2]
   274c0:	2b17      	cmp	r3, #23
   274c2:	bf38      	it	cc
   274c4:	2317      	movcc	r3, #23
   274c6:	b29a      	uxth	r2, r3
   274c8:	693b      	ldr	r3, [r7, #16]
   274ca:	805a      	strh	r2, [r3, #2]
    NRF_LOG_DEBUG("ATT MTU updated to %u bytes on connection 0x%x (response).",
                  p_link->att_mtu_effective, conn_handle);

    // Trigger an event indicating that the ATT MTU size has changed.
    // Send an event to the application only if an ATT MTU exchange was requested.
    if ((p_gatt->evt_handler != NULL) && (p_link->att_mtu_exchange_requested))
   274cc:	687b      	ldr	r3, [r7, #4]
   274ce:	699b      	ldr	r3, [r3, #24]
   274d0:	2b00      	cmp	r3, #0
   274d2:	d012      	beq.n	274fa <on_exchange_mtu_rsp_evt+0x72>
   274d4:	693b      	ldr	r3, [r7, #16]
   274d6:	795b      	ldrb	r3, [r3, #5]
   274d8:	2b00      	cmp	r3, #0
   274da:	d00e      	beq.n	274fa <on_exchange_mtu_rsp_evt+0x72>
    {
        nrf_ble_gatt_evt_t const evt =
   274dc:	f640 2377 	movw	r3, #2679	; 0xa77
   274e0:	813b      	strh	r3, [r7, #8]
   274e2:	8afb      	ldrh	r3, [r7, #22]
   274e4:	817b      	strh	r3, [r7, #10]
        {
            .evt_id                   = NRF_BLE_GATT_EVT_ATT_MTU_UPDATED,
            .conn_handle              = conn_handle,
            .params.att_mtu_effective = p_link->att_mtu_effective,
   274e6:	693b      	ldr	r3, [r7, #16]
   274e8:	885b      	ldrh	r3, [r3, #2]
        nrf_ble_gatt_evt_t const evt =
   274ea:	81bb      	strh	r3, [r7, #12]
        };

        p_gatt->evt_handler(p_gatt, &evt);
   274ec:	687b      	ldr	r3, [r7, #4]
   274ee:	699b      	ldr	r3, [r3, #24]
   274f0:	f107 0208 	add.w	r2, r7, #8
   274f4:	4611      	mov	r1, r2
   274f6:	6878      	ldr	r0, [r7, #4]
   274f8:	4798      	blx	r3
    }

    p_link->att_mtu_exchange_requested = false;
   274fa:	693b      	ldr	r3, [r7, #16]
   274fc:	2200      	movs	r2, #0
   274fe:	715a      	strb	r2, [r3, #5]
    p_link->att_mtu_exchange_pending   = false;
   27500:	693b      	ldr	r3, [r7, #16]
   27502:	2200      	movs	r2, #0
   27504:	711a      	strb	r2, [r3, #4]
}
   27506:	bf00      	nop
   27508:	3718      	adds	r7, #24
   2750a:	46bd      	mov	sp, r7
   2750c:	bd80      	pop	{r7, pc}

0002750e <on_exchange_mtu_request_evt>:
 *
 * @param[in]   p_gatt      GATT structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_exchange_mtu_request_evt(nrf_ble_gatt_t * p_gatt, ble_evt_t const * p_ble_evt)
{
   2750e:	b580      	push	{r7, lr}
   27510:	b088      	sub	sp, #32
   27512:	af00      	add	r7, sp, #0
   27514:	6078      	str	r0, [r7, #4]
   27516:	6039      	str	r1, [r7, #0]
    ret_code_t err_code;
    uint16_t   conn_handle = p_ble_evt->evt.gatts_evt.conn_handle;
   27518:	683b      	ldr	r3, [r7, #0]
   2751a:	889b      	ldrh	r3, [r3, #4]
   2751c:	83fb      	strh	r3, [r7, #30]
    uint16_t   client_mtu  = p_ble_evt->evt.gatts_evt.params.exchange_mtu_request.client_rx_mtu;
   2751e:	683b      	ldr	r3, [r7, #0]
   27520:	88db      	ldrh	r3, [r3, #6]
   27522:	83bb      	strh	r3, [r7, #28]

    nrf_ble_gatt_link_t * p_link = &p_gatt->links[conn_handle];
   27524:	8bfb      	ldrh	r3, [r7, #30]
   27526:	00db      	lsls	r3, r3, #3
   27528:	687a      	ldr	r2, [r7, #4]
   2752a:	4413      	add	r3, r2
   2752c:	3306      	adds	r3, #6
   2752e:	61bb      	str	r3, [r7, #24]

    NRF_LOG_DEBUG("Peer on connection 0x%x requested an ATT MTU of %u bytes.",
                  conn_handle, client_mtu);

    client_mtu = MAX(client_mtu, BLE_GATT_ATT_MTU_DEFAULT);
   27530:	8bbb      	ldrh	r3, [r7, #28]
   27532:	2b17      	cmp	r3, #23
   27534:	bf38      	it	cc
   27536:	2317      	movcc	r3, #23
   27538:	83bb      	strh	r3, [r7, #28]
    p_link->att_mtu_effective = MIN(client_mtu, p_link->att_mtu_desired);
   2753a:	69bb      	ldr	r3, [r7, #24]
   2753c:	881b      	ldrh	r3, [r3, #0]
   2753e:	8bba      	ldrh	r2, [r7, #28]
   27540:	4293      	cmp	r3, r2
   27542:	bf28      	it	cs
   27544:	4613      	movcs	r3, r2
   27546:	b29a      	uxth	r2, r3
   27548:	69bb      	ldr	r3, [r7, #24]
   2754a:	805a      	strh	r2, [r3, #2]
    p_link->att_mtu_exchange_pending = false;
   2754c:	69bb      	ldr	r3, [r7, #24]
   2754e:	2200      	movs	r2, #0
   27550:	711a      	strb	r2, [r3, #4]

    NRF_LOG_DEBUG("Updating ATT MTU to %u bytes (desired: %u) on connection 0x%x.",
                  p_link->att_mtu_effective, p_link->att_mtu_desired, conn_handle);

    err_code = sd_ble_gatts_exchange_mtu_reply(conn_handle, p_link->att_mtu_desired);
   27552:	69bb      	ldr	r3, [r7, #24]
   27554:	881a      	ldrh	r2, [r3, #0]
   27556:	8bfb      	ldrh	r3, [r7, #30]
   27558:	4611      	mov	r1, r2
   2755a:	4618      	mov	r0, r3
   2755c:	f7ff fef2 	bl	27344 <sd_ble_gatts_exchange_mtu_reply>
   27560:	6178      	str	r0, [r7, #20]
    }

    // If an ATT_MTU exchange was requested to the peer, defer sending
    // the data length update request and the event to the application until
    // the response for that request is received.
    if (p_link->att_mtu_exchange_requested)
   27562:	69bb      	ldr	r3, [r7, #24]
   27564:	795b      	ldrb	r3, [r3, #5]
   27566:	2b00      	cmp	r3, #0
   27568:	d113      	bne.n	27592 <on_exchange_mtu_request_evt+0x84>
    {
        return;
    }

    // The ATT MTU exchange has finished. Send an event to the application.
    if (p_gatt->evt_handler != NULL)
   2756a:	687b      	ldr	r3, [r7, #4]
   2756c:	699b      	ldr	r3, [r3, #24]
   2756e:	2b00      	cmp	r3, #0
   27570:	d010      	beq.n	27594 <on_exchange_mtu_request_evt+0x86>
    {
        nrf_ble_gatt_evt_t const evt =
   27572:	f640 2377 	movw	r3, #2679	; 0xa77
   27576:	81bb      	strh	r3, [r7, #12]
   27578:	8bfb      	ldrh	r3, [r7, #30]
   2757a:	81fb      	strh	r3, [r7, #14]
        {
            .evt_id                   = NRF_BLE_GATT_EVT_ATT_MTU_UPDATED,
            .conn_handle              = conn_handle,
            .params.att_mtu_effective = p_link->att_mtu_effective,
   2757c:	69bb      	ldr	r3, [r7, #24]
   2757e:	885b      	ldrh	r3, [r3, #2]
        nrf_ble_gatt_evt_t const evt =
   27580:	823b      	strh	r3, [r7, #16]
        };

        p_gatt->evt_handler(p_gatt, &evt);
   27582:	687b      	ldr	r3, [r7, #4]
   27584:	699b      	ldr	r3, [r3, #24]
   27586:	f107 020c 	add.w	r2, r7, #12
   2758a:	4611      	mov	r1, r2
   2758c:	6878      	ldr	r0, [r7, #4]
   2758e:	4798      	blx	r3
   27590:	e000      	b.n	27594 <on_exchange_mtu_request_evt+0x86>
        return;
   27592:	bf00      	nop
    }
}
   27594:	3720      	adds	r7, #32
   27596:	46bd      	mov	sp, r7
   27598:	bd80      	pop	{r7, pc}

0002759a <on_data_length_update_evt>:
 *
 * @param[in]   p_gatt      GATT structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_data_length_update_evt(nrf_ble_gatt_t * p_gatt, ble_evt_t const * p_ble_evt)
{
   2759a:	b5b0      	push	{r4, r5, r7, lr}
   2759c:	b092      	sub	sp, #72	; 0x48
   2759e:	af00      	add	r7, sp, #0
   275a0:	6078      	str	r0, [r7, #4]
   275a2:	6039      	str	r1, [r7, #0]
    ble_gap_evt_t const gap_evt     = p_ble_evt->evt.gap_evt;
   275a4:	683b      	ldr	r3, [r7, #0]
   275a6:	f107 0410 	add.w	r4, r7, #16
   275aa:	1d1d      	adds	r5, r3, #4
   275ac:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   275ae:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   275b0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   275b2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   275b4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   275b6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   275b8:	682b      	ldr	r3, [r5, #0]
   275ba:	6023      	str	r3, [r4, #0]
    uint16_t      const conn_handle = gap_evt.conn_handle;
   275bc:	8a3b      	ldrh	r3, [r7, #16]
   275be:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46

    // Update the connection data length.
    p_gatt->links[conn_handle].data_length_effective =
        gap_evt.params.data_length_update.effective_params.max_tx_octets;
   275c2:	8aba      	ldrh	r2, [r7, #20]
    p_gatt->links[conn_handle].data_length_effective =
   275c4:	f8b7 3046 	ldrh.w	r3, [r7, #70]	; 0x46
   275c8:	b2d1      	uxtb	r1, r2
   275ca:	687a      	ldr	r2, [r7, #4]
   275cc:	00db      	lsls	r3, r3, #3
   275ce:	4413      	add	r3, r2
   275d0:	460a      	mov	r2, r1
   275d2:	735a      	strb	r2, [r3, #13]
    NRF_LOG_DEBUG("max_rx_time: %u",
                  gap_evt.params.data_length_update.effective_params.max_rx_time_us);
    NRF_LOG_DEBUG("max_tx_time: %u",
                  gap_evt.params.data_length_update.effective_params.max_tx_time_us);

    if (p_gatt->evt_handler != NULL)
   275d4:	687b      	ldr	r3, [r7, #4]
   275d6:	699b      	ldr	r3, [r3, #24]
   275d8:	2b00      	cmp	r3, #0
   275da:	d018      	beq.n	2760e <on_data_length_update_evt+0x74>
    {
        nrf_ble_gatt_evt_t const evt =
   275dc:	f107 0308 	add.w	r3, r7, #8
   275e0:	2200      	movs	r2, #0
   275e2:	601a      	str	r2, [r3, #0]
   275e4:	809a      	strh	r2, [r3, #4]
   275e6:	f64d 237a 	movw	r3, #55930	; 0xda7a
   275ea:	813b      	strh	r3, [r7, #8]
   275ec:	f8b7 3046 	ldrh.w	r3, [r7, #70]	; 0x46
   275f0:	817b      	strh	r3, [r7, #10]
        {
            .evt_id             = NRF_BLE_GATT_EVT_DATA_LENGTH_UPDATED,
            .conn_handle        = conn_handle,
            .params.data_length = p_gatt->links[conn_handle].data_length_effective,
   275f2:	f8b7 3046 	ldrh.w	r3, [r7, #70]	; 0x46
   275f6:	687a      	ldr	r2, [r7, #4]
   275f8:	00db      	lsls	r3, r3, #3
   275fa:	4413      	add	r3, r2
   275fc:	7b5b      	ldrb	r3, [r3, #13]
        nrf_ble_gatt_evt_t const evt =
   275fe:	733b      	strb	r3, [r7, #12]
        };

        p_gatt->evt_handler(p_gatt, &evt);
   27600:	687b      	ldr	r3, [r7, #4]
   27602:	699b      	ldr	r3, [r3, #24]
   27604:	f107 0208 	add.w	r2, r7, #8
   27608:	4611      	mov	r1, r2
   2760a:	6878      	ldr	r0, [r7, #4]
   2760c:	4798      	blx	r3
    }
}
   2760e:	bf00      	nop
   27610:	3748      	adds	r7, #72	; 0x48
   27612:	46bd      	mov	sp, r7
   27614:	bdb0      	pop	{r4, r5, r7, pc}

00027616 <on_data_length_update_request_evt>:
 *
 * @param[in]   p_gatt      GATT structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_data_length_update_request_evt(nrf_ble_gatt_t * p_gatt, ble_evt_t const * p_ble_evt)
{
   27616:	b580      	push	{r7, lr}
   27618:	b088      	sub	sp, #32
   2761a:	af00      	add	r7, sp, #0
   2761c:	6078      	str	r0, [r7, #4]
   2761e:	6039      	str	r1, [r7, #0]
    ret_code_t err_code;

    ble_gap_evt_t       const * p_gap_evt = &p_ble_evt->evt.gap_evt;
   27620:	683b      	ldr	r3, [r7, #0]
   27622:	3304      	adds	r3, #4
   27624:	61fb      	str	r3, [r7, #28]
    nrf_ble_gatt_link_t       * p_link    = &p_gatt->links[p_gap_evt->conn_handle];
   27626:	69fb      	ldr	r3, [r7, #28]
   27628:	881b      	ldrh	r3, [r3, #0]
   2762a:	00db      	lsls	r3, r3, #3
   2762c:	687a      	ldr	r2, [r7, #4]
   2762e:	4413      	add	r3, r2
   27630:	3306      	adds	r3, #6
   27632:	61bb      	str	r3, [r7, #24]

    uint8_t const data_length_peer =
        p_gap_evt->params.data_length_update_request.peer_params.max_tx_octets;
   27634:	69fb      	ldr	r3, [r7, #28]
   27636:	889b      	ldrh	r3, [r3, #4]
    uint8_t const data_length_peer =
   27638:	75fb      	strb	r3, [r7, #23]

    NRF_LOG_DEBUG("Peer on connection 0x%x requested a data length of %u bytes.",
                  p_gap_evt->conn_handle, data_length_peer);

    uint8_t const data_length = MIN(p_link->data_length_desired, data_length_peer);
   2763a:	69bb      	ldr	r3, [r7, #24]
   2763c:	799b      	ldrb	r3, [r3, #6]
   2763e:	7dfa      	ldrb	r2, [r7, #23]
   27640:	4293      	cmp	r3, r2
   27642:	bf28      	it	cs
   27644:	4613      	movcs	r3, r2
   27646:	75bb      	strb	r3, [r7, #22]

    ble_gap_data_length_params_t const dlp =
   27648:	f107 0308 	add.w	r3, r7, #8
   2764c:	2200      	movs	r2, #0
   2764e:	601a      	str	r2, [r3, #0]
   27650:	605a      	str	r2, [r3, #4]
   27652:	7dbb      	ldrb	r3, [r7, #22]
   27654:	b29b      	uxth	r3, r3
   27656:	813b      	strh	r3, [r7, #8]
   27658:	7dbb      	ldrb	r3, [r7, #22]
   2765a:	b29b      	uxth	r3, r3
   2765c:	817b      	strh	r3, [r7, #10]
    };

    NRF_LOG_DEBUG("Updating data length to %u bytes on connection 0x%x.",
                  data_length, p_gap_evt->conn_handle);

    err_code = sd_ble_gap_data_length_update(p_gap_evt->conn_handle, &dlp, NULL);
   2765e:	69fb      	ldr	r3, [r7, #28]
   27660:	881b      	ldrh	r3, [r3, #0]
   27662:	f107 0108 	add.w	r1, r7, #8
   27666:	2200      	movs	r2, #0
   27668:	4618      	mov	r0, r3
   2766a:	f7ff fe63 	bl	27334 <sd_ble_gap_data_length_update>
   2766e:	6138      	str	r0, [r7, #16]
    {
        NRF_LOG_ERROR("sd_ble_gap_data_length_update() (reply)"
                      " returned unexpected value 0x%x.",
                      err_code);
    }
}
   27670:	bf00      	nop
   27672:	3720      	adds	r7, #32
   27674:	46bd      	mov	sp, r7
   27676:	bd80      	pop	{r7, pc}

00027678 <nrf_ble_gatt_init>:


ret_code_t nrf_ble_gatt_init(nrf_ble_gatt_t * p_gatt, nrf_ble_gatt_evt_handler_t evt_handler)
{
   27678:	b580      	push	{r7, lr}
   2767a:	b084      	sub	sp, #16
   2767c:	af00      	add	r7, sp, #0
   2767e:	6078      	str	r0, [r7, #4]
   27680:	6039      	str	r1, [r7, #0]
    VERIFY_PARAM_NOT_NULL(p_gatt);
   27682:	687b      	ldr	r3, [r7, #4]
   27684:	2b00      	cmp	r3, #0
   27686:	d101      	bne.n	2768c <nrf_ble_gatt_init+0x14>
   27688:	230e      	movs	r3, #14
   2768a:	e01d      	b.n	276c8 <nrf_ble_gatt_init+0x50>

    p_gatt->evt_handler             = evt_handler;
   2768c:	687b      	ldr	r3, [r7, #4]
   2768e:	683a      	ldr	r2, [r7, #0]
   27690:	619a      	str	r2, [r3, #24]
    p_gatt->att_mtu_desired_periph  = NRF_SDH_BLE_GATT_MAX_MTU_SIZE;
   27692:	687b      	ldr	r3, [r7, #4]
   27694:	2217      	movs	r2, #23
   27696:	801a      	strh	r2, [r3, #0]
    p_gatt->att_mtu_desired_central = NRF_SDH_BLE_GATT_MAX_MTU_SIZE;
   27698:	687b      	ldr	r3, [r7, #4]
   2769a:	2217      	movs	r2, #23
   2769c:	805a      	strh	r2, [r3, #2]
    p_gatt->data_length             = NRF_SDH_BLE_GATT_MAX_MTU_SIZE + L2CAP_HDR_LEN;
   2769e:	687b      	ldr	r3, [r7, #4]
   276a0:	221b      	movs	r2, #27
   276a2:	711a      	strb	r2, [r3, #4]

    for (uint32_t i = 0; i < NRF_BLE_GATT_LINK_COUNT; i++)
   276a4:	2300      	movs	r3, #0
   276a6:	60fb      	str	r3, [r7, #12]
   276a8:	e00a      	b.n	276c0 <nrf_ble_gatt_init+0x48>
    {
        link_init(&p_gatt->links[i]);
   276aa:	68fb      	ldr	r3, [r7, #12]
   276ac:	00db      	lsls	r3, r3, #3
   276ae:	687a      	ldr	r2, [r7, #4]
   276b0:	4413      	add	r3, r2
   276b2:	3306      	adds	r3, #6
   276b4:	4618      	mov	r0, r3
   276b6:	f7ff fe49 	bl	2734c <link_init>
    for (uint32_t i = 0; i < NRF_BLE_GATT_LINK_COUNT; i++)
   276ba:	68fb      	ldr	r3, [r7, #12]
   276bc:	3301      	adds	r3, #1
   276be:	60fb      	str	r3, [r7, #12]
   276c0:	68fb      	ldr	r3, [r7, #12]
   276c2:	2b01      	cmp	r3, #1
   276c4:	d9f1      	bls.n	276aa <nrf_ble_gatt_init+0x32>
    }

    return NRF_SUCCESS;
   276c6:	2300      	movs	r3, #0
}
   276c8:	4618      	mov	r0, r3
   276ca:	3710      	adds	r7, #16
   276cc:	46bd      	mov	sp, r7
   276ce:	bd80      	pop	{r7, pc}

000276d0 <nrf_ble_gatt_on_ble_evt>:
    return NRF_SUCCESS;
}


void nrf_ble_gatt_on_ble_evt(ble_evt_t const * p_ble_evt, void * p_context)
{
   276d0:	b580      	push	{r7, lr}
   276d2:	b086      	sub	sp, #24
   276d4:	af00      	add	r7, sp, #0
   276d6:	6078      	str	r0, [r7, #4]
   276d8:	6039      	str	r1, [r7, #0]
    nrf_ble_gatt_t * p_gatt      = (nrf_ble_gatt_t *)p_context;
   276da:	683b      	ldr	r3, [r7, #0]
   276dc:	617b      	str	r3, [r7, #20]
    uint16_t         conn_handle = p_ble_evt->evt.common_evt.conn_handle;
   276de:	687b      	ldr	r3, [r7, #4]
   276e0:	889b      	ldrh	r3, [r3, #4]
   276e2:	827b      	strh	r3, [r7, #18]

    if (conn_handle >= NRF_BLE_GATT_LINK_COUNT)
   276e4:	8a7b      	ldrh	r3, [r7, #18]
   276e6:	2b01      	cmp	r3, #1
   276e8:	d854      	bhi.n	27794 <nrf_ble_gatt_on_ble_evt+0xc4>
    {
        return;
    }

    switch (p_ble_evt->header.evt_id)
   276ea:	687b      	ldr	r3, [r7, #4]
   276ec:	881b      	ldrh	r3, [r3, #0]
   276ee:	2b23      	cmp	r3, #35	; 0x23
   276f0:	d026      	beq.n	27740 <nrf_ble_gatt_on_ble_evt+0x70>
   276f2:	2b23      	cmp	r3, #35	; 0x23
   276f4:	dc04      	bgt.n	27700 <nrf_ble_gatt_on_ble_evt+0x30>
   276f6:	2b10      	cmp	r3, #16
   276f8:	d009      	beq.n	2770e <nrf_ble_gatt_on_ble_evt+0x3e>
   276fa:	2b11      	cmp	r3, #17
   276fc:	d00c      	beq.n	27718 <nrf_ble_gatt_on_ble_evt+0x48>
        case BLE_GAP_EVT_DATA_LENGTH_UPDATE_REQUEST:
            on_data_length_update_request_evt(p_gatt, p_ble_evt);
            break;

        default:
            break;
   276fe:	e024      	b.n	2774a <nrf_ble_gatt_on_ble_evt+0x7a>
    switch (p_ble_evt->header.evt_id)
   27700:	2b3a      	cmp	r3, #58	; 0x3a
   27702:	d00e      	beq.n	27722 <nrf_ble_gatt_on_ble_evt+0x52>
   27704:	2b55      	cmp	r3, #85	; 0x55
   27706:	d011      	beq.n	2772c <nrf_ble_gatt_on_ble_evt+0x5c>
   27708:	2b24      	cmp	r3, #36	; 0x24
   2770a:	d014      	beq.n	27736 <nrf_ble_gatt_on_ble_evt+0x66>
            break;
   2770c:	e01d      	b.n	2774a <nrf_ble_gatt_on_ble_evt+0x7a>
            on_connected_evt(p_gatt, p_ble_evt);
   2770e:	6879      	ldr	r1, [r7, #4]
   27710:	6978      	ldr	r0, [r7, #20]
   27712:	f7ff fe5a 	bl	273ca <on_connected_evt>
            break;
   27716:	e018      	b.n	2774a <nrf_ble_gatt_on_ble_evt+0x7a>
            on_disconnected_evt(p_gatt, p_ble_evt);
   27718:	6879      	ldr	r1, [r7, #4]
   2771a:	6978      	ldr	r0, [r7, #20]
   2771c:	f7ff fea2 	bl	27464 <on_disconnected_evt>
            break;
   27720:	e013      	b.n	2774a <nrf_ble_gatt_on_ble_evt+0x7a>
            on_exchange_mtu_rsp_evt(p_gatt, p_ble_evt);
   27722:	6879      	ldr	r1, [r7, #4]
   27724:	6978      	ldr	r0, [r7, #20]
   27726:	f7ff feaf 	bl	27488 <on_exchange_mtu_rsp_evt>
            break;
   2772a:	e00e      	b.n	2774a <nrf_ble_gatt_on_ble_evt+0x7a>
            on_exchange_mtu_request_evt(p_gatt, p_ble_evt);
   2772c:	6879      	ldr	r1, [r7, #4]
   2772e:	6978      	ldr	r0, [r7, #20]
   27730:	f7ff feed 	bl	2750e <on_exchange_mtu_request_evt>
            break;
   27734:	e009      	b.n	2774a <nrf_ble_gatt_on_ble_evt+0x7a>
            on_data_length_update_evt(p_gatt, p_ble_evt);
   27736:	6879      	ldr	r1, [r7, #4]
   27738:	6978      	ldr	r0, [r7, #20]
   2773a:	f7ff ff2e 	bl	2759a <on_data_length_update_evt>
            break;
   2773e:	e004      	b.n	2774a <nrf_ble_gatt_on_ble_evt+0x7a>
            on_data_length_update_request_evt(p_gatt, p_ble_evt);
   27740:	6879      	ldr	r1, [r7, #4]
   27742:	6978      	ldr	r0, [r7, #20]
   27744:	f7ff ff67 	bl	27616 <on_data_length_update_request_evt>
            break;
   27748:	bf00      	nop
    }

    if (p_gatt->links[conn_handle].att_mtu_exchange_pending)
   2774a:	8a7b      	ldrh	r3, [r7, #18]
   2774c:	697a      	ldr	r2, [r7, #20]
   2774e:	00db      	lsls	r3, r3, #3
   27750:	4413      	add	r3, r2
   27752:	7a9b      	ldrb	r3, [r3, #10]
   27754:	2b00      	cmp	r3, #0
   27756:	d01e      	beq.n	27796 <nrf_ble_gatt_on_ble_evt+0xc6>
    {
        ret_code_t err_code;

        err_code = sd_ble_gattc_exchange_mtu_request(conn_handle,
   27758:	8a7b      	ldrh	r3, [r7, #18]
   2775a:	697a      	ldr	r2, [r7, #20]
   2775c:	00db      	lsls	r3, r3, #3
   2775e:	4413      	add	r3, r2
   27760:	88da      	ldrh	r2, [r3, #6]
   27762:	8a7b      	ldrh	r3, [r7, #18]
   27764:	4611      	mov	r1, r2
   27766:	4618      	mov	r0, r3
   27768:	f7ff fde8 	bl	2733c <sd_ble_gattc_exchange_mtu_request>
   2776c:	60f8      	str	r0, [r7, #12]
                                                     p_gatt->links[conn_handle].att_mtu_desired);

        if (err_code == NRF_SUCCESS)
   2776e:	68fb      	ldr	r3, [r7, #12]
   27770:	2b00      	cmp	r3, #0
   27772:	d10c      	bne.n	2778e <nrf_ble_gatt_on_ble_evt+0xbe>
        {
            p_gatt->links[conn_handle].att_mtu_exchange_pending   = false;
   27774:	8a7b      	ldrh	r3, [r7, #18]
   27776:	697a      	ldr	r2, [r7, #20]
   27778:	00db      	lsls	r3, r3, #3
   2777a:	4413      	add	r3, r2
   2777c:	2200      	movs	r2, #0
   2777e:	729a      	strb	r2, [r3, #10]
            p_gatt->links[conn_handle].att_mtu_exchange_requested = true;
   27780:	8a7b      	ldrh	r3, [r7, #18]
   27782:	697a      	ldr	r2, [r7, #20]
   27784:	00db      	lsls	r3, r3, #3
   27786:	4413      	add	r3, r2
   27788:	2201      	movs	r2, #1
   2778a:	72da      	strb	r2, [r3, #11]
   2778c:	e003      	b.n	27796 <nrf_ble_gatt_on_ble_evt+0xc6>

            NRF_LOG_DEBUG("Requesting to update ATT MTU to %u bytes on connection 0x%x (retry).",
                          p_gatt->links[conn_handle].att_mtu_desired, conn_handle);
        }
        else if (err_code != NRF_ERROR_BUSY)
   2778e:	68fb      	ldr	r3, [r7, #12]
   27790:	2b11      	cmp	r3, #17
   27792:	e000      	b.n	27796 <nrf_ble_gatt_on_ble_evt+0xc6>
        return;
   27794:	bf00      	nop
        {
            NRF_LOG_ERROR("sd_ble_gattc_exchange_mtu_request() returned unexpected value 0x%x.",
                          err_code);
        }
    }
}
   27796:	3718      	adds	r7, #24
   27798:	46bd      	mov	sp, r7
   2779a:	bd80      	pop	{r7, pc}

0002779c <record_activate>:
 * @param role         The role of the connection.
 *
 * @return whether the record was activated successfully.
 */
static bool record_activate(uint16_t conn_handle)
{
   2779c:	b580      	push	{r7, lr}
   2779e:	b084      	sub	sp, #16
   277a0:	af00      	add	r7, sp, #0
   277a2:	4603      	mov	r3, r0
   277a4:	80fb      	strh	r3, [r7, #6]
    uint16_t available_index = sdk_mapped_flags_first_key_index_get(~m_bcs.flags.valid_flags);
   277a6:	4b13      	ldr	r3, [pc, #76]	; (277f4 <record_activate+0x58>)
   277a8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   277aa:	43db      	mvns	r3, r3
   277ac:	4618      	mov	r0, r3
   277ae:	f000 fda0 	bl	282f2 <sdk_mapped_flags_first_key_index_get>
   277b2:	4603      	mov	r3, r0
   277b4:	81fb      	strh	r3, [r7, #14]

    if (available_index != SDK_MAPPED_FLAGS_INVALID_INDEX)
   277b6:	89fb      	ldrh	r3, [r7, #14]
   277b8:	f64f 72ff 	movw	r2, #65535	; 0xffff
   277bc:	4293      	cmp	r3, r2
   277be:	d013      	beq.n	277e8 <record_activate+0x4c>
    {
        m_bcs.valid_conn_handles[available_index] = conn_handle;
   277c0:	89fb      	ldrh	r3, [r7, #14]
   277c2:	4a0c      	ldr	r2, [pc, #48]	; (277f4 <record_activate+0x58>)
   277c4:	005b      	lsls	r3, r3, #1
   277c6:	4413      	add	r3, r2
   277c8:	88fa      	ldrh	r2, [r7, #6]
   277ca:	809a      	strh	r2, [r3, #4]
        sdk_mapped_flags_update_by_key(m_bcs.valid_conn_handles,
   277cc:	88fa      	ldrh	r2, [r7, #6]
   277ce:	2301      	movs	r3, #1
   277d0:	4909      	ldr	r1, [pc, #36]	; (277f8 <record_activate+0x5c>)
   277d2:	480a      	ldr	r0, [pc, #40]	; (277fc <record_activate+0x60>)
   277d4:	f000 fdaa 	bl	2832c <sdk_mapped_flags_update_by_key>
                                      &m_bcs.flags.connected_flags,
                                       conn_handle,
                                       1);
        sdk_mapped_flags_update_by_key(m_bcs.valid_conn_handles,
   277d8:	88fa      	ldrh	r2, [r7, #6]
   277da:	2301      	movs	r3, #1
   277dc:	4908      	ldr	r1, [pc, #32]	; (27800 <record_activate+0x64>)
   277de:	4807      	ldr	r0, [pc, #28]	; (277fc <record_activate+0x60>)
   277e0:	f000 fda4 	bl	2832c <sdk_mapped_flags_update_by_key>
                                      &m_bcs.flags.valid_flags,
                                       conn_handle,
                                       1);

        return true;
   277e4:	2301      	movs	r3, #1
   277e6:	e000      	b.n	277ea <record_activate+0x4e>
    }

    return false;
   277e8:	2300      	movs	r3, #0
}
   277ea:	4618      	mov	r0, r3
   277ec:	3710      	adds	r7, #16
   277ee:	46bd      	mov	sp, r7
   277f0:	bd80      	pop	{r7, pc}
   277f2:	bf00      	nop
   277f4:	2000534c 	.word	0x2000534c
   277f8:	20005394 	.word	0x20005394
   277fc:	20005350 	.word	0x20005350
   27800:	20005390 	.word	0x20005390

00027804 <record_invalidate>:
/**@brief Function for marking a connection record as invalid and resetting the values.
 *
 * @param p_record  The record to invalidate.
 */
static void record_invalidate(uint16_t conn_handle)
{
   27804:	b580      	push	{r7, lr}
   27806:	b084      	sub	sp, #16
   27808:	af02      	add	r7, sp, #8
   2780a:	4603      	mov	r3, r0
   2780c:	80fb      	strh	r3, [r7, #6]
    sdk_mapped_flags_bulk_update_by_key(m_bcs.valid_conn_handles,
   2780e:	88fa      	ldrh	r2, [r7, #6]
   27810:	2300      	movs	r3, #0
   27812:	9300      	str	r3, [sp, #0]
   27814:	4613      	mov	r3, r2
   27816:	221d      	movs	r2, #29
   27818:	4903      	ldr	r1, [pc, #12]	; (27828 <record_invalidate+0x24>)
   2781a:	4804      	ldr	r0, [pc, #16]	; (2782c <record_invalidate+0x28>)
   2781c:	f000 fd9e 	bl	2835c <sdk_mapped_flags_bulk_update_by_key>
                                        m_bcs.flag_array,
                                        BLE_CONN_STATE_N_FLAGS,
                                        conn_handle,
                                        0);
}
   27820:	bf00      	nop
   27822:	3708      	adds	r7, #8
   27824:	46bd      	mov	sp, r7
   27826:	bd80      	pop	{r7, pc}
   27828:	20005390 	.word	0x20005390
   2782c:	20005350 	.word	0x20005350

00027830 <record_set_disconnected>:
/**@brief Function for marking a connection as disconnected. See @ref BLE_CONN_STATUS_DISCONNECTED.
 *
 * @param p_record   The record of the connection to set as disconnected.
 */
static void record_set_disconnected(uint16_t conn_handle)
{
   27830:	b580      	push	{r7, lr}
   27832:	b082      	sub	sp, #8
   27834:	af00      	add	r7, sp, #0
   27836:	4603      	mov	r3, r0
   27838:	80fb      	strh	r3, [r7, #6]
    sdk_mapped_flags_update_by_key(m_bcs.valid_conn_handles,
   2783a:	88fa      	ldrh	r2, [r7, #6]
   2783c:	2300      	movs	r3, #0
   2783e:	4904      	ldr	r1, [pc, #16]	; (27850 <record_set_disconnected+0x20>)
   27840:	4804      	ldr	r0, [pc, #16]	; (27854 <record_set_disconnected+0x24>)
   27842:	f000 fd73 	bl	2832c <sdk_mapped_flags_update_by_key>
                                  &m_bcs.flags.connected_flags,
                                   conn_handle,
                                   0);
}
   27846:	bf00      	nop
   27848:	3708      	adds	r7, #8
   2784a:	46bd      	mov	sp, r7
   2784c:	bd80      	pop	{r7, pc}
   2784e:	bf00      	nop
   27850:	20005394 	.word	0x20005394
   27854:	20005350 	.word	0x20005350

00027858 <record_purge_disconnected>:

/**@brief Function for invalidating records with a @ref BLE_CONN_STATUS_DISCONNECTED
 *        connection status
 */
static void record_purge_disconnected()
{
   27858:	b580      	push	{r7, lr}
   2785a:	b0a4      	sub	sp, #144	; 0x90
   2785c:	af00      	add	r7, sp, #0
    sdk_mapped_flags_key_list_t disconnected_list;

    disconnected_list = sdk_mapped_flags_key_list_get(
                                   m_bcs.valid_conn_handles,
                                 (~m_bcs.flags.connected_flags) & (m_bcs.flags.valid_flags));
   2785e:	4b17      	ldr	r3, [pc, #92]	; (278bc <record_purge_disconnected+0x64>)
   27860:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   27862:	43da      	mvns	r2, r3
   27864:	4b15      	ldr	r3, [pc, #84]	; (278bc <record_purge_disconnected+0x64>)
   27866:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    disconnected_list = sdk_mapped_flags_key_list_get(
   27868:	401a      	ands	r2, r3
   2786a:	463b      	mov	r3, r7
   2786c:	4914      	ldr	r1, [pc, #80]	; (278c0 <record_purge_disconnected+0x68>)
   2786e:	4618      	mov	r0, r3
   27870:	f000 fde4 	bl	2843c <sdk_mapped_flags_key_list_get>
   27874:	f107 0348 	add.w	r3, r7, #72	; 0x48
   27878:	4639      	mov	r1, r7
   2787a:	2244      	movs	r2, #68	; 0x44
   2787c:	4618      	mov	r0, r3
   2787e:	f003 fd37 	bl	2b2f0 <memcpy>

    for (uint32_t i = 0; i < disconnected_list.len; i++)
   27882:	2300      	movs	r3, #0
   27884:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
   27888:	e00f      	b.n	278aa <record_purge_disconnected+0x52>
    {
        record_invalidate(disconnected_list.flag_keys[i]);
   2788a:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
   2788e:	005b      	lsls	r3, r3, #1
   27890:	f107 0290 	add.w	r2, r7, #144	; 0x90
   27894:	4413      	add	r3, r2
   27896:	f833 3c44 	ldrh.w	r3, [r3, #-68]
   2789a:	4618      	mov	r0, r3
   2789c:	f7ff ffb2 	bl	27804 <record_invalidate>
    for (uint32_t i = 0; i < disconnected_list.len; i++)
   278a0:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
   278a4:	3301      	adds	r3, #1
   278a6:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
   278aa:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   278ac:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
   278b0:	429a      	cmp	r2, r3
   278b2:	d3ea      	bcc.n	2788a <record_purge_disconnected+0x32>
    }
}
   278b4:	bf00      	nop
   278b6:	3790      	adds	r7, #144	; 0x90
   278b8:	46bd      	mov	sp, r7
   278ba:	bd80      	pop	{r7, pc}
   278bc:	2000534c 	.word	0x2000534c
   278c0:	20005350 	.word	0x20005350

000278c4 <ble_evt_handler>:
 *
 * @param[in]   p_ble_evt       Event received from the BLE stack.
 * @param[in]   p_context       Context.
 */
static void ble_evt_handler(ble_evt_t const * p_ble_evt, void * p_context)
{
   278c4:	b580      	push	{r7, lr}
   278c6:	b084      	sub	sp, #16
   278c8:	af00      	add	r7, sp, #0
   278ca:	6078      	str	r0, [r7, #4]
   278cc:	6039      	str	r1, [r7, #0]
    switch (p_ble_evt->header.evt_id)
   278ce:	687b      	ldr	r3, [r7, #4]
   278d0:	881b      	ldrh	r3, [r3, #0]
   278d2:	2b11      	cmp	r3, #17
   278d4:	d026      	beq.n	27924 <ble_evt_handler+0x60>
   278d6:	2b1a      	cmp	r3, #26
   278d8:	d02a      	beq.n	27930 <ble_evt_handler+0x6c>
   278da:	2b10      	cmp	r3, #16
   278dc:	d000      	beq.n	278e0 <ble_evt_handler+0x1c>
                         &m_bcs.flags.mitm_protected_flags,
                          p_ble_evt->evt.gap_evt.conn_handle,
                         (p_ble_evt->evt.gap_evt.params.conn_sec_update.conn_sec.sec_mode.lv > 2));
            break;
    }
}
   278de:	e048      	b.n	27972 <ble_evt_handler+0xae>
            record_purge_disconnected();
   278e0:	f7ff ffba 	bl	27858 <record_purge_disconnected>
            if ( !record_activate(p_ble_evt->evt.gap_evt.conn_handle) )
   278e4:	687b      	ldr	r3, [r7, #4]
   278e6:	889b      	ldrh	r3, [r3, #4]
   278e8:	4618      	mov	r0, r3
   278ea:	f7ff ff57 	bl	2779c <record_activate>
   278ee:	4603      	mov	r3, r0
   278f0:	f083 0301 	eor.w	r3, r3, #1
   278f4:	b2db      	uxtb	r3, r3
   278f6:	2b00      	cmp	r3, #0
   278f8:	d005      	beq.n	27906 <ble_evt_handler+0x42>
                APP_ERROR_HANDLER(NRF_ERROR_NO_MEM);
   278fa:	4a20      	ldr	r2, [pc, #128]	; (2797c <ble_evt_handler+0xb8>)
   278fc:	21e5      	movs	r1, #229	; 0xe5
   278fe:	2004      	movs	r0, #4
   27900:	f7ff fa0e 	bl	26d20 <app_error_handler>
            break;
   27904:	e035      	b.n	27972 <ble_evt_handler+0xae>
                        (p_ble_evt->evt.gap_evt.params.connected.role == BLE_GAP_ROLE_CENTRAL);
   27906:	687b      	ldr	r3, [r7, #4]
   27908:	7bdb      	ldrb	r3, [r3, #15]
                bool is_central =
   2790a:	2b02      	cmp	r3, #2
   2790c:	bf0c      	ite	eq
   2790e:	2301      	moveq	r3, #1
   27910:	2300      	movne	r3, #0
   27912:	73fb      	strb	r3, [r7, #15]
                sdk_mapped_flags_update_by_key(m_bcs.valid_conn_handles,
   27914:	687b      	ldr	r3, [r7, #4]
   27916:	889a      	ldrh	r2, [r3, #4]
   27918:	7bfb      	ldrb	r3, [r7, #15]
   2791a:	4919      	ldr	r1, [pc, #100]	; (27980 <ble_evt_handler+0xbc>)
   2791c:	4819      	ldr	r0, [pc, #100]	; (27984 <ble_evt_handler+0xc0>)
   2791e:	f000 fd05 	bl	2832c <sdk_mapped_flags_update_by_key>
            break;
   27922:	e026      	b.n	27972 <ble_evt_handler+0xae>
            record_set_disconnected(p_ble_evt->evt.gap_evt.conn_handle);
   27924:	687b      	ldr	r3, [r7, #4]
   27926:	889b      	ldrh	r3, [r3, #4]
   27928:	4618      	mov	r0, r3
   2792a:	f7ff ff81 	bl	27830 <record_set_disconnected>
            break;
   2792e:	e020      	b.n	27972 <ble_evt_handler+0xae>
            sdk_mapped_flags_update_by_key(
   27930:	687b      	ldr	r3, [r7, #4]
   27932:	889a      	ldrh	r2, [r3, #4]
                         (p_ble_evt->evt.gap_evt.params.conn_sec_update.conn_sec.sec_mode.lv > 1));
   27934:	687b      	ldr	r3, [r7, #4]
   27936:	7a1b      	ldrb	r3, [r3, #8]
   27938:	f3c3 1303 	ubfx	r3, r3, #4, #4
   2793c:	b2db      	uxtb	r3, r3
            sdk_mapped_flags_update_by_key(
   2793e:	2b01      	cmp	r3, #1
   27940:	bf8c      	ite	hi
   27942:	2301      	movhi	r3, #1
   27944:	2300      	movls	r3, #0
   27946:	b2db      	uxtb	r3, r3
   27948:	490f      	ldr	r1, [pc, #60]	; (27988 <ble_evt_handler+0xc4>)
   2794a:	480e      	ldr	r0, [pc, #56]	; (27984 <ble_evt_handler+0xc0>)
   2794c:	f000 fcee 	bl	2832c <sdk_mapped_flags_update_by_key>
            sdk_mapped_flags_update_by_key(
   27950:	687b      	ldr	r3, [r7, #4]
   27952:	889a      	ldrh	r2, [r3, #4]
                         (p_ble_evt->evt.gap_evt.params.conn_sec_update.conn_sec.sec_mode.lv > 2));
   27954:	687b      	ldr	r3, [r7, #4]
   27956:	7a1b      	ldrb	r3, [r3, #8]
   27958:	f3c3 1303 	ubfx	r3, r3, #4, #4
   2795c:	b2db      	uxtb	r3, r3
            sdk_mapped_flags_update_by_key(
   2795e:	2b02      	cmp	r3, #2
   27960:	bf8c      	ite	hi
   27962:	2301      	movhi	r3, #1
   27964:	2300      	movls	r3, #0
   27966:	b2db      	uxtb	r3, r3
   27968:	4908      	ldr	r1, [pc, #32]	; (2798c <ble_evt_handler+0xc8>)
   2796a:	4806      	ldr	r0, [pc, #24]	; (27984 <ble_evt_handler+0xc0>)
   2796c:	f000 fcde 	bl	2832c <sdk_mapped_flags_update_by_key>
            break;
   27970:	bf00      	nop
}
   27972:	bf00      	nop
   27974:	3710      	adds	r7, #16
   27976:	46bd      	mov	sp, r7
   27978:	bd80      	pop	{r7, pc}
   2797a:	bf00      	nop
   2797c:	0002b61c 	.word	0x0002b61c
   27980:	20005398 	.word	0x20005398
   27984:	20005350 	.word	0x20005350
   27988:	2000539c 	.word	0x2000539c
   2798c:	200053a0 	.word	0x200053a0

00027990 <ble_conn_state_role>:
                                       conn_handle);
}


uint8_t ble_conn_state_role(uint16_t conn_handle)
{
   27990:	b580      	push	{r7, lr}
   27992:	b084      	sub	sp, #16
   27994:	af00      	add	r7, sp, #0
   27996:	4603      	mov	r3, r0
   27998:	80fb      	strh	r3, [r7, #6]
    uint8_t role = BLE_GAP_ROLE_INVALID;
   2799a:	2300      	movs	r3, #0
   2799c:	73fb      	strb	r3, [r7, #15]

    if ( sdk_mapped_flags_get_by_key(m_bcs.valid_conn_handles, m_bcs.flags.valid_flags, conn_handle) )
   2799e:	4b0f      	ldr	r3, [pc, #60]	; (279dc <ble_conn_state_role+0x4c>)
   279a0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   279a2:	88fa      	ldrh	r2, [r7, #6]
   279a4:	4619      	mov	r1, r3
   279a6:	480e      	ldr	r0, [pc, #56]	; (279e0 <ble_conn_state_role+0x50>)
   279a8:	f000 fd20 	bl	283ec <sdk_mapped_flags_get_by_key>
   279ac:	4603      	mov	r3, r0
   279ae:	2b00      	cmp	r3, #0
   279b0:	d00f      	beq.n	279d2 <ble_conn_state_role+0x42>
    {
        bool central = sdk_mapped_flags_get_by_key(m_bcs.valid_conn_handles,
   279b2:	4b0a      	ldr	r3, [pc, #40]	; (279dc <ble_conn_state_role+0x4c>)
   279b4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   279b6:	88fa      	ldrh	r2, [r7, #6]
   279b8:	4619      	mov	r1, r3
   279ba:	4809      	ldr	r0, [pc, #36]	; (279e0 <ble_conn_state_role+0x50>)
   279bc:	f000 fd16 	bl	283ec <sdk_mapped_flags_get_by_key>
   279c0:	4603      	mov	r3, r0
   279c2:	73bb      	strb	r3, [r7, #14]
                                                   m_bcs.flags.central_flags,
                                                   conn_handle);

        role = central ? BLE_GAP_ROLE_CENTRAL : BLE_GAP_ROLE_PERIPH;
   279c4:	7bbb      	ldrb	r3, [r7, #14]
   279c6:	2b00      	cmp	r3, #0
   279c8:	d001      	beq.n	279ce <ble_conn_state_role+0x3e>
   279ca:	2302      	movs	r3, #2
   279cc:	e000      	b.n	279d0 <ble_conn_state_role+0x40>
   279ce:	2301      	movs	r3, #1
   279d0:	73fb      	strb	r3, [r7, #15]
    }

    return role;
   279d2:	7bfb      	ldrb	r3, [r7, #15]
}
   279d4:	4618      	mov	r0, r3
   279d6:	3710      	adds	r7, #16
   279d8:	46bd      	mov	sp, r7
   279da:	bd80      	pop	{r7, pc}
   279dc:	2000534c 	.word	0x2000534c
   279e0:	20005350 	.word	0x20005350

000279e4 <uint16_decode>:
 * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
 *
 * @return      Decoded value.
 */
static __INLINE uint16_t uint16_decode(const uint8_t * p_encoded_data)
{
   279e4:	b480      	push	{r7}
   279e6:	b083      	sub	sp, #12
   279e8:	af00      	add	r7, sp, #0
   279ea:	6078      	str	r0, [r7, #4]
        return ( (((uint16_t)((uint8_t *)p_encoded_data)[0])) |
   279ec:	687b      	ldr	r3, [r7, #4]
   279ee:	781b      	ldrb	r3, [r3, #0]
   279f0:	b21a      	sxth	r2, r3
                 (((uint16_t)((uint8_t *)p_encoded_data)[1]) << 8 ));
   279f2:	687b      	ldr	r3, [r7, #4]
   279f4:	3301      	adds	r3, #1
   279f6:	781b      	ldrb	r3, [r3, #0]
   279f8:	021b      	lsls	r3, r3, #8
        return ( (((uint16_t)((uint8_t *)p_encoded_data)[0])) |
   279fa:	b21b      	sxth	r3, r3
   279fc:	4313      	orrs	r3, r2
   279fe:	b21b      	sxth	r3, r3
   27a00:	b29b      	uxth	r3, r3
}
   27a02:	4618      	mov	r0, r3
   27a04:	370c      	adds	r7, #12
   27a06:	46bd      	mov	sp, r7
   27a08:	bc80      	pop	{r7}
   27a0a:	4770      	bx	lr

00027a0c <ble_srv_is_notification_enabled>:
#include "nordic_common.h"
#include "app_error.h"
#include "ble.h"

bool ble_srv_is_notification_enabled(uint8_t const * p_encoded_data)
{
   27a0c:	b580      	push	{r7, lr}
   27a0e:	b084      	sub	sp, #16
   27a10:	af00      	add	r7, sp, #0
   27a12:	6078      	str	r0, [r7, #4]
    uint16_t cccd_value = uint16_decode(p_encoded_data);
   27a14:	6878      	ldr	r0, [r7, #4]
   27a16:	f7ff ffe5 	bl	279e4 <uint16_decode>
   27a1a:	4603      	mov	r3, r0
   27a1c:	81fb      	strh	r3, [r7, #14]
    return ((cccd_value & BLE_GATT_HVX_NOTIFICATION) != 0);
   27a1e:	89fb      	ldrh	r3, [r7, #14]
   27a20:	f003 0301 	and.w	r3, r3, #1
   27a24:	2b00      	cmp	r3, #0
   27a26:	bf14      	ite	ne
   27a28:	2301      	movne	r3, #1
   27a2a:	2300      	moveq	r3, #0
   27a2c:	b2db      	uxtb	r3, r3
}
   27a2e:	4618      	mov	r0, r3
   27a30:	3710      	adds	r7, #16
   27a32:	46bd      	mov	sp, r7
   27a34:	bd80      	pop	{r7, pc}

00027a36 <ble_srv_is_indication_enabled>:

bool ble_srv_is_indication_enabled(uint8_t const * p_encoded_data)
{
   27a36:	b580      	push	{r7, lr}
   27a38:	b084      	sub	sp, #16
   27a3a:	af00      	add	r7, sp, #0
   27a3c:	6078      	str	r0, [r7, #4]
    uint16_t cccd_value = uint16_decode(p_encoded_data);
   27a3e:	6878      	ldr	r0, [r7, #4]
   27a40:	f7ff ffd0 	bl	279e4 <uint16_decode>
   27a44:	4603      	mov	r3, r0
   27a46:	81fb      	strh	r3, [r7, #14]
    return ((cccd_value & BLE_GATT_HVX_INDICATION) != 0);
   27a48:	89fb      	ldrh	r3, [r7, #14]
   27a4a:	f003 0302 	and.w	r3, r3, #2
   27a4e:	2b00      	cmp	r3, #0
   27a50:	bf14      	ite	ne
   27a52:	2301      	movne	r3, #1
   27a54:	2300      	moveq	r3, #0
   27a56:	b2db      	uxtb	r3, r3
}
   27a58:	4618      	mov	r0, r3
   27a5a:	3710      	adds	r7, #16
   27a5c:	46bd      	mov	sp, r7
   27a5e:	bd80      	pop	{r7, pc}

00027a60 <sd_ble_gap_adv_start>:
SVCALL(SD_BLE_GAP_ADV_START, uint32_t, sd_ble_gap_adv_start(ble_gap_adv_params_t const *p_adv_params, uint8_t conn_cfg_tag));
   27a60:	df73      	svc	115	; 0x73
   27a62:	4770      	bx	lr
   27a64:	bf00      	nop
   27a66:	4618      	mov	r0, r3

00027a68 <whitelist_has_entries>:
    }

#else

    static bool whitelist_has_entries(ble_advertising_t * const p_advertising)
    {
   27a68:	b480      	push	{r7}
   27a6a:	b083      	sub	sp, #12
   27a6c:	af00      	add	r7, sp, #0
   27a6e:	6078      	str	r0, [r7, #4]
        return p_advertising->whitelist_in_use;
   27a70:	687b      	ldr	r3, [r7, #4]
   27a72:	f893 30d6 	ldrb.w	r3, [r3, #214]	; 0xd6
    }
   27a76:	4618      	mov	r0, r3
   27a78:	370c      	adds	r7, #12
   27a7a:	46bd      	mov	sp, r7
   27a7c:	bc80      	pop	{r7}
   27a7e:	4770      	bx	lr

00027a80 <addr_is_valid>:


/**@brief Function for checking if an address is valid.
 */
static bool addr_is_valid(uint8_t const * const addr)
{
   27a80:	b480      	push	{r7}
   27a82:	b085      	sub	sp, #20
   27a84:	af00      	add	r7, sp, #0
   27a86:	6078      	str	r0, [r7, #4]
    for (uint32_t i = 0; i < BLE_GAP_ADDR_LEN; i++)
   27a88:	2300      	movs	r3, #0
   27a8a:	60fb      	str	r3, [r7, #12]
   27a8c:	e00a      	b.n	27aa4 <addr_is_valid+0x24>
    {
        if (addr[i] != 0)
   27a8e:	687a      	ldr	r2, [r7, #4]
   27a90:	68fb      	ldr	r3, [r7, #12]
   27a92:	4413      	add	r3, r2
   27a94:	781b      	ldrb	r3, [r3, #0]
   27a96:	2b00      	cmp	r3, #0
   27a98:	d001      	beq.n	27a9e <addr_is_valid+0x1e>
        {
            return true;
   27a9a:	2301      	movs	r3, #1
   27a9c:	e006      	b.n	27aac <addr_is_valid+0x2c>
    for (uint32_t i = 0; i < BLE_GAP_ADDR_LEN; i++)
   27a9e:	68fb      	ldr	r3, [r7, #12]
   27aa0:	3301      	adds	r3, #1
   27aa2:	60fb      	str	r3, [r7, #12]
   27aa4:	68fb      	ldr	r3, [r7, #12]
   27aa6:	2b05      	cmp	r3, #5
   27aa8:	d9f1      	bls.n	27a8e <addr_is_valid+0xe>
        }
    }
    return false;
   27aaa:	2300      	movs	r3, #0
}
   27aac:	4618      	mov	r0, r3
   27aae:	3714      	adds	r7, #20
   27ab0:	46bd      	mov	sp, r7
   27ab2:	bc80      	pop	{r7}
   27ab4:	4770      	bx	lr
	...

00027ab8 <adv_mode_next_get>:


static ble_adv_mode_t adv_mode_next_get(ble_adv_mode_t adv_mode)
{
   27ab8:	b480      	push	{r7}
   27aba:	b083      	sub	sp, #12
   27abc:	af00      	add	r7, sp, #0
   27abe:	4603      	mov	r3, r0
   27ac0:	71fb      	strb	r3, [r7, #7]
    return (ble_adv_mode_t)((adv_mode + 1) % BLE_ADV_MODES);
   27ac2:	79fb      	ldrb	r3, [r7, #7]
   27ac4:	1c5a      	adds	r2, r3, #1
   27ac6:	4b08      	ldr	r3, [pc, #32]	; (27ae8 <adv_mode_next_get+0x30>)
   27ac8:	fb83 1302 	smull	r1, r3, r3, r2
   27acc:	1059      	asrs	r1, r3, #1
   27ace:	17d3      	asrs	r3, r2, #31
   27ad0:	1ac9      	subs	r1, r1, r3
   27ad2:	460b      	mov	r3, r1
   27ad4:	009b      	lsls	r3, r3, #2
   27ad6:	440b      	add	r3, r1
   27ad8:	1ad1      	subs	r1, r2, r3
   27ada:	b2cb      	uxtb	r3, r1
}
   27adc:	4618      	mov	r0, r3
   27ade:	370c      	adds	r7, #12
   27ae0:	46bd      	mov	sp, r7
   27ae2:	bc80      	pop	{r7}
   27ae4:	4770      	bx	lr
   27ae6:	bf00      	nop
   27ae8:	66666667 	.word	0x66666667

00027aec <on_connected>:
/**@brief Function for handling the Connected event.
 *
 * @param[in] p_ble_evt Event received from the BLE stack.
 */
static void on_connected(ble_advertising_t * const p_advertising, ble_evt_t const * p_ble_evt)
{
   27aec:	b480      	push	{r7}
   27aee:	b083      	sub	sp, #12
   27af0:	af00      	add	r7, sp, #0
   27af2:	6078      	str	r0, [r7, #4]
   27af4:	6039      	str	r1, [r7, #0]
    if (p_ble_evt->evt.gap_evt.params.connected.role == BLE_GAP_ROLE_PERIPH)
   27af6:	683b      	ldr	r3, [r7, #0]
   27af8:	7bdb      	ldrb	r3, [r3, #15]
   27afa:	2b01      	cmp	r3, #1
   27afc:	d104      	bne.n	27b08 <on_connected+0x1c>
    {
        p_advertising->current_slave_link_conn_handle = p_ble_evt->evt.gap_evt.conn_handle;
   27afe:	683b      	ldr	r3, [r7, #0]
   27b00:	889a      	ldrh	r2, [r3, #4]
   27b02:	687b      	ldr	r3, [r7, #4]
   27b04:	f8a3 20c8 	strh.w	r2, [r3, #200]	; 0xc8
    }
}
   27b08:	bf00      	nop
   27b0a:	370c      	adds	r7, #12
   27b0c:	46bd      	mov	sp, r7
   27b0e:	bc80      	pop	{r7}
   27b10:	4770      	bx	lr

00027b12 <on_disconnected>:
 *
 * @param[in] p_advertising Advertising module instance.
 * @param[in] p_ble_evt Event received from the BLE stack.
 */
static void on_disconnected(ble_advertising_t * const p_advertising, ble_evt_t const * p_ble_evt)
{
   27b12:	b580      	push	{r7, lr}
   27b14:	b084      	sub	sp, #16
   27b16:	af00      	add	r7, sp, #0
   27b18:	6078      	str	r0, [r7, #4]
   27b1a:	6039      	str	r1, [r7, #0]
    uint32_t ret;

    p_advertising->whitelist_temporarily_disabled = false;
   27b1c:	687b      	ldr	r3, [r7, #4]
   27b1e:	2200      	movs	r2, #0
   27b20:	f883 20d4 	strb.w	r2, [r3, #212]	; 0xd4

    if (p_ble_evt->evt.gap_evt.conn_handle == p_advertising->current_slave_link_conn_handle &&
   27b24:	683b      	ldr	r3, [r7, #0]
   27b26:	889a      	ldrh	r2, [r3, #4]
   27b28:	687b      	ldr	r3, [r7, #4]
   27b2a:	f8b3 30c8 	ldrh.w	r3, [r3, #200]	; 0xc8
   27b2e:	429a      	cmp	r2, r3
   27b30:	d118      	bne.n	27b64 <on_disconnected+0x52>
        p_advertising->adv_modes_config.ble_adv_on_disconnect_disabled == false)
   27b32:	687b      	ldr	r3, [r7, #4]
   27b34:	791b      	ldrb	r3, [r3, #4]
   27b36:	f083 0301 	eor.w	r3, r3, #1
   27b3a:	b2db      	uxtb	r3, r3
    if (p_ble_evt->evt.gap_evt.conn_handle == p_advertising->current_slave_link_conn_handle &&
   27b3c:	2b00      	cmp	r3, #0
   27b3e:	d011      	beq.n	27b64 <on_disconnected+0x52>
    {
       ret = ble_advertising_start(p_advertising, BLE_ADV_MODE_DIRECTED);
   27b40:	2101      	movs	r1, #1
   27b42:	6878      	ldr	r0, [r7, #4]
   27b44:	f000 fa5c 	bl	28000 <ble_advertising_start>
   27b48:	60f8      	str	r0, [r7, #12]
       if ((ret != NRF_SUCCESS) && (p_advertising->error_handler != NULL))
   27b4a:	68fb      	ldr	r3, [r7, #12]
   27b4c:	2b00      	cmp	r3, #0
   27b4e:	d009      	beq.n	27b64 <on_disconnected+0x52>
   27b50:	687b      	ldr	r3, [r7, #4]
   27b52:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
   27b56:	2b00      	cmp	r3, #0
   27b58:	d004      	beq.n	27b64 <on_disconnected+0x52>
       {
           p_advertising->error_handler(ret);
   27b5a:	687b      	ldr	r3, [r7, #4]
   27b5c:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
   27b60:	68f8      	ldr	r0, [r7, #12]
   27b62:	4798      	blx	r3
       }
    }
}
   27b64:	bf00      	nop
   27b66:	3710      	adds	r7, #16
   27b68:	46bd      	mov	sp, r7
   27b6a:	bd80      	pop	{r7, pc}

00027b6c <on_timeout>:
 *
 * @param[in] p_advertising Advertising module instance.
 * @param[in] p_ble_evt Event received from the BLE stack.
 */
static void on_timeout(ble_advertising_t * const p_advertising, ble_evt_t const * p_ble_evt)
{
   27b6c:	b580      	push	{r7, lr}
   27b6e:	b084      	sub	sp, #16
   27b70:	af00      	add	r7, sp, #0
   27b72:	6078      	str	r0, [r7, #4]
   27b74:	6039      	str	r1, [r7, #0]
    ret_code_t ret;

    if (p_ble_evt->evt.gap_evt.params.timeout.src != BLE_GAP_TIMEOUT_SRC_ADVERTISING)
   27b76:	683b      	ldr	r3, [r7, #0]
   27b78:	7a1b      	ldrb	r3, [r3, #8]
   27b7a:	2b00      	cmp	r3, #0
   27b7c:	d118      	bne.n	27bb0 <on_timeout+0x44>
        // Nothing to do.
        return;
    }

    // Start advertising in the next mode.
    ret = ble_advertising_start(p_advertising, adv_mode_next_get(p_advertising->adv_mode_current));
   27b7e:	687b      	ldr	r3, [r7, #4]
   27b80:	78db      	ldrb	r3, [r3, #3]
   27b82:	4618      	mov	r0, r3
   27b84:	f7ff ff98 	bl	27ab8 <adv_mode_next_get>
   27b88:	4603      	mov	r3, r0
   27b8a:	4619      	mov	r1, r3
   27b8c:	6878      	ldr	r0, [r7, #4]
   27b8e:	f000 fa37 	bl	28000 <ble_advertising_start>
   27b92:	60f8      	str	r0, [r7, #12]

    if ((ret != NRF_SUCCESS) && (p_advertising->error_handler != NULL))
   27b94:	68fb      	ldr	r3, [r7, #12]
   27b96:	2b00      	cmp	r3, #0
   27b98:	d00b      	beq.n	27bb2 <on_timeout+0x46>
   27b9a:	687b      	ldr	r3, [r7, #4]
   27b9c:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
   27ba0:	2b00      	cmp	r3, #0
   27ba2:	d006      	beq.n	27bb2 <on_timeout+0x46>
    {
        p_advertising->error_handler(ret);
   27ba4:	687b      	ldr	r3, [r7, #4]
   27ba6:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
   27baa:	68f8      	ldr	r0, [r7, #12]
   27bac:	4798      	blx	r3
   27bae:	e000      	b.n	27bb2 <on_timeout+0x46>
        return;
   27bb0:	bf00      	nop
    }
}
   27bb2:	3710      	adds	r7, #16
   27bb4:	46bd      	mov	sp, r7
   27bb6:	bd80      	pop	{r7, pc}

00027bb8 <flash_access_in_progress>:
/** @brief Function to determine if a flash write operation in in progress.
 *
 * @return true if a flash operation is in progress, false if not.
 */
static bool flash_access_in_progress()
{
   27bb8:	b580      	push	{r7, lr}
   27bba:	af00      	add	r7, sp, #0
    return nrf_fstorage_is_busy(NULL);
   27bbc:	2000      	movs	r0, #0
   27bbe:	f000 fc75 	bl	284ac <nrf_fstorage_is_busy>
   27bc2:	4603      	mov	r3, r0
}
   27bc4:	4618      	mov	r0, r3
   27bc6:	bd80      	pop	{r7, pc}

00027bc8 <adv_mode_next_avail_get>:
 *
 * @returns adv_mode if possible, or the best available mode if not.
 */
static ble_adv_mode_t adv_mode_next_avail_get(ble_advertising_t * const p_advertising,
                                              ble_adv_mode_t            adv_mode)
{
   27bc8:	b580      	push	{r7, lr}
   27bca:	b084      	sub	sp, #16
   27bcc:	af00      	add	r7, sp, #0
   27bce:	6078      	str	r0, [r7, #4]
   27bd0:	460b      	mov	r3, r1
   27bd2:	70fb      	strb	r3, [r7, #3]
    bool peer_addr_is_valid = addr_is_valid(p_advertising->peer_address.addr);
   27bd4:	687b      	ldr	r3, [r7, #4]
   27bd6:	3326      	adds	r3, #38	; 0x26
   27bd8:	4618      	mov	r0, r3
   27bda:	f7ff ff51 	bl	27a80 <addr_is_valid>
   27bde:	4603      	mov	r3, r0
   27be0:	73fb      	strb	r3, [r7, #15]

    // If a mode is disabled, continue to the next mode.

    switch (adv_mode)
   27be2:	78fb      	ldrb	r3, [r7, #3]
   27be4:	3b01      	subs	r3, #1
   27be6:	2b03      	cmp	r3, #3
   27be8:	d828      	bhi.n	27c3c <adv_mode_next_avail_get+0x74>
   27bea:	a201      	add	r2, pc, #4	; (adr r2, 27bf0 <adv_mode_next_avail_get+0x28>)
   27bec:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   27bf0:	00027c01 	.word	0x00027c01
   27bf4:	00027c13 	.word	0x00027c13
   27bf8:	00027c25 	.word	0x00027c25
   27bfc:	00027c31 	.word	0x00027c31
    {
        case BLE_ADV_MODE_DIRECTED:
            if ((p_advertising->adv_modes_config.ble_adv_directed_enabled) && peer_addr_is_valid)
   27c00:	687b      	ldr	r3, [r7, #4]
   27c02:	799b      	ldrb	r3, [r3, #6]
   27c04:	2b00      	cmp	r3, #0
   27c06:	d004      	beq.n	27c12 <adv_mode_next_avail_get+0x4a>
   27c08:	7bfb      	ldrb	r3, [r7, #15]
   27c0a:	2b00      	cmp	r3, #0
   27c0c:	d001      	beq.n	27c12 <adv_mode_next_avail_get+0x4a>
            {
                return BLE_ADV_MODE_DIRECTED;
   27c0e:	2301      	movs	r3, #1
   27c10:	e015      	b.n	27c3e <adv_mode_next_avail_get+0x76>
            }
            // Fallthrough.

        case BLE_ADV_MODE_DIRECTED_SLOW:
            if ((p_advertising->adv_modes_config.ble_adv_directed_slow_enabled) && peer_addr_is_valid)
   27c12:	687b      	ldr	r3, [r7, #4]
   27c14:	79db      	ldrb	r3, [r3, #7]
   27c16:	2b00      	cmp	r3, #0
   27c18:	d004      	beq.n	27c24 <adv_mode_next_avail_get+0x5c>
   27c1a:	7bfb      	ldrb	r3, [r7, #15]
   27c1c:	2b00      	cmp	r3, #0
   27c1e:	d001      	beq.n	27c24 <adv_mode_next_avail_get+0x5c>
            {
                return BLE_ADV_MODE_DIRECTED_SLOW;
   27c20:	2302      	movs	r3, #2
   27c22:	e00c      	b.n	27c3e <adv_mode_next_avail_get+0x76>
            }
            // Fallthrough.

        case BLE_ADV_MODE_FAST:
            if (p_advertising->adv_modes_config.ble_adv_fast_enabled)
   27c24:	687b      	ldr	r3, [r7, #4]
   27c26:	7a1b      	ldrb	r3, [r3, #8]
   27c28:	2b00      	cmp	r3, #0
   27c2a:	d001      	beq.n	27c30 <adv_mode_next_avail_get+0x68>
            {
                return BLE_ADV_MODE_FAST;
   27c2c:	2303      	movs	r3, #3
   27c2e:	e006      	b.n	27c3e <adv_mode_next_avail_get+0x76>
            }
            // Fallthrough.

        case BLE_ADV_MODE_SLOW:
            if (p_advertising->adv_modes_config.ble_adv_slow_enabled)
   27c30:	687b      	ldr	r3, [r7, #4]
   27c32:	7a5b      	ldrb	r3, [r3, #9]
   27c34:	2b00      	cmp	r3, #0
   27c36:	d001      	beq.n	27c3c <adv_mode_next_avail_get+0x74>
            {
                return BLE_ADV_MODE_SLOW;
   27c38:	2304      	movs	r3, #4
   27c3a:	e000      	b.n	27c3e <adv_mode_next_avail_get+0x76>
            }
            // Fallthrough.

        default:
            return BLE_ADV_MODE_IDLE;
   27c3c:	2300      	movs	r3, #0
    }
}
   27c3e:	4618      	mov	r0, r3
   27c40:	3710      	adds	r7, #16
   27c42:	46bd      	mov	sp, r7
   27c44:	bd80      	pop	{r7, pc}
   27c46:	bf00      	nop

00027c48 <set_adv_mode_directed>:
 *
 * @return NRF_SUCCESS
 */
static ret_code_t set_adv_mode_directed(ble_advertising_t * const p_advertising,
                                        ble_gap_adv_params_t    * p_adv_params)
{
   27c48:	b480      	push	{r7}
   27c4a:	b083      	sub	sp, #12
   27c4c:	af00      	add	r7, sp, #0
   27c4e:	6078      	str	r0, [r7, #4]
   27c50:	6039      	str	r1, [r7, #0]
    p_advertising->adv_evt  = BLE_ADV_EVT_DIRECTED;
   27c52:	687b      	ldr	r3, [r7, #4]
   27c54:	2201      	movs	r2, #1
   27c56:	709a      	strb	r2, [r3, #2]

    p_adv_params->p_peer_addr = &(p_advertising->peer_address);
   27c58:	687b      	ldr	r3, [r7, #4]
   27c5a:	f103 0225 	add.w	r2, r3, #37	; 0x25
   27c5e:	683b      	ldr	r3, [r7, #0]
   27c60:	605a      	str	r2, [r3, #4]
    p_adv_params->type        = BLE_GAP_ADV_TYPE_ADV_DIRECT_IND;
   27c62:	683b      	ldr	r3, [r7, #0]
   27c64:	2201      	movs	r2, #1
   27c66:	701a      	strb	r2, [r3, #0]
    p_adv_params->timeout     = 0;
   27c68:	683b      	ldr	r3, [r7, #0]
   27c6a:	2200      	movs	r2, #0
   27c6c:	819a      	strh	r2, [r3, #12]
    p_adv_params->interval    = 0;
   27c6e:	683b      	ldr	r3, [r7, #0]
   27c70:	2200      	movs	r2, #0
   27c72:	815a      	strh	r2, [r3, #10]

    return NRF_SUCCESS;
   27c74:	2300      	movs	r3, #0
}
   27c76:	4618      	mov	r0, r3
   27c78:	370c      	adds	r7, #12
   27c7a:	46bd      	mov	sp, r7
   27c7c:	bc80      	pop	{r7}
   27c7e:	4770      	bx	lr

00027c80 <set_adv_mode_directed_slow>:
 *
 * @return NRF_SUCCESS
 */
static ret_code_t set_adv_mode_directed_slow(ble_advertising_t * const p_advertising,
                                             ble_gap_adv_params_t    * p_adv_params)
{
   27c80:	b480      	push	{r7}
   27c82:	b083      	sub	sp, #12
   27c84:	af00      	add	r7, sp, #0
   27c86:	6078      	str	r0, [r7, #4]
   27c88:	6039      	str	r1, [r7, #0]
    p_advertising->adv_evt = BLE_ADV_EVT_DIRECTED_SLOW;
   27c8a:	687b      	ldr	r3, [r7, #4]
   27c8c:	2202      	movs	r2, #2
   27c8e:	709a      	strb	r2, [r3, #2]

    p_adv_params->p_peer_addr = &p_advertising->peer_address;
   27c90:	687b      	ldr	r3, [r7, #4]
   27c92:	f103 0225 	add.w	r2, r3, #37	; 0x25
   27c96:	683b      	ldr	r3, [r7, #0]
   27c98:	605a      	str	r2, [r3, #4]
    p_adv_params->type        = BLE_GAP_ADV_TYPE_ADV_DIRECT_IND;
   27c9a:	683b      	ldr	r3, [r7, #0]
   27c9c:	2201      	movs	r2, #1
   27c9e:	701a      	strb	r2, [r3, #0]
    p_adv_params->timeout     = p_advertising->adv_modes_config.ble_adv_directed_slow_timeout;
   27ca0:	687b      	ldr	r3, [r7, #4]
   27ca2:	691b      	ldr	r3, [r3, #16]
   27ca4:	b29a      	uxth	r2, r3
   27ca6:	683b      	ldr	r3, [r7, #0]
   27ca8:	819a      	strh	r2, [r3, #12]
    p_adv_params->interval    = p_advertising->adv_modes_config.ble_adv_directed_slow_interval;
   27caa:	687b      	ldr	r3, [r7, #4]
   27cac:	68db      	ldr	r3, [r3, #12]
   27cae:	b29a      	uxth	r2, r3
   27cb0:	683b      	ldr	r3, [r7, #0]
   27cb2:	815a      	strh	r2, [r3, #10]

    return NRF_SUCCESS;
   27cb4:	2300      	movs	r3, #0
}
   27cb6:	4618      	mov	r0, r3
   27cb8:	370c      	adds	r7, #12
   27cba:	46bd      	mov	sp, r7
   27cbc:	bc80      	pop	{r7}
   27cbe:	4770      	bx	lr

00027cc0 <set_adv_mode_fast>:
 *
 * @return NRF_SUCCESS or an error from @ref ble_advdata_set().
 */
static ret_code_t set_adv_mode_fast(ble_advertising_t * const p_advertising,
                                    ble_gap_adv_params_t    * p_adv_params)
{
   27cc0:	b580      	push	{r7, lr}
   27cc2:	b084      	sub	sp, #16
   27cc4:	af00      	add	r7, sp, #0
   27cc6:	6078      	str	r0, [r7, #4]
   27cc8:	6039      	str	r1, [r7, #0]
    ret_code_t ret;

    p_adv_params->interval = p_advertising->adv_modes_config.ble_adv_fast_interval;
   27cca:	687b      	ldr	r3, [r7, #4]
   27ccc:	695b      	ldr	r3, [r3, #20]
   27cce:	b29a      	uxth	r2, r3
   27cd0:	683b      	ldr	r3, [r7, #0]
   27cd2:	815a      	strh	r2, [r3, #10]
    p_adv_params->timeout  = p_advertising->adv_modes_config.ble_adv_fast_timeout;
   27cd4:	687b      	ldr	r3, [r7, #4]
   27cd6:	699b      	ldr	r3, [r3, #24]
   27cd8:	b29a      	uxth	r2, r3
   27cda:	683b      	ldr	r3, [r7, #0]
   27cdc:	819a      	strh	r2, [r3, #12]

    if ((p_advertising->adv_modes_config.ble_adv_whitelist_enabled) &&
   27cde:	687b      	ldr	r3, [r7, #4]
   27ce0:	795b      	ldrb	r3, [r3, #5]
   27ce2:	2b00      	cmp	r3, #0
   27ce4:	d024      	beq.n	27d30 <set_adv_mode_fast+0x70>
        (!p_advertising->whitelist_temporarily_disabled) &&
   27ce6:	687b      	ldr	r3, [r7, #4]
   27ce8:	f893 30d4 	ldrb.w	r3, [r3, #212]	; 0xd4
   27cec:	f083 0301 	eor.w	r3, r3, #1
   27cf0:	b2db      	uxtb	r3, r3
    if ((p_advertising->adv_modes_config.ble_adv_whitelist_enabled) &&
   27cf2:	2b00      	cmp	r3, #0
   27cf4:	d01c      	beq.n	27d30 <set_adv_mode_fast+0x70>
        (whitelist_has_entries(p_advertising)))
   27cf6:	6878      	ldr	r0, [r7, #4]
   27cf8:	f7ff feb6 	bl	27a68 <whitelist_has_entries>
   27cfc:	4603      	mov	r3, r0
        (!p_advertising->whitelist_temporarily_disabled) &&
   27cfe:	2b00      	cmp	r3, #0
   27d00:	d016      	beq.n	27d30 <set_adv_mode_fast+0x70>
    {
        #if (NRF_SD_BLE_API_VERSION <= 2)
            p_adv_params->p_whitelist = &m_whitelist;
        #endif

        p_adv_params->fp = BLE_GAP_ADV_FP_FILTER_CONNREQ;
   27d02:	683b      	ldr	r3, [r7, #0]
   27d04:	2202      	movs	r2, #2
   27d06:	721a      	strb	r2, [r3, #8]
        p_advertising->advdata.flags  = BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED;
   27d08:	687b      	ldr	r3, [r7, #4]
   27d0a:	2204      	movs	r2, #4
   27d0c:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33

        ret = ble_advdata_set(&(p_advertising->advdata), NULL);
   27d10:	687b      	ldr	r3, [r7, #4]
   27d12:	3330      	adds	r3, #48	; 0x30
   27d14:	2100      	movs	r1, #0
   27d16:	4618      	mov	r0, r3
   27d18:	f7fe ffa2 	bl	26c60 <ble_advdata_set>
   27d1c:	60f8      	str	r0, [r7, #12]
        if (ret != NRF_SUCCESS)
   27d1e:	68fb      	ldr	r3, [r7, #12]
   27d20:	2b00      	cmp	r3, #0
   27d22:	d001      	beq.n	27d28 <set_adv_mode_fast+0x68>
        {
            return ret;
   27d24:	68fb      	ldr	r3, [r7, #12]
   27d26:	e007      	b.n	27d38 <set_adv_mode_fast+0x78>
        }

        p_advertising->adv_evt = BLE_ADV_EVT_FAST_WHITELIST;
   27d28:	687b      	ldr	r3, [r7, #4]
   27d2a:	2205      	movs	r2, #5
   27d2c:	709a      	strb	r2, [r3, #2]
   27d2e:	e002      	b.n	27d36 <set_adv_mode_fast+0x76>
    }
    else
    {
        p_advertising->adv_evt = BLE_ADV_EVT_FAST;
   27d30:	687b      	ldr	r3, [r7, #4]
   27d32:	2203      	movs	r2, #3
   27d34:	709a      	strb	r2, [r3, #2]
    }

    return NRF_SUCCESS;
   27d36:	2300      	movs	r3, #0
}
   27d38:	4618      	mov	r0, r3
   27d3a:	3710      	adds	r7, #16
   27d3c:	46bd      	mov	sp, r7
   27d3e:	bd80      	pop	{r7, pc}

00027d40 <set_adv_mode_slow>:
 *
 * @return NRF_SUCCESS or an error from @ref ble_advdata_set().
 */
static ret_code_t set_adv_mode_slow(ble_advertising_t * const p_advertising,
                                    ble_gap_adv_params_t    * p_adv_params)
{
   27d40:	b580      	push	{r7, lr}
   27d42:	b084      	sub	sp, #16
   27d44:	af00      	add	r7, sp, #0
   27d46:	6078      	str	r0, [r7, #4]
   27d48:	6039      	str	r1, [r7, #0]
    ret_code_t ret;

    p_adv_params->interval = p_advertising->adv_modes_config.ble_adv_slow_interval;
   27d4a:	687b      	ldr	r3, [r7, #4]
   27d4c:	69db      	ldr	r3, [r3, #28]
   27d4e:	b29a      	uxth	r2, r3
   27d50:	683b      	ldr	r3, [r7, #0]
   27d52:	815a      	strh	r2, [r3, #10]
    p_adv_params->timeout  = p_advertising->adv_modes_config.ble_adv_slow_timeout;
   27d54:	687b      	ldr	r3, [r7, #4]
   27d56:	6a1b      	ldr	r3, [r3, #32]
   27d58:	b29a      	uxth	r2, r3
   27d5a:	683b      	ldr	r3, [r7, #0]
   27d5c:	819a      	strh	r2, [r3, #12]

    if ((p_advertising->adv_modes_config.ble_adv_whitelist_enabled) &&
   27d5e:	687b      	ldr	r3, [r7, #4]
   27d60:	795b      	ldrb	r3, [r3, #5]
   27d62:	2b00      	cmp	r3, #0
   27d64:	d024      	beq.n	27db0 <set_adv_mode_slow+0x70>
        (!p_advertising->whitelist_temporarily_disabled) &&
   27d66:	687b      	ldr	r3, [r7, #4]
   27d68:	f893 30d4 	ldrb.w	r3, [r3, #212]	; 0xd4
   27d6c:	f083 0301 	eor.w	r3, r3, #1
   27d70:	b2db      	uxtb	r3, r3
    if ((p_advertising->adv_modes_config.ble_adv_whitelist_enabled) &&
   27d72:	2b00      	cmp	r3, #0
   27d74:	d01c      	beq.n	27db0 <set_adv_mode_slow+0x70>
        (whitelist_has_entries(p_advertising)))
   27d76:	6878      	ldr	r0, [r7, #4]
   27d78:	f7ff fe76 	bl	27a68 <whitelist_has_entries>
   27d7c:	4603      	mov	r3, r0
        (!p_advertising->whitelist_temporarily_disabled) &&
   27d7e:	2b00      	cmp	r3, #0
   27d80:	d016      	beq.n	27db0 <set_adv_mode_slow+0x70>
        {
            p_adv_params->p_whitelist = &p_advertising->whitelist;
        }
        #endif

        p_adv_params->fp = BLE_GAP_ADV_FP_FILTER_CONNREQ;
   27d82:	683b      	ldr	r3, [r7, #0]
   27d84:	2202      	movs	r2, #2
   27d86:	721a      	strb	r2, [r3, #8]
        p_advertising->advdata.flags  = BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED;
   27d88:	687b      	ldr	r3, [r7, #4]
   27d8a:	2204      	movs	r2, #4
   27d8c:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33

        ret = ble_advdata_set(&(p_advertising->advdata), NULL);
   27d90:	687b      	ldr	r3, [r7, #4]
   27d92:	3330      	adds	r3, #48	; 0x30
   27d94:	2100      	movs	r1, #0
   27d96:	4618      	mov	r0, r3
   27d98:	f7fe ff62 	bl	26c60 <ble_advdata_set>
   27d9c:	60f8      	str	r0, [r7, #12]
        if (ret != NRF_SUCCESS)
   27d9e:	68fb      	ldr	r3, [r7, #12]
   27da0:	2b00      	cmp	r3, #0
   27da2:	d001      	beq.n	27da8 <set_adv_mode_slow+0x68>
        {
            return ret;
   27da4:	68fb      	ldr	r3, [r7, #12]
   27da6:	e007      	b.n	27db8 <set_adv_mode_slow+0x78>
        }

        p_advertising->adv_evt = BLE_ADV_EVT_SLOW_WHITELIST;
   27da8:	687b      	ldr	r3, [r7, #4]
   27daa:	2206      	movs	r2, #6
   27dac:	709a      	strb	r2, [r3, #2]
   27dae:	e002      	b.n	27db6 <set_adv_mode_slow+0x76>
    }
    else
    {
        p_advertising->adv_evt = BLE_ADV_EVT_SLOW;
   27db0:	687b      	ldr	r3, [r7, #4]
   27db2:	2204      	movs	r2, #4
   27db4:	709a      	strb	r2, [r3, #2]
    }

    return NRF_SUCCESS;
   27db6:	2300      	movs	r3, #0
}
   27db8:	4618      	mov	r0, r3
   27dba:	3710      	adds	r7, #16
   27dbc:	46bd      	mov	sp, r7
   27dbe:	bd80      	pop	{r7, pc}

00027dc0 <ble_advertising_conn_cfg_tag_set>:


void ble_advertising_conn_cfg_tag_set(ble_advertising_t * const p_advertising,
                                      uint8_t                   ble_cfg_tag)
{
   27dc0:	b480      	push	{r7}
   27dc2:	b083      	sub	sp, #12
   27dc4:	af00      	add	r7, sp, #0
   27dc6:	6078      	str	r0, [r7, #4]
   27dc8:	460b      	mov	r3, r1
   27dca:	70fb      	strb	r3, [r7, #3]
    p_advertising->conn_cfg_tag = ble_cfg_tag;
   27dcc:	687b      	ldr	r3, [r7, #4]
   27dce:	78fa      	ldrb	r2, [r7, #3]
   27dd0:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
}
   27dd4:	bf00      	nop
   27dd6:	370c      	adds	r7, #12
   27dd8:	46bd      	mov	sp, r7
   27dda:	bc80      	pop	{r7}
   27ddc:	4770      	bx	lr

00027dde <ble_advertising_init>:


uint32_t ble_advertising_init(ble_advertising_t            * const p_advertising,
                              ble_advertising_init_t const * const p_init)
{
   27dde:	b5b0      	push	{r4, r5, r7, lr}
   27de0:	b086      	sub	sp, #24
   27de2:	af00      	add	r7, sp, #0
   27de4:	6078      	str	r0, [r7, #4]
   27de6:	6039      	str	r1, [r7, #0]
    uint32_t ret;
    if ((p_init == NULL) || (p_advertising == NULL))
   27de8:	683b      	ldr	r3, [r7, #0]
   27dea:	2b00      	cmp	r3, #0
   27dec:	d002      	beq.n	27df4 <ble_advertising_init+0x16>
   27dee:	687b      	ldr	r3, [r7, #4]
   27df0:	2b00      	cmp	r3, #0
   27df2:	d101      	bne.n	27df8 <ble_advertising_init+0x1a>
    {
        return NRF_ERROR_NULL;
   27df4:	230e      	movs	r3, #14
   27df6:	e0ff      	b.n	27ff8 <ble_advertising_init+0x21a>
    }

    p_advertising->initialized                    = true;
   27df8:	687b      	ldr	r3, [r7, #4]
   27dfa:	2201      	movs	r2, #1
   27dfc:	701a      	strb	r2, [r3, #0]
    p_advertising->adv_mode_current               = BLE_ADV_MODE_IDLE;
   27dfe:	687b      	ldr	r3, [r7, #4]
   27e00:	2200      	movs	r2, #0
   27e02:	70da      	strb	r2, [r3, #3]
    p_advertising->adv_modes_config               = p_init->config;
   27e04:	687a      	ldr	r2, [r7, #4]
   27e06:	683b      	ldr	r3, [r7, #0]
   27e08:	1d14      	adds	r4, r2, #4
   27e0a:	f103 0578 	add.w	r5, r3, #120	; 0x78
   27e0e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   27e10:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   27e12:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   27e16:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    p_advertising->conn_cfg_tag                   = BLE_CONN_CFG_TAG_DEFAULT;
   27e1a:	687b      	ldr	r3, [r7, #4]
   27e1c:	2200      	movs	r2, #0
   27e1e:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
    p_advertising->evt_handler                    = p_init->evt_handler;
   27e22:	683b      	ldr	r3, [r7, #0]
   27e24:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
   27e28:	687b      	ldr	r3, [r7, #4]
   27e2a:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
    p_advertising->error_handler                  = p_init->error_handler;
   27e2e:	683b      	ldr	r3, [r7, #0]
   27e30:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
   27e34:	687b      	ldr	r3, [r7, #4]
   27e36:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
    p_advertising->current_slave_link_conn_handle = BLE_CONN_HANDLE_INVALID;
   27e3a:	687b      	ldr	r3, [r7, #4]
   27e3c:	f64f 72ff 	movw	r2, #65535	; 0xffff
   27e40:	f8a3 20c8 	strh.w	r2, [r3, #200]	; 0xc8

    memset(&p_advertising->peer_address, 0, sizeof(p_advertising->peer_address));
   27e44:	687b      	ldr	r3, [r7, #4]
   27e46:	3325      	adds	r3, #37	; 0x25
   27e48:	2207      	movs	r2, #7
   27e4a:	2100      	movs	r1, #0
   27e4c:	4618      	mov	r0, r3
   27e4e:	f7fb fbe5 	bl	2361c <memset>
    memset(&p_advertising->advdata,      0, sizeof(p_advertising->advdata));
   27e52:	687b      	ldr	r3, [r7, #4]
   27e54:	3330      	adds	r3, #48	; 0x30
   27e56:	223c      	movs	r2, #60	; 0x3c
   27e58:	2100      	movs	r1, #0
   27e5a:	4618      	mov	r0, r3
   27e5c:	f7fb fbde 	bl	2361c <memset>

    // Copy advertising data.
    p_advertising->advdata.name_type          = p_init->advdata.name_type;
   27e60:	683b      	ldr	r3, [r7, #0]
   27e62:	781a      	ldrb	r2, [r3, #0]
   27e64:	687b      	ldr	r3, [r7, #4]
   27e66:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
    p_advertising->advdata.include_appearance = p_init->advdata.include_appearance;
   27e6a:	683b      	ldr	r3, [r7, #0]
   27e6c:	789a      	ldrb	r2, [r3, #2]
   27e6e:	687b      	ldr	r3, [r7, #4]
   27e70:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
    p_advertising->advdata.flags              = p_init->advdata.flags;
   27e74:	683b      	ldr	r3, [r7, #0]
   27e76:	78da      	ldrb	r2, [r3, #3]
   27e78:	687b      	ldr	r3, [r7, #4]
   27e7a:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
    p_advertising->advdata.short_name_len     = p_init->advdata.short_name_len;
   27e7e:	683b      	ldr	r3, [r7, #0]
   27e80:	785a      	ldrb	r2, [r3, #1]
   27e82:	687b      	ldr	r3, [r7, #4]
   27e84:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31

    p_advertising->advdata.uuids_complete          = p_init->advdata.uuids_complete;
   27e88:	687b      	ldr	r3, [r7, #4]
   27e8a:	683a      	ldr	r2, [r7, #0]
   27e8c:	3340      	adds	r3, #64	; 0x40
   27e8e:	3210      	adds	r2, #16
   27e90:	e892 0003 	ldmia.w	r2, {r0, r1}
   27e94:	e883 0003 	stmia.w	r3, {r0, r1}
    p_advertising->advdata.uuids_more_available    = p_init->advdata.uuids_more_available;
   27e98:	687b      	ldr	r3, [r7, #4]
   27e9a:	683a      	ldr	r2, [r7, #0]
   27e9c:	3338      	adds	r3, #56	; 0x38
   27e9e:	3208      	adds	r2, #8
   27ea0:	e892 0003 	ldmia.w	r2, {r0, r1}
   27ea4:	e883 0003 	stmia.w	r3, {r0, r1}
    p_advertising->advdata.uuids_solicited         = p_init->advdata.uuids_solicited;
   27ea8:	687b      	ldr	r3, [r7, #4]
   27eaa:	683a      	ldr	r2, [r7, #0]
   27eac:	3348      	adds	r3, #72	; 0x48
   27eae:	3218      	adds	r2, #24
   27eb0:	e892 0003 	ldmia.w	r2, {r0, r1}
   27eb4:	e883 0003 	stmia.w	r3, {r0, r1}
    p_advertising->advdata.include_ble_device_addr = p_init->advdata.include_ble_device_addr;
   27eb8:	683b      	ldr	r3, [r7, #0]
   27eba:	f893 202d 	ldrb.w	r2, [r3, #45]	; 0x2d
   27ebe:	687b      	ldr	r3, [r7, #4]
   27ec0:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d

    if (p_init->advdata.p_manuf_specific_data != NULL)
   27ec4:	683b      	ldr	r3, [r7, #0]
   27ec6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   27ec8:	2b00      	cmp	r3, #0
   27eca:	d02e      	beq.n	27f2a <ble_advertising_init+0x14c>
    {
        p_advertising->advdata.p_manuf_specific_data   = &(p_advertising->manuf_specific_data);
   27ecc:	687b      	ldr	r3, [r7, #4]
   27ece:	f103 026c 	add.w	r2, r3, #108	; 0x6c
   27ed2:	687b      	ldr	r3, [r7, #4]
   27ed4:	655a      	str	r2, [r3, #84]	; 0x54
        p_advertising->manuf_specific_data.data.p_data = p_advertising->manuf_data_array;
   27ed6:	687b      	ldr	r3, [r7, #4]
   27ed8:	f103 0278 	add.w	r2, r3, #120	; 0x78
   27edc:	687b      	ldr	r3, [r7, #4]
   27ede:	675a      	str	r2, [r3, #116]	; 0x74
        p_advertising->advdata.p_manuf_specific_data->company_identifier =
            p_init->advdata.p_manuf_specific_data->company_identifier;
   27ee0:	683b      	ldr	r3, [r7, #0]
   27ee2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
        p_advertising->advdata.p_manuf_specific_data->company_identifier =
   27ee4:	687b      	ldr	r3, [r7, #4]
   27ee6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
            p_init->advdata.p_manuf_specific_data->company_identifier;
   27ee8:	8812      	ldrh	r2, [r2, #0]
        p_advertising->advdata.p_manuf_specific_data->company_identifier =
   27eea:	801a      	strh	r2, [r3, #0]
        p_advertising->advdata.p_manuf_specific_data->data.size = p_init->advdata.p_manuf_specific_data->data.size;
   27eec:	683b      	ldr	r3, [r7, #0]
   27eee:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   27ef0:	687b      	ldr	r3, [r7, #4]
   27ef2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   27ef4:	8892      	ldrh	r2, [r2, #4]
   27ef6:	809a      	strh	r2, [r3, #4]

        for (uint32_t i = 0; i < p_advertising->advdata.p_manuf_specific_data->data.size; i++)
   27ef8:	2300      	movs	r3, #0
   27efa:	617b      	str	r3, [r7, #20]
   27efc:	e00e      	b.n	27f1c <ble_advertising_init+0x13e>
        {
            p_advertising->manuf_data_array[i] = p_init->advdata.p_manuf_specific_data->data.p_data[i];
   27efe:	683b      	ldr	r3, [r7, #0]
   27f00:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   27f02:	689a      	ldr	r2, [r3, #8]
   27f04:	697b      	ldr	r3, [r7, #20]
   27f06:	4413      	add	r3, r2
   27f08:	7819      	ldrb	r1, [r3, #0]
   27f0a:	687a      	ldr	r2, [r7, #4]
   27f0c:	697b      	ldr	r3, [r7, #20]
   27f0e:	4413      	add	r3, r2
   27f10:	3378      	adds	r3, #120	; 0x78
   27f12:	460a      	mov	r2, r1
   27f14:	701a      	strb	r2, [r3, #0]
        for (uint32_t i = 0; i < p_advertising->advdata.p_manuf_specific_data->data.size; i++)
   27f16:	697b      	ldr	r3, [r7, #20]
   27f18:	3301      	adds	r3, #1
   27f1a:	617b      	str	r3, [r7, #20]
   27f1c:	687b      	ldr	r3, [r7, #4]
   27f1e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   27f20:	889b      	ldrh	r3, [r3, #4]
   27f22:	461a      	mov	r2, r3
   27f24:	697b      	ldr	r3, [r7, #20]
   27f26:	4293      	cmp	r3, r2
   27f28:	d3e9      	bcc.n	27efe <ble_advertising_init+0x120>
        }
    }

    if (p_init->advdata.p_service_data_array != NULL)
   27f2a:	683b      	ldr	r3, [r7, #0]
   27f2c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   27f2e:	2b00      	cmp	r3, #0
   27f30:	d03a      	beq.n	27fa8 <ble_advertising_init+0x1ca>
    {
        p_advertising->service_data.data.p_data                   = p_advertising->service_data_array;
   27f32:	687b      	ldr	r3, [r7, #4]
   27f34:	f103 02a4 	add.w	r2, r3, #164	; 0xa4
   27f38:	687b      	ldr	r3, [r7, #4]
   27f3a:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
        p_advertising->advdata.p_service_data_array               = &(p_advertising->service_data);
   27f3e:	687b      	ldr	r3, [r7, #4]
   27f40:	f103 0298 	add.w	r2, r3, #152	; 0x98
   27f44:	687b      	ldr	r3, [r7, #4]
   27f46:	659a      	str	r2, [r3, #88]	; 0x58
        p_advertising->advdata.p_service_data_array->data.p_data  = p_advertising->service_data_array;
   27f48:	687b      	ldr	r3, [r7, #4]
   27f4a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
   27f4c:	687a      	ldr	r2, [r7, #4]
   27f4e:	32a4      	adds	r2, #164	; 0xa4
   27f50:	609a      	str	r2, [r3, #8]
        p_advertising->advdata.p_service_data_array->data.size    = p_init->advdata.p_service_data_array->data.size;
   27f52:	683b      	ldr	r3, [r7, #0]
   27f54:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   27f56:	687b      	ldr	r3, [r7, #4]
   27f58:	6d9b      	ldr	r3, [r3, #88]	; 0x58
   27f5a:	8892      	ldrh	r2, [r2, #4]
   27f5c:	809a      	strh	r2, [r3, #4]
        p_advertising->advdata.p_service_data_array->service_uuid = p_init->advdata.p_service_data_array->service_uuid;
   27f5e:	683b      	ldr	r3, [r7, #0]
   27f60:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   27f62:	687b      	ldr	r3, [r7, #4]
   27f64:	6d9b      	ldr	r3, [r3, #88]	; 0x58
   27f66:	8812      	ldrh	r2, [r2, #0]
   27f68:	801a      	strh	r2, [r3, #0]

        for (uint32_t i = 0; i < p_advertising->advdata.p_service_data_array->data.size; i++)
   27f6a:	2300      	movs	r3, #0
   27f6c:	613b      	str	r3, [r7, #16]
   27f6e:	e00e      	b.n	27f8e <ble_advertising_init+0x1b0>
        {
            p_advertising->service_data_array[i] = p_init->advdata.p_service_data_array->data.p_data[i];
   27f70:	683b      	ldr	r3, [r7, #0]
   27f72:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   27f74:	689a      	ldr	r2, [r3, #8]
   27f76:	693b      	ldr	r3, [r7, #16]
   27f78:	4413      	add	r3, r2
   27f7a:	7819      	ldrb	r1, [r3, #0]
   27f7c:	687a      	ldr	r2, [r7, #4]
   27f7e:	693b      	ldr	r3, [r7, #16]
   27f80:	4413      	add	r3, r2
   27f82:	33a4      	adds	r3, #164	; 0xa4
   27f84:	460a      	mov	r2, r1
   27f86:	701a      	strb	r2, [r3, #0]
        for (uint32_t i = 0; i < p_advertising->advdata.p_service_data_array->data.size; i++)
   27f88:	693b      	ldr	r3, [r7, #16]
   27f8a:	3301      	adds	r3, #1
   27f8c:	613b      	str	r3, [r7, #16]
   27f8e:	687b      	ldr	r3, [r7, #4]
   27f90:	6d9b      	ldr	r3, [r3, #88]	; 0x58
   27f92:	889b      	ldrh	r3, [r3, #4]
   27f94:	461a      	mov	r2, r3
   27f96:	693b      	ldr	r3, [r7, #16]
   27f98:	4293      	cmp	r3, r2
   27f9a:	d3e9      	bcc.n	27f70 <ble_advertising_init+0x192>
        }

        p_advertising->advdata.service_data_count = p_init->advdata.service_data_count;
   27f9c:	683b      	ldr	r3, [r7, #0]
   27f9e:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c
   27fa2:	687b      	ldr	r3, [r7, #4]
   27fa4:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
    }

    if (p_init->advdata.p_slave_conn_int != NULL)
   27fa8:	683b      	ldr	r3, [r7, #0]
   27faa:	6a1b      	ldr	r3, [r3, #32]
   27fac:	2b00      	cmp	r3, #0
   27fae:	d010      	beq.n	27fd2 <ble_advertising_init+0x1f4>
    {
        p_advertising->advdata.p_slave_conn_int                    = &(p_advertising->slave_conn_int);
   27fb0:	687b      	ldr	r3, [r7, #4]
   27fb2:	f103 02c4 	add.w	r2, r3, #196	; 0xc4
   27fb6:	687b      	ldr	r3, [r7, #4]
   27fb8:	651a      	str	r2, [r3, #80]	; 0x50
        p_advertising->advdata.p_slave_conn_int->max_conn_interval = p_init->advdata.p_slave_conn_int->max_conn_interval;
   27fba:	683b      	ldr	r3, [r7, #0]
   27fbc:	6a1a      	ldr	r2, [r3, #32]
   27fbe:	687b      	ldr	r3, [r7, #4]
   27fc0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
   27fc2:	8852      	ldrh	r2, [r2, #2]
   27fc4:	805a      	strh	r2, [r3, #2]
        p_advertising->advdata.p_slave_conn_int->min_conn_interval = p_init->advdata.p_slave_conn_int->min_conn_interval;
   27fc6:	683b      	ldr	r3, [r7, #0]
   27fc8:	6a1a      	ldr	r2, [r3, #32]
   27fca:	687b      	ldr	r3, [r7, #4]
   27fcc:	6d1b      	ldr	r3, [r3, #80]	; 0x50
   27fce:	8812      	ldrh	r2, [r2, #0]
   27fd0:	801a      	strh	r2, [r3, #0]
    }

    if (p_init->advdata.p_tx_power_level != NULL)
   27fd2:	683b      	ldr	r3, [r7, #0]
   27fd4:	685b      	ldr	r3, [r3, #4]
   27fd6:	2b00      	cmp	r3, #0
   27fd8:	d003      	beq.n	27fe2 <ble_advertising_init+0x204>
    {
        p_advertising->advdata.p_tx_power_level = p_init->advdata.p_tx_power_level;
   27fda:	683b      	ldr	r3, [r7, #0]
   27fdc:	685a      	ldr	r2, [r3, #4]
   27fde:	687b      	ldr	r3, [r7, #4]
   27fe0:	635a      	str	r2, [r3, #52]	; 0x34
        for (int i = 0; i <BLE_GAP_WHITELIST_IRK_MAX_COUNT ; i++)
        {
            p_advertising->whitelist.pp_irks[i] = &p_advertising->whitelist_irks[i];
        }
#endif
    ret = ble_advdata_set(&(p_advertising->advdata), &(p_init->srdata));
   27fe2:	687b      	ldr	r3, [r7, #4]
   27fe4:	f103 0230 	add.w	r2, r3, #48	; 0x30
   27fe8:	683b      	ldr	r3, [r7, #0]
   27fea:	333c      	adds	r3, #60	; 0x3c
   27fec:	4619      	mov	r1, r3
   27fee:	4610      	mov	r0, r2
   27ff0:	f7fe fe36 	bl	26c60 <ble_advdata_set>
   27ff4:	60f8      	str	r0, [r7, #12]
    return ret;
   27ff6:	68fb      	ldr	r3, [r7, #12]
}
   27ff8:	4618      	mov	r0, r3
   27ffa:	3718      	adds	r7, #24
   27ffc:	46bd      	mov	sp, r7
   27ffe:	bdb0      	pop	{r4, r5, r7, pc}

00028000 <ble_advertising_start>:


uint32_t ble_advertising_start(ble_advertising_t * const p_advertising,
                               ble_adv_mode_t            advertising_mode)
{
   28000:	b580      	push	{r7, lr}
   28002:	b088      	sub	sp, #32
   28004:	af00      	add	r7, sp, #0
   28006:	6078      	str	r0, [r7, #4]
   28008:	460b      	mov	r3, r1
   2800a:	70fb      	strb	r3, [r7, #3]
    uint32_t             ret;
    ble_gap_adv_params_t adv_params;

    if (p_advertising->initialized == false)
   2800c:	687b      	ldr	r3, [r7, #4]
   2800e:	781b      	ldrb	r3, [r3, #0]
   28010:	f083 0301 	eor.w	r3, r3, #1
   28014:	b2db      	uxtb	r3, r3
   28016:	2b00      	cmp	r3, #0
   28018:	d001      	beq.n	2801e <ble_advertising_start+0x1e>
    {
        return NRF_ERROR_INVALID_STATE;
   2801a:	2308      	movs	r3, #8
   2801c:	e0d3      	b.n	281c6 <ble_advertising_start+0x1c6>
    }

    p_advertising->adv_mode_current = advertising_mode;
   2801e:	687b      	ldr	r3, [r7, #4]
   28020:	78fa      	ldrb	r2, [r7, #3]
   28022:	70da      	strb	r2, [r3, #3]

    // Delay starting advertising until the flash operations are complete.
    if (flash_access_in_progress())
   28024:	f7ff fdc8 	bl	27bb8 <flash_access_in_progress>
   28028:	4603      	mov	r3, r0
   2802a:	2b00      	cmp	r3, #0
   2802c:	d004      	beq.n	28038 <ble_advertising_start+0x38>
    {
        p_advertising->advertising_start_pending = true;
   2802e:	687b      	ldr	r3, [r7, #4]
   28030:	2201      	movs	r2, #1
   28032:	705a      	strb	r2, [r3, #1]
        return NRF_SUCCESS;
   28034:	2300      	movs	r3, #0
   28036:	e0c6      	b.n	281c6 <ble_advertising_start+0x1c6>
    }

   memset(&p_advertising->peer_address, 0, sizeof(p_advertising->peer_address));
   28038:	687b      	ldr	r3, [r7, #4]
   2803a:	3325      	adds	r3, #37	; 0x25
   2803c:	2207      	movs	r2, #7
   2803e:	2100      	movs	r1, #0
   28040:	4618      	mov	r0, r3
   28042:	f7fb faeb 	bl	2361c <memset>

    if (  ((p_advertising->adv_modes_config.ble_adv_directed_enabled)      && (p_advertising->adv_mode_current == BLE_ADV_MODE_DIRECTED))
   28046:	687b      	ldr	r3, [r7, #4]
   28048:	799b      	ldrb	r3, [r3, #6]
   2804a:	2b00      	cmp	r3, #0
   2804c:	d003      	beq.n	28056 <ble_advertising_start+0x56>
   2804e:	687b      	ldr	r3, [r7, #4]
   28050:	78db      	ldrb	r3, [r3, #3]
   28052:	2b01      	cmp	r3, #1
   28054:	d00f      	beq.n	28076 <ble_advertising_start+0x76>
        ||((p_advertising->adv_modes_config.ble_adv_directed_slow_enabled) && (p_advertising->adv_mode_current == BLE_ADV_MODE_DIRECTED))
   28056:	687b      	ldr	r3, [r7, #4]
   28058:	79db      	ldrb	r3, [r3, #7]
   2805a:	2b00      	cmp	r3, #0
   2805c:	d003      	beq.n	28066 <ble_advertising_start+0x66>
   2805e:	687b      	ldr	r3, [r7, #4]
   28060:	78db      	ldrb	r3, [r3, #3]
   28062:	2b01      	cmp	r3, #1
   28064:	d007      	beq.n	28076 <ble_advertising_start+0x76>
        ||((p_advertising->adv_modes_config.ble_adv_directed_slow_enabled) && (p_advertising->adv_mode_current == BLE_ADV_MODE_DIRECTED_SLOW))
   28066:	687b      	ldr	r3, [r7, #4]
   28068:	79db      	ldrb	r3, [r3, #7]
   2806a:	2b00      	cmp	r3, #0
   2806c:	d016      	beq.n	2809c <ble_advertising_start+0x9c>
   2806e:	687b      	ldr	r3, [r7, #4]
   28070:	78db      	ldrb	r3, [r3, #3]
   28072:	2b02      	cmp	r3, #2
   28074:	d112      	bne.n	2809c <ble_advertising_start+0x9c>
       )
    {
        if (p_advertising->evt_handler != NULL)
   28076:	687b      	ldr	r3, [r7, #4]
   28078:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
   2807c:	2b00      	cmp	r3, #0
   2807e:	d009      	beq.n	28094 <ble_advertising_start+0x94>
        {
            p_advertising->peer_addr_reply_expected = true;
   28080:	687b      	ldr	r3, [r7, #4]
   28082:	2201      	movs	r2, #1
   28084:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
            p_advertising->evt_handler(BLE_ADV_EVT_PEER_ADDR_REQUEST);
   28088:	687b      	ldr	r3, [r7, #4]
   2808a:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
   2808e:	2008      	movs	r0, #8
   28090:	4798      	blx	r3
   28092:	e003      	b.n	2809c <ble_advertising_start+0x9c>
        }
        else
        {
            p_advertising->peer_addr_reply_expected = false;
   28094:	687b      	ldr	r3, [r7, #4]
   28096:	2200      	movs	r2, #0
   28098:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
        }
    }

    p_advertising->adv_mode_current = adv_mode_next_avail_get(p_advertising, advertising_mode);
   2809c:	78fb      	ldrb	r3, [r7, #3]
   2809e:	4619      	mov	r1, r3
   280a0:	6878      	ldr	r0, [r7, #4]
   280a2:	f7ff fd91 	bl	27bc8 <adv_mode_next_avail_get>
   280a6:	4603      	mov	r3, r0
   280a8:	461a      	mov	r2, r3
   280aa:	687b      	ldr	r3, [r7, #4]
   280ac:	70da      	strb	r2, [r3, #3]

    // Fetch the whitelist.
    if ((p_advertising->evt_handler != NULL) &&
   280ae:	687b      	ldr	r3, [r7, #4]
   280b0:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
   280b4:	2b00      	cmp	r3, #0
   280b6:	d021      	beq.n	280fc <ble_advertising_start+0xfc>
        (p_advertising->adv_mode_current == BLE_ADV_MODE_FAST || p_advertising->adv_mode_current == BLE_ADV_MODE_SLOW) &&
   280b8:	687b      	ldr	r3, [r7, #4]
   280ba:	78db      	ldrb	r3, [r3, #3]
    if ((p_advertising->evt_handler != NULL) &&
   280bc:	2b03      	cmp	r3, #3
   280be:	d003      	beq.n	280c8 <ble_advertising_start+0xc8>
        (p_advertising->adv_mode_current == BLE_ADV_MODE_FAST || p_advertising->adv_mode_current == BLE_ADV_MODE_SLOW) &&
   280c0:	687b      	ldr	r3, [r7, #4]
   280c2:	78db      	ldrb	r3, [r3, #3]
   280c4:	2b04      	cmp	r3, #4
   280c6:	d119      	bne.n	280fc <ble_advertising_start+0xfc>
        (p_advertising->adv_modes_config.ble_adv_whitelist_enabled) &&
   280c8:	687b      	ldr	r3, [r7, #4]
   280ca:	795b      	ldrb	r3, [r3, #5]
        (p_advertising->adv_mode_current == BLE_ADV_MODE_FAST || p_advertising->adv_mode_current == BLE_ADV_MODE_SLOW) &&
   280cc:	2b00      	cmp	r3, #0
   280ce:	d015      	beq.n	280fc <ble_advertising_start+0xfc>
        (!p_advertising->whitelist_temporarily_disabled))
   280d0:	687b      	ldr	r3, [r7, #4]
   280d2:	f893 30d4 	ldrb.w	r3, [r3, #212]	; 0xd4
   280d6:	f083 0301 	eor.w	r3, r3, #1
   280da:	b2db      	uxtb	r3, r3
        (p_advertising->adv_modes_config.ble_adv_whitelist_enabled) &&
   280dc:	2b00      	cmp	r3, #0
   280de:	d00d      	beq.n	280fc <ble_advertising_start+0xfc>
    {
        #if (NRF_SD_BLE_API_VERSION >= 3)
            p_advertising->whitelist_in_use = false;
   280e0:	687b      	ldr	r3, [r7, #4]
   280e2:	2200      	movs	r2, #0
   280e4:	f883 20d6 	strb.w	r2, [r3, #214]	; 0xd6
        #endif
        p_advertising->whitelist_reply_expected = true;
   280e8:	687b      	ldr	r3, [r7, #4]
   280ea:	2201      	movs	r2, #1
   280ec:	f883 20d5 	strb.w	r2, [r3, #213]	; 0xd5
        p_advertising->evt_handler(BLE_ADV_EVT_WHITELIST_REQUEST);
   280f0:	687b      	ldr	r3, [r7, #4]
   280f2:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
   280f6:	2007      	movs	r0, #7
   280f8:	4798      	blx	r3
   280fa:	e003      	b.n	28104 <ble_advertising_start+0x104>
    }
    else
    {
        p_advertising->whitelist_reply_expected = false;
   280fc:	687b      	ldr	r3, [r7, #4]
   280fe:	2200      	movs	r2, #0
   28100:	f883 20d5 	strb.w	r2, [r3, #213]	; 0xd5
    }

    // Initialize advertising parameters with default values.
    memset(&adv_params, 0, sizeof(adv_params));
   28104:	f107 030c 	add.w	r3, r7, #12
   28108:	2210      	movs	r2, #16
   2810a:	2100      	movs	r1, #0
   2810c:	4618      	mov	r0, r3
   2810e:	f7fb fa85 	bl	2361c <memset>

    adv_params.type = BLE_GAP_ADV_TYPE_ADV_IND;
   28112:	2300      	movs	r3, #0
   28114:	733b      	strb	r3, [r7, #12]
    adv_params.fp   = BLE_GAP_ADV_FP_ANY;
   28116:	2300      	movs	r3, #0
   28118:	753b      	strb	r3, [r7, #20]

    // Set advertising parameters and events according to selected advertising mode.
    switch (p_advertising->adv_mode_current)
   2811a:	687b      	ldr	r3, [r7, #4]
   2811c:	78db      	ldrb	r3, [r3, #3]
   2811e:	2b04      	cmp	r3, #4
   28120:	d830      	bhi.n	28184 <ble_advertising_start+0x184>
   28122:	a201      	add	r2, pc, #4	; (adr r2, 28128 <ble_advertising_start+0x128>)
   28124:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   28128:	0002817d 	.word	0x0002817d
   2812c:	0002813d 	.word	0x0002813d
   28130:	0002814d 	.word	0x0002814d
   28134:	0002815d 	.word	0x0002815d
   28138:	0002816d 	.word	0x0002816d
    {
        case BLE_ADV_MODE_DIRECTED:
            ret = set_adv_mode_directed(p_advertising, &adv_params);
   2813c:	f107 030c 	add.w	r3, r7, #12
   28140:	4619      	mov	r1, r3
   28142:	6878      	ldr	r0, [r7, #4]
   28144:	f7ff fd80 	bl	27c48 <set_adv_mode_directed>
   28148:	61f8      	str	r0, [r7, #28]
            break;
   2814a:	e01c      	b.n	28186 <ble_advertising_start+0x186>

        case BLE_ADV_MODE_DIRECTED_SLOW:
            ret = set_adv_mode_directed_slow(p_advertising, &adv_params);
   2814c:	f107 030c 	add.w	r3, r7, #12
   28150:	4619      	mov	r1, r3
   28152:	6878      	ldr	r0, [r7, #4]
   28154:	f7ff fd94 	bl	27c80 <set_adv_mode_directed_slow>
   28158:	61f8      	str	r0, [r7, #28]
            break;
   2815a:	e014      	b.n	28186 <ble_advertising_start+0x186>

        case BLE_ADV_MODE_FAST:
            ret = set_adv_mode_fast(p_advertising, &adv_params);
   2815c:	f107 030c 	add.w	r3, r7, #12
   28160:	4619      	mov	r1, r3
   28162:	6878      	ldr	r0, [r7, #4]
   28164:	f7ff fdac 	bl	27cc0 <set_adv_mode_fast>
   28168:	61f8      	str	r0, [r7, #28]
            break;
   2816a:	e00c      	b.n	28186 <ble_advertising_start+0x186>

        case BLE_ADV_MODE_SLOW:
            ret = set_adv_mode_slow(p_advertising, &adv_params);
   2816c:	f107 030c 	add.w	r3, r7, #12
   28170:	4619      	mov	r1, r3
   28172:	6878      	ldr	r0, [r7, #4]
   28174:	f7ff fde4 	bl	27d40 <set_adv_mode_slow>
   28178:	61f8      	str	r0, [r7, #28]
            break;
   2817a:	e004      	b.n	28186 <ble_advertising_start+0x186>

        case BLE_ADV_MODE_IDLE:
            p_advertising->adv_evt = BLE_ADV_EVT_IDLE;
   2817c:	687b      	ldr	r3, [r7, #4]
   2817e:	2200      	movs	r2, #0
   28180:	709a      	strb	r2, [r3, #2]
            break;
   28182:	e000      	b.n	28186 <ble_advertising_start+0x186>

        default:
            break;
   28184:	bf00      	nop
    }

    if (p_advertising->adv_mode_current != BLE_ADV_MODE_IDLE)
   28186:	687b      	ldr	r3, [r7, #4]
   28188:	78db      	ldrb	r3, [r3, #3]
   2818a:	2b00      	cmp	r3, #0
   2818c:	d00e      	beq.n	281ac <ble_advertising_start+0x1ac>
    {
        ret = sd_ble_gap_adv_start(&adv_params, p_advertising->conn_cfg_tag);
   2818e:	687b      	ldr	r3, [r7, #4]
   28190:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
   28194:	f107 030c 	add.w	r3, r7, #12
   28198:	4611      	mov	r1, r2
   2819a:	4618      	mov	r0, r3
   2819c:	f7ff fc60 	bl	27a60 <sd_ble_gap_adv_start>
   281a0:	61f8      	str	r0, [r7, #28]
        if (ret != NRF_SUCCESS)
   281a2:	69fb      	ldr	r3, [r7, #28]
   281a4:	2b00      	cmp	r3, #0
   281a6:	d001      	beq.n	281ac <ble_advertising_start+0x1ac>
        {
            return ret;
   281a8:	69fb      	ldr	r3, [r7, #28]
   281aa:	e00c      	b.n	281c6 <ble_advertising_start+0x1c6>
        }
    }

    if (p_advertising->evt_handler != NULL)
   281ac:	687b      	ldr	r3, [r7, #4]
   281ae:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
   281b2:	2b00      	cmp	r3, #0
   281b4:	d006      	beq.n	281c4 <ble_advertising_start+0x1c4>
    {
        p_advertising->evt_handler(p_advertising->adv_evt);
   281b6:	687b      	ldr	r3, [r7, #4]
   281b8:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
   281bc:	687a      	ldr	r2, [r7, #4]
   281be:	7892      	ldrb	r2, [r2, #2]
   281c0:	4610      	mov	r0, r2
   281c2:	4798      	blx	r3
    }

    return NRF_SUCCESS;
   281c4:	2300      	movs	r3, #0
}
   281c6:	4618      	mov	r0, r3
   281c8:	3720      	adds	r7, #32
   281ca:	46bd      	mov	sp, r7
   281cc:	bd80      	pop	{r7, pc}
   281ce:	bf00      	nop

000281d0 <ble_advertising_on_ble_evt>:


void ble_advertising_on_ble_evt(ble_evt_t const * p_ble_evt, void * p_context)
{
   281d0:	b580      	push	{r7, lr}
   281d2:	b084      	sub	sp, #16
   281d4:	af00      	add	r7, sp, #0
   281d6:	6078      	str	r0, [r7, #4]
   281d8:	6039      	str	r1, [r7, #0]
    ble_advertising_t * p_advertising = (ble_advertising_t *)p_context;
   281da:	683b      	ldr	r3, [r7, #0]
   281dc:	60fb      	str	r3, [r7, #12]

    switch (p_ble_evt->header.evt_id)
   281de:	687b      	ldr	r3, [r7, #4]
   281e0:	881b      	ldrh	r3, [r3, #0]
   281e2:	2b11      	cmp	r3, #17
   281e4:	d009      	beq.n	281fa <ble_advertising_on_ble_evt+0x2a>
   281e6:	2b1b      	cmp	r3, #27
   281e8:	d00c      	beq.n	28204 <ble_advertising_on_ble_evt+0x34>
   281ea:	2b10      	cmp	r3, #16
   281ec:	d000      	beq.n	281f0 <ble_advertising_on_ble_evt+0x20>
        case BLE_GAP_EVT_TIMEOUT:
            on_timeout(p_advertising, p_ble_evt);
            break;

        default:
            break;
   281ee:	e00e      	b.n	2820e <ble_advertising_on_ble_evt+0x3e>
            on_connected(p_advertising, p_ble_evt);
   281f0:	6879      	ldr	r1, [r7, #4]
   281f2:	68f8      	ldr	r0, [r7, #12]
   281f4:	f7ff fc7a 	bl	27aec <on_connected>
            break;
   281f8:	e009      	b.n	2820e <ble_advertising_on_ble_evt+0x3e>
            on_disconnected(p_advertising, p_ble_evt);
   281fa:	6879      	ldr	r1, [r7, #4]
   281fc:	68f8      	ldr	r0, [r7, #12]
   281fe:	f7ff fc88 	bl	27b12 <on_disconnected>
            break;
   28202:	e004      	b.n	2820e <ble_advertising_on_ble_evt+0x3e>
            on_timeout(p_advertising, p_ble_evt);
   28204:	6879      	ldr	r1, [r7, #4]
   28206:	68f8      	ldr	r0, [r7, #12]
   28208:	f7ff fcb0 	bl	27b6c <on_timeout>
            break;
   2820c:	bf00      	nop
    }
}
   2820e:	bf00      	nop
   28210:	3710      	adds	r7, #16
   28212:	46bd      	mov	sp, r7
   28214:	bd80      	pop	{r7, pc}

00028216 <ble_advertising_on_sys_evt>:


void ble_advertising_on_sys_evt(uint32_t evt_id, void * p_context)
{
   28216:	b580      	push	{r7, lr}
   28218:	b084      	sub	sp, #16
   2821a:	af00      	add	r7, sp, #0
   2821c:	6078      	str	r0, [r7, #4]
   2821e:	6039      	str	r1, [r7, #0]
    ble_advertising_t * p_advertising = (ble_advertising_t *)p_context;
   28220:	683b      	ldr	r3, [r7, #0]
   28222:	60fb      	str	r3, [r7, #12]

    switch (evt_id)
   28224:	687b      	ldr	r3, [r7, #4]
   28226:	3b02      	subs	r3, #2
   28228:	2b01      	cmp	r3, #1
   2822a:	d81b      	bhi.n	28264 <ble_advertising_on_sys_evt+0x4e>
    {
        //When a flash operation finishes, re-attempt to start advertising operations.
        case NRF_EVT_FLASH_OPERATION_SUCCESS:
        case NRF_EVT_FLASH_OPERATION_ERROR:
        {
            if (p_advertising->advertising_start_pending)
   2822c:	68fb      	ldr	r3, [r7, #12]
   2822e:	785b      	ldrb	r3, [r3, #1]
   28230:	2b00      	cmp	r3, #0
   28232:	d019      	beq.n	28268 <ble_advertising_on_sys_evt+0x52>
            {
                p_advertising->advertising_start_pending = false;
   28234:	68fb      	ldr	r3, [r7, #12]
   28236:	2200      	movs	r2, #0
   28238:	705a      	strb	r2, [r3, #1]
                ret_code_t ret = ble_advertising_start(p_advertising,
   2823a:	68fb      	ldr	r3, [r7, #12]
   2823c:	78db      	ldrb	r3, [r3, #3]
   2823e:	4619      	mov	r1, r3
   28240:	68f8      	ldr	r0, [r7, #12]
   28242:	f7ff fedd 	bl	28000 <ble_advertising_start>
   28246:	60b8      	str	r0, [r7, #8]
                                                       p_advertising->adv_mode_current);

                if ((ret != NRF_SUCCESS) && (p_advertising->error_handler != NULL))
   28248:	68bb      	ldr	r3, [r7, #8]
   2824a:	2b00      	cmp	r3, #0
   2824c:	d00c      	beq.n	28268 <ble_advertising_on_sys_evt+0x52>
   2824e:	68fb      	ldr	r3, [r7, #12]
   28250:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
   28254:	2b00      	cmp	r3, #0
   28256:	d007      	beq.n	28268 <ble_advertising_on_sys_evt+0x52>
                {
                    p_advertising->error_handler(ret);
   28258:	68fb      	ldr	r3, [r7, #12]
   2825a:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
   2825e:	68b8      	ldr	r0, [r7, #8]
   28260:	4798      	blx	r3
                }
            }
        } break;
   28262:	e001      	b.n	28268 <ble_advertising_on_sys_evt+0x52>

        default:
            // No implementation needed.
            break;
   28264:	bf00      	nop
   28266:	e000      	b.n	2826a <ble_advertising_on_sys_evt+0x54>
        } break;
   28268:	bf00      	nop
    }
}
   2826a:	bf00      	nop
   2826c:	3710      	adds	r7, #16
   2826e:	46bd      	mov	sp, r7
   28270:	bd80      	pop	{r7, pc}

00028272 <sdk_mapped_flags_set_by_index>:
 *
 * @param[in]  p_flags  The collection of flags to modify.
 * @param[in]  index    The index of the flag to modify.
 */
static __INLINE void sdk_mapped_flags_set_by_index(sdk_mapped_flags_t * p_flags, uint16_t index)
{
   28272:	b480      	push	{r7}
   28274:	b083      	sub	sp, #12
   28276:	af00      	add	r7, sp, #0
   28278:	6078      	str	r0, [r7, #4]
   2827a:	460b      	mov	r3, r1
   2827c:	807b      	strh	r3, [r7, #2]
    *p_flags |= (1U << index);
   2827e:	687b      	ldr	r3, [r7, #4]
   28280:	681a      	ldr	r2, [r3, #0]
   28282:	887b      	ldrh	r3, [r7, #2]
   28284:	2101      	movs	r1, #1
   28286:	fa01 f303 	lsl.w	r3, r1, r3
   2828a:	431a      	orrs	r2, r3
   2828c:	687b      	ldr	r3, [r7, #4]
   2828e:	601a      	str	r2, [r3, #0]
}
   28290:	bf00      	nop
   28292:	370c      	adds	r7, #12
   28294:	46bd      	mov	sp, r7
   28296:	bc80      	pop	{r7}
   28298:	4770      	bx	lr

0002829a <sdk_mapped_flags_clear_by_index>:
 *
 * @param[in]  p_flags  The collection of flags to modify.
 * @param[in]  index    The index of the flag to modify.
 */
static __INLINE void sdk_mapped_flags_clear_by_index(sdk_mapped_flags_t * p_flags, uint16_t index)
{
   2829a:	b480      	push	{r7}
   2829c:	b083      	sub	sp, #12
   2829e:	af00      	add	r7, sp, #0
   282a0:	6078      	str	r0, [r7, #4]
   282a2:	460b      	mov	r3, r1
   282a4:	807b      	strh	r3, [r7, #2]
    *p_flags &= ~(1U << index);
   282a6:	687b      	ldr	r3, [r7, #4]
   282a8:	681a      	ldr	r2, [r3, #0]
   282aa:	887b      	ldrh	r3, [r7, #2]
   282ac:	2101      	movs	r1, #1
   282ae:	fa01 f303 	lsl.w	r3, r1, r3
   282b2:	43db      	mvns	r3, r3
   282b4:	401a      	ands	r2, r3
   282b6:	687b      	ldr	r3, [r7, #4]
   282b8:	601a      	str	r2, [r3, #0]
}
   282ba:	bf00      	nop
   282bc:	370c      	adds	r7, #12
   282be:	46bd      	mov	sp, r7
   282c0:	bc80      	pop	{r7}
   282c2:	4770      	bx	lr

000282c4 <sdk_mapped_flags_get_by_index>:
 *
 * @param[in]  p_flags  The collection of flags to read.
 * @param[in]  index    The index of the flag to get.
 */
static __INLINE bool sdk_mapped_flags_get_by_index(sdk_mapped_flags_t flags, uint16_t index)
{
   282c4:	b480      	push	{r7}
   282c6:	b083      	sub	sp, #12
   282c8:	af00      	add	r7, sp, #0
   282ca:	6078      	str	r0, [r7, #4]
   282cc:	460b      	mov	r3, r1
   282ce:	807b      	strh	r3, [r7, #2]
    return ((flags & (1 << index)) != 0);
   282d0:	887b      	ldrh	r3, [r7, #2]
   282d2:	2201      	movs	r2, #1
   282d4:	fa02 f303 	lsl.w	r3, r2, r3
   282d8:	461a      	mov	r2, r3
   282da:	687b      	ldr	r3, [r7, #4]
   282dc:	4013      	ands	r3, r2
   282de:	2b00      	cmp	r3, #0
   282e0:	bf14      	ite	ne
   282e2:	2301      	movne	r3, #1
   282e4:	2300      	moveq	r3, #0
   282e6:	b2db      	uxtb	r3, r3
}
   282e8:	4618      	mov	r0, r3
   282ea:	370c      	adds	r7, #12
   282ec:	46bd      	mov	sp, r7
   282ee:	bc80      	pop	{r7}
   282f0:	4770      	bx	lr

000282f2 <sdk_mapped_flags_first_key_index_get>:



uint16_t sdk_mapped_flags_first_key_index_get(sdk_mapped_flags_t flags)
{
   282f2:	b580      	push	{r7, lr}
   282f4:	b084      	sub	sp, #16
   282f6:	af00      	add	r7, sp, #0
   282f8:	6078      	str	r0, [r7, #4]
    for (uint16_t i = 0; i < SDK_MAPPED_FLAGS_N_KEYS; i++)
   282fa:	2300      	movs	r3, #0
   282fc:	81fb      	strh	r3, [r7, #14]
   282fe:	e00c      	b.n	2831a <sdk_mapped_flags_first_key_index_get+0x28>
    {
        if (sdk_mapped_flags_get_by_index(flags, i))
   28300:	89fb      	ldrh	r3, [r7, #14]
   28302:	4619      	mov	r1, r3
   28304:	6878      	ldr	r0, [r7, #4]
   28306:	f7ff ffdd 	bl	282c4 <sdk_mapped_flags_get_by_index>
   2830a:	4603      	mov	r3, r0
   2830c:	2b00      	cmp	r3, #0
   2830e:	d001      	beq.n	28314 <sdk_mapped_flags_first_key_index_get+0x22>
        {
            return i;
   28310:	89fb      	ldrh	r3, [r7, #14]
   28312:	e007      	b.n	28324 <sdk_mapped_flags_first_key_index_get+0x32>
    for (uint16_t i = 0; i < SDK_MAPPED_FLAGS_N_KEYS; i++)
   28314:	89fb      	ldrh	r3, [r7, #14]
   28316:	3301      	adds	r3, #1
   28318:	81fb      	strh	r3, [r7, #14]
   2831a:	89fb      	ldrh	r3, [r7, #14]
   2831c:	2b1f      	cmp	r3, #31
   2831e:	d9ef      	bls.n	28300 <sdk_mapped_flags_first_key_index_get+0xe>
        }
    }
    return SDK_MAPPED_FLAGS_INVALID_INDEX;
   28320:	f64f 73ff 	movw	r3, #65535	; 0xffff
}
   28324:	4618      	mov	r0, r3
   28326:	3710      	adds	r7, #16
   28328:	46bd      	mov	sp, r7
   2832a:	bd80      	pop	{r7, pc}

0002832c <sdk_mapped_flags_update_by_key>:

void sdk_mapped_flags_update_by_key(uint16_t           * p_keys,
                                    sdk_mapped_flags_t * p_flags,
                                    uint16_t             key,
                                    bool                 value)
{
   2832c:	b580      	push	{r7, lr}
   2832e:	b086      	sub	sp, #24
   28330:	af02      	add	r7, sp, #8
   28332:	60f8      	str	r0, [r7, #12]
   28334:	60b9      	str	r1, [r7, #8]
   28336:	4611      	mov	r1, r2
   28338:	461a      	mov	r2, r3
   2833a:	460b      	mov	r3, r1
   2833c:	80fb      	strh	r3, [r7, #6]
   2833e:	4613      	mov	r3, r2
   28340:	717b      	strb	r3, [r7, #5]
    sdk_mapped_flags_bulk_update_by_key(p_keys, p_flags, 1, key, value);
   28342:	88fa      	ldrh	r2, [r7, #6]
   28344:	797b      	ldrb	r3, [r7, #5]
   28346:	9300      	str	r3, [sp, #0]
   28348:	4613      	mov	r3, r2
   2834a:	2201      	movs	r2, #1
   2834c:	68b9      	ldr	r1, [r7, #8]
   2834e:	68f8      	ldr	r0, [r7, #12]
   28350:	f000 f804 	bl	2835c <sdk_mapped_flags_bulk_update_by_key>
}
   28354:	bf00      	nop
   28356:	3710      	adds	r7, #16
   28358:	46bd      	mov	sp, r7
   2835a:	bd80      	pop	{r7, pc}

0002835c <sdk_mapped_flags_bulk_update_by_key>:
void sdk_mapped_flags_bulk_update_by_key(uint16_t           * p_keys,
                                         sdk_mapped_flags_t * p_flags,
                                         uint32_t             n_flag_collections,
                                         uint16_t             key,
                                         bool                 value)
{
   2835c:	b580      	push	{r7, lr}
   2835e:	b086      	sub	sp, #24
   28360:	af00      	add	r7, sp, #0
   28362:	60f8      	str	r0, [r7, #12]
   28364:	60b9      	str	r1, [r7, #8]
   28366:	607a      	str	r2, [r7, #4]
   28368:	807b      	strh	r3, [r7, #2]
    if ((p_keys != NULL) && (p_flags != NULL) && (n_flag_collections > 0))
   2836a:	68fb      	ldr	r3, [r7, #12]
   2836c:	2b00      	cmp	r3, #0
   2836e:	d03a      	beq.n	283e6 <sdk_mapped_flags_bulk_update_by_key+0x8a>
   28370:	68bb      	ldr	r3, [r7, #8]
   28372:	2b00      	cmp	r3, #0
   28374:	d037      	beq.n	283e6 <sdk_mapped_flags_bulk_update_by_key+0x8a>
   28376:	687b      	ldr	r3, [r7, #4]
   28378:	2b00      	cmp	r3, #0
   2837a:	d034      	beq.n	283e6 <sdk_mapped_flags_bulk_update_by_key+0x8a>
    {
        for (uint32_t i = 0; i < SDK_MAPPED_FLAGS_N_KEYS; i++)
   2837c:	2300      	movs	r3, #0
   2837e:	617b      	str	r3, [r7, #20]
   28380:	e02e      	b.n	283e0 <sdk_mapped_flags_bulk_update_by_key+0x84>
        {
            if (p_keys[i] == key)
   28382:	697b      	ldr	r3, [r7, #20]
   28384:	005b      	lsls	r3, r3, #1
   28386:	68fa      	ldr	r2, [r7, #12]
   28388:	4413      	add	r3, r2
   2838a:	881b      	ldrh	r3, [r3, #0]
   2838c:	887a      	ldrh	r2, [r7, #2]
   2838e:	429a      	cmp	r2, r3
   28390:	d123      	bne.n	283da <sdk_mapped_flags_bulk_update_by_key+0x7e>
            {
                for (uint32_t j = 0; j < n_flag_collections; j++)
   28392:	2300      	movs	r3, #0
   28394:	613b      	str	r3, [r7, #16]
   28396:	e01b      	b.n	283d0 <sdk_mapped_flags_bulk_update_by_key+0x74>
                {
                    if (value)
   28398:	f897 3020 	ldrb.w	r3, [r7, #32]
   2839c:	2b00      	cmp	r3, #0
   2839e:	d00a      	beq.n	283b6 <sdk_mapped_flags_bulk_update_by_key+0x5a>
                    {
                        sdk_mapped_flags_set_by_index(&p_flags[j], i);
   283a0:	693b      	ldr	r3, [r7, #16]
   283a2:	009b      	lsls	r3, r3, #2
   283a4:	68ba      	ldr	r2, [r7, #8]
   283a6:	4413      	add	r3, r2
   283a8:	697a      	ldr	r2, [r7, #20]
   283aa:	b292      	uxth	r2, r2
   283ac:	4611      	mov	r1, r2
   283ae:	4618      	mov	r0, r3
   283b0:	f7ff ff5f 	bl	28272 <sdk_mapped_flags_set_by_index>
   283b4:	e009      	b.n	283ca <sdk_mapped_flags_bulk_update_by_key+0x6e>
                    }
                    else
                    {
                        sdk_mapped_flags_clear_by_index(&p_flags[j], i);
   283b6:	693b      	ldr	r3, [r7, #16]
   283b8:	009b      	lsls	r3, r3, #2
   283ba:	68ba      	ldr	r2, [r7, #8]
   283bc:	4413      	add	r3, r2
   283be:	697a      	ldr	r2, [r7, #20]
   283c0:	b292      	uxth	r2, r2
   283c2:	4611      	mov	r1, r2
   283c4:	4618      	mov	r0, r3
   283c6:	f7ff ff68 	bl	2829a <sdk_mapped_flags_clear_by_index>
                for (uint32_t j = 0; j < n_flag_collections; j++)
   283ca:	693b      	ldr	r3, [r7, #16]
   283cc:	3301      	adds	r3, #1
   283ce:	613b      	str	r3, [r7, #16]
   283d0:	693a      	ldr	r2, [r7, #16]
   283d2:	687b      	ldr	r3, [r7, #4]
   283d4:	429a      	cmp	r2, r3
   283d6:	d3df      	bcc.n	28398 <sdk_mapped_flags_bulk_update_by_key+0x3c>
                    }
                }
                return;
   283d8:	e005      	b.n	283e6 <sdk_mapped_flags_bulk_update_by_key+0x8a>
        for (uint32_t i = 0; i < SDK_MAPPED_FLAGS_N_KEYS; i++)
   283da:	697b      	ldr	r3, [r7, #20]
   283dc:	3301      	adds	r3, #1
   283de:	617b      	str	r3, [r7, #20]
   283e0:	697b      	ldr	r3, [r7, #20]
   283e2:	2b1f      	cmp	r3, #31
   283e4:	d9cd      	bls.n	28382 <sdk_mapped_flags_bulk_update_by_key+0x26>
            }
        }
    }
}
   283e6:	3718      	adds	r7, #24
   283e8:	46bd      	mov	sp, r7
   283ea:	bd80      	pop	{r7, pc}

000283ec <sdk_mapped_flags_get_by_key>:
    return false;
}


bool sdk_mapped_flags_get_by_key(uint16_t * p_keys, sdk_mapped_flags_t flags, uint16_t key)
{
   283ec:	b580      	push	{r7, lr}
   283ee:	b086      	sub	sp, #24
   283f0:	af00      	add	r7, sp, #0
   283f2:	60f8      	str	r0, [r7, #12]
   283f4:	60b9      	str	r1, [r7, #8]
   283f6:	4613      	mov	r3, r2
   283f8:	80fb      	strh	r3, [r7, #6]
    if (p_keys != NULL)
   283fa:	68fb      	ldr	r3, [r7, #12]
   283fc:	2b00      	cmp	r3, #0
   283fe:	d018      	beq.n	28432 <sdk_mapped_flags_get_by_key+0x46>
    {
        for (uint32_t i = 0; i < SDK_MAPPED_FLAGS_N_KEYS; i++)
   28400:	2300      	movs	r3, #0
   28402:	617b      	str	r3, [r7, #20]
   28404:	e012      	b.n	2842c <sdk_mapped_flags_get_by_key+0x40>
        {
            if (p_keys[i] == key)
   28406:	697b      	ldr	r3, [r7, #20]
   28408:	005b      	lsls	r3, r3, #1
   2840a:	68fa      	ldr	r2, [r7, #12]
   2840c:	4413      	add	r3, r2
   2840e:	881b      	ldrh	r3, [r3, #0]
   28410:	88fa      	ldrh	r2, [r7, #6]
   28412:	429a      	cmp	r2, r3
   28414:	d107      	bne.n	28426 <sdk_mapped_flags_get_by_key+0x3a>
            {
                return sdk_mapped_flags_get_by_index(flags, i);
   28416:	697b      	ldr	r3, [r7, #20]
   28418:	b29b      	uxth	r3, r3
   2841a:	4619      	mov	r1, r3
   2841c:	68b8      	ldr	r0, [r7, #8]
   2841e:	f7ff ff51 	bl	282c4 <sdk_mapped_flags_get_by_index>
   28422:	4603      	mov	r3, r0
   28424:	e006      	b.n	28434 <sdk_mapped_flags_get_by_key+0x48>
        for (uint32_t i = 0; i < SDK_MAPPED_FLAGS_N_KEYS; i++)
   28426:	697b      	ldr	r3, [r7, #20]
   28428:	3301      	adds	r3, #1
   2842a:	617b      	str	r3, [r7, #20]
   2842c:	697b      	ldr	r3, [r7, #20]
   2842e:	2b1f      	cmp	r3, #31
   28430:	d9e9      	bls.n	28406 <sdk_mapped_flags_get_by_key+0x1a>
            }
        }
    }
    return false;
   28432:	2300      	movs	r3, #0
}
   28434:	4618      	mov	r0, r3
   28436:	3718      	adds	r7, #24
   28438:	46bd      	mov	sp, r7
   2843a:	bd80      	pop	{r7, pc}

0002843c <sdk_mapped_flags_key_list_get>:


sdk_mapped_flags_key_list_t sdk_mapped_flags_key_list_get(uint16_t           * p_keys,
                                                          sdk_mapped_flags_t   flags)
{
   2843c:	b580      	push	{r7, lr}
   2843e:	b096      	sub	sp, #88	; 0x58
   28440:	af00      	add	r7, sp, #0
   28442:	60f8      	str	r0, [r7, #12]
   28444:	60b9      	str	r1, [r7, #8]
   28446:	607a      	str	r2, [r7, #4]
    sdk_mapped_flags_key_list_t key_list;
    key_list.len = 0;
   28448:	2300      	movs	r3, #0
   2844a:	613b      	str	r3, [r7, #16]

    if (p_keys != NULL)
   2844c:	68bb      	ldr	r3, [r7, #8]
   2844e:	2b00      	cmp	r3, #0
   28450:	d01f      	beq.n	28492 <sdk_mapped_flags_key_list_get+0x56>
    {
        for (uint32_t i = 0; i < SDK_MAPPED_FLAGS_N_KEYS; i++)
   28452:	2300      	movs	r3, #0
   28454:	657b      	str	r3, [r7, #84]	; 0x54
   28456:	e019      	b.n	2848c <sdk_mapped_flags_key_list_get+0x50>
        {
            if (sdk_mapped_flags_get_by_index(flags, i))
   28458:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   2845a:	b29b      	uxth	r3, r3
   2845c:	4619      	mov	r1, r3
   2845e:	6878      	ldr	r0, [r7, #4]
   28460:	f7ff ff30 	bl	282c4 <sdk_mapped_flags_get_by_index>
   28464:	4603      	mov	r3, r0
   28466:	2b00      	cmp	r3, #0
   28468:	d00d      	beq.n	28486 <sdk_mapped_flags_key_list_get+0x4a>
            {
                key_list.flag_keys[key_list.len++] = p_keys[i];
   2846a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   2846c:	005b      	lsls	r3, r3, #1
   2846e:	68ba      	ldr	r2, [r7, #8]
   28470:	441a      	add	r2, r3
   28472:	693b      	ldr	r3, [r7, #16]
   28474:	1c59      	adds	r1, r3, #1
   28476:	6139      	str	r1, [r7, #16]
   28478:	8812      	ldrh	r2, [r2, #0]
   2847a:	005b      	lsls	r3, r3, #1
   2847c:	f107 0158 	add.w	r1, r7, #88	; 0x58
   28480:	440b      	add	r3, r1
   28482:	f823 2c44 	strh.w	r2, [r3, #-68]
        for (uint32_t i = 0; i < SDK_MAPPED_FLAGS_N_KEYS; i++)
   28486:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   28488:	3301      	adds	r3, #1
   2848a:	657b      	str	r3, [r7, #84]	; 0x54
   2848c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   2848e:	2b1f      	cmp	r3, #31
   28490:	d9e2      	bls.n	28458 <sdk_mapped_flags_key_list_get+0x1c>
            }
        }
    }

    return key_list;
   28492:	68fb      	ldr	r3, [r7, #12]
   28494:	4618      	mov	r0, r3
   28496:	f107 0310 	add.w	r3, r7, #16
   2849a:	2244      	movs	r2, #68	; 0x44
   2849c:	4619      	mov	r1, r3
   2849e:	f002 ff27 	bl	2b2f0 <memcpy>
}
   284a2:	68f8      	ldr	r0, [r7, #12]
   284a4:	3758      	adds	r7, #88	; 0x58
   284a6:	46bd      	mov	sp, r7
   284a8:	bd80      	pop	{r7, pc}
	...

000284ac <nrf_fstorage_is_busy>:
    return ((nrf_fstorage_api_t *)p_fs->p_api)->erase(p_fs, page_addr, len, p_context);
}


bool nrf_fstorage_is_busy(nrf_fstorage_t const * p_fs)
{
   284ac:	b580      	push	{r7, lr}
   284ae:	b084      	sub	sp, #16
   284b0:	af00      	add	r7, sp, #0
   284b2:	6078      	str	r0, [r7, #4]
    nrf_fstorage_api_t const * p_api;

    /* If a NULL instance is provided, return true if any instance is busy.
     * Uninitialized instances are considered not busy. */
    if ((p_fs == NULL) || (p_fs->p_api == NULL))
   284b4:	687b      	ldr	r3, [r7, #4]
   284b6:	2b00      	cmp	r3, #0
   284b8:	d003      	beq.n	284c2 <nrf_fstorage_is_busy+0x16>
   284ba:	687b      	ldr	r3, [r7, #4]
   284bc:	681b      	ldr	r3, [r3, #0]
   284be:	2b00      	cmp	r3, #0
   284c0:	d129      	bne.n	28516 <nrf_fstorage_is_busy+0x6a>
    {
        for (uint32_t i = 0; i < NRF_FSTORAGE_INSTANCE_CNT; i++)
   284c2:	2300      	movs	r3, #0
   284c4:	60fb      	str	r3, [r7, #12]
   284c6:	e01a      	b.n	284fe <nrf_fstorage_is_busy+0x52>
        {
            p_fs  = NRF_FSTORAGE_INSTANCE_GET(i);   /* cannot be NULL. */
   284c8:	68fa      	ldr	r2, [r7, #12]
   284ca:	4613      	mov	r3, r2
   284cc:	009b      	lsls	r3, r3, #2
   284ce:	4413      	add	r3, r2
   284d0:	009b      	lsls	r3, r3, #2
   284d2:	461a      	mov	r2, r3
   284d4:	4b16      	ldr	r3, [pc, #88]	; (28530 <nrf_fstorage_is_busy+0x84>)
   284d6:	4413      	add	r3, r2
   284d8:	607b      	str	r3, [r7, #4]
            p_api = (nrf_fstorage_api_t*)p_fs->p_api;
   284da:	687b      	ldr	r3, [r7, #4]
   284dc:	681b      	ldr	r3, [r3, #0]
   284de:	60bb      	str	r3, [r7, #8]

            if (p_api != NULL)
   284e0:	68bb      	ldr	r3, [r7, #8]
   284e2:	2b00      	cmp	r3, #0
   284e4:	d008      	beq.n	284f8 <nrf_fstorage_is_busy+0x4c>
            {
                /* p_api->is_busy() cannot be NULL. */
                if (p_api->is_busy(p_fs))
   284e6:	68bb      	ldr	r3, [r7, #8]
   284e8:	695b      	ldr	r3, [r3, #20]
   284ea:	6878      	ldr	r0, [r7, #4]
   284ec:	4798      	blx	r3
   284ee:	4603      	mov	r3, r0
   284f0:	2b00      	cmp	r3, #0
   284f2:	d001      	beq.n	284f8 <nrf_fstorage_is_busy+0x4c>
                {
                    return true;
   284f4:	2301      	movs	r3, #1
   284f6:	e016      	b.n	28526 <nrf_fstorage_is_busy+0x7a>
        for (uint32_t i = 0; i < NRF_FSTORAGE_INSTANCE_CNT; i++)
   284f8:	68fb      	ldr	r3, [r7, #12]
   284fa:	3301      	adds	r3, #1
   284fc:	60fb      	str	r3, [r7, #12]
   284fe:	4a0d      	ldr	r2, [pc, #52]	; (28534 <nrf_fstorage_is_busy+0x88>)
   28500:	4b0b      	ldr	r3, [pc, #44]	; (28530 <nrf_fstorage_is_busy+0x84>)
   28502:	1ad3      	subs	r3, r2, r3
   28504:	4a0c      	ldr	r2, [pc, #48]	; (28538 <nrf_fstorage_is_busy+0x8c>)
   28506:	fba2 2303 	umull	r2, r3, r2, r3
   2850a:	091b      	lsrs	r3, r3, #4
   2850c:	68fa      	ldr	r2, [r7, #12]
   2850e:	429a      	cmp	r2, r3
   28510:	d3da      	bcc.n	284c8 <nrf_fstorage_is_busy+0x1c>
                }
            }
        }

        return false;
   28512:	2300      	movs	r3, #0
   28514:	e007      	b.n	28526 <nrf_fstorage_is_busy+0x7a>
    }

    p_api = (nrf_fstorage_api_t*)p_fs->p_api;
   28516:	687b      	ldr	r3, [r7, #4]
   28518:	681b      	ldr	r3, [r3, #0]
   2851a:	60bb      	str	r3, [r7, #8]

    return p_api->is_busy(p_fs);
   2851c:	68bb      	ldr	r3, [r7, #8]
   2851e:	695b      	ldr	r3, [r3, #20]
   28520:	6878      	ldr	r0, [r7, #4]
   28522:	4798      	blx	r3
   28524:	4603      	mov	r3, r0
}
   28526:	4618      	mov	r0, r3
   28528:	3710      	adds	r7, #16
   2852a:	46bd      	mov	sp, r7
   2852c:	bd80      	pop	{r7, pc}
   2852e:	bf00      	nop
   28530:	20005088 	.word	0x20005088
   28534:	20005088 	.word	0x20005088
   28538:	cccccccd 	.word	0xcccccccd

0002853c <Reset_Handler>:
   2853c:	490b      	ldr	r1, [pc, #44]	; (2856c <Reset_Handler+0x30>)
   2853e:	4a0c      	ldr	r2, [pc, #48]	; (28570 <Reset_Handler+0x34>)
   28540:	4b0c      	ldr	r3, [pc, #48]	; (28574 <Reset_Handler+0x38>)
   28542:	1a9b      	subs	r3, r3, r2
   28544:	dd03      	ble.n	2854e <Reset_Handler+0x12>
   28546:	3b04      	subs	r3, #4
   28548:	58c8      	ldr	r0, [r1, r3]
   2854a:	50d0      	str	r0, [r2, r3]
   2854c:	dcfb      	bgt.n	28546 <Reset_Handler+0xa>
   2854e:	4909      	ldr	r1, [pc, #36]	; (28574 <Reset_Handler+0x38>)
   28550:	4a09      	ldr	r2, [pc, #36]	; (28578 <Reset_Handler+0x3c>)
   28552:	2000      	movs	r0, #0
   28554:	1a52      	subs	r2, r2, r1
   28556:	dd02      	ble.n	2855e <Reset_Handler+0x22>
   28558:	3a04      	subs	r2, #4
   2855a:	5088      	str	r0, [r1, r2]
   2855c:	dcfc      	bgt.n	28558 <Reset_Handler+0x1c>
   2855e:	f7fb fa75 	bl	23a4c <SystemInit>
   28562:	f7fb f9df 	bl	23924 <main>
   28566:	f7fa ff85 	bl	23474 <_mainCRTStartup>
   2856a:	0000      	.short	0x0000
   2856c:	0002b700 	.word	0x0002b700
   28570:	20005000 	.word	0x20005000
   28574:	20005088 	.word	0x20005088
   28578:	20005494 	.word	0x20005494

0002857c <NMI_Handler>:
   2857c:	e7fe      	b.n	2857c <NMI_Handler>

0002857e <HardFault_Handler>:
   2857e:	e7fe      	b.n	2857e <HardFault_Handler>

00028580 <MemoryManagement_Handler>:
   28580:	e7fe      	b.n	28580 <MemoryManagement_Handler>

00028582 <BusFault_Handler>:
   28582:	e7fe      	b.n	28582 <BusFault_Handler>

00028584 <UsageFault_Handler>:
   28584:	e7fe      	b.n	28584 <UsageFault_Handler>

00028586 <SVC_Handler>:
   28586:	e7fe      	b.n	28586 <SVC_Handler>

00028588 <DebugMon_Handler>:
   28588:	e7fe      	b.n	28588 <DebugMon_Handler>

0002858a <PendSV_Handler>:
   2858a:	e7fe      	b.n	2858a <PendSV_Handler>

0002858c <SysTick_Handler>:
   2858c:	e7fe      	b.n	2858c <SysTick_Handler>

0002858e <Default_Handler>:
   2858e:	e7fe      	b.n	2858e <Default_Handler>

00028590 <AES_Te0>:
   28590:	a563 63c6 847c 7cf8 9977 77ee 8d7b 7bf6     c..c|..|w..w{..{
   285a0:	0df2 f2ff bd6b 6bd6 b16f 6fde 54c5 c591     ....k..ko..o.T..
   285b0:	5030 3060 0301 0102 a967 67ce 7d2b 2b56     0P`0....g..g+}V+
   285c0:	19fe fee7 62d7 d7b5 e6ab ab4d 9a76 76ec     .....b....M.v..v
   285d0:	45ca ca8f 9d82 821f 40c9 c989 877d 7dfa     .E.......@..}..}
   285e0:	15fa faef eb59 59b2 c947 478e 0bf0 f0fb     ....Y..YG..G....
   285f0:	ecad ad41 67d4 d4b3 fda2 a25f eaaf af45     ..A..g...._...E.
   28600:	bf9c 9c23 f7a4 a453 9672 72e4 5bc0 c09b     ..#...S.r..r.[..
   28610:	c2b7 b775 1cfd fde1 ae93 933d 6a26 264c     ..u.......=.&jL&
   28620:	5a36 366c 413f 3f7e 02f7 f7f5 4fcc cc83     6Zl6?A~?.....O..
   28630:	5c34 3468 f4a5 a551 34e5 e5d1 08f1 f1f9     4\h4..Q..4......
   28640:	9371 71e2 73d8 d8ab 5331 3162 3f15 152a     q..q.s..1Sb1.?*.
   28650:	0c04 0408 52c7 c795 6523 2346 5ec3 c39d     .....R..#eF#.^..
   28660:	2818 1830 a196 9637 0f05 050a b59a 9a2f     .(0...7......./.
   28670:	0907 070e 3612 1224 9b80 801b 3de2 e2df     .....6$......=..
   28680:	26eb ebcd 6927 274e cdb2 b27f 9f75 75ea     .&..'iN'....u..u
   28690:	1b09 0912 9e83 831d 742c 2c58 2e1a 1a34     ........,tX,..4.
   286a0:	2d1b 1b36 b26e 6edc ee5a 5ab4 fba0 a05b     .-6.n..nZ..Z..[.
   286b0:	f652 52a4 4d3b 3b76 61d6 d6b7 ceb3 b37d     R..R;Mv;.a....}.
   286c0:	7b29 2952 3ee3 e3dd 712f 2f5e 9784 8413     ){R).>../q^/....
   286d0:	f553 53a6 68d1 d1b9 0000 0000 2ced edc1     S..S.h.......,..
   286e0:	6020 2040 1ffc fce3 c8b1 b179 ed5b 5bb6      `@ ......y.[..[
   286f0:	be6a 6ad4 46cb cb8d d9be be67 4b39 3972     j..j.F....g.9Kr9
   28700:	de4a 4a94 d44c 4c98 e858 58b0 4acf cf85     J..JL..LX..X.J..
   28710:	6bd0 d0bb 2aef efc5 e5aa aa4f 16fb fbed     .k...*....O.....
   28720:	c543 4386 d74d 4d9a 5533 3366 9485 8511     C..CM..M3Uf3....
   28730:	cf45 458a 10f9 f9e9 0602 0204 817f 7ffe     E..E............
   28740:	f050 50a0 443c 3c78 ba9f 9f25 e3a8 a84b     P..P<Dx<..%...K.
   28750:	f351 51a2 fea3 a35d c040 4080 8a8f 8f05     Q..Q..].@..@....
   28760:	ad92 923f bc9d 9d21 4838 3870 04f5 f5f1     ..?...!.8Hp8....
   28770:	dfbc bc63 c1b6 b677 75da daaf 6321 2142     ..c...w..u..!cB!
   28780:	3010 1020 1aff ffe5 0ef3 f3fd 6dd2 d2bf     .0 ..........m..
   28790:	4ccd cd81 140c 0c18 3513 1326 2fec ecc3     .L.......5&../..
   287a0:	e15f 5fbe a297 9735 cc44 4488 3917 172e     _.._..5.D..D.9..
   287b0:	57c4 c493 f2a7 a755 827e 7efc 473d 3d7a     .W....U.~..~=Gz=
   287c0:	ac64 64c8 e75d 5dba 2b19 1932 9573 73e6     d..d]..].+2.s..s
   287d0:	a060 60c0 9881 8119 d14f 4f9e 7fdc dca3     `..`....O..O....
   287e0:	6622 2244 7e2a 2a54 ab90 903b 8388 880b     "fD"*~T*..;.....
   287f0:	ca46 468c 29ee eec7 d3b8 b86b 3c14 1428     F..F.)....k..<(.
   28800:	79de dea7 e25e 5ebc 1d0b 0b16 76db dbad     .y..^..^.....v..
   28810:	3be0 e0db 5632 3264 4e3a 3a74 1e0a 0a14     .;..2Vd2:Nt:....
   28820:	db49 4992 0a06 060c 6c24 2448 e45c 5cb8     I..I....$lH$\..\
   28830:	5dc2 c29f 6ed3 d3bd efac ac43 a662 62c4     .]...n....C.b..b
   28840:	a891 9139 a495 9531 37e4 e4d3 8b79 79f2     ..9...1..7..y..y
   28850:	32e7 e7d5 43c8 c88b 5937 376e b76d 6dda     .2...C..7Yn7m..m
   28860:	8c8d 8d01 64d5 d5b1 d24e 4e9c e0a9 a949     .....d..N..N..I.
   28870:	b46c 6cd8 fa56 56ac 07f4 f4f3 25ea eacf     l..lV..V.....%..
   28880:	af65 65ca 8e7a 7af4 e9ae ae47 1808 0810     e..ez..z..G.....
   28890:	d5ba ba6f 8878 78f0 6f25 254a 722e 2e5c     ..o.x..x%oJ%.r\.
   288a0:	241c 1c38 f1a6 a657 c7b4 b473 51c6 c697     .$8...W...s..Q..
   288b0:	23e8 e8cb 7cdd dda1 9c74 74e8 211f 1f3e     .#...|..t..t.!>.
   288c0:	dd4b 4b96 dcbd bd61 868b 8b0d 858a 8a0f     K..K..a.........
   288d0:	9070 70e0 423e 3e7c c4b5 b571 aa66 66cc     p..p>B|>..q.f..f
   288e0:	d848 4890 0503 0306 01f6 f6f7 120e 0e1c     H..H............
   288f0:	a361 61c2 5f35 356a f957 57ae d0b9 b969     a..a5_j5W..W..i.
   28900:	9186 8617 58c1 c199 271d 1d3a b99e 9e27     .....X...':...'.
   28910:	38e1 e1d9 13f8 f8eb b398 982b 3311 1122     .8........+..3".
   28920:	bb69 69d2 70d9 d9a9 898e 8e07 a794 9433     i..i.p........3.
   28930:	b69b 9b2d 221e 1e3c 9287 8715 20e9 e9c9     ..-.."<...... ..
   28940:	49ce ce87 ff55 55aa 7828 2850 7adf dfa5     .I..U..U(xP(.z..
   28950:	8f8c 8c03 f8a1 a159 8089 8909 170d 0d1a     ......Y.........
   28960:	dabf bf65 31e6 e6d7 c642 4284 b868 68d0     ..e..1..B..Bh..h
   28970:	c341 4182 b099 9929 772d 2d5a 110f 0f1e     A..A..).-wZ-....
   28980:	cbb0 b07b fc54 54a8 d6bb bb6d 3a16 162c     ..{.T..T..m..:,.

00028990 <AES_128_keyschedule>:
   28990:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
   28994:	e890 00f0 	ldmia.w	r0, {r4, r5, r6, r7}
   28998:	f2af 430c 	subw	r3, pc, #1036	; 0x40c
   2899c:	fa5f f897 	uxtb.w	r8, r7, ror #8
   289a0:	fa5f f9a7 	uxtb.w	r9, r7, ror #16
   289a4:	fa5f fab7 	uxtb.w	sl, r7, ror #24
   289a8:	fa5f fb87 	uxtb.w	fp, r7
   289ac:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   289b0:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   289b4:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   289b8:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   289bc:	f008 08ff 	and.w	r8, r8, #255	; 0xff
   289c0:	f009 09ff 	and.w	r9, r9, #255	; 0xff
   289c4:	f00a 0aff 	and.w	sl, sl, #255	; 0xff
   289c8:	f084 0401 	eor.w	r4, r4, #1
   289cc:	ea84 0408 	eor.w	r4, r4, r8
   289d0:	ea84 2409 	eor.w	r4, r4, r9, lsl #8
   289d4:	ea84 440a 	eor.w	r4, r4, sl, lsl #16
   289d8:	ea84 640b 	eor.w	r4, r4, fp, lsl #24
   289dc:	ea85 0504 	eor.w	r5, r5, r4
   289e0:	ea86 0605 	eor.w	r6, r6, r5
   289e4:	ea87 0706 	eor.w	r7, r7, r6
   289e8:	600c      	str	r4, [r1, #0]
   289ea:	604d      	str	r5, [r1, #4]
   289ec:	608e      	str	r6, [r1, #8]
   289ee:	60cf      	str	r7, [r1, #12]
   289f0:	fa5f f897 	uxtb.w	r8, r7, ror #8
   289f4:	fa5f f9a7 	uxtb.w	r9, r7, ror #16
   289f8:	fa5f fab7 	uxtb.w	sl, r7, ror #24
   289fc:	fa5f fb87 	uxtb.w	fp, r7
   28a00:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   28a04:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   28a08:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   28a0c:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   28a10:	f008 08ff 	and.w	r8, r8, #255	; 0xff
   28a14:	f009 09ff 	and.w	r9, r9, #255	; 0xff
   28a18:	f00a 0aff 	and.w	sl, sl, #255	; 0xff
   28a1c:	f084 0402 	eor.w	r4, r4, #2
   28a20:	ea84 0408 	eor.w	r4, r4, r8
   28a24:	ea84 2409 	eor.w	r4, r4, r9, lsl #8
   28a28:	ea84 440a 	eor.w	r4, r4, sl, lsl #16
   28a2c:	ea84 640b 	eor.w	r4, r4, fp, lsl #24
   28a30:	ea85 0504 	eor.w	r5, r5, r4
   28a34:	ea86 0605 	eor.w	r6, r6, r5
   28a38:	ea87 0706 	eor.w	r7, r7, r6
   28a3c:	610c      	str	r4, [r1, #16]
   28a3e:	614d      	str	r5, [r1, #20]
   28a40:	618e      	str	r6, [r1, #24]
   28a42:	61cf      	str	r7, [r1, #28]
   28a44:	fa5f f897 	uxtb.w	r8, r7, ror #8
   28a48:	fa5f f9a7 	uxtb.w	r9, r7, ror #16
   28a4c:	fa5f fab7 	uxtb.w	sl, r7, ror #24
   28a50:	fa5f fb87 	uxtb.w	fp, r7
   28a54:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   28a58:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   28a5c:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   28a60:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   28a64:	f008 08ff 	and.w	r8, r8, #255	; 0xff
   28a68:	f009 09ff 	and.w	r9, r9, #255	; 0xff
   28a6c:	f00a 0aff 	and.w	sl, sl, #255	; 0xff
   28a70:	f084 0404 	eor.w	r4, r4, #4
   28a74:	ea84 0408 	eor.w	r4, r4, r8
   28a78:	ea84 2409 	eor.w	r4, r4, r9, lsl #8
   28a7c:	ea84 440a 	eor.w	r4, r4, sl, lsl #16
   28a80:	ea84 640b 	eor.w	r4, r4, fp, lsl #24
   28a84:	ea85 0504 	eor.w	r5, r5, r4
   28a88:	ea86 0605 	eor.w	r6, r6, r5
   28a8c:	ea87 0706 	eor.w	r7, r7, r6
   28a90:	620c      	str	r4, [r1, #32]
   28a92:	624d      	str	r5, [r1, #36]	; 0x24
   28a94:	628e      	str	r6, [r1, #40]	; 0x28
   28a96:	62cf      	str	r7, [r1, #44]	; 0x2c
   28a98:	fa5f f897 	uxtb.w	r8, r7, ror #8
   28a9c:	fa5f f9a7 	uxtb.w	r9, r7, ror #16
   28aa0:	fa5f fab7 	uxtb.w	sl, r7, ror #24
   28aa4:	fa5f fb87 	uxtb.w	fp, r7
   28aa8:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   28aac:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   28ab0:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   28ab4:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   28ab8:	f008 08ff 	and.w	r8, r8, #255	; 0xff
   28abc:	f009 09ff 	and.w	r9, r9, #255	; 0xff
   28ac0:	f00a 0aff 	and.w	sl, sl, #255	; 0xff
   28ac4:	f084 0408 	eor.w	r4, r4, #8
   28ac8:	ea84 0408 	eor.w	r4, r4, r8
   28acc:	ea84 2409 	eor.w	r4, r4, r9, lsl #8
   28ad0:	ea84 440a 	eor.w	r4, r4, sl, lsl #16
   28ad4:	ea84 640b 	eor.w	r4, r4, fp, lsl #24
   28ad8:	ea85 0504 	eor.w	r5, r5, r4
   28adc:	ea86 0605 	eor.w	r6, r6, r5
   28ae0:	ea87 0706 	eor.w	r7, r7, r6
   28ae4:	630c      	str	r4, [r1, #48]	; 0x30
   28ae6:	634d      	str	r5, [r1, #52]	; 0x34
   28ae8:	638e      	str	r6, [r1, #56]	; 0x38
   28aea:	63cf      	str	r7, [r1, #60]	; 0x3c
   28aec:	fa5f f897 	uxtb.w	r8, r7, ror #8
   28af0:	fa5f f9a7 	uxtb.w	r9, r7, ror #16
   28af4:	fa5f fab7 	uxtb.w	sl, r7, ror #24
   28af8:	fa5f fb87 	uxtb.w	fp, r7
   28afc:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   28b00:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   28b04:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   28b08:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   28b0c:	f008 08ff 	and.w	r8, r8, #255	; 0xff
   28b10:	f009 09ff 	and.w	r9, r9, #255	; 0xff
   28b14:	f00a 0aff 	and.w	sl, sl, #255	; 0xff
   28b18:	f084 0410 	eor.w	r4, r4, #16
   28b1c:	ea84 0408 	eor.w	r4, r4, r8
   28b20:	ea84 2409 	eor.w	r4, r4, r9, lsl #8
   28b24:	ea84 440a 	eor.w	r4, r4, sl, lsl #16
   28b28:	ea84 640b 	eor.w	r4, r4, fp, lsl #24
   28b2c:	ea85 0504 	eor.w	r5, r5, r4
   28b30:	ea86 0605 	eor.w	r6, r6, r5
   28b34:	ea87 0706 	eor.w	r7, r7, r6
   28b38:	640c      	str	r4, [r1, #64]	; 0x40
   28b3a:	644d      	str	r5, [r1, #68]	; 0x44
   28b3c:	648e      	str	r6, [r1, #72]	; 0x48
   28b3e:	64cf      	str	r7, [r1, #76]	; 0x4c
   28b40:	fa5f f897 	uxtb.w	r8, r7, ror #8
   28b44:	fa5f f9a7 	uxtb.w	r9, r7, ror #16
   28b48:	fa5f fab7 	uxtb.w	sl, r7, ror #24
   28b4c:	fa5f fb87 	uxtb.w	fp, r7
   28b50:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   28b54:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   28b58:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   28b5c:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   28b60:	f008 08ff 	and.w	r8, r8, #255	; 0xff
   28b64:	f009 09ff 	and.w	r9, r9, #255	; 0xff
   28b68:	f00a 0aff 	and.w	sl, sl, #255	; 0xff
   28b6c:	f084 0420 	eor.w	r4, r4, #32
   28b70:	ea84 0408 	eor.w	r4, r4, r8
   28b74:	ea84 2409 	eor.w	r4, r4, r9, lsl #8
   28b78:	ea84 440a 	eor.w	r4, r4, sl, lsl #16
   28b7c:	ea84 640b 	eor.w	r4, r4, fp, lsl #24
   28b80:	ea85 0504 	eor.w	r5, r5, r4
   28b84:	ea86 0605 	eor.w	r6, r6, r5
   28b88:	ea87 0706 	eor.w	r7, r7, r6
   28b8c:	650c      	str	r4, [r1, #80]	; 0x50
   28b8e:	654d      	str	r5, [r1, #84]	; 0x54
   28b90:	658e      	str	r6, [r1, #88]	; 0x58
   28b92:	65cf      	str	r7, [r1, #92]	; 0x5c
   28b94:	fa5f f897 	uxtb.w	r8, r7, ror #8
   28b98:	fa5f f9a7 	uxtb.w	r9, r7, ror #16
   28b9c:	fa5f fab7 	uxtb.w	sl, r7, ror #24
   28ba0:	fa5f fb87 	uxtb.w	fp, r7
   28ba4:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   28ba8:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   28bac:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   28bb0:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   28bb4:	f008 08ff 	and.w	r8, r8, #255	; 0xff
   28bb8:	f009 09ff 	and.w	r9, r9, #255	; 0xff
   28bbc:	f00a 0aff 	and.w	sl, sl, #255	; 0xff
   28bc0:	f084 0440 	eor.w	r4, r4, #64	; 0x40
   28bc4:	ea84 0408 	eor.w	r4, r4, r8
   28bc8:	ea84 2409 	eor.w	r4, r4, r9, lsl #8
   28bcc:	ea84 440a 	eor.w	r4, r4, sl, lsl #16
   28bd0:	ea84 640b 	eor.w	r4, r4, fp, lsl #24
   28bd4:	ea85 0504 	eor.w	r5, r5, r4
   28bd8:	ea86 0605 	eor.w	r6, r6, r5
   28bdc:	ea87 0706 	eor.w	r7, r7, r6
   28be0:	660c      	str	r4, [r1, #96]	; 0x60
   28be2:	664d      	str	r5, [r1, #100]	; 0x64
   28be4:	668e      	str	r6, [r1, #104]	; 0x68
   28be6:	66cf      	str	r7, [r1, #108]	; 0x6c
   28be8:	fa5f f897 	uxtb.w	r8, r7, ror #8
   28bec:	fa5f f9a7 	uxtb.w	r9, r7, ror #16
   28bf0:	fa5f fab7 	uxtb.w	sl, r7, ror #24
   28bf4:	fa5f fb87 	uxtb.w	fp, r7
   28bf8:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   28bfc:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   28c00:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   28c04:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   28c08:	f008 08ff 	and.w	r8, r8, #255	; 0xff
   28c0c:	f009 09ff 	and.w	r9, r9, #255	; 0xff
   28c10:	f00a 0aff 	and.w	sl, sl, #255	; 0xff
   28c14:	f084 0480 	eor.w	r4, r4, #128	; 0x80
   28c18:	ea84 0408 	eor.w	r4, r4, r8
   28c1c:	ea84 2409 	eor.w	r4, r4, r9, lsl #8
   28c20:	ea84 440a 	eor.w	r4, r4, sl, lsl #16
   28c24:	ea84 640b 	eor.w	r4, r4, fp, lsl #24
   28c28:	ea85 0504 	eor.w	r5, r5, r4
   28c2c:	ea86 0605 	eor.w	r6, r6, r5
   28c30:	ea87 0706 	eor.w	r7, r7, r6
   28c34:	670c      	str	r4, [r1, #112]	; 0x70
   28c36:	674d      	str	r5, [r1, #116]	; 0x74
   28c38:	678e      	str	r6, [r1, #120]	; 0x78
   28c3a:	67cf      	str	r7, [r1, #124]	; 0x7c
   28c3c:	f101 0180 	add.w	r1, r1, #128	; 0x80
   28c40:	fa5f f897 	uxtb.w	r8, r7, ror #8
   28c44:	fa5f f9a7 	uxtb.w	r9, r7, ror #16
   28c48:	fa5f fab7 	uxtb.w	sl, r7, ror #24
   28c4c:	fa5f fb87 	uxtb.w	fp, r7
   28c50:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   28c54:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   28c58:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   28c5c:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   28c60:	f008 08ff 	and.w	r8, r8, #255	; 0xff
   28c64:	f009 09ff 	and.w	r9, r9, #255	; 0xff
   28c68:	f00a 0aff 	and.w	sl, sl, #255	; 0xff
   28c6c:	f084 041b 	eor.w	r4, r4, #27
   28c70:	ea84 0408 	eor.w	r4, r4, r8
   28c74:	ea84 2409 	eor.w	r4, r4, r9, lsl #8
   28c78:	ea84 440a 	eor.w	r4, r4, sl, lsl #16
   28c7c:	ea84 640b 	eor.w	r4, r4, fp, lsl #24
   28c80:	ea85 0504 	eor.w	r5, r5, r4
   28c84:	ea86 0605 	eor.w	r6, r6, r5
   28c88:	ea87 0706 	eor.w	r7, r7, r6
   28c8c:	600c      	str	r4, [r1, #0]
   28c8e:	604d      	str	r5, [r1, #4]
   28c90:	608e      	str	r6, [r1, #8]
   28c92:	60cf      	str	r7, [r1, #12]
   28c94:	fa5f f897 	uxtb.w	r8, r7, ror #8
   28c98:	fa5f f9a7 	uxtb.w	r9, r7, ror #16
   28c9c:	fa5f fab7 	uxtb.w	sl, r7, ror #24
   28ca0:	fa5f fb87 	uxtb.w	fp, r7
   28ca4:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   28ca8:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   28cac:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   28cb0:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   28cb4:	f008 08ff 	and.w	r8, r8, #255	; 0xff
   28cb8:	f009 09ff 	and.w	r9, r9, #255	; 0xff
   28cbc:	f00a 0aff 	and.w	sl, sl, #255	; 0xff
   28cc0:	f084 0436 	eor.w	r4, r4, #54	; 0x36
   28cc4:	ea84 0408 	eor.w	r4, r4, r8
   28cc8:	ea84 2409 	eor.w	r4, r4, r9, lsl #8
   28ccc:	ea84 440a 	eor.w	r4, r4, sl, lsl #16
   28cd0:	ea84 640b 	eor.w	r4, r4, fp, lsl #24
   28cd4:	ea85 0504 	eor.w	r5, r5, r4
   28cd8:	ea86 0605 	eor.w	r6, r6, r5
   28cdc:	ea87 0706 	eor.w	r7, r7, r6
   28ce0:	610c      	str	r4, [r1, #16]
   28ce2:	614d      	str	r5, [r1, #20]
   28ce4:	618e      	str	r6, [r1, #24]
   28ce6:	61cf      	str	r7, [r1, #28]
   28ce8:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
   28cec:	4770      	bx	lr
   28cee:	46c0      	nop			; (mov r8, r8)

00028cf0 <AES_128_encrypt>:
   28cf0:	e92d 5ff4 	stmdb	sp!, {r2, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
   28cf4:	e891 00f0 	ldmia.w	r1, {r4, r5, r6, r7}
   28cf8:	e8b0 0f00 	ldmia.w	r0!, {r8, r9, sl, fp}
   28cfc:	ea4f 0e00 	mov.w	lr, r0
   28d00:	f2af 7c74 	subw	ip, pc, #1908	; 0x774
   28d04:	ea84 0408 	eor.w	r4, r4, r8
   28d08:	ea85 0509 	eor.w	r5, r5, r9
   28d0c:	ea86 060a 	eor.w	r6, r6, sl
   28d10:	ea87 070b 	eor.w	r7, r7, fp
   28d14:	e8be 0f00 	ldmia.w	lr!, {r8, r9, sl, fp}
   28d18:	b2e0      	uxtb	r0, r4
   28d1a:	b2e9      	uxtb	r1, r5
   28d1c:	b2f2      	uxtb	r2, r6
   28d1e:	b2fb      	uxtb	r3, r7
   28d20:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   28d24:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   28d28:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   28d2c:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   28d30:	ea88 4830 	eor.w	r8, r8, r0, ror #16
   28d34:	ea89 4931 	eor.w	r9, r9, r1, ror #16
   28d38:	ea8a 4a32 	eor.w	sl, sl, r2, ror #16
   28d3c:	ea8b 4b33 	eor.w	fp, fp, r3, ror #16
   28d40:	fa5f f095 	uxtb.w	r0, r5, ror #8
   28d44:	fa5f f196 	uxtb.w	r1, r6, ror #8
   28d48:	fa5f f297 	uxtb.w	r2, r7, ror #8
   28d4c:	fa5f f394 	uxtb.w	r3, r4, ror #8
   28d50:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   28d54:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   28d58:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   28d5c:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   28d60:	ea88 2830 	eor.w	r8, r8, r0, ror #8
   28d64:	ea89 2931 	eor.w	r9, r9, r1, ror #8
   28d68:	ea8a 2a32 	eor.w	sl, sl, r2, ror #8
   28d6c:	ea8b 2b33 	eor.w	fp, fp, r3, ror #8
   28d70:	fa5f f0a6 	uxtb.w	r0, r6, ror #16
   28d74:	fa5f f1a7 	uxtb.w	r1, r7, ror #16
   28d78:	fa5f f2a4 	uxtb.w	r2, r4, ror #16
   28d7c:	fa5f f3a5 	uxtb.w	r3, r5, ror #16
   28d80:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   28d84:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   28d88:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   28d8c:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   28d90:	ea88 0800 	eor.w	r8, r8, r0
   28d94:	ea89 0901 	eor.w	r9, r9, r1
   28d98:	ea8a 0a02 	eor.w	sl, sl, r2
   28d9c:	ea8b 0b03 	eor.w	fp, fp, r3
   28da0:	fa5f f0b7 	uxtb.w	r0, r7, ror #24
   28da4:	fa5f f1b4 	uxtb.w	r1, r4, ror #24
   28da8:	fa5f f2b5 	uxtb.w	r2, r5, ror #24
   28dac:	fa5f f3b6 	uxtb.w	r3, r6, ror #24
   28db0:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   28db4:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   28db8:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   28dbc:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   28dc0:	ea88 6830 	eor.w	r8, r8, r0, ror #24
   28dc4:	ea89 6931 	eor.w	r9, r9, r1, ror #24
   28dc8:	ea8a 6a32 	eor.w	sl, sl, r2, ror #24
   28dcc:	ea8b 6b33 	eor.w	fp, fp, r3, ror #24
   28dd0:	e8be 00f0 	ldmia.w	lr!, {r4, r5, r6, r7}
   28dd4:	fa5f f088 	uxtb.w	r0, r8
   28dd8:	fa5f f189 	uxtb.w	r1, r9
   28ddc:	fa5f f28a 	uxtb.w	r2, sl
   28de0:	fa5f f38b 	uxtb.w	r3, fp
   28de4:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   28de8:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   28dec:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   28df0:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   28df4:	ea84 4430 	eor.w	r4, r4, r0, ror #16
   28df8:	ea85 4531 	eor.w	r5, r5, r1, ror #16
   28dfc:	ea86 4632 	eor.w	r6, r6, r2, ror #16
   28e00:	ea87 4733 	eor.w	r7, r7, r3, ror #16
   28e04:	fa5f f099 	uxtb.w	r0, r9, ror #8
   28e08:	fa5f f19a 	uxtb.w	r1, sl, ror #8
   28e0c:	fa5f f29b 	uxtb.w	r2, fp, ror #8
   28e10:	fa5f f398 	uxtb.w	r3, r8, ror #8
   28e14:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   28e18:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   28e1c:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   28e20:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   28e24:	ea84 2430 	eor.w	r4, r4, r0, ror #8
   28e28:	ea85 2531 	eor.w	r5, r5, r1, ror #8
   28e2c:	ea86 2632 	eor.w	r6, r6, r2, ror #8
   28e30:	ea87 2733 	eor.w	r7, r7, r3, ror #8
   28e34:	fa5f f0aa 	uxtb.w	r0, sl, ror #16
   28e38:	fa5f f1ab 	uxtb.w	r1, fp, ror #16
   28e3c:	fa5f f2a8 	uxtb.w	r2, r8, ror #16
   28e40:	fa5f f3a9 	uxtb.w	r3, r9, ror #16
   28e44:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   28e48:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   28e4c:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   28e50:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   28e54:	ea84 0400 	eor.w	r4, r4, r0
   28e58:	ea85 0501 	eor.w	r5, r5, r1
   28e5c:	ea86 0602 	eor.w	r6, r6, r2
   28e60:	ea87 0703 	eor.w	r7, r7, r3
   28e64:	fa5f f0bb 	uxtb.w	r0, fp, ror #24
   28e68:	fa5f f1b8 	uxtb.w	r1, r8, ror #24
   28e6c:	fa5f f2b9 	uxtb.w	r2, r9, ror #24
   28e70:	fa5f f3ba 	uxtb.w	r3, sl, ror #24
   28e74:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   28e78:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   28e7c:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   28e80:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   28e84:	ea84 6430 	eor.w	r4, r4, r0, ror #24
   28e88:	ea85 6531 	eor.w	r5, r5, r1, ror #24
   28e8c:	ea86 6632 	eor.w	r6, r6, r2, ror #24
   28e90:	ea87 6733 	eor.w	r7, r7, r3, ror #24
   28e94:	e8be 0f00 	ldmia.w	lr!, {r8, r9, sl, fp}
   28e98:	b2e0      	uxtb	r0, r4
   28e9a:	b2e9      	uxtb	r1, r5
   28e9c:	b2f2      	uxtb	r2, r6
   28e9e:	b2fb      	uxtb	r3, r7
   28ea0:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   28ea4:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   28ea8:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   28eac:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   28eb0:	ea88 4830 	eor.w	r8, r8, r0, ror #16
   28eb4:	ea89 4931 	eor.w	r9, r9, r1, ror #16
   28eb8:	ea8a 4a32 	eor.w	sl, sl, r2, ror #16
   28ebc:	ea8b 4b33 	eor.w	fp, fp, r3, ror #16
   28ec0:	fa5f f095 	uxtb.w	r0, r5, ror #8
   28ec4:	fa5f f196 	uxtb.w	r1, r6, ror #8
   28ec8:	fa5f f297 	uxtb.w	r2, r7, ror #8
   28ecc:	fa5f f394 	uxtb.w	r3, r4, ror #8
   28ed0:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   28ed4:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   28ed8:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   28edc:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   28ee0:	ea88 2830 	eor.w	r8, r8, r0, ror #8
   28ee4:	ea89 2931 	eor.w	r9, r9, r1, ror #8
   28ee8:	ea8a 2a32 	eor.w	sl, sl, r2, ror #8
   28eec:	ea8b 2b33 	eor.w	fp, fp, r3, ror #8
   28ef0:	fa5f f0a6 	uxtb.w	r0, r6, ror #16
   28ef4:	fa5f f1a7 	uxtb.w	r1, r7, ror #16
   28ef8:	fa5f f2a4 	uxtb.w	r2, r4, ror #16
   28efc:	fa5f f3a5 	uxtb.w	r3, r5, ror #16
   28f00:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   28f04:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   28f08:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   28f0c:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   28f10:	ea88 0800 	eor.w	r8, r8, r0
   28f14:	ea89 0901 	eor.w	r9, r9, r1
   28f18:	ea8a 0a02 	eor.w	sl, sl, r2
   28f1c:	ea8b 0b03 	eor.w	fp, fp, r3
   28f20:	fa5f f0b7 	uxtb.w	r0, r7, ror #24
   28f24:	fa5f f1b4 	uxtb.w	r1, r4, ror #24
   28f28:	fa5f f2b5 	uxtb.w	r2, r5, ror #24
   28f2c:	fa5f f3b6 	uxtb.w	r3, r6, ror #24
   28f30:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   28f34:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   28f38:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   28f3c:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   28f40:	ea88 6830 	eor.w	r8, r8, r0, ror #24
   28f44:	ea89 6931 	eor.w	r9, r9, r1, ror #24
   28f48:	ea8a 6a32 	eor.w	sl, sl, r2, ror #24
   28f4c:	ea8b 6b33 	eor.w	fp, fp, r3, ror #24
   28f50:	e8be 00f0 	ldmia.w	lr!, {r4, r5, r6, r7}
   28f54:	fa5f f088 	uxtb.w	r0, r8
   28f58:	fa5f f189 	uxtb.w	r1, r9
   28f5c:	fa5f f28a 	uxtb.w	r2, sl
   28f60:	fa5f f38b 	uxtb.w	r3, fp
   28f64:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   28f68:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   28f6c:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   28f70:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   28f74:	ea84 4430 	eor.w	r4, r4, r0, ror #16
   28f78:	ea85 4531 	eor.w	r5, r5, r1, ror #16
   28f7c:	ea86 4632 	eor.w	r6, r6, r2, ror #16
   28f80:	ea87 4733 	eor.w	r7, r7, r3, ror #16
   28f84:	fa5f f099 	uxtb.w	r0, r9, ror #8
   28f88:	fa5f f19a 	uxtb.w	r1, sl, ror #8
   28f8c:	fa5f f29b 	uxtb.w	r2, fp, ror #8
   28f90:	fa5f f398 	uxtb.w	r3, r8, ror #8
   28f94:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   28f98:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   28f9c:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   28fa0:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   28fa4:	ea84 2430 	eor.w	r4, r4, r0, ror #8
   28fa8:	ea85 2531 	eor.w	r5, r5, r1, ror #8
   28fac:	ea86 2632 	eor.w	r6, r6, r2, ror #8
   28fb0:	ea87 2733 	eor.w	r7, r7, r3, ror #8
   28fb4:	fa5f f0aa 	uxtb.w	r0, sl, ror #16
   28fb8:	fa5f f1ab 	uxtb.w	r1, fp, ror #16
   28fbc:	fa5f f2a8 	uxtb.w	r2, r8, ror #16
   28fc0:	fa5f f3a9 	uxtb.w	r3, r9, ror #16
   28fc4:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   28fc8:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   28fcc:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   28fd0:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   28fd4:	ea84 0400 	eor.w	r4, r4, r0
   28fd8:	ea85 0501 	eor.w	r5, r5, r1
   28fdc:	ea86 0602 	eor.w	r6, r6, r2
   28fe0:	ea87 0703 	eor.w	r7, r7, r3
   28fe4:	fa5f f0bb 	uxtb.w	r0, fp, ror #24
   28fe8:	fa5f f1b8 	uxtb.w	r1, r8, ror #24
   28fec:	fa5f f2b9 	uxtb.w	r2, r9, ror #24
   28ff0:	fa5f f3ba 	uxtb.w	r3, sl, ror #24
   28ff4:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   28ff8:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   28ffc:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   29000:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   29004:	ea84 6430 	eor.w	r4, r4, r0, ror #24
   29008:	ea85 6531 	eor.w	r5, r5, r1, ror #24
   2900c:	ea86 6632 	eor.w	r6, r6, r2, ror #24
   29010:	ea87 6733 	eor.w	r7, r7, r3, ror #24
   29014:	e8be 0f00 	ldmia.w	lr!, {r8, r9, sl, fp}
   29018:	b2e0      	uxtb	r0, r4
   2901a:	b2e9      	uxtb	r1, r5
   2901c:	b2f2      	uxtb	r2, r6
   2901e:	b2fb      	uxtb	r3, r7
   29020:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   29024:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   29028:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2902c:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   29030:	ea88 4830 	eor.w	r8, r8, r0, ror #16
   29034:	ea89 4931 	eor.w	r9, r9, r1, ror #16
   29038:	ea8a 4a32 	eor.w	sl, sl, r2, ror #16
   2903c:	ea8b 4b33 	eor.w	fp, fp, r3, ror #16
   29040:	fa5f f095 	uxtb.w	r0, r5, ror #8
   29044:	fa5f f196 	uxtb.w	r1, r6, ror #8
   29048:	fa5f f297 	uxtb.w	r2, r7, ror #8
   2904c:	fa5f f394 	uxtb.w	r3, r4, ror #8
   29050:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   29054:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   29058:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2905c:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   29060:	ea88 2830 	eor.w	r8, r8, r0, ror #8
   29064:	ea89 2931 	eor.w	r9, r9, r1, ror #8
   29068:	ea8a 2a32 	eor.w	sl, sl, r2, ror #8
   2906c:	ea8b 2b33 	eor.w	fp, fp, r3, ror #8
   29070:	fa5f f0a6 	uxtb.w	r0, r6, ror #16
   29074:	fa5f f1a7 	uxtb.w	r1, r7, ror #16
   29078:	fa5f f2a4 	uxtb.w	r2, r4, ror #16
   2907c:	fa5f f3a5 	uxtb.w	r3, r5, ror #16
   29080:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   29084:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   29088:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2908c:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   29090:	ea88 0800 	eor.w	r8, r8, r0
   29094:	ea89 0901 	eor.w	r9, r9, r1
   29098:	ea8a 0a02 	eor.w	sl, sl, r2
   2909c:	ea8b 0b03 	eor.w	fp, fp, r3
   290a0:	fa5f f0b7 	uxtb.w	r0, r7, ror #24
   290a4:	fa5f f1b4 	uxtb.w	r1, r4, ror #24
   290a8:	fa5f f2b5 	uxtb.w	r2, r5, ror #24
   290ac:	fa5f f3b6 	uxtb.w	r3, r6, ror #24
   290b0:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   290b4:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   290b8:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   290bc:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   290c0:	ea88 6830 	eor.w	r8, r8, r0, ror #24
   290c4:	ea89 6931 	eor.w	r9, r9, r1, ror #24
   290c8:	ea8a 6a32 	eor.w	sl, sl, r2, ror #24
   290cc:	ea8b 6b33 	eor.w	fp, fp, r3, ror #24
   290d0:	e8be 00f0 	ldmia.w	lr!, {r4, r5, r6, r7}
   290d4:	fa5f f088 	uxtb.w	r0, r8
   290d8:	fa5f f189 	uxtb.w	r1, r9
   290dc:	fa5f f28a 	uxtb.w	r2, sl
   290e0:	fa5f f38b 	uxtb.w	r3, fp
   290e4:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   290e8:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   290ec:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   290f0:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   290f4:	ea84 4430 	eor.w	r4, r4, r0, ror #16
   290f8:	ea85 4531 	eor.w	r5, r5, r1, ror #16
   290fc:	ea86 4632 	eor.w	r6, r6, r2, ror #16
   29100:	ea87 4733 	eor.w	r7, r7, r3, ror #16
   29104:	fa5f f099 	uxtb.w	r0, r9, ror #8
   29108:	fa5f f19a 	uxtb.w	r1, sl, ror #8
   2910c:	fa5f f29b 	uxtb.w	r2, fp, ror #8
   29110:	fa5f f398 	uxtb.w	r3, r8, ror #8
   29114:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   29118:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2911c:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   29120:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   29124:	ea84 2430 	eor.w	r4, r4, r0, ror #8
   29128:	ea85 2531 	eor.w	r5, r5, r1, ror #8
   2912c:	ea86 2632 	eor.w	r6, r6, r2, ror #8
   29130:	ea87 2733 	eor.w	r7, r7, r3, ror #8
   29134:	fa5f f0aa 	uxtb.w	r0, sl, ror #16
   29138:	fa5f f1ab 	uxtb.w	r1, fp, ror #16
   2913c:	fa5f f2a8 	uxtb.w	r2, r8, ror #16
   29140:	fa5f f3a9 	uxtb.w	r3, r9, ror #16
   29144:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   29148:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2914c:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   29150:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   29154:	ea84 0400 	eor.w	r4, r4, r0
   29158:	ea85 0501 	eor.w	r5, r5, r1
   2915c:	ea86 0602 	eor.w	r6, r6, r2
   29160:	ea87 0703 	eor.w	r7, r7, r3
   29164:	fa5f f0bb 	uxtb.w	r0, fp, ror #24
   29168:	fa5f f1b8 	uxtb.w	r1, r8, ror #24
   2916c:	fa5f f2b9 	uxtb.w	r2, r9, ror #24
   29170:	fa5f f3ba 	uxtb.w	r3, sl, ror #24
   29174:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   29178:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2917c:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   29180:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   29184:	ea84 6430 	eor.w	r4, r4, r0, ror #24
   29188:	ea85 6531 	eor.w	r5, r5, r1, ror #24
   2918c:	ea86 6632 	eor.w	r6, r6, r2, ror #24
   29190:	ea87 6733 	eor.w	r7, r7, r3, ror #24
   29194:	e8be 0f00 	ldmia.w	lr!, {r8, r9, sl, fp}
   29198:	b2e0      	uxtb	r0, r4
   2919a:	b2e9      	uxtb	r1, r5
   2919c:	b2f2      	uxtb	r2, r6
   2919e:	b2fb      	uxtb	r3, r7
   291a0:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   291a4:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   291a8:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   291ac:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   291b0:	ea88 4830 	eor.w	r8, r8, r0, ror #16
   291b4:	ea89 4931 	eor.w	r9, r9, r1, ror #16
   291b8:	ea8a 4a32 	eor.w	sl, sl, r2, ror #16
   291bc:	ea8b 4b33 	eor.w	fp, fp, r3, ror #16
   291c0:	fa5f f095 	uxtb.w	r0, r5, ror #8
   291c4:	fa5f f196 	uxtb.w	r1, r6, ror #8
   291c8:	fa5f f297 	uxtb.w	r2, r7, ror #8
   291cc:	fa5f f394 	uxtb.w	r3, r4, ror #8
   291d0:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   291d4:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   291d8:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   291dc:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   291e0:	ea88 2830 	eor.w	r8, r8, r0, ror #8
   291e4:	ea89 2931 	eor.w	r9, r9, r1, ror #8
   291e8:	ea8a 2a32 	eor.w	sl, sl, r2, ror #8
   291ec:	ea8b 2b33 	eor.w	fp, fp, r3, ror #8
   291f0:	fa5f f0a6 	uxtb.w	r0, r6, ror #16
   291f4:	fa5f f1a7 	uxtb.w	r1, r7, ror #16
   291f8:	fa5f f2a4 	uxtb.w	r2, r4, ror #16
   291fc:	fa5f f3a5 	uxtb.w	r3, r5, ror #16
   29200:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   29204:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   29208:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2920c:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   29210:	ea88 0800 	eor.w	r8, r8, r0
   29214:	ea89 0901 	eor.w	r9, r9, r1
   29218:	ea8a 0a02 	eor.w	sl, sl, r2
   2921c:	ea8b 0b03 	eor.w	fp, fp, r3
   29220:	fa5f f0b7 	uxtb.w	r0, r7, ror #24
   29224:	fa5f f1b4 	uxtb.w	r1, r4, ror #24
   29228:	fa5f f2b5 	uxtb.w	r2, r5, ror #24
   2922c:	fa5f f3b6 	uxtb.w	r3, r6, ror #24
   29230:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   29234:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   29238:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2923c:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   29240:	ea88 6830 	eor.w	r8, r8, r0, ror #24
   29244:	ea89 6931 	eor.w	r9, r9, r1, ror #24
   29248:	ea8a 6a32 	eor.w	sl, sl, r2, ror #24
   2924c:	ea8b 6b33 	eor.w	fp, fp, r3, ror #24
   29250:	e8be 00f0 	ldmia.w	lr!, {r4, r5, r6, r7}
   29254:	fa5f f088 	uxtb.w	r0, r8
   29258:	fa5f f189 	uxtb.w	r1, r9
   2925c:	fa5f f28a 	uxtb.w	r2, sl
   29260:	fa5f f38b 	uxtb.w	r3, fp
   29264:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   29268:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2926c:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   29270:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   29274:	ea84 4430 	eor.w	r4, r4, r0, ror #16
   29278:	ea85 4531 	eor.w	r5, r5, r1, ror #16
   2927c:	ea86 4632 	eor.w	r6, r6, r2, ror #16
   29280:	ea87 4733 	eor.w	r7, r7, r3, ror #16
   29284:	fa5f f099 	uxtb.w	r0, r9, ror #8
   29288:	fa5f f19a 	uxtb.w	r1, sl, ror #8
   2928c:	fa5f f29b 	uxtb.w	r2, fp, ror #8
   29290:	fa5f f398 	uxtb.w	r3, r8, ror #8
   29294:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   29298:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2929c:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   292a0:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   292a4:	ea84 2430 	eor.w	r4, r4, r0, ror #8
   292a8:	ea85 2531 	eor.w	r5, r5, r1, ror #8
   292ac:	ea86 2632 	eor.w	r6, r6, r2, ror #8
   292b0:	ea87 2733 	eor.w	r7, r7, r3, ror #8
   292b4:	fa5f f0aa 	uxtb.w	r0, sl, ror #16
   292b8:	fa5f f1ab 	uxtb.w	r1, fp, ror #16
   292bc:	fa5f f2a8 	uxtb.w	r2, r8, ror #16
   292c0:	fa5f f3a9 	uxtb.w	r3, r9, ror #16
   292c4:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   292c8:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   292cc:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   292d0:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   292d4:	ea84 0400 	eor.w	r4, r4, r0
   292d8:	ea85 0501 	eor.w	r5, r5, r1
   292dc:	ea86 0602 	eor.w	r6, r6, r2
   292e0:	ea87 0703 	eor.w	r7, r7, r3
   292e4:	fa5f f0bb 	uxtb.w	r0, fp, ror #24
   292e8:	fa5f f1b8 	uxtb.w	r1, r8, ror #24
   292ec:	fa5f f2b9 	uxtb.w	r2, r9, ror #24
   292f0:	fa5f f3ba 	uxtb.w	r3, sl, ror #24
   292f4:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   292f8:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   292fc:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   29300:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   29304:	ea84 6430 	eor.w	r4, r4, r0, ror #24
   29308:	ea85 6531 	eor.w	r5, r5, r1, ror #24
   2930c:	ea86 6632 	eor.w	r6, r6, r2, ror #24
   29310:	ea87 6733 	eor.w	r7, r7, r3, ror #24
   29314:	e8be 0f00 	ldmia.w	lr!, {r8, r9, sl, fp}
   29318:	b2e0      	uxtb	r0, r4
   2931a:	b2e9      	uxtb	r1, r5
   2931c:	b2f2      	uxtb	r2, r6
   2931e:	b2fb      	uxtb	r3, r7
   29320:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   29324:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   29328:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2932c:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   29330:	ea88 4830 	eor.w	r8, r8, r0, ror #16
   29334:	ea89 4931 	eor.w	r9, r9, r1, ror #16
   29338:	ea8a 4a32 	eor.w	sl, sl, r2, ror #16
   2933c:	ea8b 4b33 	eor.w	fp, fp, r3, ror #16
   29340:	fa5f f095 	uxtb.w	r0, r5, ror #8
   29344:	fa5f f196 	uxtb.w	r1, r6, ror #8
   29348:	fa5f f297 	uxtb.w	r2, r7, ror #8
   2934c:	fa5f f394 	uxtb.w	r3, r4, ror #8
   29350:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   29354:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   29358:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2935c:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   29360:	ea88 2830 	eor.w	r8, r8, r0, ror #8
   29364:	ea89 2931 	eor.w	r9, r9, r1, ror #8
   29368:	ea8a 2a32 	eor.w	sl, sl, r2, ror #8
   2936c:	ea8b 2b33 	eor.w	fp, fp, r3, ror #8
   29370:	fa5f f0a6 	uxtb.w	r0, r6, ror #16
   29374:	fa5f f1a7 	uxtb.w	r1, r7, ror #16
   29378:	fa5f f2a4 	uxtb.w	r2, r4, ror #16
   2937c:	fa5f f3a5 	uxtb.w	r3, r5, ror #16
   29380:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   29384:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   29388:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2938c:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   29390:	ea88 0800 	eor.w	r8, r8, r0
   29394:	ea89 0901 	eor.w	r9, r9, r1
   29398:	ea8a 0a02 	eor.w	sl, sl, r2
   2939c:	ea8b 0b03 	eor.w	fp, fp, r3
   293a0:	fa5f f0b7 	uxtb.w	r0, r7, ror #24
   293a4:	fa5f f1b4 	uxtb.w	r1, r4, ror #24
   293a8:	fa5f f2b5 	uxtb.w	r2, r5, ror #24
   293ac:	fa5f f3b6 	uxtb.w	r3, r6, ror #24
   293b0:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   293b4:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   293b8:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   293bc:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   293c0:	ea88 6830 	eor.w	r8, r8, r0, ror #24
   293c4:	ea89 6931 	eor.w	r9, r9, r1, ror #24
   293c8:	ea8a 6a32 	eor.w	sl, sl, r2, ror #24
   293cc:	ea8b 6b33 	eor.w	fp, fp, r3, ror #24
   293d0:	fa5f f0bb 	uxtb.w	r0, fp, ror #24
   293d4:	fa5f f1b8 	uxtb.w	r1, r8, ror #24
   293d8:	fa5f f2b9 	uxtb.w	r2, r9, ror #24
   293dc:	fa5f f3ba 	uxtb.w	r3, sl, ror #24
   293e0:	f85c 4020 	ldr.w	r4, [ip, r0, lsl #2]
   293e4:	f85c 5021 	ldr.w	r5, [ip, r1, lsl #2]
   293e8:	f85c 6022 	ldr.w	r6, [ip, r2, lsl #2]
   293ec:	f85c 7023 	ldr.w	r7, [ip, r3, lsl #2]
   293f0:	fa5f f0aa 	uxtb.w	r0, sl, ror #16
   293f4:	fa5f f1ab 	uxtb.w	r1, fp, ror #16
   293f8:	fa5f f2a8 	uxtb.w	r2, r8, ror #16
   293fc:	fa5f f3a9 	uxtb.w	r3, r9, ror #16
   29400:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   29404:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   29408:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2940c:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   29410:	f360 641f 	bfi	r4, r0, #24, #8
   29414:	f361 651f 	bfi	r5, r1, #24, #8
   29418:	f362 661f 	bfi	r6, r2, #24, #8
   2941c:	f363 671f 	bfi	r7, r3, #24, #8
   29420:	fa5f f088 	uxtb.w	r0, r8
   29424:	fa5f f189 	uxtb.w	r1, r9
   29428:	fa5f f28a 	uxtb.w	r2, sl
   2942c:	fa5f f38b 	uxtb.w	r3, fp
   29430:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   29434:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   29438:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2943c:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   29440:	f360 240f 	bfi	r4, r0, #8, #8
   29444:	f361 250f 	bfi	r5, r1, #8, #8
   29448:	f362 260f 	bfi	r6, r2, #8, #8
   2944c:	f363 270f 	bfi	r7, r3, #8, #8
   29450:	fa5f f099 	uxtb.w	r0, r9, ror #8
   29454:	fa5f f19a 	uxtb.w	r1, sl, ror #8
   29458:	fa5f f29b 	uxtb.w	r2, fp, ror #8
   2945c:	fa5f f398 	uxtb.w	r3, r8, ror #8
   29460:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   29464:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   29468:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2946c:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   29470:	f360 4417 	bfi	r4, r0, #16, #8
   29474:	f361 4517 	bfi	r5, r1, #16, #8
   29478:	f362 4617 	bfi	r6, r2, #16, #8
   2947c:	f363 4717 	bfi	r7, r3, #16, #8
   29480:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
   29484:	ea80 2034 	eor.w	r0, r0, r4, ror #8
   29488:	ea81 2135 	eor.w	r1, r1, r5, ror #8
   2948c:	ea82 2236 	eor.w	r2, r2, r6, ror #8
   29490:	f85d 4b04 	ldr.w	r4, [sp], #4
   29494:	ea83 2337 	eor.w	r3, r3, r7, ror #8
   29498:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
   2949c:	e8bd 5ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
   294a0:	4770      	bx	lr
   294a2:	46c0      	nop			; (mov r8, r8)
   294a4:	46c0      	nop			; (mov r8, r8)
   294a6:	46c0      	nop			; (mov r8, r8)
   294a8:	46c0      	nop			; (mov r8, r8)
   294aa:	46c0      	nop			; (mov r8, r8)
   294ac:	46c0      	nop			; (mov r8, r8)
   294ae:	46c0      	nop			; (mov r8, r8)

000294b0 <AES_Td0>:
   294b0:	50a7 f451 5365 417e c3a4 171a 965e 273a     .PQ.eS~A....^.:'
   294c0:	cb6b ab3b f145 9d1f ab58 faac 9303 e34b     k.;.E...X.....K.
   294d0:	55fa 3020 f66d 76ad 9176 cc88 254c 02f5     .U 0m..vv...L%..
   294e0:	fcd7 e54f d7cb 2ac5 8044 3526 8fa3 62b5     ..O....*D.&5...b
   294f0:	495a b1de 671b ba25 980e ea45 e1c0 fe5d     ZI...g%...E...].
   29500:	0275 2fc3 12f0 4c81 a397 468d c6f9 d36b     u../...L...F..k.
   29510:	e75f 8f03 959c 9215 eb7a 6dbf da59 5295     _.......z..mY..R
   29520:	2d83 bed4 d321 7458 2969 e049 44c8 c98e     .-..!.Xti)I..D..
   29530:	6a89 c275 7879 8ef4 6b3e 5899 dd71 b927     .ju.yx..>k.Xq.'.
   29540:	b64f e1be 17ad 88f0 66ac 20c9 b43a ce7d     O........f. :.}.
   29550:	184a df63 8231 1ae5 6033 5197 457f 5362     J.c.1...3`.Q.EbS
   29560:	e077 64b1 84ae 6bbb 1ca0 81fe 942b 08f9     w..d...k....+...
   29570:	5868 4870 19fd 458f 876c de94 b7f8 7b52     hXpH...El.....R{
   29580:	23d3 73ab e202 4b72 578f 1fe3 2aab 5566     .#.s..rK.W...*fU
   29590:	0728 ebb2 03c2 b52f 9a7b c586 a508 37d3     (...../.{......7
   295a0:	f287 2830 b2a5 bf23 ba6a 0302 5c82 16ed     ..0(..#.j....\..
   295b0:	2b1c cf8a 92b4 79a7 f0f2 07f3 a1e2 694e     .+.....y......Ni
   295c0:	cdf4 da65 d5be 0506 1f62 34d1 8afe a6c4     ..e.....b..4....
   295d0:	9d53 2e34 a055 f3a2 32e1 8a05 75eb f6a4     S.4.U....2...u..
   295e0:	39ec 830b aaef 6040 069f 715e 5110 6ebd     .9....@`..^q.Q.n
   295f0:	f98a 213e 3d06 dd96 ae05 3edd 46bd e64d     ..>!.=.....>.FM.
   29600:	b58d 5491 055d c471 6fd4 0604 ff15 5060     ...T].q..o....`P
   29610:	24fb 9819 97e9 bdd6 cc43 4089 779e d967     .$......C..@.wg.
   29620:	bd42 e8b0 888b 8907 385b 19e7 dbee c879     B.......[8....y.
   29630:	470a 7ca1 e90f 427c c91e 84f8 0000 0000     .G.|..|B........
   29640:	8386 8009 48ed 2b32 ac70 111e 4e72 5a6c     .....H2+p...rNlZ
   29650:	fbff 0efd 5638 850f 1ed5 ae3d 2739 2d36     ....8V....=.9'6-
   29660:	64d9 0f0a 21a6 5c68 d154 5b9b 3a2e 3624     .d...!h\T..[.:$6
   29670:	b167 0a0c 0fe7 5793 d296 eeb4 9e91 9b1b     g......W........
   29680:	4fc5 c080 a220 dc61 694b 775a 161a 121c     .O.. .a.KiZw....
   29690:	0aba 93e2 e52a a0c0 43e0 223c 1d17 1b12     ....*....C<"....
   296a0:	0b0d 090e adc7 8bf2 b9a8 b62d c8a9 1e14     ..........-.....
   296b0:	8519 f157 4c07 75af bbdd 99ee fd60 7fa3     ..W..L.u....`...
   296c0:	9f26 01f7 bcf5 725c c53b 6644 347e fb5b     &.....\r;.Df~4[.
   296d0:	7629 438b dcc6 23cb 68fc edb6 63f1 e4b8     )v.C...#.h...c..
   296e0:	cadc 31d7 1085 6342 4022 9713 2011 c684     ...1..Bc"@... ..
   296f0:	7d24 4a85 f83d bbd2 1132 f9ae 6da1 29c7     $}.J=...2....m.)
   29700:	4b2f 9e1d f330 b2dc ec52 860d d0e3 c177     /K..0...R.....w.
   29710:	6c16 b32b 99b9 70a9 fa48 9411 2264 e947     .l+....pH...d"G.
   29720:	c48c fca8 1a3f f0a0 d82c 7d56 ef90 3322     ....?...,.V}.."3
   29730:	c74e 4987 c1d1 38d9 fea2 ca8c 360b d498     N..I...8.....6..
   29740:	cf81 f5a6 28de 7aa5 268e b7da a4bf ad3f     .....(.z.&....?.
   29750:	e49d 3a2c 0d92 7850 9bcc 5f6a 6246 7e54     ..,:..Px..j_FbT~
   29760:	c213 8df6 e8b8 d890 5ef7 392e f5af c382     .........^.9....
   29770:	be80 5d9f 7c93 d069 a92d d56f b312 25cf     ...].|i.-.o....%
   29780:	3b99 acc8 a77d 1810 6e63 9ce8 7bbb 3bdb     .;..}...cn...{.;
   29790:	0978 26cd f418 596e 01b7 9aec a89a 4f83     x..&..nY.......O
   297a0:	656e 95e6 7ee6 ffaa 08cf bc21 e6e8 15ef     ne...~....!.....
   297b0:	d99b e7ba ce36 6f4a d409 9fea d67c b029     ....6.Jo....|.).
   297c0:	afb2 a431 3123 3f2a 3094 a5c6 c066 a235     ..1.#1*?.0..f.5.
   297d0:	37bc 4e74 a6ca 82fc b0d0 90e0 15d8 a733     .7tN..........3.
   297e0:	4a98 04f1 f7da ec41 0e50 cd7f 2ff6 9117     .J....A.P..../..
   297f0:	8dd6 4d76 4db0 ef43 544d aacc df04 96e4     ..vM.MC.MT......
   29800:	e3b5 d19e 1b88 6a4c b81f 2cc1 7f51 6546     ......Lj...,Q.Fe
   29810:	04ea 5e9d 5d35 8c01 7374 87fa 2e41 0bfb     ...^5]..ts..A...
   29820:	5a1d 67b3 52d2 db92 3356 10e9 1347 d66d     .Z.g.R..V3..G.m.
   29830:	8c61 d79a 7a0c a137 8e14 f859 893c 13eb     a....z7...Y.<...
   29840:	ee27 a9ce 35c9 61b7 ede5 1ce1 3cb1 477a     '....5.a.....<zG
   29850:	59df d29c 3f73 f255 79ce 1418 bf37 c773     .Y..s?U..y..7.s.
   29860:	eacd f753 5baa fd5f 146f 3ddf 86db 4478     ..S..[_.o..=..xD
   29870:	81f3 afca 3ec4 68b9 2c34 2438 5f40 a3c2     .....>.h4,8$@_..
   29880:	72c3 1d16 0c25 e2bc 8b49 3c28 4195 0dff     .r..%...I.(<.A..
   29890:	7101 a839 deb3 0c08 9ce4 b4d8 90c1 5664     .q9...........dV
   298a0:	6184 cb7b 70b6 32d5 745c 6c48 4257 b8d0     .a{..p.2\tHlWB..

000298b0 <AES_Td4>:
   298b0:	0052 0000 0009 0000 006a 0000 00d5 0000     R.......j.......
   298c0:	0030 0000 0036 0000 00a5 0000 0038 0000     0...6.......8...
   298d0:	00bf 0000 0040 0000 00a3 0000 009e 0000     ....@...........
   298e0:	0081 0000 00f3 0000 00d7 0000 00fb 0000     ................
   298f0:	007c 0000 00e3 0000 0039 0000 0082 0000     |.......9.......
   29900:	009b 0000 002f 0000 00ff 0000 0087 0000     ..../...........
   29910:	0034 0000 008e 0000 0043 0000 0044 0000     4.......C...D...
   29920:	00c4 0000 00de 0000 00e9 0000 00cb 0000     ................
   29930:	0054 0000 007b 0000 0094 0000 0032 0000     T...{.......2...
   29940:	00a6 0000 00c2 0000 0023 0000 003d 0000     ........#...=...
   29950:	00ee 0000 004c 0000 0095 0000 000b 0000     ....L...........
   29960:	0042 0000 00fa 0000 00c3 0000 004e 0000     B...........N...
   29970:	0008 0000 002e 0000 00a1 0000 0066 0000     ............f...
   29980:	0028 0000 00d9 0000 0024 0000 00b2 0000     (.......$.......
   29990:	0076 0000 005b 0000 00a2 0000 0049 0000     v...[.......I...
   299a0:	006d 0000 008b 0000 00d1 0000 0025 0000     m...........%...
   299b0:	0072 0000 00f8 0000 00f6 0000 0064 0000     r...........d...
   299c0:	0086 0000 0068 0000 0098 0000 0016 0000     ....h...........
   299d0:	00d4 0000 00a4 0000 005c 0000 00cc 0000     ........\.......
   299e0:	005d 0000 0065 0000 00b6 0000 0092 0000     ]...e...........
   299f0:	006c 0000 0070 0000 0048 0000 0050 0000     l...p...H...P...
   29a00:	00fd 0000 00ed 0000 00b9 0000 00da 0000     ................
   29a10:	005e 0000 0015 0000 0046 0000 0057 0000     ^.......F...W...
   29a20:	00a7 0000 008d 0000 009d 0000 0084 0000     ................
   29a30:	0090 0000 00d8 0000 00ab 0000 0000 0000     ................
   29a40:	008c 0000 00bc 0000 00d3 0000 000a 0000     ................
   29a50:	00f7 0000 00e4 0000 0058 0000 0005 0000     ........X.......
   29a60:	00b8 0000 00b3 0000 0045 0000 0006 0000     ........E.......
   29a70:	00d0 0000 002c 0000 001e 0000 008f 0000     ....,...........
   29a80:	00ca 0000 003f 0000 000f 0000 0002 0000     ....?...........
   29a90:	00c1 0000 00af 0000 00bd 0000 0003 0000     ................
   29aa0:	0001 0000 0013 0000 008a 0000 006b 0000     ............k...
   29ab0:	003a 0000 0091 0000 0011 0000 0041 0000     :...........A...
   29ac0:	004f 0000 0067 0000 00dc 0000 00ea 0000     O...g...........
   29ad0:	0097 0000 00f2 0000 00cf 0000 00ce 0000     ................
   29ae0:	00f0 0000 00b4 0000 00e6 0000 0073 0000     ............s...
   29af0:	0096 0000 00ac 0000 0074 0000 0022 0000     ........t..."...
   29b00:	00e7 0000 00ad 0000 0035 0000 0085 0000     ........5.......
   29b10:	00e2 0000 00f9 0000 0037 0000 00e8 0000     ........7.......
   29b20:	001c 0000 0075 0000 00df 0000 006e 0000     ....u.......n...
   29b30:	0047 0000 00f1 0000 001a 0000 0071 0000     G...........q...
   29b40:	001d 0000 0029 0000 00c5 0000 0089 0000     ....)...........
   29b50:	006f 0000 00b7 0000 0062 0000 000e 0000     o.......b.......
   29b60:	00aa 0000 0018 0000 00be 0000 001b 0000     ................
   29b70:	00fc 0000 0056 0000 003e 0000 004b 0000     ....V...>...K...
   29b80:	00c6 0000 00d2 0000 0079 0000 0020 0000     ........y... ...
   29b90:	009a 0000 00db 0000 00c0 0000 00fe 0000     ................
   29ba0:	0078 0000 00cd 0000 005a 0000 00f4 0000     x.......Z.......
   29bb0:	001f 0000 00dd 0000 00a8 0000 0033 0000     ............3...
   29bc0:	0088 0000 0007 0000 00c7 0000 0031 0000     ............1...
   29bd0:	00b1 0000 0012 0000 0010 0000 0059 0000     ............Y...
   29be0:	0027 0000 0080 0000 00ec 0000 005f 0000     '..........._...
   29bf0:	0060 0000 0051 0000 007f 0000 00a9 0000     `...Q...........
   29c00:	0019 0000 00b5 0000 004a 0000 000d 0000     ........J.......
   29c10:	002d 0000 00e5 0000 007a 0000 009f 0000     -.......z.......
   29c20:	0093 0000 00c9 0000 009c 0000 00ef 0000     ................
   29c30:	00a0 0000 00e0 0000 003b 0000 004d 0000     ........;...M...
   29c40:	00ae 0000 002a 0000 00f5 0000 00b0 0000     ....*...........
   29c50:	00c8 0000 00eb 0000 00bb 0000 003c 0000     ............<...
   29c60:	0083 0000 0053 0000 0099 0000 0061 0000     ....S.......a...
   29c70:	0017 0000 002b 0000 0004 0000 007e 0000     ....+.......~...
   29c80:	00ba 0000 0077 0000 00d6 0000 0026 0000     ....w.......&...
   29c90:	00e1 0000 0069 0000 0014 0000 0063 0000     ....i.......c...
   29ca0:	0055 0000 0021 0000 000c 0000 007d 0000     U...!.......}...

00029cb0 <AES_128_keyschedule_dec>:
   29cb0:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
   29cb4:	e890 00f0 	ldmia.w	r0, {r4, r5, r6, r7}
   29cb8:	f6af 020c 	subw	r2, pc, #2060	; 0x80c
   29cbc:	f8df 3e4c 	ldr.w	r3, [pc, #3660]	; 2ab0c <AES_128_keyschedule_dec+0xe5c>
   29cc0:	fa5f f897 	uxtb.w	r8, r7, ror #8
   29cc4:	fa5f f9a7 	uxtb.w	r9, r7, ror #16
   29cc8:	fa5f fab7 	uxtb.w	sl, r7, ror #24
   29ccc:	fa5f fb87 	uxtb.w	fp, r7
   29cd0:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   29cd4:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   29cd8:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   29cdc:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   29ce0:	f008 08ff 	and.w	r8, r8, #255	; 0xff
   29ce4:	f009 09ff 	and.w	r9, r9, #255	; 0xff
   29ce8:	f00a 0aff 	and.w	sl, sl, #255	; 0xff
   29cec:	f084 0401 	eor.w	r4, r4, #1
   29cf0:	ea84 0408 	eor.w	r4, r4, r8
   29cf4:	ea84 2409 	eor.w	r4, r4, r9, lsl #8
   29cf8:	ea84 440a 	eor.w	r4, r4, sl, lsl #16
   29cfc:	ea84 640b 	eor.w	r4, r4, fp, lsl #24
   29d00:	ea85 0504 	eor.w	r5, r5, r4
   29d04:	ea86 0605 	eor.w	r6, r6, r5
   29d08:	ea87 0706 	eor.w	r7, r7, r6
   29d0c:	e92d 00f0 	stmdb	sp!, {r4, r5, r6, r7}
   29d10:	fa5f f897 	uxtb.w	r8, r7, ror #8
   29d14:	fa5f f9a7 	uxtb.w	r9, r7, ror #16
   29d18:	fa5f fab7 	uxtb.w	sl, r7, ror #24
   29d1c:	fa5f fb87 	uxtb.w	fp, r7
   29d20:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   29d24:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   29d28:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   29d2c:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   29d30:	f008 08ff 	and.w	r8, r8, #255	; 0xff
   29d34:	f009 09ff 	and.w	r9, r9, #255	; 0xff
   29d38:	f00a 0aff 	and.w	sl, sl, #255	; 0xff
   29d3c:	f084 0402 	eor.w	r4, r4, #2
   29d40:	ea84 0408 	eor.w	r4, r4, r8
   29d44:	ea84 2409 	eor.w	r4, r4, r9, lsl #8
   29d48:	ea84 440a 	eor.w	r4, r4, sl, lsl #16
   29d4c:	ea84 640b 	eor.w	r4, r4, fp, lsl #24
   29d50:	ea85 0504 	eor.w	r5, r5, r4
   29d54:	ea86 0605 	eor.w	r6, r6, r5
   29d58:	ea87 0706 	eor.w	r7, r7, r6
   29d5c:	e92d 00f0 	stmdb	sp!, {r4, r5, r6, r7}
   29d60:	fa5f f897 	uxtb.w	r8, r7, ror #8
   29d64:	fa5f f9a7 	uxtb.w	r9, r7, ror #16
   29d68:	fa5f fab7 	uxtb.w	sl, r7, ror #24
   29d6c:	fa5f fb87 	uxtb.w	fp, r7
   29d70:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   29d74:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   29d78:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   29d7c:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   29d80:	f008 08ff 	and.w	r8, r8, #255	; 0xff
   29d84:	f009 09ff 	and.w	r9, r9, #255	; 0xff
   29d88:	f00a 0aff 	and.w	sl, sl, #255	; 0xff
   29d8c:	f084 0404 	eor.w	r4, r4, #4
   29d90:	ea84 0408 	eor.w	r4, r4, r8
   29d94:	ea84 2409 	eor.w	r4, r4, r9, lsl #8
   29d98:	ea84 440a 	eor.w	r4, r4, sl, lsl #16
   29d9c:	ea84 640b 	eor.w	r4, r4, fp, lsl #24
   29da0:	ea85 0504 	eor.w	r5, r5, r4
   29da4:	ea86 0605 	eor.w	r6, r6, r5
   29da8:	ea87 0706 	eor.w	r7, r7, r6
   29dac:	e92d 00f0 	stmdb	sp!, {r4, r5, r6, r7}
   29db0:	fa5f f897 	uxtb.w	r8, r7, ror #8
   29db4:	fa5f f9a7 	uxtb.w	r9, r7, ror #16
   29db8:	fa5f fab7 	uxtb.w	sl, r7, ror #24
   29dbc:	fa5f fb87 	uxtb.w	fp, r7
   29dc0:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   29dc4:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   29dc8:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   29dcc:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   29dd0:	f008 08ff 	and.w	r8, r8, #255	; 0xff
   29dd4:	f009 09ff 	and.w	r9, r9, #255	; 0xff
   29dd8:	f00a 0aff 	and.w	sl, sl, #255	; 0xff
   29ddc:	f084 0408 	eor.w	r4, r4, #8
   29de0:	ea84 0408 	eor.w	r4, r4, r8
   29de4:	ea84 2409 	eor.w	r4, r4, r9, lsl #8
   29de8:	ea84 440a 	eor.w	r4, r4, sl, lsl #16
   29dec:	ea84 640b 	eor.w	r4, r4, fp, lsl #24
   29df0:	ea85 0504 	eor.w	r5, r5, r4
   29df4:	ea86 0605 	eor.w	r6, r6, r5
   29df8:	ea87 0706 	eor.w	r7, r7, r6
   29dfc:	e92d 00f0 	stmdb	sp!, {r4, r5, r6, r7}
   29e00:	fa5f f897 	uxtb.w	r8, r7, ror #8
   29e04:	fa5f f9a7 	uxtb.w	r9, r7, ror #16
   29e08:	fa5f fab7 	uxtb.w	sl, r7, ror #24
   29e0c:	fa5f fb87 	uxtb.w	fp, r7
   29e10:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   29e14:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   29e18:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   29e1c:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   29e20:	f008 08ff 	and.w	r8, r8, #255	; 0xff
   29e24:	f009 09ff 	and.w	r9, r9, #255	; 0xff
   29e28:	f00a 0aff 	and.w	sl, sl, #255	; 0xff
   29e2c:	f084 0410 	eor.w	r4, r4, #16
   29e30:	ea84 0408 	eor.w	r4, r4, r8
   29e34:	ea84 2409 	eor.w	r4, r4, r9, lsl #8
   29e38:	ea84 440a 	eor.w	r4, r4, sl, lsl #16
   29e3c:	ea84 640b 	eor.w	r4, r4, fp, lsl #24
   29e40:	ea85 0504 	eor.w	r5, r5, r4
   29e44:	ea86 0605 	eor.w	r6, r6, r5
   29e48:	ea87 0706 	eor.w	r7, r7, r6
   29e4c:	e92d 00f0 	stmdb	sp!, {r4, r5, r6, r7}
   29e50:	fa5f f897 	uxtb.w	r8, r7, ror #8
   29e54:	fa5f f9a7 	uxtb.w	r9, r7, ror #16
   29e58:	fa5f fab7 	uxtb.w	sl, r7, ror #24
   29e5c:	fa5f fb87 	uxtb.w	fp, r7
   29e60:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   29e64:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   29e68:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   29e6c:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   29e70:	f008 08ff 	and.w	r8, r8, #255	; 0xff
   29e74:	f009 09ff 	and.w	r9, r9, #255	; 0xff
   29e78:	f00a 0aff 	and.w	sl, sl, #255	; 0xff
   29e7c:	f084 0420 	eor.w	r4, r4, #32
   29e80:	ea84 0408 	eor.w	r4, r4, r8
   29e84:	ea84 2409 	eor.w	r4, r4, r9, lsl #8
   29e88:	ea84 440a 	eor.w	r4, r4, sl, lsl #16
   29e8c:	ea84 640b 	eor.w	r4, r4, fp, lsl #24
   29e90:	ea85 0504 	eor.w	r5, r5, r4
   29e94:	ea86 0605 	eor.w	r6, r6, r5
   29e98:	ea87 0706 	eor.w	r7, r7, r6
   29e9c:	e92d 00f0 	stmdb	sp!, {r4, r5, r6, r7}
   29ea0:	fa5f f897 	uxtb.w	r8, r7, ror #8
   29ea4:	fa5f f9a7 	uxtb.w	r9, r7, ror #16
   29ea8:	fa5f fab7 	uxtb.w	sl, r7, ror #24
   29eac:	fa5f fb87 	uxtb.w	fp, r7
   29eb0:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   29eb4:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   29eb8:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   29ebc:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   29ec0:	f008 08ff 	and.w	r8, r8, #255	; 0xff
   29ec4:	f009 09ff 	and.w	r9, r9, #255	; 0xff
   29ec8:	f00a 0aff 	and.w	sl, sl, #255	; 0xff
   29ecc:	f084 0440 	eor.w	r4, r4, #64	; 0x40
   29ed0:	ea84 0408 	eor.w	r4, r4, r8
   29ed4:	ea84 2409 	eor.w	r4, r4, r9, lsl #8
   29ed8:	ea84 440a 	eor.w	r4, r4, sl, lsl #16
   29edc:	ea84 640b 	eor.w	r4, r4, fp, lsl #24
   29ee0:	ea85 0504 	eor.w	r5, r5, r4
   29ee4:	ea86 0605 	eor.w	r6, r6, r5
   29ee8:	ea87 0706 	eor.w	r7, r7, r6
   29eec:	e92d 00f0 	stmdb	sp!, {r4, r5, r6, r7}
   29ef0:	fa5f f897 	uxtb.w	r8, r7, ror #8
   29ef4:	fa5f f9a7 	uxtb.w	r9, r7, ror #16
   29ef8:	fa5f fab7 	uxtb.w	sl, r7, ror #24
   29efc:	fa5f fb87 	uxtb.w	fp, r7
   29f00:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   29f04:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   29f08:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   29f0c:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   29f10:	f008 08ff 	and.w	r8, r8, #255	; 0xff
   29f14:	f009 09ff 	and.w	r9, r9, #255	; 0xff
   29f18:	f00a 0aff 	and.w	sl, sl, #255	; 0xff
   29f1c:	f084 0480 	eor.w	r4, r4, #128	; 0x80
   29f20:	ea84 0408 	eor.w	r4, r4, r8
   29f24:	ea84 2409 	eor.w	r4, r4, r9, lsl #8
   29f28:	ea84 440a 	eor.w	r4, r4, sl, lsl #16
   29f2c:	ea84 640b 	eor.w	r4, r4, fp, lsl #24
   29f30:	ea85 0504 	eor.w	r5, r5, r4
   29f34:	ea86 0605 	eor.w	r6, r6, r5
   29f38:	ea87 0706 	eor.w	r7, r7, r6
   29f3c:	e92d 00f0 	stmdb	sp!, {r4, r5, r6, r7}
   29f40:	fa5f f897 	uxtb.w	r8, r7, ror #8
   29f44:	fa5f f9a7 	uxtb.w	r9, r7, ror #16
   29f48:	fa5f fab7 	uxtb.w	sl, r7, ror #24
   29f4c:	fa5f fb87 	uxtb.w	fp, r7
   29f50:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   29f54:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   29f58:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   29f5c:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   29f60:	f008 08ff 	and.w	r8, r8, #255	; 0xff
   29f64:	f009 09ff 	and.w	r9, r9, #255	; 0xff
   29f68:	f00a 0aff 	and.w	sl, sl, #255	; 0xff
   29f6c:	f084 041b 	eor.w	r4, r4, #27
   29f70:	ea84 0408 	eor.w	r4, r4, r8
   29f74:	ea84 2409 	eor.w	r4, r4, r9, lsl #8
   29f78:	ea84 440a 	eor.w	r4, r4, sl, lsl #16
   29f7c:	ea84 640b 	eor.w	r4, r4, fp, lsl #24
   29f80:	ea85 0504 	eor.w	r5, r5, r4
   29f84:	ea86 0605 	eor.w	r6, r6, r5
   29f88:	ea87 0706 	eor.w	r7, r7, r6
   29f8c:	e92d 00f0 	stmdb	sp!, {r4, r5, r6, r7}
   29f90:	fa5f f897 	uxtb.w	r8, r7, ror #8
   29f94:	fa5f f9a7 	uxtb.w	r9, r7, ror #16
   29f98:	fa5f fab7 	uxtb.w	sl, r7, ror #24
   29f9c:	fa5f fb87 	uxtb.w	fp, r7
   29fa0:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   29fa4:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   29fa8:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   29fac:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   29fb0:	f008 08ff 	and.w	r8, r8, #255	; 0xff
   29fb4:	f009 09ff 	and.w	r9, r9, #255	; 0xff
   29fb8:	f00a 0aff 	and.w	sl, sl, #255	; 0xff
   29fbc:	f084 0436 	eor.w	r4, r4, #54	; 0x36
   29fc0:	ea84 0408 	eor.w	r4, r4, r8
   29fc4:	ea84 2409 	eor.w	r4, r4, r9, lsl #8
   29fc8:	ea84 440a 	eor.w	r4, r4, sl, lsl #16
   29fcc:	ea84 640b 	eor.w	r4, r4, fp, lsl #24
   29fd0:	ea85 0504 	eor.w	r5, r5, r4
   29fd4:	ea86 0605 	eor.w	r6, r6, r5
   29fd8:	ea87 0706 	eor.w	r7, r7, r6
   29fdc:	600c      	str	r4, [r1, #0]
   29fde:	604d      	str	r5, [r1, #4]
   29fe0:	608e      	str	r6, [r1, #8]
   29fe2:	60cf      	str	r7, [r1, #12]
   29fe4:	e8bd 00f0 	ldmia.w	sp!, {r4, r5, r6, r7}
   29fe8:	fa5f f894 	uxtb.w	r8, r4, ror #8
   29fec:	fa5f f9a4 	uxtb.w	r9, r4, ror #16
   29ff0:	fa5f fab4 	uxtb.w	sl, r4, ror #24
   29ff4:	fa5f fb84 	uxtb.w	fp, r4
   29ff8:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   29ffc:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a000:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a004:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a008:	fa5f f888 	uxtb.w	r8, r8
   2a00c:	fa5f f989 	uxtb.w	r9, r9
   2a010:	fa5f fa8a 	uxtb.w	sl, sl
   2a014:	fa5f fb8b 	uxtb.w	fp, fp
   2a018:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a01c:	f852 4029 	ldr.w	r4, [r2, r9, lsl #2]
   2a020:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a024:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a028:	ea84 643a 	eor.w	r4, r4, sl, ror #24
   2a02c:	ea84 443b 	eor.w	r4, r4, fp, ror #16
   2a030:	ea84 2438 	eor.w	r4, r4, r8, ror #8
   2a034:	fa5f f895 	uxtb.w	r8, r5, ror #8
   2a038:	fa5f f9a5 	uxtb.w	r9, r5, ror #16
   2a03c:	fa5f fab5 	uxtb.w	sl, r5, ror #24
   2a040:	fa5f fb85 	uxtb.w	fp, r5
   2a044:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a048:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a04c:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a050:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a054:	fa5f f888 	uxtb.w	r8, r8
   2a058:	fa5f f989 	uxtb.w	r9, r9
   2a05c:	fa5f fa8a 	uxtb.w	sl, sl
   2a060:	fa5f fb8b 	uxtb.w	fp, fp
   2a064:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a068:	f852 5029 	ldr.w	r5, [r2, r9, lsl #2]
   2a06c:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a070:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a074:	ea85 653a 	eor.w	r5, r5, sl, ror #24
   2a078:	ea85 453b 	eor.w	r5, r5, fp, ror #16
   2a07c:	ea85 2538 	eor.w	r5, r5, r8, ror #8
   2a080:	fa5f f896 	uxtb.w	r8, r6, ror #8
   2a084:	fa5f f9a6 	uxtb.w	r9, r6, ror #16
   2a088:	fa5f fab6 	uxtb.w	sl, r6, ror #24
   2a08c:	fa5f fb86 	uxtb.w	fp, r6
   2a090:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a094:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a098:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a09c:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a0a0:	fa5f f888 	uxtb.w	r8, r8
   2a0a4:	fa5f f989 	uxtb.w	r9, r9
   2a0a8:	fa5f fa8a 	uxtb.w	sl, sl
   2a0ac:	fa5f fb8b 	uxtb.w	fp, fp
   2a0b0:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a0b4:	f852 6029 	ldr.w	r6, [r2, r9, lsl #2]
   2a0b8:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a0bc:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a0c0:	ea86 663a 	eor.w	r6, r6, sl, ror #24
   2a0c4:	ea86 463b 	eor.w	r6, r6, fp, ror #16
   2a0c8:	ea86 2638 	eor.w	r6, r6, r8, ror #8
   2a0cc:	fa5f f897 	uxtb.w	r8, r7, ror #8
   2a0d0:	fa5f f9a7 	uxtb.w	r9, r7, ror #16
   2a0d4:	fa5f fab7 	uxtb.w	sl, r7, ror #24
   2a0d8:	fa5f fb87 	uxtb.w	fp, r7
   2a0dc:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a0e0:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a0e4:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a0e8:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a0ec:	fa5f f888 	uxtb.w	r8, r8
   2a0f0:	fa5f f989 	uxtb.w	r9, r9
   2a0f4:	fa5f fa8a 	uxtb.w	sl, sl
   2a0f8:	fa5f fb8b 	uxtb.w	fp, fp
   2a0fc:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a100:	f852 7029 	ldr.w	r7, [r2, r9, lsl #2]
   2a104:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a108:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a10c:	ea87 673a 	eor.w	r7, r7, sl, ror #24
   2a110:	ea87 473b 	eor.w	r7, r7, fp, ror #16
   2a114:	ea87 2738 	eor.w	r7, r7, r8, ror #8
   2a118:	610c      	str	r4, [r1, #16]
   2a11a:	614d      	str	r5, [r1, #20]
   2a11c:	618e      	str	r6, [r1, #24]
   2a11e:	61cf      	str	r7, [r1, #28]
   2a120:	e8bd 00f0 	ldmia.w	sp!, {r4, r5, r6, r7}
   2a124:	fa5f f894 	uxtb.w	r8, r4, ror #8
   2a128:	fa5f f9a4 	uxtb.w	r9, r4, ror #16
   2a12c:	fa5f fab4 	uxtb.w	sl, r4, ror #24
   2a130:	fa5f fb84 	uxtb.w	fp, r4
   2a134:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a138:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a13c:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a140:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a144:	fa5f f888 	uxtb.w	r8, r8
   2a148:	fa5f f989 	uxtb.w	r9, r9
   2a14c:	fa5f fa8a 	uxtb.w	sl, sl
   2a150:	fa5f fb8b 	uxtb.w	fp, fp
   2a154:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a158:	f852 4029 	ldr.w	r4, [r2, r9, lsl #2]
   2a15c:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a160:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a164:	ea84 643a 	eor.w	r4, r4, sl, ror #24
   2a168:	ea84 443b 	eor.w	r4, r4, fp, ror #16
   2a16c:	ea84 2438 	eor.w	r4, r4, r8, ror #8
   2a170:	fa5f f895 	uxtb.w	r8, r5, ror #8
   2a174:	fa5f f9a5 	uxtb.w	r9, r5, ror #16
   2a178:	fa5f fab5 	uxtb.w	sl, r5, ror #24
   2a17c:	fa5f fb85 	uxtb.w	fp, r5
   2a180:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a184:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a188:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a18c:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a190:	fa5f f888 	uxtb.w	r8, r8
   2a194:	fa5f f989 	uxtb.w	r9, r9
   2a198:	fa5f fa8a 	uxtb.w	sl, sl
   2a19c:	fa5f fb8b 	uxtb.w	fp, fp
   2a1a0:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a1a4:	f852 5029 	ldr.w	r5, [r2, r9, lsl #2]
   2a1a8:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a1ac:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a1b0:	ea85 653a 	eor.w	r5, r5, sl, ror #24
   2a1b4:	ea85 453b 	eor.w	r5, r5, fp, ror #16
   2a1b8:	ea85 2538 	eor.w	r5, r5, r8, ror #8
   2a1bc:	fa5f f896 	uxtb.w	r8, r6, ror #8
   2a1c0:	fa5f f9a6 	uxtb.w	r9, r6, ror #16
   2a1c4:	fa5f fab6 	uxtb.w	sl, r6, ror #24
   2a1c8:	fa5f fb86 	uxtb.w	fp, r6
   2a1cc:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a1d0:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a1d4:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a1d8:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a1dc:	fa5f f888 	uxtb.w	r8, r8
   2a1e0:	fa5f f989 	uxtb.w	r9, r9
   2a1e4:	fa5f fa8a 	uxtb.w	sl, sl
   2a1e8:	fa5f fb8b 	uxtb.w	fp, fp
   2a1ec:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a1f0:	f852 6029 	ldr.w	r6, [r2, r9, lsl #2]
   2a1f4:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a1f8:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a1fc:	ea86 663a 	eor.w	r6, r6, sl, ror #24
   2a200:	ea86 463b 	eor.w	r6, r6, fp, ror #16
   2a204:	ea86 2638 	eor.w	r6, r6, r8, ror #8
   2a208:	fa5f f897 	uxtb.w	r8, r7, ror #8
   2a20c:	fa5f f9a7 	uxtb.w	r9, r7, ror #16
   2a210:	fa5f fab7 	uxtb.w	sl, r7, ror #24
   2a214:	fa5f fb87 	uxtb.w	fp, r7
   2a218:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a21c:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a220:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a224:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a228:	fa5f f888 	uxtb.w	r8, r8
   2a22c:	fa5f f989 	uxtb.w	r9, r9
   2a230:	fa5f fa8a 	uxtb.w	sl, sl
   2a234:	fa5f fb8b 	uxtb.w	fp, fp
   2a238:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a23c:	f852 7029 	ldr.w	r7, [r2, r9, lsl #2]
   2a240:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a244:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a248:	ea87 673a 	eor.w	r7, r7, sl, ror #24
   2a24c:	ea87 473b 	eor.w	r7, r7, fp, ror #16
   2a250:	ea87 2738 	eor.w	r7, r7, r8, ror #8
   2a254:	620c      	str	r4, [r1, #32]
   2a256:	624d      	str	r5, [r1, #36]	; 0x24
   2a258:	628e      	str	r6, [r1, #40]	; 0x28
   2a25a:	62cf      	str	r7, [r1, #44]	; 0x2c
   2a25c:	e8bd 00f0 	ldmia.w	sp!, {r4, r5, r6, r7}
   2a260:	fa5f f894 	uxtb.w	r8, r4, ror #8
   2a264:	fa5f f9a4 	uxtb.w	r9, r4, ror #16
   2a268:	fa5f fab4 	uxtb.w	sl, r4, ror #24
   2a26c:	fa5f fb84 	uxtb.w	fp, r4
   2a270:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a274:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a278:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a27c:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a280:	fa5f f888 	uxtb.w	r8, r8
   2a284:	fa5f f989 	uxtb.w	r9, r9
   2a288:	fa5f fa8a 	uxtb.w	sl, sl
   2a28c:	fa5f fb8b 	uxtb.w	fp, fp
   2a290:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a294:	f852 4029 	ldr.w	r4, [r2, r9, lsl #2]
   2a298:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a29c:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a2a0:	ea84 643a 	eor.w	r4, r4, sl, ror #24
   2a2a4:	ea84 443b 	eor.w	r4, r4, fp, ror #16
   2a2a8:	ea84 2438 	eor.w	r4, r4, r8, ror #8
   2a2ac:	fa5f f895 	uxtb.w	r8, r5, ror #8
   2a2b0:	fa5f f9a5 	uxtb.w	r9, r5, ror #16
   2a2b4:	fa5f fab5 	uxtb.w	sl, r5, ror #24
   2a2b8:	fa5f fb85 	uxtb.w	fp, r5
   2a2bc:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a2c0:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a2c4:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a2c8:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a2cc:	fa5f f888 	uxtb.w	r8, r8
   2a2d0:	fa5f f989 	uxtb.w	r9, r9
   2a2d4:	fa5f fa8a 	uxtb.w	sl, sl
   2a2d8:	fa5f fb8b 	uxtb.w	fp, fp
   2a2dc:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a2e0:	f852 5029 	ldr.w	r5, [r2, r9, lsl #2]
   2a2e4:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a2e8:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a2ec:	ea85 653a 	eor.w	r5, r5, sl, ror #24
   2a2f0:	ea85 453b 	eor.w	r5, r5, fp, ror #16
   2a2f4:	ea85 2538 	eor.w	r5, r5, r8, ror #8
   2a2f8:	fa5f f896 	uxtb.w	r8, r6, ror #8
   2a2fc:	fa5f f9a6 	uxtb.w	r9, r6, ror #16
   2a300:	fa5f fab6 	uxtb.w	sl, r6, ror #24
   2a304:	fa5f fb86 	uxtb.w	fp, r6
   2a308:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a30c:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a310:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a314:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a318:	fa5f f888 	uxtb.w	r8, r8
   2a31c:	fa5f f989 	uxtb.w	r9, r9
   2a320:	fa5f fa8a 	uxtb.w	sl, sl
   2a324:	fa5f fb8b 	uxtb.w	fp, fp
   2a328:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a32c:	f852 6029 	ldr.w	r6, [r2, r9, lsl #2]
   2a330:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a334:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a338:	ea86 663a 	eor.w	r6, r6, sl, ror #24
   2a33c:	ea86 463b 	eor.w	r6, r6, fp, ror #16
   2a340:	ea86 2638 	eor.w	r6, r6, r8, ror #8
   2a344:	fa5f f897 	uxtb.w	r8, r7, ror #8
   2a348:	fa5f f9a7 	uxtb.w	r9, r7, ror #16
   2a34c:	fa5f fab7 	uxtb.w	sl, r7, ror #24
   2a350:	fa5f fb87 	uxtb.w	fp, r7
   2a354:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a358:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a35c:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a360:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a364:	fa5f f888 	uxtb.w	r8, r8
   2a368:	fa5f f989 	uxtb.w	r9, r9
   2a36c:	fa5f fa8a 	uxtb.w	sl, sl
   2a370:	fa5f fb8b 	uxtb.w	fp, fp
   2a374:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a378:	f852 7029 	ldr.w	r7, [r2, r9, lsl #2]
   2a37c:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a380:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a384:	ea87 673a 	eor.w	r7, r7, sl, ror #24
   2a388:	ea87 473b 	eor.w	r7, r7, fp, ror #16
   2a38c:	ea87 2738 	eor.w	r7, r7, r8, ror #8
   2a390:	630c      	str	r4, [r1, #48]	; 0x30
   2a392:	634d      	str	r5, [r1, #52]	; 0x34
   2a394:	638e      	str	r6, [r1, #56]	; 0x38
   2a396:	63cf      	str	r7, [r1, #60]	; 0x3c
   2a398:	e8bd 00f0 	ldmia.w	sp!, {r4, r5, r6, r7}
   2a39c:	fa5f f894 	uxtb.w	r8, r4, ror #8
   2a3a0:	fa5f f9a4 	uxtb.w	r9, r4, ror #16
   2a3a4:	fa5f fab4 	uxtb.w	sl, r4, ror #24
   2a3a8:	fa5f fb84 	uxtb.w	fp, r4
   2a3ac:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a3b0:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a3b4:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a3b8:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a3bc:	fa5f f888 	uxtb.w	r8, r8
   2a3c0:	fa5f f989 	uxtb.w	r9, r9
   2a3c4:	fa5f fa8a 	uxtb.w	sl, sl
   2a3c8:	fa5f fb8b 	uxtb.w	fp, fp
   2a3cc:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a3d0:	f852 4029 	ldr.w	r4, [r2, r9, lsl #2]
   2a3d4:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a3d8:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a3dc:	ea84 643a 	eor.w	r4, r4, sl, ror #24
   2a3e0:	ea84 443b 	eor.w	r4, r4, fp, ror #16
   2a3e4:	ea84 2438 	eor.w	r4, r4, r8, ror #8
   2a3e8:	fa5f f895 	uxtb.w	r8, r5, ror #8
   2a3ec:	fa5f f9a5 	uxtb.w	r9, r5, ror #16
   2a3f0:	fa5f fab5 	uxtb.w	sl, r5, ror #24
   2a3f4:	fa5f fb85 	uxtb.w	fp, r5
   2a3f8:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a3fc:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a400:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a404:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a408:	fa5f f888 	uxtb.w	r8, r8
   2a40c:	fa5f f989 	uxtb.w	r9, r9
   2a410:	fa5f fa8a 	uxtb.w	sl, sl
   2a414:	fa5f fb8b 	uxtb.w	fp, fp
   2a418:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a41c:	f852 5029 	ldr.w	r5, [r2, r9, lsl #2]
   2a420:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a424:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a428:	ea85 653a 	eor.w	r5, r5, sl, ror #24
   2a42c:	ea85 453b 	eor.w	r5, r5, fp, ror #16
   2a430:	ea85 2538 	eor.w	r5, r5, r8, ror #8
   2a434:	fa5f f896 	uxtb.w	r8, r6, ror #8
   2a438:	fa5f f9a6 	uxtb.w	r9, r6, ror #16
   2a43c:	fa5f fab6 	uxtb.w	sl, r6, ror #24
   2a440:	fa5f fb86 	uxtb.w	fp, r6
   2a444:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a448:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a44c:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a450:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a454:	fa5f f888 	uxtb.w	r8, r8
   2a458:	fa5f f989 	uxtb.w	r9, r9
   2a45c:	fa5f fa8a 	uxtb.w	sl, sl
   2a460:	fa5f fb8b 	uxtb.w	fp, fp
   2a464:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a468:	f852 6029 	ldr.w	r6, [r2, r9, lsl #2]
   2a46c:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a470:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a474:	ea86 663a 	eor.w	r6, r6, sl, ror #24
   2a478:	ea86 463b 	eor.w	r6, r6, fp, ror #16
   2a47c:	ea86 2638 	eor.w	r6, r6, r8, ror #8
   2a480:	fa5f f897 	uxtb.w	r8, r7, ror #8
   2a484:	fa5f f9a7 	uxtb.w	r9, r7, ror #16
   2a488:	fa5f fab7 	uxtb.w	sl, r7, ror #24
   2a48c:	fa5f fb87 	uxtb.w	fp, r7
   2a490:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a494:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a498:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a49c:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a4a0:	fa5f f888 	uxtb.w	r8, r8
   2a4a4:	fa5f f989 	uxtb.w	r9, r9
   2a4a8:	fa5f fa8a 	uxtb.w	sl, sl
   2a4ac:	fa5f fb8b 	uxtb.w	fp, fp
   2a4b0:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a4b4:	f852 7029 	ldr.w	r7, [r2, r9, lsl #2]
   2a4b8:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a4bc:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a4c0:	ea87 673a 	eor.w	r7, r7, sl, ror #24
   2a4c4:	ea87 473b 	eor.w	r7, r7, fp, ror #16
   2a4c8:	ea87 2738 	eor.w	r7, r7, r8, ror #8
   2a4cc:	640c      	str	r4, [r1, #64]	; 0x40
   2a4ce:	644d      	str	r5, [r1, #68]	; 0x44
   2a4d0:	648e      	str	r6, [r1, #72]	; 0x48
   2a4d2:	64cf      	str	r7, [r1, #76]	; 0x4c
   2a4d4:	e8bd 00f0 	ldmia.w	sp!, {r4, r5, r6, r7}
   2a4d8:	fa5f f894 	uxtb.w	r8, r4, ror #8
   2a4dc:	fa5f f9a4 	uxtb.w	r9, r4, ror #16
   2a4e0:	fa5f fab4 	uxtb.w	sl, r4, ror #24
   2a4e4:	fa5f fb84 	uxtb.w	fp, r4
   2a4e8:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a4ec:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a4f0:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a4f4:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a4f8:	fa5f f888 	uxtb.w	r8, r8
   2a4fc:	fa5f f989 	uxtb.w	r9, r9
   2a500:	fa5f fa8a 	uxtb.w	sl, sl
   2a504:	fa5f fb8b 	uxtb.w	fp, fp
   2a508:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a50c:	f852 4029 	ldr.w	r4, [r2, r9, lsl #2]
   2a510:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a514:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a518:	ea84 643a 	eor.w	r4, r4, sl, ror #24
   2a51c:	ea84 443b 	eor.w	r4, r4, fp, ror #16
   2a520:	ea84 2438 	eor.w	r4, r4, r8, ror #8
   2a524:	fa5f f895 	uxtb.w	r8, r5, ror #8
   2a528:	fa5f f9a5 	uxtb.w	r9, r5, ror #16
   2a52c:	fa5f fab5 	uxtb.w	sl, r5, ror #24
   2a530:	fa5f fb85 	uxtb.w	fp, r5
   2a534:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a538:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a53c:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a540:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a544:	fa5f f888 	uxtb.w	r8, r8
   2a548:	fa5f f989 	uxtb.w	r9, r9
   2a54c:	fa5f fa8a 	uxtb.w	sl, sl
   2a550:	fa5f fb8b 	uxtb.w	fp, fp
   2a554:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a558:	f852 5029 	ldr.w	r5, [r2, r9, lsl #2]
   2a55c:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a560:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a564:	ea85 653a 	eor.w	r5, r5, sl, ror #24
   2a568:	ea85 453b 	eor.w	r5, r5, fp, ror #16
   2a56c:	ea85 2538 	eor.w	r5, r5, r8, ror #8
   2a570:	fa5f f896 	uxtb.w	r8, r6, ror #8
   2a574:	fa5f f9a6 	uxtb.w	r9, r6, ror #16
   2a578:	fa5f fab6 	uxtb.w	sl, r6, ror #24
   2a57c:	fa5f fb86 	uxtb.w	fp, r6
   2a580:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a584:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a588:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a58c:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a590:	fa5f f888 	uxtb.w	r8, r8
   2a594:	fa5f f989 	uxtb.w	r9, r9
   2a598:	fa5f fa8a 	uxtb.w	sl, sl
   2a59c:	fa5f fb8b 	uxtb.w	fp, fp
   2a5a0:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a5a4:	f852 6029 	ldr.w	r6, [r2, r9, lsl #2]
   2a5a8:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a5ac:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a5b0:	ea86 663a 	eor.w	r6, r6, sl, ror #24
   2a5b4:	ea86 463b 	eor.w	r6, r6, fp, ror #16
   2a5b8:	ea86 2638 	eor.w	r6, r6, r8, ror #8
   2a5bc:	fa5f f897 	uxtb.w	r8, r7, ror #8
   2a5c0:	fa5f f9a7 	uxtb.w	r9, r7, ror #16
   2a5c4:	fa5f fab7 	uxtb.w	sl, r7, ror #24
   2a5c8:	fa5f fb87 	uxtb.w	fp, r7
   2a5cc:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a5d0:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a5d4:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a5d8:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a5dc:	fa5f f888 	uxtb.w	r8, r8
   2a5e0:	fa5f f989 	uxtb.w	r9, r9
   2a5e4:	fa5f fa8a 	uxtb.w	sl, sl
   2a5e8:	fa5f fb8b 	uxtb.w	fp, fp
   2a5ec:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a5f0:	f852 7029 	ldr.w	r7, [r2, r9, lsl #2]
   2a5f4:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a5f8:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a5fc:	ea87 673a 	eor.w	r7, r7, sl, ror #24
   2a600:	ea87 473b 	eor.w	r7, r7, fp, ror #16
   2a604:	ea87 2738 	eor.w	r7, r7, r8, ror #8
   2a608:	650c      	str	r4, [r1, #80]	; 0x50
   2a60a:	654d      	str	r5, [r1, #84]	; 0x54
   2a60c:	658e      	str	r6, [r1, #88]	; 0x58
   2a60e:	65cf      	str	r7, [r1, #92]	; 0x5c
   2a610:	e8bd 00f0 	ldmia.w	sp!, {r4, r5, r6, r7}
   2a614:	fa5f f894 	uxtb.w	r8, r4, ror #8
   2a618:	fa5f f9a4 	uxtb.w	r9, r4, ror #16
   2a61c:	fa5f fab4 	uxtb.w	sl, r4, ror #24
   2a620:	fa5f fb84 	uxtb.w	fp, r4
   2a624:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a628:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a62c:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a630:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a634:	fa5f f888 	uxtb.w	r8, r8
   2a638:	fa5f f989 	uxtb.w	r9, r9
   2a63c:	fa5f fa8a 	uxtb.w	sl, sl
   2a640:	fa5f fb8b 	uxtb.w	fp, fp
   2a644:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a648:	f852 4029 	ldr.w	r4, [r2, r9, lsl #2]
   2a64c:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a650:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a654:	ea84 643a 	eor.w	r4, r4, sl, ror #24
   2a658:	ea84 443b 	eor.w	r4, r4, fp, ror #16
   2a65c:	ea84 2438 	eor.w	r4, r4, r8, ror #8
   2a660:	fa5f f895 	uxtb.w	r8, r5, ror #8
   2a664:	fa5f f9a5 	uxtb.w	r9, r5, ror #16
   2a668:	fa5f fab5 	uxtb.w	sl, r5, ror #24
   2a66c:	fa5f fb85 	uxtb.w	fp, r5
   2a670:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a674:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a678:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a67c:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a680:	fa5f f888 	uxtb.w	r8, r8
   2a684:	fa5f f989 	uxtb.w	r9, r9
   2a688:	fa5f fa8a 	uxtb.w	sl, sl
   2a68c:	fa5f fb8b 	uxtb.w	fp, fp
   2a690:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a694:	f852 5029 	ldr.w	r5, [r2, r9, lsl #2]
   2a698:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a69c:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a6a0:	ea85 653a 	eor.w	r5, r5, sl, ror #24
   2a6a4:	ea85 453b 	eor.w	r5, r5, fp, ror #16
   2a6a8:	ea85 2538 	eor.w	r5, r5, r8, ror #8
   2a6ac:	fa5f f896 	uxtb.w	r8, r6, ror #8
   2a6b0:	fa5f f9a6 	uxtb.w	r9, r6, ror #16
   2a6b4:	fa5f fab6 	uxtb.w	sl, r6, ror #24
   2a6b8:	fa5f fb86 	uxtb.w	fp, r6
   2a6bc:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a6c0:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a6c4:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a6c8:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a6cc:	fa5f f888 	uxtb.w	r8, r8
   2a6d0:	fa5f f989 	uxtb.w	r9, r9
   2a6d4:	fa5f fa8a 	uxtb.w	sl, sl
   2a6d8:	fa5f fb8b 	uxtb.w	fp, fp
   2a6dc:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a6e0:	f852 6029 	ldr.w	r6, [r2, r9, lsl #2]
   2a6e4:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a6e8:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a6ec:	ea86 663a 	eor.w	r6, r6, sl, ror #24
   2a6f0:	ea86 463b 	eor.w	r6, r6, fp, ror #16
   2a6f4:	ea86 2638 	eor.w	r6, r6, r8, ror #8
   2a6f8:	fa5f f897 	uxtb.w	r8, r7, ror #8
   2a6fc:	fa5f f9a7 	uxtb.w	r9, r7, ror #16
   2a700:	fa5f fab7 	uxtb.w	sl, r7, ror #24
   2a704:	fa5f fb87 	uxtb.w	fp, r7
   2a708:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a70c:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a710:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a714:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a718:	fa5f f888 	uxtb.w	r8, r8
   2a71c:	fa5f f989 	uxtb.w	r9, r9
   2a720:	fa5f fa8a 	uxtb.w	sl, sl
   2a724:	fa5f fb8b 	uxtb.w	fp, fp
   2a728:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a72c:	f852 7029 	ldr.w	r7, [r2, r9, lsl #2]
   2a730:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a734:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a738:	ea87 673a 	eor.w	r7, r7, sl, ror #24
   2a73c:	ea87 473b 	eor.w	r7, r7, fp, ror #16
   2a740:	ea87 2738 	eor.w	r7, r7, r8, ror #8
   2a744:	660c      	str	r4, [r1, #96]	; 0x60
   2a746:	664d      	str	r5, [r1, #100]	; 0x64
   2a748:	668e      	str	r6, [r1, #104]	; 0x68
   2a74a:	66cf      	str	r7, [r1, #108]	; 0x6c
   2a74c:	e8bd 00f0 	ldmia.w	sp!, {r4, r5, r6, r7}
   2a750:	fa5f f894 	uxtb.w	r8, r4, ror #8
   2a754:	fa5f f9a4 	uxtb.w	r9, r4, ror #16
   2a758:	fa5f fab4 	uxtb.w	sl, r4, ror #24
   2a75c:	fa5f fb84 	uxtb.w	fp, r4
   2a760:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a764:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a768:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a76c:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a770:	fa5f f888 	uxtb.w	r8, r8
   2a774:	fa5f f989 	uxtb.w	r9, r9
   2a778:	fa5f fa8a 	uxtb.w	sl, sl
   2a77c:	fa5f fb8b 	uxtb.w	fp, fp
   2a780:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a784:	f852 4029 	ldr.w	r4, [r2, r9, lsl #2]
   2a788:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a78c:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a790:	ea84 643a 	eor.w	r4, r4, sl, ror #24
   2a794:	ea84 443b 	eor.w	r4, r4, fp, ror #16
   2a798:	ea84 2438 	eor.w	r4, r4, r8, ror #8
   2a79c:	fa5f f895 	uxtb.w	r8, r5, ror #8
   2a7a0:	fa5f f9a5 	uxtb.w	r9, r5, ror #16
   2a7a4:	fa5f fab5 	uxtb.w	sl, r5, ror #24
   2a7a8:	fa5f fb85 	uxtb.w	fp, r5
   2a7ac:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a7b0:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a7b4:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a7b8:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a7bc:	fa5f f888 	uxtb.w	r8, r8
   2a7c0:	fa5f f989 	uxtb.w	r9, r9
   2a7c4:	fa5f fa8a 	uxtb.w	sl, sl
   2a7c8:	fa5f fb8b 	uxtb.w	fp, fp
   2a7cc:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a7d0:	f852 5029 	ldr.w	r5, [r2, r9, lsl #2]
   2a7d4:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a7d8:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a7dc:	ea85 653a 	eor.w	r5, r5, sl, ror #24
   2a7e0:	ea85 453b 	eor.w	r5, r5, fp, ror #16
   2a7e4:	ea85 2538 	eor.w	r5, r5, r8, ror #8
   2a7e8:	fa5f f896 	uxtb.w	r8, r6, ror #8
   2a7ec:	fa5f f9a6 	uxtb.w	r9, r6, ror #16
   2a7f0:	fa5f fab6 	uxtb.w	sl, r6, ror #24
   2a7f4:	fa5f fb86 	uxtb.w	fp, r6
   2a7f8:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a7fc:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a800:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a804:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a808:	fa5f f888 	uxtb.w	r8, r8
   2a80c:	fa5f f989 	uxtb.w	r9, r9
   2a810:	fa5f fa8a 	uxtb.w	sl, sl
   2a814:	fa5f fb8b 	uxtb.w	fp, fp
   2a818:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a81c:	f852 6029 	ldr.w	r6, [r2, r9, lsl #2]
   2a820:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a824:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a828:	ea86 663a 	eor.w	r6, r6, sl, ror #24
   2a82c:	ea86 463b 	eor.w	r6, r6, fp, ror #16
   2a830:	ea86 2638 	eor.w	r6, r6, r8, ror #8
   2a834:	fa5f f897 	uxtb.w	r8, r7, ror #8
   2a838:	fa5f f9a7 	uxtb.w	r9, r7, ror #16
   2a83c:	fa5f fab7 	uxtb.w	sl, r7, ror #24
   2a840:	fa5f fb87 	uxtb.w	fp, r7
   2a844:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a848:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a84c:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a850:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a854:	fa5f f888 	uxtb.w	r8, r8
   2a858:	fa5f f989 	uxtb.w	r9, r9
   2a85c:	fa5f fa8a 	uxtb.w	sl, sl
   2a860:	fa5f fb8b 	uxtb.w	fp, fp
   2a864:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a868:	f852 7029 	ldr.w	r7, [r2, r9, lsl #2]
   2a86c:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a870:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a874:	ea87 673a 	eor.w	r7, r7, sl, ror #24
   2a878:	ea87 473b 	eor.w	r7, r7, fp, ror #16
   2a87c:	ea87 2738 	eor.w	r7, r7, r8, ror #8
   2a880:	670c      	str	r4, [r1, #112]	; 0x70
   2a882:	674d      	str	r5, [r1, #116]	; 0x74
   2a884:	678e      	str	r6, [r1, #120]	; 0x78
   2a886:	67cf      	str	r7, [r1, #124]	; 0x7c
   2a888:	e8bd 00f0 	ldmia.w	sp!, {r4, r5, r6, r7}
   2a88c:	fa5f f894 	uxtb.w	r8, r4, ror #8
   2a890:	fa5f f9a4 	uxtb.w	r9, r4, ror #16
   2a894:	fa5f fab4 	uxtb.w	sl, r4, ror #24
   2a898:	fa5f fb84 	uxtb.w	fp, r4
   2a89c:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a8a0:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a8a4:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a8a8:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a8ac:	fa5f f888 	uxtb.w	r8, r8
   2a8b0:	fa5f f989 	uxtb.w	r9, r9
   2a8b4:	fa5f fa8a 	uxtb.w	sl, sl
   2a8b8:	fa5f fb8b 	uxtb.w	fp, fp
   2a8bc:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a8c0:	f852 4029 	ldr.w	r4, [r2, r9, lsl #2]
   2a8c4:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a8c8:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a8cc:	ea84 643a 	eor.w	r4, r4, sl, ror #24
   2a8d0:	ea84 443b 	eor.w	r4, r4, fp, ror #16
   2a8d4:	ea84 2438 	eor.w	r4, r4, r8, ror #8
   2a8d8:	fa5f f895 	uxtb.w	r8, r5, ror #8
   2a8dc:	fa5f f9a5 	uxtb.w	r9, r5, ror #16
   2a8e0:	fa5f fab5 	uxtb.w	sl, r5, ror #24
   2a8e4:	fa5f fb85 	uxtb.w	fp, r5
   2a8e8:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a8ec:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a8f0:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a8f4:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a8f8:	fa5f f888 	uxtb.w	r8, r8
   2a8fc:	fa5f f989 	uxtb.w	r9, r9
   2a900:	fa5f fa8a 	uxtb.w	sl, sl
   2a904:	fa5f fb8b 	uxtb.w	fp, fp
   2a908:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a90c:	f852 5029 	ldr.w	r5, [r2, r9, lsl #2]
   2a910:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a914:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a918:	ea85 653a 	eor.w	r5, r5, sl, ror #24
   2a91c:	ea85 453b 	eor.w	r5, r5, fp, ror #16
   2a920:	ea85 2538 	eor.w	r5, r5, r8, ror #8
   2a924:	fa5f f896 	uxtb.w	r8, r6, ror #8
   2a928:	fa5f f9a6 	uxtb.w	r9, r6, ror #16
   2a92c:	fa5f fab6 	uxtb.w	sl, r6, ror #24
   2a930:	fa5f fb86 	uxtb.w	fp, r6
   2a934:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a938:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a93c:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a940:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a944:	fa5f f888 	uxtb.w	r8, r8
   2a948:	fa5f f989 	uxtb.w	r9, r9
   2a94c:	fa5f fa8a 	uxtb.w	sl, sl
   2a950:	fa5f fb8b 	uxtb.w	fp, fp
   2a954:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a958:	f852 6029 	ldr.w	r6, [r2, r9, lsl #2]
   2a95c:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a960:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a964:	ea86 663a 	eor.w	r6, r6, sl, ror #24
   2a968:	ea86 463b 	eor.w	r6, r6, fp, ror #16
   2a96c:	ea86 2638 	eor.w	r6, r6, r8, ror #8
   2a970:	fa5f f897 	uxtb.w	r8, r7, ror #8
   2a974:	fa5f f9a7 	uxtb.w	r9, r7, ror #16
   2a978:	fa5f fab7 	uxtb.w	sl, r7, ror #24
   2a97c:	fa5f fb87 	uxtb.w	fp, r7
   2a980:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a984:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a988:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a98c:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a990:	fa5f f888 	uxtb.w	r8, r8
   2a994:	fa5f f989 	uxtb.w	r9, r9
   2a998:	fa5f fa8a 	uxtb.w	sl, sl
   2a99c:	fa5f fb8b 	uxtb.w	fp, fp
   2a9a0:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2a9a4:	f852 7029 	ldr.w	r7, [r2, r9, lsl #2]
   2a9a8:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2a9ac:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2a9b0:	ea87 673a 	eor.w	r7, r7, sl, ror #24
   2a9b4:	ea87 473b 	eor.w	r7, r7, fp, ror #16
   2a9b8:	ea87 2738 	eor.w	r7, r7, r8, ror #8
   2a9bc:	f101 0180 	add.w	r1, r1, #128	; 0x80
   2a9c0:	600c      	str	r4, [r1, #0]
   2a9c2:	604d      	str	r5, [r1, #4]
   2a9c4:	608e      	str	r6, [r1, #8]
   2a9c6:	60cf      	str	r7, [r1, #12]
   2a9c8:	e8bd 00f0 	ldmia.w	sp!, {r4, r5, r6, r7}
   2a9cc:	fa5f f894 	uxtb.w	r8, r4, ror #8
   2a9d0:	fa5f f9a4 	uxtb.w	r9, r4, ror #16
   2a9d4:	fa5f fab4 	uxtb.w	sl, r4, ror #24
   2a9d8:	fa5f fb84 	uxtb.w	fp, r4
   2a9dc:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2a9e0:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2a9e4:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2a9e8:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2a9ec:	fa5f f888 	uxtb.w	r8, r8
   2a9f0:	fa5f f989 	uxtb.w	r9, r9
   2a9f4:	fa5f fa8a 	uxtb.w	sl, sl
   2a9f8:	fa5f fb8b 	uxtb.w	fp, fp
   2a9fc:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2aa00:	f852 4029 	ldr.w	r4, [r2, r9, lsl #2]
   2aa04:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2aa08:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2aa0c:	ea84 643a 	eor.w	r4, r4, sl, ror #24
   2aa10:	ea84 443b 	eor.w	r4, r4, fp, ror #16
   2aa14:	ea84 2438 	eor.w	r4, r4, r8, ror #8
   2aa18:	fa5f f895 	uxtb.w	r8, r5, ror #8
   2aa1c:	fa5f f9a5 	uxtb.w	r9, r5, ror #16
   2aa20:	fa5f fab5 	uxtb.w	sl, r5, ror #24
   2aa24:	fa5f fb85 	uxtb.w	fp, r5
   2aa28:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2aa2c:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2aa30:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2aa34:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2aa38:	fa5f f888 	uxtb.w	r8, r8
   2aa3c:	fa5f f989 	uxtb.w	r9, r9
   2aa40:	fa5f fa8a 	uxtb.w	sl, sl
   2aa44:	fa5f fb8b 	uxtb.w	fp, fp
   2aa48:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2aa4c:	f852 5029 	ldr.w	r5, [r2, r9, lsl #2]
   2aa50:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2aa54:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2aa58:	ea85 653a 	eor.w	r5, r5, sl, ror #24
   2aa5c:	ea85 453b 	eor.w	r5, r5, fp, ror #16
   2aa60:	ea85 2538 	eor.w	r5, r5, r8, ror #8
   2aa64:	fa5f f896 	uxtb.w	r8, r6, ror #8
   2aa68:	fa5f f9a6 	uxtb.w	r9, r6, ror #16
   2aa6c:	fa5f fab6 	uxtb.w	sl, r6, ror #24
   2aa70:	fa5f fb86 	uxtb.w	fp, r6
   2aa74:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2aa78:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2aa7c:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2aa80:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2aa84:	fa5f f888 	uxtb.w	r8, r8
   2aa88:	fa5f f989 	uxtb.w	r9, r9
   2aa8c:	fa5f fa8a 	uxtb.w	sl, sl
   2aa90:	fa5f fb8b 	uxtb.w	fp, fp
   2aa94:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2aa98:	f852 6029 	ldr.w	r6, [r2, r9, lsl #2]
   2aa9c:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2aaa0:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2aaa4:	ea86 663a 	eor.w	r6, r6, sl, ror #24
   2aaa8:	ea86 463b 	eor.w	r6, r6, fp, ror #16
   2aaac:	ea86 2638 	eor.w	r6, r6, r8, ror #8
   2aab0:	fa5f f897 	uxtb.w	r8, r7, ror #8
   2aab4:	fa5f f9a7 	uxtb.w	r9, r7, ror #16
   2aab8:	fa5f fab7 	uxtb.w	sl, r7, ror #24
   2aabc:	fa5f fb87 	uxtb.w	fp, r7
   2aac0:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
   2aac4:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
   2aac8:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
   2aacc:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
   2aad0:	fa5f f888 	uxtb.w	r8, r8
   2aad4:	fa5f f989 	uxtb.w	r9, r9
   2aad8:	fa5f fa8a 	uxtb.w	sl, sl
   2aadc:	fa5f fb8b 	uxtb.w	fp, fp
   2aae0:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
   2aae4:	f852 7029 	ldr.w	r7, [r2, r9, lsl #2]
   2aae8:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
   2aaec:	f852 b02b 	ldr.w	fp, [r2, fp, lsl #2]
   2aaf0:	ea87 673a 	eor.w	r7, r7, sl, ror #24
   2aaf4:	ea87 473b 	eor.w	r7, r7, fp, ror #16
   2aaf8:	ea87 2738 	eor.w	r7, r7, r8, ror #8
   2aafc:	610c      	str	r4, [r1, #16]
   2aafe:	614d      	str	r5, [r1, #20]
   2ab00:	618e      	str	r6, [r1, #24]
   2ab02:	61cf      	str	r7, [r1, #28]
   2ab04:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
   2ab08:	4770      	bx	lr
   2ab0a:	0000      	.short	0x0000
   2ab0c:	00028590 	.word	0x00028590

0002ab10 <AES_128_decrypt>:
   2ab10:	e92d 5ff4 	stmdb	sp!, {r2, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
   2ab14:	e891 00f0 	ldmia.w	r1, {r4, r5, r6, r7}
   2ab18:	e8b0 0f00 	ldmia.w	r0!, {r8, r9, sl, fp}
   2ab1c:	ea4f 0e00 	mov.w	lr, r0
   2ab20:	f8df c7a4 	ldr.w	ip, [pc, #1956]	; 2b2c8 <AES_128_decrypt+0x7b8>
   2ab24:	ea84 0408 	eor.w	r4, r4, r8
   2ab28:	ea85 0509 	eor.w	r5, r5, r9
   2ab2c:	ea86 060a 	eor.w	r6, r6, sl
   2ab30:	ea87 070b 	eor.w	r7, r7, fp
   2ab34:	e8be 0f00 	ldmia.w	lr!, {r8, r9, sl, fp}
   2ab38:	b2e0      	uxtb	r0, r4
   2ab3a:	b2e9      	uxtb	r1, r5
   2ab3c:	b2f2      	uxtb	r2, r6
   2ab3e:	b2fb      	uxtb	r3, r7
   2ab40:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2ab44:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2ab48:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2ab4c:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2ab50:	ea88 4830 	eor.w	r8, r8, r0, ror #16
   2ab54:	ea89 4931 	eor.w	r9, r9, r1, ror #16
   2ab58:	ea8a 4a32 	eor.w	sl, sl, r2, ror #16
   2ab5c:	ea8b 4b33 	eor.w	fp, fp, r3, ror #16
   2ab60:	fa5f f097 	uxtb.w	r0, r7, ror #8
   2ab64:	fa5f f194 	uxtb.w	r1, r4, ror #8
   2ab68:	fa5f f295 	uxtb.w	r2, r5, ror #8
   2ab6c:	fa5f f396 	uxtb.w	r3, r6, ror #8
   2ab70:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2ab74:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2ab78:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2ab7c:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2ab80:	ea88 2830 	eor.w	r8, r8, r0, ror #8
   2ab84:	ea89 2931 	eor.w	r9, r9, r1, ror #8
   2ab88:	ea8a 2a32 	eor.w	sl, sl, r2, ror #8
   2ab8c:	ea8b 2b33 	eor.w	fp, fp, r3, ror #8
   2ab90:	fa5f f0a6 	uxtb.w	r0, r6, ror #16
   2ab94:	fa5f f1a7 	uxtb.w	r1, r7, ror #16
   2ab98:	fa5f f2a4 	uxtb.w	r2, r4, ror #16
   2ab9c:	fa5f f3a5 	uxtb.w	r3, r5, ror #16
   2aba0:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2aba4:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2aba8:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2abac:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2abb0:	ea88 0800 	eor.w	r8, r8, r0
   2abb4:	ea89 0901 	eor.w	r9, r9, r1
   2abb8:	ea8a 0a02 	eor.w	sl, sl, r2
   2abbc:	ea8b 0b03 	eor.w	fp, fp, r3
   2abc0:	fa5f f0b5 	uxtb.w	r0, r5, ror #24
   2abc4:	fa5f f1b6 	uxtb.w	r1, r6, ror #24
   2abc8:	fa5f f2b7 	uxtb.w	r2, r7, ror #24
   2abcc:	fa5f f3b4 	uxtb.w	r3, r4, ror #24
   2abd0:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2abd4:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2abd8:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2abdc:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2abe0:	ea88 6830 	eor.w	r8, r8, r0, ror #24
   2abe4:	ea89 6931 	eor.w	r9, r9, r1, ror #24
   2abe8:	ea8a 6a32 	eor.w	sl, sl, r2, ror #24
   2abec:	ea8b 6b33 	eor.w	fp, fp, r3, ror #24
   2abf0:	e8be 00f0 	ldmia.w	lr!, {r4, r5, r6, r7}
   2abf4:	fa5f f088 	uxtb.w	r0, r8
   2abf8:	fa5f f189 	uxtb.w	r1, r9
   2abfc:	fa5f f28a 	uxtb.w	r2, sl
   2ac00:	fa5f f38b 	uxtb.w	r3, fp
   2ac04:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2ac08:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2ac0c:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2ac10:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2ac14:	ea84 4430 	eor.w	r4, r4, r0, ror #16
   2ac18:	ea85 4531 	eor.w	r5, r5, r1, ror #16
   2ac1c:	ea86 4632 	eor.w	r6, r6, r2, ror #16
   2ac20:	ea87 4733 	eor.w	r7, r7, r3, ror #16
   2ac24:	fa5f f09b 	uxtb.w	r0, fp, ror #8
   2ac28:	fa5f f198 	uxtb.w	r1, r8, ror #8
   2ac2c:	fa5f f299 	uxtb.w	r2, r9, ror #8
   2ac30:	fa5f f39a 	uxtb.w	r3, sl, ror #8
   2ac34:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2ac38:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2ac3c:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2ac40:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2ac44:	ea84 2430 	eor.w	r4, r4, r0, ror #8
   2ac48:	ea85 2531 	eor.w	r5, r5, r1, ror #8
   2ac4c:	ea86 2632 	eor.w	r6, r6, r2, ror #8
   2ac50:	ea87 2733 	eor.w	r7, r7, r3, ror #8
   2ac54:	fa5f f0aa 	uxtb.w	r0, sl, ror #16
   2ac58:	fa5f f1ab 	uxtb.w	r1, fp, ror #16
   2ac5c:	fa5f f2a8 	uxtb.w	r2, r8, ror #16
   2ac60:	fa5f f3a9 	uxtb.w	r3, r9, ror #16
   2ac64:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2ac68:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2ac6c:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2ac70:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2ac74:	ea84 0400 	eor.w	r4, r4, r0
   2ac78:	ea85 0501 	eor.w	r5, r5, r1
   2ac7c:	ea86 0602 	eor.w	r6, r6, r2
   2ac80:	ea87 0703 	eor.w	r7, r7, r3
   2ac84:	fa5f f0b9 	uxtb.w	r0, r9, ror #24
   2ac88:	fa5f f1ba 	uxtb.w	r1, sl, ror #24
   2ac8c:	fa5f f2bb 	uxtb.w	r2, fp, ror #24
   2ac90:	fa5f f3b8 	uxtb.w	r3, r8, ror #24
   2ac94:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2ac98:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2ac9c:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2aca0:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2aca4:	ea84 6430 	eor.w	r4, r4, r0, ror #24
   2aca8:	ea85 6531 	eor.w	r5, r5, r1, ror #24
   2acac:	ea86 6632 	eor.w	r6, r6, r2, ror #24
   2acb0:	ea87 6733 	eor.w	r7, r7, r3, ror #24
   2acb4:	e8be 0f00 	ldmia.w	lr!, {r8, r9, sl, fp}
   2acb8:	b2e0      	uxtb	r0, r4
   2acba:	b2e9      	uxtb	r1, r5
   2acbc:	b2f2      	uxtb	r2, r6
   2acbe:	b2fb      	uxtb	r3, r7
   2acc0:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2acc4:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2acc8:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2accc:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2acd0:	ea88 4830 	eor.w	r8, r8, r0, ror #16
   2acd4:	ea89 4931 	eor.w	r9, r9, r1, ror #16
   2acd8:	ea8a 4a32 	eor.w	sl, sl, r2, ror #16
   2acdc:	ea8b 4b33 	eor.w	fp, fp, r3, ror #16
   2ace0:	fa5f f097 	uxtb.w	r0, r7, ror #8
   2ace4:	fa5f f194 	uxtb.w	r1, r4, ror #8
   2ace8:	fa5f f295 	uxtb.w	r2, r5, ror #8
   2acec:	fa5f f396 	uxtb.w	r3, r6, ror #8
   2acf0:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2acf4:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2acf8:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2acfc:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2ad00:	ea88 2830 	eor.w	r8, r8, r0, ror #8
   2ad04:	ea89 2931 	eor.w	r9, r9, r1, ror #8
   2ad08:	ea8a 2a32 	eor.w	sl, sl, r2, ror #8
   2ad0c:	ea8b 2b33 	eor.w	fp, fp, r3, ror #8
   2ad10:	fa5f f0a6 	uxtb.w	r0, r6, ror #16
   2ad14:	fa5f f1a7 	uxtb.w	r1, r7, ror #16
   2ad18:	fa5f f2a4 	uxtb.w	r2, r4, ror #16
   2ad1c:	fa5f f3a5 	uxtb.w	r3, r5, ror #16
   2ad20:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2ad24:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2ad28:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2ad2c:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2ad30:	ea88 0800 	eor.w	r8, r8, r0
   2ad34:	ea89 0901 	eor.w	r9, r9, r1
   2ad38:	ea8a 0a02 	eor.w	sl, sl, r2
   2ad3c:	ea8b 0b03 	eor.w	fp, fp, r3
   2ad40:	fa5f f0b5 	uxtb.w	r0, r5, ror #24
   2ad44:	fa5f f1b6 	uxtb.w	r1, r6, ror #24
   2ad48:	fa5f f2b7 	uxtb.w	r2, r7, ror #24
   2ad4c:	fa5f f3b4 	uxtb.w	r3, r4, ror #24
   2ad50:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2ad54:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2ad58:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2ad5c:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2ad60:	ea88 6830 	eor.w	r8, r8, r0, ror #24
   2ad64:	ea89 6931 	eor.w	r9, r9, r1, ror #24
   2ad68:	ea8a 6a32 	eor.w	sl, sl, r2, ror #24
   2ad6c:	ea8b 6b33 	eor.w	fp, fp, r3, ror #24
   2ad70:	e8be 00f0 	ldmia.w	lr!, {r4, r5, r6, r7}
   2ad74:	fa5f f088 	uxtb.w	r0, r8
   2ad78:	fa5f f189 	uxtb.w	r1, r9
   2ad7c:	fa5f f28a 	uxtb.w	r2, sl
   2ad80:	fa5f f38b 	uxtb.w	r3, fp
   2ad84:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2ad88:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2ad8c:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2ad90:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2ad94:	ea84 4430 	eor.w	r4, r4, r0, ror #16
   2ad98:	ea85 4531 	eor.w	r5, r5, r1, ror #16
   2ad9c:	ea86 4632 	eor.w	r6, r6, r2, ror #16
   2ada0:	ea87 4733 	eor.w	r7, r7, r3, ror #16
   2ada4:	fa5f f09b 	uxtb.w	r0, fp, ror #8
   2ada8:	fa5f f198 	uxtb.w	r1, r8, ror #8
   2adac:	fa5f f299 	uxtb.w	r2, r9, ror #8
   2adb0:	fa5f f39a 	uxtb.w	r3, sl, ror #8
   2adb4:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2adb8:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2adbc:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2adc0:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2adc4:	ea84 2430 	eor.w	r4, r4, r0, ror #8
   2adc8:	ea85 2531 	eor.w	r5, r5, r1, ror #8
   2adcc:	ea86 2632 	eor.w	r6, r6, r2, ror #8
   2add0:	ea87 2733 	eor.w	r7, r7, r3, ror #8
   2add4:	fa5f f0aa 	uxtb.w	r0, sl, ror #16
   2add8:	fa5f f1ab 	uxtb.w	r1, fp, ror #16
   2addc:	fa5f f2a8 	uxtb.w	r2, r8, ror #16
   2ade0:	fa5f f3a9 	uxtb.w	r3, r9, ror #16
   2ade4:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2ade8:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2adec:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2adf0:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2adf4:	ea84 0400 	eor.w	r4, r4, r0
   2adf8:	ea85 0501 	eor.w	r5, r5, r1
   2adfc:	ea86 0602 	eor.w	r6, r6, r2
   2ae00:	ea87 0703 	eor.w	r7, r7, r3
   2ae04:	fa5f f0b9 	uxtb.w	r0, r9, ror #24
   2ae08:	fa5f f1ba 	uxtb.w	r1, sl, ror #24
   2ae0c:	fa5f f2bb 	uxtb.w	r2, fp, ror #24
   2ae10:	fa5f f3b8 	uxtb.w	r3, r8, ror #24
   2ae14:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2ae18:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2ae1c:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2ae20:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2ae24:	ea84 6430 	eor.w	r4, r4, r0, ror #24
   2ae28:	ea85 6531 	eor.w	r5, r5, r1, ror #24
   2ae2c:	ea86 6632 	eor.w	r6, r6, r2, ror #24
   2ae30:	ea87 6733 	eor.w	r7, r7, r3, ror #24
   2ae34:	e8be 0f00 	ldmia.w	lr!, {r8, r9, sl, fp}
   2ae38:	b2e0      	uxtb	r0, r4
   2ae3a:	b2e9      	uxtb	r1, r5
   2ae3c:	b2f2      	uxtb	r2, r6
   2ae3e:	b2fb      	uxtb	r3, r7
   2ae40:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2ae44:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2ae48:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2ae4c:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2ae50:	ea88 4830 	eor.w	r8, r8, r0, ror #16
   2ae54:	ea89 4931 	eor.w	r9, r9, r1, ror #16
   2ae58:	ea8a 4a32 	eor.w	sl, sl, r2, ror #16
   2ae5c:	ea8b 4b33 	eor.w	fp, fp, r3, ror #16
   2ae60:	fa5f f097 	uxtb.w	r0, r7, ror #8
   2ae64:	fa5f f194 	uxtb.w	r1, r4, ror #8
   2ae68:	fa5f f295 	uxtb.w	r2, r5, ror #8
   2ae6c:	fa5f f396 	uxtb.w	r3, r6, ror #8
   2ae70:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2ae74:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2ae78:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2ae7c:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2ae80:	ea88 2830 	eor.w	r8, r8, r0, ror #8
   2ae84:	ea89 2931 	eor.w	r9, r9, r1, ror #8
   2ae88:	ea8a 2a32 	eor.w	sl, sl, r2, ror #8
   2ae8c:	ea8b 2b33 	eor.w	fp, fp, r3, ror #8
   2ae90:	fa5f f0a6 	uxtb.w	r0, r6, ror #16
   2ae94:	fa5f f1a7 	uxtb.w	r1, r7, ror #16
   2ae98:	fa5f f2a4 	uxtb.w	r2, r4, ror #16
   2ae9c:	fa5f f3a5 	uxtb.w	r3, r5, ror #16
   2aea0:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2aea4:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2aea8:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2aeac:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2aeb0:	ea88 0800 	eor.w	r8, r8, r0
   2aeb4:	ea89 0901 	eor.w	r9, r9, r1
   2aeb8:	ea8a 0a02 	eor.w	sl, sl, r2
   2aebc:	ea8b 0b03 	eor.w	fp, fp, r3
   2aec0:	fa5f f0b5 	uxtb.w	r0, r5, ror #24
   2aec4:	fa5f f1b6 	uxtb.w	r1, r6, ror #24
   2aec8:	fa5f f2b7 	uxtb.w	r2, r7, ror #24
   2aecc:	fa5f f3b4 	uxtb.w	r3, r4, ror #24
   2aed0:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2aed4:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2aed8:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2aedc:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2aee0:	ea88 6830 	eor.w	r8, r8, r0, ror #24
   2aee4:	ea89 6931 	eor.w	r9, r9, r1, ror #24
   2aee8:	ea8a 6a32 	eor.w	sl, sl, r2, ror #24
   2aeec:	ea8b 6b33 	eor.w	fp, fp, r3, ror #24
   2aef0:	e8be 00f0 	ldmia.w	lr!, {r4, r5, r6, r7}
   2aef4:	fa5f f088 	uxtb.w	r0, r8
   2aef8:	fa5f f189 	uxtb.w	r1, r9
   2aefc:	fa5f f28a 	uxtb.w	r2, sl
   2af00:	fa5f f38b 	uxtb.w	r3, fp
   2af04:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2af08:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2af0c:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2af10:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2af14:	ea84 4430 	eor.w	r4, r4, r0, ror #16
   2af18:	ea85 4531 	eor.w	r5, r5, r1, ror #16
   2af1c:	ea86 4632 	eor.w	r6, r6, r2, ror #16
   2af20:	ea87 4733 	eor.w	r7, r7, r3, ror #16
   2af24:	fa5f f09b 	uxtb.w	r0, fp, ror #8
   2af28:	fa5f f198 	uxtb.w	r1, r8, ror #8
   2af2c:	fa5f f299 	uxtb.w	r2, r9, ror #8
   2af30:	fa5f f39a 	uxtb.w	r3, sl, ror #8
   2af34:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2af38:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2af3c:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2af40:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2af44:	ea84 2430 	eor.w	r4, r4, r0, ror #8
   2af48:	ea85 2531 	eor.w	r5, r5, r1, ror #8
   2af4c:	ea86 2632 	eor.w	r6, r6, r2, ror #8
   2af50:	ea87 2733 	eor.w	r7, r7, r3, ror #8
   2af54:	fa5f f0aa 	uxtb.w	r0, sl, ror #16
   2af58:	fa5f f1ab 	uxtb.w	r1, fp, ror #16
   2af5c:	fa5f f2a8 	uxtb.w	r2, r8, ror #16
   2af60:	fa5f f3a9 	uxtb.w	r3, r9, ror #16
   2af64:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2af68:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2af6c:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2af70:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2af74:	ea84 0400 	eor.w	r4, r4, r0
   2af78:	ea85 0501 	eor.w	r5, r5, r1
   2af7c:	ea86 0602 	eor.w	r6, r6, r2
   2af80:	ea87 0703 	eor.w	r7, r7, r3
   2af84:	fa5f f0b9 	uxtb.w	r0, r9, ror #24
   2af88:	fa5f f1ba 	uxtb.w	r1, sl, ror #24
   2af8c:	fa5f f2bb 	uxtb.w	r2, fp, ror #24
   2af90:	fa5f f3b8 	uxtb.w	r3, r8, ror #24
   2af94:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2af98:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2af9c:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2afa0:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2afa4:	ea84 6430 	eor.w	r4, r4, r0, ror #24
   2afa8:	ea85 6531 	eor.w	r5, r5, r1, ror #24
   2afac:	ea86 6632 	eor.w	r6, r6, r2, ror #24
   2afb0:	ea87 6733 	eor.w	r7, r7, r3, ror #24
   2afb4:	e8be 0f00 	ldmia.w	lr!, {r8, r9, sl, fp}
   2afb8:	b2e0      	uxtb	r0, r4
   2afba:	b2e9      	uxtb	r1, r5
   2afbc:	b2f2      	uxtb	r2, r6
   2afbe:	b2fb      	uxtb	r3, r7
   2afc0:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2afc4:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2afc8:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2afcc:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2afd0:	ea88 4830 	eor.w	r8, r8, r0, ror #16
   2afd4:	ea89 4931 	eor.w	r9, r9, r1, ror #16
   2afd8:	ea8a 4a32 	eor.w	sl, sl, r2, ror #16
   2afdc:	ea8b 4b33 	eor.w	fp, fp, r3, ror #16
   2afe0:	fa5f f097 	uxtb.w	r0, r7, ror #8
   2afe4:	fa5f f194 	uxtb.w	r1, r4, ror #8
   2afe8:	fa5f f295 	uxtb.w	r2, r5, ror #8
   2afec:	fa5f f396 	uxtb.w	r3, r6, ror #8
   2aff0:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2aff4:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2aff8:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2affc:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2b000:	ea88 2830 	eor.w	r8, r8, r0, ror #8
   2b004:	ea89 2931 	eor.w	r9, r9, r1, ror #8
   2b008:	ea8a 2a32 	eor.w	sl, sl, r2, ror #8
   2b00c:	ea8b 2b33 	eor.w	fp, fp, r3, ror #8
   2b010:	fa5f f0a6 	uxtb.w	r0, r6, ror #16
   2b014:	fa5f f1a7 	uxtb.w	r1, r7, ror #16
   2b018:	fa5f f2a4 	uxtb.w	r2, r4, ror #16
   2b01c:	fa5f f3a5 	uxtb.w	r3, r5, ror #16
   2b020:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2b024:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2b028:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2b02c:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2b030:	ea88 0800 	eor.w	r8, r8, r0
   2b034:	ea89 0901 	eor.w	r9, r9, r1
   2b038:	ea8a 0a02 	eor.w	sl, sl, r2
   2b03c:	ea8b 0b03 	eor.w	fp, fp, r3
   2b040:	fa5f f0b5 	uxtb.w	r0, r5, ror #24
   2b044:	fa5f f1b6 	uxtb.w	r1, r6, ror #24
   2b048:	fa5f f2b7 	uxtb.w	r2, r7, ror #24
   2b04c:	fa5f f3b4 	uxtb.w	r3, r4, ror #24
   2b050:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2b054:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2b058:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2b05c:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2b060:	ea88 6830 	eor.w	r8, r8, r0, ror #24
   2b064:	ea89 6931 	eor.w	r9, r9, r1, ror #24
   2b068:	ea8a 6a32 	eor.w	sl, sl, r2, ror #24
   2b06c:	ea8b 6b33 	eor.w	fp, fp, r3, ror #24
   2b070:	e8be 00f0 	ldmia.w	lr!, {r4, r5, r6, r7}
   2b074:	fa5f f088 	uxtb.w	r0, r8
   2b078:	fa5f f189 	uxtb.w	r1, r9
   2b07c:	fa5f f28a 	uxtb.w	r2, sl
   2b080:	fa5f f38b 	uxtb.w	r3, fp
   2b084:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2b088:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2b08c:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2b090:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2b094:	ea84 4430 	eor.w	r4, r4, r0, ror #16
   2b098:	ea85 4531 	eor.w	r5, r5, r1, ror #16
   2b09c:	ea86 4632 	eor.w	r6, r6, r2, ror #16
   2b0a0:	ea87 4733 	eor.w	r7, r7, r3, ror #16
   2b0a4:	fa5f f09b 	uxtb.w	r0, fp, ror #8
   2b0a8:	fa5f f198 	uxtb.w	r1, r8, ror #8
   2b0ac:	fa5f f299 	uxtb.w	r2, r9, ror #8
   2b0b0:	fa5f f39a 	uxtb.w	r3, sl, ror #8
   2b0b4:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2b0b8:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2b0bc:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2b0c0:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2b0c4:	ea84 2430 	eor.w	r4, r4, r0, ror #8
   2b0c8:	ea85 2531 	eor.w	r5, r5, r1, ror #8
   2b0cc:	ea86 2632 	eor.w	r6, r6, r2, ror #8
   2b0d0:	ea87 2733 	eor.w	r7, r7, r3, ror #8
   2b0d4:	fa5f f0aa 	uxtb.w	r0, sl, ror #16
   2b0d8:	fa5f f1ab 	uxtb.w	r1, fp, ror #16
   2b0dc:	fa5f f2a8 	uxtb.w	r2, r8, ror #16
   2b0e0:	fa5f f3a9 	uxtb.w	r3, r9, ror #16
   2b0e4:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2b0e8:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2b0ec:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2b0f0:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2b0f4:	ea84 0400 	eor.w	r4, r4, r0
   2b0f8:	ea85 0501 	eor.w	r5, r5, r1
   2b0fc:	ea86 0602 	eor.w	r6, r6, r2
   2b100:	ea87 0703 	eor.w	r7, r7, r3
   2b104:	fa5f f0b9 	uxtb.w	r0, r9, ror #24
   2b108:	fa5f f1ba 	uxtb.w	r1, sl, ror #24
   2b10c:	fa5f f2bb 	uxtb.w	r2, fp, ror #24
   2b110:	fa5f f3b8 	uxtb.w	r3, r8, ror #24
   2b114:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2b118:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2b11c:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2b120:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2b124:	ea84 6430 	eor.w	r4, r4, r0, ror #24
   2b128:	ea85 6531 	eor.w	r5, r5, r1, ror #24
   2b12c:	ea86 6632 	eor.w	r6, r6, r2, ror #24
   2b130:	ea87 6733 	eor.w	r7, r7, r3, ror #24
   2b134:	e8be 0f00 	ldmia.w	lr!, {r8, r9, sl, fp}
   2b138:	b2e0      	uxtb	r0, r4
   2b13a:	b2e9      	uxtb	r1, r5
   2b13c:	b2f2      	uxtb	r2, r6
   2b13e:	b2fb      	uxtb	r3, r7
   2b140:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2b144:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2b148:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2b14c:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2b150:	ea88 4830 	eor.w	r8, r8, r0, ror #16
   2b154:	ea89 4931 	eor.w	r9, r9, r1, ror #16
   2b158:	ea8a 4a32 	eor.w	sl, sl, r2, ror #16
   2b15c:	ea8b 4b33 	eor.w	fp, fp, r3, ror #16
   2b160:	fa5f f097 	uxtb.w	r0, r7, ror #8
   2b164:	fa5f f194 	uxtb.w	r1, r4, ror #8
   2b168:	fa5f f295 	uxtb.w	r2, r5, ror #8
   2b16c:	fa5f f396 	uxtb.w	r3, r6, ror #8
   2b170:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2b174:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2b178:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2b17c:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2b180:	ea88 2830 	eor.w	r8, r8, r0, ror #8
   2b184:	ea89 2931 	eor.w	r9, r9, r1, ror #8
   2b188:	ea8a 2a32 	eor.w	sl, sl, r2, ror #8
   2b18c:	ea8b 2b33 	eor.w	fp, fp, r3, ror #8
   2b190:	fa5f f0a6 	uxtb.w	r0, r6, ror #16
   2b194:	fa5f f1a7 	uxtb.w	r1, r7, ror #16
   2b198:	fa5f f2a4 	uxtb.w	r2, r4, ror #16
   2b19c:	fa5f f3a5 	uxtb.w	r3, r5, ror #16
   2b1a0:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2b1a4:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2b1a8:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2b1ac:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2b1b0:	ea88 0800 	eor.w	r8, r8, r0
   2b1b4:	ea89 0901 	eor.w	r9, r9, r1
   2b1b8:	ea8a 0a02 	eor.w	sl, sl, r2
   2b1bc:	ea8b 0b03 	eor.w	fp, fp, r3
   2b1c0:	fa5f f0b5 	uxtb.w	r0, r5, ror #24
   2b1c4:	fa5f f1b6 	uxtb.w	r1, r6, ror #24
   2b1c8:	fa5f f2b7 	uxtb.w	r2, r7, ror #24
   2b1cc:	fa5f f3b4 	uxtb.w	r3, r4, ror #24
   2b1d0:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2b1d4:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2b1d8:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2b1dc:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2b1e0:	f8df c0e8 	ldr.w	ip, [pc, #232]	; 2b2cc <AES_128_decrypt+0x7bc>
   2b1e4:	ea88 6830 	eor.w	r8, r8, r0, ror #24
   2b1e8:	ea89 6931 	eor.w	r9, r9, r1, ror #24
   2b1ec:	ea8a 6a32 	eor.w	sl, sl, r2, ror #24
   2b1f0:	ea8b 6b33 	eor.w	fp, fp, r3, ror #24
   2b1f4:	e8be 00f0 	ldmia.w	lr!, {r4, r5, r6, r7}
   2b1f8:	fa5f f088 	uxtb.w	r0, r8
   2b1fc:	fa5f f189 	uxtb.w	r1, r9
   2b200:	fa5f f28a 	uxtb.w	r2, sl
   2b204:	fa5f f38b 	uxtb.w	r3, fp
   2b208:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2b20c:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2b210:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2b214:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2b218:	ea84 0400 	eor.w	r4, r4, r0
   2b21c:	ea85 0501 	eor.w	r5, r5, r1
   2b220:	ea86 0602 	eor.w	r6, r6, r2
   2b224:	ea87 0703 	eor.w	r7, r7, r3
   2b228:	fa5f f09b 	uxtb.w	r0, fp, ror #8
   2b22c:	fa5f f198 	uxtb.w	r1, r8, ror #8
   2b230:	fa5f f299 	uxtb.w	r2, r9, ror #8
   2b234:	fa5f f39a 	uxtb.w	r3, sl, ror #8
   2b238:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2b23c:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2b240:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2b244:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2b248:	ea84 2400 	eor.w	r4, r4, r0, lsl #8
   2b24c:	ea85 2501 	eor.w	r5, r5, r1, lsl #8
   2b250:	ea86 2602 	eor.w	r6, r6, r2, lsl #8
   2b254:	ea87 2703 	eor.w	r7, r7, r3, lsl #8
   2b258:	fa5f f0aa 	uxtb.w	r0, sl, ror #16
   2b25c:	fa5f f1ab 	uxtb.w	r1, fp, ror #16
   2b260:	fa5f f2a8 	uxtb.w	r2, r8, ror #16
   2b264:	fa5f f3a9 	uxtb.w	r3, r9, ror #16
   2b268:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2b26c:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2b270:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2b274:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2b278:	ea84 4400 	eor.w	r4, r4, r0, lsl #16
   2b27c:	ea85 4501 	eor.w	r5, r5, r1, lsl #16
   2b280:	ea86 4602 	eor.w	r6, r6, r2, lsl #16
   2b284:	ea87 4703 	eor.w	r7, r7, r3, lsl #16
   2b288:	fa5f f0b9 	uxtb.w	r0, r9, ror #24
   2b28c:	fa5f f1ba 	uxtb.w	r1, sl, ror #24
   2b290:	fa5f f2bb 	uxtb.w	r2, fp, ror #24
   2b294:	fa5f f3b8 	uxtb.w	r3, r8, ror #24
   2b298:	f85c 0020 	ldr.w	r0, [ip, r0, lsl #2]
   2b29c:	f85c 1021 	ldr.w	r1, [ip, r1, lsl #2]
   2b2a0:	f85c 2022 	ldr.w	r2, [ip, r2, lsl #2]
   2b2a4:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
   2b2a8:	ea84 6400 	eor.w	r4, r4, r0, lsl #24
   2b2ac:	ea85 6501 	eor.w	r5, r5, r1, lsl #24
   2b2b0:	ea86 6602 	eor.w	r6, r6, r2, lsl #24
   2b2b4:	f85d 2b04 	ldr.w	r2, [sp], #4
   2b2b8:	ea87 6703 	eor.w	r7, r7, r3, lsl #24
   2b2bc:	e882 00f0 	stmia.w	r2, {r4, r5, r6, r7}
   2b2c0:	e8bd 5ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
   2b2c4:	4770      	bx	lr
   2b2c6:	0000      	.short	0x0000
   2b2c8:	000294b0 	.word	0x000294b0
   2b2cc:	000298b0 	.word	0x000298b0

0002b2d0 <malloc>:
   2b2d0:	4b02      	ldr	r3, [pc, #8]	; (2b2dc <malloc+0xc>)
   2b2d2:	4601      	mov	r1, r0
   2b2d4:	6818      	ldr	r0, [r3, #0]
   2b2d6:	f000 b865 	b.w	2b3a4 <_malloc_r>
   2b2da:	bf00      	nop
   2b2dc:	20005000 	.word	0x20005000

0002b2e0 <free>:
   2b2e0:	4b02      	ldr	r3, [pc, #8]	; (2b2ec <free+0xc>)
   2b2e2:	4601      	mov	r1, r0
   2b2e4:	6818      	ldr	r0, [r3, #0]
   2b2e6:	f000 b80f 	b.w	2b308 <_free_r>
   2b2ea:	bf00      	nop
   2b2ec:	20005000 	.word	0x20005000

0002b2f0 <memcpy>:
   2b2f0:	b510      	push	{r4, lr}
   2b2f2:	1e43      	subs	r3, r0, #1
   2b2f4:	440a      	add	r2, r1
   2b2f6:	4291      	cmp	r1, r2
   2b2f8:	d100      	bne.n	2b2fc <memcpy+0xc>
   2b2fa:	bd10      	pop	{r4, pc}
   2b2fc:	f811 4b01 	ldrb.w	r4, [r1], #1
   2b300:	f803 4f01 	strb.w	r4, [r3, #1]!
   2b304:	e7f7      	b.n	2b2f6 <memcpy+0x6>
	...

0002b308 <_free_r>:
   2b308:	b538      	push	{r3, r4, r5, lr}
   2b30a:	4605      	mov	r5, r0
   2b30c:	2900      	cmp	r1, #0
   2b30e:	d045      	beq.n	2b39c <_free_r+0x94>
   2b310:	f851 3c04 	ldr.w	r3, [r1, #-4]
   2b314:	1f0c      	subs	r4, r1, #4
   2b316:	2b00      	cmp	r3, #0
   2b318:	bfb8      	it	lt
   2b31a:	18e4      	addlt	r4, r4, r3
   2b31c:	f000 f8b8 	bl	2b490 <__malloc_lock>
   2b320:	4a1f      	ldr	r2, [pc, #124]	; (2b3a0 <_free_r+0x98>)
   2b322:	6813      	ldr	r3, [r2, #0]
   2b324:	4610      	mov	r0, r2
   2b326:	b933      	cbnz	r3, 2b336 <_free_r+0x2e>
   2b328:	6063      	str	r3, [r4, #4]
   2b32a:	6014      	str	r4, [r2, #0]
   2b32c:	4628      	mov	r0, r5
   2b32e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   2b332:	f000 b8ae 	b.w	2b492 <__malloc_unlock>
   2b336:	42a3      	cmp	r3, r4
   2b338:	d90c      	bls.n	2b354 <_free_r+0x4c>
   2b33a:	6821      	ldr	r1, [r4, #0]
   2b33c:	1862      	adds	r2, r4, r1
   2b33e:	4293      	cmp	r3, r2
   2b340:	bf04      	itt	eq
   2b342:	681a      	ldreq	r2, [r3, #0]
   2b344:	685b      	ldreq	r3, [r3, #4]
   2b346:	6063      	str	r3, [r4, #4]
   2b348:	bf04      	itt	eq
   2b34a:	1852      	addeq	r2, r2, r1
   2b34c:	6022      	streq	r2, [r4, #0]
   2b34e:	6004      	str	r4, [r0, #0]
   2b350:	e7ec      	b.n	2b32c <_free_r+0x24>
   2b352:	4613      	mov	r3, r2
   2b354:	685a      	ldr	r2, [r3, #4]
   2b356:	b10a      	cbz	r2, 2b35c <_free_r+0x54>
   2b358:	42a2      	cmp	r2, r4
   2b35a:	d9fa      	bls.n	2b352 <_free_r+0x4a>
   2b35c:	6819      	ldr	r1, [r3, #0]
   2b35e:	1858      	adds	r0, r3, r1
   2b360:	42a0      	cmp	r0, r4
   2b362:	d10b      	bne.n	2b37c <_free_r+0x74>
   2b364:	6820      	ldr	r0, [r4, #0]
   2b366:	4401      	add	r1, r0
   2b368:	1858      	adds	r0, r3, r1
   2b36a:	4282      	cmp	r2, r0
   2b36c:	6019      	str	r1, [r3, #0]
   2b36e:	d1dd      	bne.n	2b32c <_free_r+0x24>
   2b370:	6810      	ldr	r0, [r2, #0]
   2b372:	6852      	ldr	r2, [r2, #4]
   2b374:	605a      	str	r2, [r3, #4]
   2b376:	4401      	add	r1, r0
   2b378:	6019      	str	r1, [r3, #0]
   2b37a:	e7d7      	b.n	2b32c <_free_r+0x24>
   2b37c:	d902      	bls.n	2b384 <_free_r+0x7c>
   2b37e:	230c      	movs	r3, #12
   2b380:	602b      	str	r3, [r5, #0]
   2b382:	e7d3      	b.n	2b32c <_free_r+0x24>
   2b384:	6820      	ldr	r0, [r4, #0]
   2b386:	1821      	adds	r1, r4, r0
   2b388:	428a      	cmp	r2, r1
   2b38a:	bf04      	itt	eq
   2b38c:	6811      	ldreq	r1, [r2, #0]
   2b38e:	6852      	ldreq	r2, [r2, #4]
   2b390:	6062      	str	r2, [r4, #4]
   2b392:	bf04      	itt	eq
   2b394:	1809      	addeq	r1, r1, r0
   2b396:	6021      	streq	r1, [r4, #0]
   2b398:	605c      	str	r4, [r3, #4]
   2b39a:	e7c7      	b.n	2b32c <_free_r+0x24>
   2b39c:	bd38      	pop	{r3, r4, r5, pc}
   2b39e:	bf00      	nop
   2b3a0:	20005404 	.word	0x20005404

0002b3a4 <_malloc_r>:
   2b3a4:	b570      	push	{r4, r5, r6, lr}
   2b3a6:	1ccd      	adds	r5, r1, #3
   2b3a8:	f025 0503 	bic.w	r5, r5, #3
   2b3ac:	3508      	adds	r5, #8
   2b3ae:	2d0c      	cmp	r5, #12
   2b3b0:	bf38      	it	cc
   2b3b2:	250c      	movcc	r5, #12
   2b3b4:	2d00      	cmp	r5, #0
   2b3b6:	4606      	mov	r6, r0
   2b3b8:	db01      	blt.n	2b3be <_malloc_r+0x1a>
   2b3ba:	42a9      	cmp	r1, r5
   2b3bc:	d903      	bls.n	2b3c6 <_malloc_r+0x22>
   2b3be:	230c      	movs	r3, #12
   2b3c0:	6033      	str	r3, [r6, #0]
   2b3c2:	2000      	movs	r0, #0
   2b3c4:	bd70      	pop	{r4, r5, r6, pc}
   2b3c6:	f000 f863 	bl	2b490 <__malloc_lock>
   2b3ca:	4a23      	ldr	r2, [pc, #140]	; (2b458 <_malloc_r+0xb4>)
   2b3cc:	6814      	ldr	r4, [r2, #0]
   2b3ce:	4621      	mov	r1, r4
   2b3d0:	b991      	cbnz	r1, 2b3f8 <_malloc_r+0x54>
   2b3d2:	4c22      	ldr	r4, [pc, #136]	; (2b45c <_malloc_r+0xb8>)
   2b3d4:	6823      	ldr	r3, [r4, #0]
   2b3d6:	b91b      	cbnz	r3, 2b3e0 <_malloc_r+0x3c>
   2b3d8:	4630      	mov	r0, r6
   2b3da:	f000 f841 	bl	2b460 <_sbrk_r>
   2b3de:	6020      	str	r0, [r4, #0]
   2b3e0:	4629      	mov	r1, r5
   2b3e2:	4630      	mov	r0, r6
   2b3e4:	f000 f83c 	bl	2b460 <_sbrk_r>
   2b3e8:	1c43      	adds	r3, r0, #1
   2b3ea:	d126      	bne.n	2b43a <_malloc_r+0x96>
   2b3ec:	230c      	movs	r3, #12
   2b3ee:	6033      	str	r3, [r6, #0]
   2b3f0:	4630      	mov	r0, r6
   2b3f2:	f000 f84e 	bl	2b492 <__malloc_unlock>
   2b3f6:	e7e4      	b.n	2b3c2 <_malloc_r+0x1e>
   2b3f8:	680b      	ldr	r3, [r1, #0]
   2b3fa:	1b5b      	subs	r3, r3, r5
   2b3fc:	d41a      	bmi.n	2b434 <_malloc_r+0x90>
   2b3fe:	2b0b      	cmp	r3, #11
   2b400:	d90f      	bls.n	2b422 <_malloc_r+0x7e>
   2b402:	600b      	str	r3, [r1, #0]
   2b404:	50cd      	str	r5, [r1, r3]
   2b406:	18cc      	adds	r4, r1, r3
   2b408:	4630      	mov	r0, r6
   2b40a:	f000 f842 	bl	2b492 <__malloc_unlock>
   2b40e:	f104 000b 	add.w	r0, r4, #11
   2b412:	1d23      	adds	r3, r4, #4
   2b414:	f020 0007 	bic.w	r0, r0, #7
   2b418:	1ac3      	subs	r3, r0, r3
   2b41a:	d01b      	beq.n	2b454 <_malloc_r+0xb0>
   2b41c:	425a      	negs	r2, r3
   2b41e:	50e2      	str	r2, [r4, r3]
   2b420:	bd70      	pop	{r4, r5, r6, pc}
   2b422:	428c      	cmp	r4, r1
   2b424:	bf0d      	iteet	eq
   2b426:	6863      	ldreq	r3, [r4, #4]
   2b428:	684b      	ldrne	r3, [r1, #4]
   2b42a:	6063      	strne	r3, [r4, #4]
   2b42c:	6013      	streq	r3, [r2, #0]
   2b42e:	bf18      	it	ne
   2b430:	460c      	movne	r4, r1
   2b432:	e7e9      	b.n	2b408 <_malloc_r+0x64>
   2b434:	460c      	mov	r4, r1
   2b436:	6849      	ldr	r1, [r1, #4]
   2b438:	e7ca      	b.n	2b3d0 <_malloc_r+0x2c>
   2b43a:	1cc4      	adds	r4, r0, #3
   2b43c:	f024 0403 	bic.w	r4, r4, #3
   2b440:	42a0      	cmp	r0, r4
   2b442:	d005      	beq.n	2b450 <_malloc_r+0xac>
   2b444:	1a21      	subs	r1, r4, r0
   2b446:	4630      	mov	r0, r6
   2b448:	f000 f80a 	bl	2b460 <_sbrk_r>
   2b44c:	3001      	adds	r0, #1
   2b44e:	d0cd      	beq.n	2b3ec <_malloc_r+0x48>
   2b450:	6025      	str	r5, [r4, #0]
   2b452:	e7d9      	b.n	2b408 <_malloc_r+0x64>
   2b454:	bd70      	pop	{r4, r5, r6, pc}
   2b456:	bf00      	nop
   2b458:	20005404 	.word	0x20005404
   2b45c:	20005408 	.word	0x20005408

0002b460 <_sbrk_r>:
   2b460:	b538      	push	{r3, r4, r5, lr}
   2b462:	4c06      	ldr	r4, [pc, #24]	; (2b47c <_sbrk_r+0x1c>)
   2b464:	2300      	movs	r3, #0
   2b466:	4605      	mov	r5, r0
   2b468:	4608      	mov	r0, r1
   2b46a:	6023      	str	r3, [r4, #0]
   2b46c:	f000 f812 	bl	2b494 <_sbrk>
   2b470:	1c43      	adds	r3, r0, #1
   2b472:	d102      	bne.n	2b47a <_sbrk_r+0x1a>
   2b474:	6823      	ldr	r3, [r4, #0]
   2b476:	b103      	cbz	r3, 2b47a <_sbrk_r+0x1a>
   2b478:	602b      	str	r3, [r5, #0]
   2b47a:	bd38      	pop	{r3, r4, r5, pc}
   2b47c:	20005490 	.word	0x20005490

0002b480 <strlen>:
   2b480:	4603      	mov	r3, r0
   2b482:	f813 2b01 	ldrb.w	r2, [r3], #1
   2b486:	2a00      	cmp	r2, #0
   2b488:	d1fb      	bne.n	2b482 <strlen+0x2>
   2b48a:	1a18      	subs	r0, r3, r0
   2b48c:	3801      	subs	r0, #1
   2b48e:	4770      	bx	lr

0002b490 <__malloc_lock>:
   2b490:	4770      	bx	lr

0002b492 <__malloc_unlock>:
   2b492:	4770      	bx	lr

0002b494 <_sbrk>:
   2b494:	4a04      	ldr	r2, [pc, #16]	; (2b4a8 <_sbrk+0x14>)
   2b496:	4905      	ldr	r1, [pc, #20]	; (2b4ac <_sbrk+0x18>)
   2b498:	6813      	ldr	r3, [r2, #0]
   2b49a:	2b00      	cmp	r3, #0
   2b49c:	bf08      	it	eq
   2b49e:	460b      	moveq	r3, r1
   2b4a0:	4418      	add	r0, r3
   2b4a2:	6010      	str	r0, [r2, #0]
   2b4a4:	4618      	mov	r0, r3
   2b4a6:	4770      	bx	lr
   2b4a8:	2000540c 	.word	0x2000540c
   2b4ac:	20005498 	.word	0x20005498

0002b4b0 <_init>:
   2b4b0:	e1a0c00d 	mov	ip, sp
   2b4b4:	e92ddff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
   2b4b8:	e24cb004 	sub	fp, ip, #4
   2b4bc:	e24bd028 	sub	sp, fp, #40	; 0x28
   2b4c0:	e89d6ff0 	ldm	sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, lr}
   2b4c4:	e12fff1e 	bx	lr

0002b4c8 <_fini>:
   2b4c8:	e1a0c00d 	mov	ip, sp
   2b4cc:	e92ddff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
   2b4d0:	e24cb004 	sub	fp, ip, #4
   2b4d4:	e24bd028 	sub	sp, fp, #40	; 0x28
   2b4d8:	e89d6ff0 	ldm	sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, lr}
   2b4dc:	e12fff1e 	bx	lr

0002b4e0 <_global_impure_ptr>:
   2b4e0:	20005004 65756c62 746f6f74 6c622f68     .P. bluetooth/bl
   2b4f0:	6f635f65 6e6f6d6d 0000632e 5479654b     e_common.c..KeyT
   2b500:	00006761 65756c62 746f6f74 64612f68     ag..bluetooth/ad
   2b510:	74726576 6e697369 00632e67 7774694c     vertising.c.Litw
   2b520:	4f202c6f 797a636a 206f6e7a 616a6f6d     o, Ojczyzno moja
   2b530:	6c492021 69432065 72742065 6162657a     ! Ile Cie trzeba
   2b540:	6e656320 00006369 00007854 6e657645      cenic..Tx..Even
   2b550:	00007374 ac2007b0 3c2016ca 7214e7b9     ts.... ... <...r
   2b560:	ac040000                                ....

0002b564 <sdh_req_observers>:
   2b564:	0002b6c8 0002b6c8 00000008              ............

0002b570 <sdh_state_observers>:
   2b570:	0002b6c8 0002b6c8 00000008              ............

0002b57c <sdh_stack_observers>:
   2b57c:	0002b6b8 0002b6c8 00000008 07021000     ................

0002b58c <sdh_ble_observers>:
   2b58c:	0002b6c8 0002b6e8 00000008 3566726e     ............nrf5
   2b59c:	6b647332 2e34315f 2f302e30 706d6f63     2sdk_14.0.0/comp
   2b5ac:	6e656e6f 732f7374 6474666f 63697665     onents/softdevic
   2b5bc:	6f632f65 6e6f6d6d 66726e2f 6864735f     e/common/nrf_sdh
   2b5cc:	656c625f 0000632e                       _ble.c..

0002b5d4 <sdh_soc_observers>:
   2b5d4:	0002b6e8 0002b6f8 00000008 3566726e     ............nrf5
   2b5e4:	6b647332 2e34315f 2f302e30 706d6f63     2sdk_14.0.0/comp
   2b5f4:	6e656e6f 732f7374 6474666f 63697665     onents/softdevic
   2b604:	6f632f65 6e6f6d6d 66726e2f 6864735f     e/common/nrf_sdh
   2b614:	636f735f 0000632e 3566726e 6b647332     _soc.c..nrf52sdk
   2b624:	2e34315f 2f302e30 706d6f63 6e656e6f     _14.0.0/componen
   2b634:	622f7374 632f656c 6f6d6d6f 6c622f6e     ts/ble/common/bl
   2b644:	6f635f65 735f6e6e 65746174 0000632e     e_conn_state.c..

0002b654 <__sf_fake_stderr>:
	...

0002b674 <__sf_fake_stdin>:
	...

0002b694 <__sf_fake_stdout>:
	...

0002b6b4 <__EH_FRAME_BEGIN__>:
   2b6b4:	00000000                                ....
